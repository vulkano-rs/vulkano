//! The procedural macro for vulkano's shader system.
//! Manages the compile-time compilation of shader code into SPIR-V and generation of associated
//! Rust code.
//!
//! # Basic usage
//!
//! ```
//! mod vs {
//!     vulkano_shaders::shader! {
//!         ty: "vertex",
//!         src: r"
//!             #version 450
//!
//!             layout(location = 0) in vec3 position;
//!
//!             void main() {
//!                 gl_Position = vec4(position, 1.0);
//!             }
//!         ",
//!     }
//! }
//! # fn main() {}
//! ```
//!
//! # Details
//!
//! If you want to take a look at what the macro generates, your best option is to use
//! [cargo-expand] to view the expansion of the macro in your own code. On the other hand, if you
//! are looking for a high-level overview, you can see the below section.
//!
//! # Generated code overview
//!
//! The macro generates the following items of interest:
//!
//! - The `load` constructor. This function takes an `Arc<Device>`, constructs a [`ShaderModule`]
//!   with the passed-in device and the shader data provided via the macro, and returns
//!   `Result<Arc<ShaderModule>, Validated<VulkanError>>`. Before doing so, it checks every
//!   capability instruction in the shader data, verifying that the passed-in `Device` has the
//!   appropriate features enabled.
//! - If the `shaders` option is used, then instead of one `load` constructor, there is one for
//!   each shader. They are named based on the provided names, `load_first`, `load_second` etc.
//! - A Rust struct translated from each struct contained in the shader data. By default, each
//!   structure has a `Clone` and a `Copy` implementation. This behavior could be customized
//!   through the `custom_derives` macro option (see below for details). Each struct also has an
//!   implementation of [`BufferContents`], so that it can be read from/written to a buffer.
//!
//! All of these generated items will be accessed through the module where the macro was invoked.
//! If you wanted to store the `ShaderModule` in a struct of your own, you could do something like
//! this:
//!
//! ```
//! # fn main() {}
//! # use std::sync::Arc;
//! # use vulkano::{device::Device, shader::ShaderModule, Validated, VulkanError};
//! #
//! # mod vs {
//! #     vulkano_shaders::shader!{
//! #         ty: "vertex",
//! #         src: r"
//! #             #version 450
//! #
//! #             layout(location = 0) in vec3 position;
//! #
//! #             void main() {
//! #                 gl_Position = vec4(position, 1.0);
//! #             }
//! #         ",
//! #     }
//! # }
//! // ...various use statements...
//! // ...`vs` module containing a `shader!` call...
//!
//! pub struct Shaders {
//!     pub vs: Arc<ShaderModule>,
//! }
//!
//! impl Shaders {
//!     pub fn load(device: Arc<Device>) -> Result<Self, Validated<VulkanError>> {
//!         Ok(Self {
//!             vs: vs::load(device)?,
//!         })
//!     }
//! }
//! ```
//!
//! # Options
//!
//! The options available are in the form of the following fields:
//!
//! ## `ty: "..."`
//!
//! This defines what shader type the shader source will be compiled into. The type can be any of
//! the following:
//!
//! - `vertex`
//! - `tess_ctrl`
//! - `tess_eval`
//! - `geometry`
//! - `task`
//! - `mesh`
//! - `fragment`
//! - `compute`
//! - `raygen`
//! - `anyhit`
//! - `closesthit`
//! - `miss`
//! - `intersection`
//! - `callable`
//!
//! For details on what these shader types mean, [see Vulkano's documentation][pipeline].
//!
//! ## `src: "..."`
//!
//! Provides the raw shader source to be compiled in the form of a string. Cannot be used in
//! conjunction with the `path` or `bytes` field.
//!
//! ## `path: "..."`
//!
//! Provides the path to the shader source to be compiled, relative to your `Cargo.toml`. Cannot be
//! used in conjunction with the `src` or `bytes` field.
//!
//! ## `bytes: "..."`
//!
//! Provides the path to precompiled SPIR-V bytecode, relative to your `Cargo.toml`. Cannot be used
//! in conjunction with the `src` or `path` field, and may also not specify a shader `ty` type.
//! This allows using shaders compiled through a separate build system.
//!
//! ## `root_path_env: "..."`
//!
//! Instead of searching relative to your `Cargo.toml`, search relative to some other folder
//! specified by this env variable. The intended use case is using `OUT_DIR` to be able to load
//! shaders generated by your build script. Defaults to `CARGO_MANIFEST_DIR` corresponding to the
//! folder of your `Cargo.toml`.
//!
//! See [`cargo-env-vars`] for a full set of env variables set by cargo. It is also possible to
//! specify env variables from within the build script using the following:
//! ```rust
//! # let shader_out_dir = "";
//! println!("cargo:rustc-env=SHADER_OUT_DIR={shader_out_dir}");
//! ```
//!
//! ## `shaders: { first: { src: "...", ty: "..." }, ... }`
//!
//! With these options the user can compile several shaders in a single macro invocation. Each
//! entry key will be the suffix of the generated `load` function (`load_first` in this case).
//! However, all other Rust structs translated from the shader source will be shared between
//! shaders. The macro checks that the source structs with the same names between different shaders
//! have the same declaration signature, and throws a compile-time error if they don't.
//!
//! Each entry expects a `src`, `path`, `bytes`, and `ty` pairs same as above.
//!
//! ## `include: ["...", "...", ...]`
//!
//! Specifies the standard include directories to be searched through when using the
//! `#include <...>` directive within a shader source. Include directories can be absolute or
//! relative to your `Cargo.toml`. If `path` was specified, relative paths can also be used
//! (`#include "..."`), without the need to specify one or more standard include directories.
//! Relative paths are relative to the directory which contains the source file the
//! `#include "..."` directive is declared in.
//!
//! ## `define: [("NAME", "VALUE"), ...]`
//!
//! Adds the given macro definitions to the pre-processor. This is equivalent to passing the
//! `-DNAME=VALUE` argument on the command line.
//!
//! ## `lang: "..."`
//!
//! Provides the language of the shader source. Must be either `glsl` or `hlsl` (defaults to  
//! `glsl`).
//!
//! ## `vulkan_version: "major.minor"` and `spirv_version: "major.minor"`
//!
//! Sets the Vulkan and SPIR-V versions to compile into, respectively. These map directly to the
//! [`set_target_env`] and [`set_target_spirv`] compile options. If neither option is specified,
//! then SPIR-V 1.0 code targeting Vulkan 1.0 will be generated.
//!
//! The generated code must be supported by the device at runtime. If not, then an error will be
//! returned when calling `load`.
//!
//! ## `generate_structs: true`
//!
//! Generate rust structs that represent the structs contained in the shader. They all implement
//! [`BufferContents`], which allows then to be passed to the shader, without having to worry about
//! the layout of the struct manually. However, some use-cases, such as Rust-GPU, may not have any
//! use for such structs, and may choose to disable them.
//!
//! ## `custom_derives: [Clone, Default, PartialEq, ...]`
//!
//! Extends the list of derive macros that are added to the `derive` attribute of Rust structs that
//! represent shader structs.
//!
//! By default, each generated struct derives `Clone` and `Copy`. If the struct has unsized members
//! none of the derives are applied on the struct, except [`BufferContents`], which is always
//! derived.
//!
//! ## `linalg_type: "..."`
//!
//! Specifies the way that linear algebra types should be generated. It can be any of the
//! following:
//!
//! - `std`
//! - `cgmath`
//! - `nalgebra`
//!
//! The default is `std`, which uses arrays to represent vectors and matrices. Note that if the
//! chosen crate doesn't have a type that represents a certain linear algebra type (e.g. `mat3`, or
//! a rectangular matrix) then the macro will default back to arrays for that type.
//!
//! If you use linear algebra types from a third-party crate, then you have to have the crate in
//! your dependencies with the appropriate feature enabled that adds `bytemuck` support.
//!
//! ## `dump: true`
//!
//! The crate fails to compile but prints the generated Rust code to stdout.
//!
//! # Cargo features
//!
//! | Feature                     | Description                                             |
//! |-----------------------------|---------------------------------------------------------|
//! | `shaderc-build-from-source` | Build the `shaderc` library from source when compiling. |
//! | `shaderc-debug`             | Compile shaders with debug information included.        |
//!
//! [`cargo-env-vars`]: https://doc.rust-lang.org/cargo/reference/environment-variables.html
//! [cargo-expand]: https://github.com/dtolnay/cargo-expand
//! [`ShaderModule`]: vulkano::shader::ShaderModule
//! [pipeline]: vulkano::pipeline
//! [`set_target_env`]: shaderc::CompileOptions::set_target_env
//! [`set_target_spirv`]: shaderc::CompileOptions::set_target_spirv
//! [`BufferContents`]: vulkano::buffer::BufferContents

#![doc(html_logo_url = "https://raw.githubusercontent.com/vulkano-rs/vulkano/master/logo.png")]
#![recursion_limit = "1024"]

use ahash::{HashMap, HashSet};
use proc_macro2::{Span, TokenStream};
use quote::{format_ident, quote};
use shaderc::{Compiler, EnvVersion, ShaderKind, SourceLanguage, SpirvVersion};
use std::{
    cell::RefCell,
    env::{self, VarError},
    fs, iter,
    path::{Path, PathBuf},
};
use syn::{
    braced, bracketed, parenthesized,
    parse::{Parse, ParseStream, Result},
    parse_macro_input, parse_quote,
    token::Paren,
    Error, Ident, LitBool, LitStr, Token,
};
use vulkano::shader::spirv::{self, Spirv};

mod codegen;
mod structs;

#[proc_macro]
pub fn shader(input: proc_macro::TokenStream) -> proc_macro::TokenStream {
    let input = parse_macro_input!(input as MacroInput);

    shader_inner(input)
        .unwrap_or_else(Error::into_compile_error)
        .into()
}

fn shader_inner(input: MacroInput) -> Result<TokenStream> {
    let base_path = match &input.macro_options.base_path {
        Some(BasePath::Path(path)) => {
            if path.is_absolute() {
                path.clone()
            } else {
                Path::new(env::var("CARGO_MANIFEST_DIR").as_deref().unwrap_or(".")).join(path)
            }
        }
        Some(BasePath::Env(var)) => match env::var(var.value()) {
            Ok(path) => path.into(),
            Err(VarError::NotPresent) => bail!(var, "environment variable not found"),
            Err(VarError::NotUnicode(_)) => bail!(var, "environment variable is not valid unicode"),
        },
        None => env::var("CARGO_MANIFEST_DIR")
            .as_deref()
            .unwrap_or(".")
            .into(),
    };

    let include_paths = input
        .macro_options
        .include_paths
        .iter()
        .map(|path| {
            if path.is_absolute() {
                path.clone()
            } else {
                Path::new(env::var("CARGO_MANIFEST_DIR").as_deref().unwrap_or(".")).join(path)
            }
        })
        .collect::<Vec<_>>();

    let compiler = Compiler::new()
        .ok_or_else(|| Error::new(Span::call_site(), "failed to create shader compiler"))?;

    let sources_to_include = RefCell::new(HashSet::default());
    let mut registered_structs = HashMap::default();

    let mut shaders_code = TokenStream::new();
    let mut structs_code = TokenStream::new();

    for (shader_name, shader_source) in input.shaders {
        let some_shader_name = shader_name.as_deref().unwrap_or("shader");
        match shader_source {
            ShaderSource::Src { src, entry_points } => {
                let entry_points = codegen::compile(
                    &compiler,
                    &input.macro_options,
                    None,
                    some_shader_name,
                    &src.value(),
                    entry_points,
                    &base_path,
                    &include_paths,
                    &sources_to_include,
                )
                .or_else(|err| bail!(src, "{err}"))?;

                let entry_points = entry_points
                    .iter()
                    .map(|(name, artifact)| (name.as_deref(), artifact.as_binary()))
                    .collect::<Vec<_>>();

                shaders_code.extend(codegen::generate_shader_code(&entry_points, &shader_name));

                if input.macro_options.generate_structs {
                    for (_, words) in entry_points {
                        let spirv = Spirv::new(words)
                            .or_else(|err| bail!(src, "failed to parse SPIR-V: {err}"))?;

                        structs_code.extend(structs::generate_structs(
                            &input.macro_options,
                            spirv,
                            some_shader_name.to_owned(),
                            src.clone(),
                            &mut registered_structs,
                        )?);
                    }
                }
            }
            ShaderSource::Path {
                path: path_lit,
                entry_points,
            } => {
                let path = base_path
                    .join(path_lit.value())
                    .into_os_string()
                    .into_string()
                    .unwrap();

                let src = fs::read_to_string(&path)
                    .or_else(|err| bail!(path_lit, "failed to read {path}: {err}"))?;

                let entry_points = codegen::compile(
                    &compiler,
                    &input.macro_options,
                    Some(&path),
                    some_shader_name,
                    &src,
                    entry_points,
                    &base_path,
                    &include_paths,
                    &sources_to_include,
                )
                .or_else(|err| bail!(path_lit, "{err}"))?;

                let entry_points = entry_points
                    .iter()
                    .map(|(name, artifact)| (name.as_deref(), artifact.as_binary()))
                    .collect::<Vec<_>>();

                shaders_code.extend(codegen::generate_shader_code(&entry_points, &shader_name));

                if input.macro_options.generate_structs {
                    for (_, words) in entry_points {
                        let spirv = Spirv::new(words)
                            .or_else(|err| bail!(path_lit, "failed to parse SPIR-V: {err}"))?;

                        structs_code.extend(structs::generate_structs(
                            &input.macro_options,
                            spirv,
                            some_shader_name.to_owned(),
                            path_lit.clone(),
                            &mut registered_structs,
                        )?);
                    }
                }

                sources_to_include.borrow_mut().insert(path);
            }
            ShaderSource::Bytes { path: path_lit } => {
                let path = base_path
                    .join(path_lit.value())
                    .into_os_string()
                    .into_string()
                    .unwrap();

                let bytes = fs::read(&path)
                    .or_else(|err| bail!(path_lit, "failed to read `{path}`: {err}"))?;

                let words = spirv::bytes_to_words(&bytes).or_else(|_| {
                    bail!(
                        path_lit,
                        "the byte length of `{path}` is not a multiple of 4"
                    )
                })?;

                shaders_code.extend(codegen::generate_shader_code(
                    &[(None, &words)],
                    &shader_name,
                ));

                if input.macro_options.generate_structs {
                    let spirv = Spirv::new(&words)
                        .or_else(|err| bail!(path_lit, "failed to parse SPIR-V: {err}"))?;

                    structs_code.extend(structs::generate_structs(
                        &input.macro_options,
                        spirv,
                        some_shader_name.to_owned(),
                        path_lit,
                        &mut registered_structs,
                    )?);
                }

                sources_to_include.borrow_mut().insert(path);
            }
        }
    }

    let includes = sources_to_include
        .take()
        .into_iter()
        .enumerate()
        .map(|(index, source)| {
            let ident = format_ident!("_INCLUDE{index}");
            quote! {
                const #ident: &[u8] = include_bytes!(#source);
            }
        });

    Ok(quote! {
        #structs_code
        #shaders_code
        #( #includes )*
    })
}

struct MacroInput {
    shaders: HashMap<Option<String>, ShaderSource>,
    macro_options: MacroOptions,
}

enum ShaderSource {
    Src {
        src: LitStr,
        entry_points: HashMap<Option<String>, ShaderKind>,
    },
    Path {
        path: LitStr,
        entry_points: HashMap<Option<String>, ShaderKind>,
    },
    Bytes {
        path: LitStr,
    },
}

struct MacroOptions {
    source_language: SourceLanguage,
    vulkan_version: Option<EnvVersion>,
    spirv_version: Option<SpirvVersion>,
    base_path: Option<BasePath>,
    include_paths: Vec<PathBuf>,
    macro_defines: Vec<(String, Option<String>)>,
    generate_structs: bool,
    custom_derives: Vec<syn::Path>,
    linalg_types: LinAlgTypes,
}

enum BasePath {
    Path(PathBuf),
    Env(LitStr),
}

#[derive(Default)]
enum LinAlgTypes {
    #[default]
    Std,
    Cgmath,
    Nalgebra,
}

impl Parse for MacroInput {
    fn parse(input: ParseStream<'_>) -> Result<Self> {
        let mut shaders = None;
        let mut src = None;
        let mut path = None;
        let mut bytes = None;
        let mut entry_points = None;
        let mut stage = None;

        let mut source_language = None;
        let mut vulkan_version = None;
        let mut spirv_version = None;
        let mut base_path = None;
        let mut base_path_env = None;
        let mut include_paths = None;
        let mut macro_defines = None;
        let mut generate_structs = None;
        let mut custom_derives = None;
        let mut linalg_types = None;

        while !input.is_empty() {
            let field = input.parse::<Ident>()?;
            input.parse::<Token![:]>()?;

            match field.to_string().as_str() {
                "shaders" => parse_shaders(input, field, &mut shaders)?,
                "src" => parse_src(input, field, &mut src)?,
                "path" => parse_path(input, field, &mut path)?,
                "bytes" => parse_bytes(input, field, &mut bytes)?,
                "entry_points" => parse_entry_points(input, field, &mut entry_points)?,
                "stage" => parse_stage(input, field, &mut stage)?,
                "lang" => parse_lang(input, field, &mut source_language)?,
                "vulkan_version" => parse_vulkan_version(input, field, &mut vulkan_version)?,
                "spirv_version" => parse_spirv_version(input, field, &mut spirv_version)?,
                "base_path" => parse_base_path(input, field, &mut base_path)?,
                "base_path_env" => parse_base_path_env(input, field, &mut base_path_env)?,
                "include" => parse_include(input, field, &mut include_paths)?,
                "define" => parse_define(input, field, &mut macro_defines)?,
                "generate_structs" => parse_generate_structs(input, field, &mut generate_structs)?,
                "custom_derives" => parse_custom_derives(input, field, &mut custom_derives)?,
                "linalg_types" => parse_linalg_types(input, field, &mut linalg_types)?,
                other => bail!(field, "unsupported field `{other}`"),
            }

            if !input.is_empty() {
                input.parse::<Token![,]>()?;
            }
        }

        let shaders = match (src, path, bytes, shaders) {
            (Some(src), None, None, None) => {
                let entry_points = match (entry_points, stage) {
                    (Some(entry_points), None) => entry_points,
                    (None, Some(stage)) => iter::once((None, stage)).collect(),
                    _ => bail!(
                        "exactly one of the fields `entry_points` and `stage` must be defined"
                    ),
                };

                iter::once((None, ShaderSource::Src { src, entry_points })).collect()
            }
            (None, Some(path), None, None) => {
                let entry_points = match (entry_points, stage) {
                    (Some(entry_points), None) => entry_points,
                    (None, Some(stage)) => iter::once((None, stage)).collect(),
                    _ => bail!(
                        "exactly one of the fields `entry_points` and `stage` must be defined"
                    ),
                };

                iter::once((None, ShaderSource::Path { path, entry_points })).collect()
            }
            (None, None, Some(bytes), None) => {
                if entry_points.is_some() {
                    bail!("field `entry_points` cannot be defined when `bytes` is used");
                }

                if stage.is_some() {
                    bail!("field `stage` cannot be defined when `bytes` is used");
                }

                iter::once((None, ShaderSource::Bytes { path: bytes })).collect()
            }
            (None, None, None, Some(shaders)) => {
                if entry_points.is_some() {
                    bail!("field `entry_points` cannot be defined when `shaders` is used");
                }

                if stage.is_some() {
                    bail!("field `stage` cannot be defined when `shaders` is used");
                }

                shaders
            }
            _ => bail!(
                "exactly one of the fields `src`, `path`, `bytes` and `shaders` must be defined"
            ),
        };

        let base_path = match (base_path, base_path_env) {
            (None, None) => None,
            (Some(base_path), None) => Some(BasePath::Path(base_path)),
            (None, Some(base_path_env)) => Some(BasePath::Env(base_path_env)),
            (Some(_), Some(_)) => {
                bail!("only one of the fields `base_path` and `base_path_env` can be defined");
            }
        };

        Ok(MacroInput {
            shaders,
            macro_options: MacroOptions {
                source_language: source_language.unwrap_or(SourceLanguage::GLSL),
                vulkan_version,
                spirv_version,
                base_path,
                include_paths: include_paths.unwrap_or_default(),
                macro_defines: macro_defines.unwrap_or_default(),
                generate_structs: generate_structs.unwrap_or(true),
                custom_derives: custom_derives.unwrap_or_else(|| {
                    vec![
                        parse_quote!(::std::clone::Clone),
                        parse_quote!(::std::marker::Copy),
                    ]
                }),
                linalg_types: linalg_types.unwrap_or_default(),
            },
        })
    }
}

fn parse_shaders(
    input: ParseStream<'_>,
    field: Ident,
    shaders: &mut Option<HashMap<Option<String>, ShaderSource>>,
) -> Result<()> {
    if shaders.is_some() {
        bail!(field, "field `shaders` was already defined");
    }

    let shaders = shaders.insert(HashMap::default());

    let in_braces;
    let braces = braced!(in_braces in input);

    while !in_braces.is_empty() {
        let mut src = None;
        let mut path = None;
        let mut bytes = None;
        let mut entry_points = None;
        let mut stage = None;

        let ident = in_braces.parse::<Ident>()?;
        in_braces.parse::<Token![:]>()?;
        let name = Some(ident.to_string());

        if shaders.contains_key(&name) {
            bail!(ident, "shader `{ident}` was already defined");
        }

        let in_shader;
        let shader = braced!(in_shader in in_braces);

        while !in_shader.is_empty() {
            let field = in_shader.parse::<Ident>()?;
            in_shader.parse::<Token![:]>()?;

            match field.to_string().as_str() {
                "src" => parse_src(&in_shader, field, &mut src)?,
                "path" => parse_path(&in_shader, field, &mut path)?,
                "bytes" => parse_bytes(&in_shader, field, &mut bytes)?,
                "entry_points" => parse_entry_points(&in_shader, field, &mut entry_points)?,
                "stage" => parse_stage(&in_shader, field, &mut stage)?,
                other => bail!(field, "unsupported field `{other}`"),
            }

            if !in_shader.is_empty() {
                in_shader.parse::<Token![,]>()?;
            }
        }

        let source = match (src, path, bytes) {
            (Some(src), None, None) => {
                let entry_points = match (entry_points, stage) {
                    (Some(entry_points), None) => entry_points,
                    (None, Some(stage)) => iter::once((None, stage)).collect(),
                    _ => bail!(
                        ident,
                        "exactly one of the fields `entry_points` and `stage` must be defined"
                    ),
                };

                ShaderSource::Src { src, entry_points }
            }
            (None, Some(path), None) => {
                let entry_points = match (entry_points, stage) {
                    (Some(entry_points), None) => entry_points,
                    (None, Some(stage)) => iter::once((None, stage)).collect(),
                    _ => bail!(
                        ident,
                        "exactly one of the fields `entry_points` and `stage` must be defined"
                    ),
                };

                ShaderSource::Path { path, entry_points }
            }
            (None, None, Some(bytes)) => {
                if entry_points.is_some() {
                    bail!(
                        ident,
                        "field `entry_points` cannot be defined when `bytes` is used"
                    );
                }

                if stage.is_some() {
                    bail!(
                        ident,
                        "field `stage` cannot be defined when `bytes` is used"
                    );
                }

                ShaderSource::Bytes { path: bytes }
            }
            _ => {
                return Err(Error::new(
                    shader.span.join(),
                    "exactly one of the fields `src`, `path` and `bytes` must be defined",
                ))
            }
        };

        shaders.insert(name, source);

        if !in_braces.is_empty() {
            in_braces.parse::<Token![,]>()?;
        }
    }

    if shaders.is_empty() {
        return Err(Error::new(
            braces.span.join(),
            "at least one shader must be defined",
        ));
    }

    Ok(())
}

fn parse_src(input: ParseStream<'_>, field: Ident, src: &mut Option<LitStr>) -> Result<()> {
    if src.is_some() {
        bail!(field, "field `src` was already defined");
    }

    *src = Some(input.parse::<LitStr>()?);
    Ok(())
}

fn parse_path(input: ParseStream<'_>, field: Ident, path: &mut Option<LitStr>) -> Result<()> {
    if path.is_some() {
        bail!(field, "field `path` was already defined");
    }

    *path = Some(input.parse::<LitStr>()?);
    Ok(())
}

fn parse_bytes(input: ParseStream<'_>, field: Ident, bytes: &mut Option<LitStr>) -> Result<()> {
    if bytes.is_some() {
        bail!(field, "field `bytes` was already defined");
    }

    *bytes = Some(input.parse::<LitStr>()?);
    Ok(())
}

fn parse_entry_points(
    input: ParseStream<'_>,
    field: Ident,
    entry_points: &mut Option<HashMap<Option<String>, ShaderKind>>,
) -> Result<()> {
    if entry_points.is_some() {
        bail!(field, "field `entry_points` was already defined");
    }

    let entry_points = entry_points.insert(HashMap::default());

    let in_braces;
    let braces = braced!(in_braces in input);

    while !in_braces.is_empty() {
        let ident = in_braces.parse::<Ident>()?;
        in_braces.parse::<Token![:]>()?;
        let name = Some(ident.to_string());

        if entry_points.contains_key(&name) {
            bail!(ident, "entry point `{ident}` was already defined");
        }

        entry_points.insert(name, parse_shader_kind(&in_braces)?);

        if !in_braces.is_empty() {
            in_braces.parse::<Token![,]>()?;
        }
    }

    if entry_points.is_empty() {
        return Err(Error::new(
            braces.span.join(),
            "at least one entry point must be defined",
        ));
    }

    Ok(())
}

fn parse_stage(input: ParseStream<'_>, field: Ident, stage: &mut Option<ShaderKind>) -> Result<()> {
    if stage.is_some() {
        bail!(field, "field `stage` was already defined");
    }

    *stage = Some(parse_shader_kind(input)?);
    Ok(())
}

fn parse_shader_kind(input: ParseStream<'_>) -> Result<ShaderKind> {
    let lit = input.parse::<LitStr>()?;

    Ok(match lit.value().as_str() {
        "vertex" => ShaderKind::Vertex,
        "fragment" => ShaderKind::Fragment,
        "compute" => ShaderKind::Compute,
        "geometry" => ShaderKind::Geometry,
        "tess_ctrl" => ShaderKind::TessControl,
        "tess_eval" => ShaderKind::TessEvaluation,
        "task" => ShaderKind::Task,
        "mesh" => ShaderKind::Mesh,
        "raygen" => ShaderKind::RayGeneration,
        "any_hit" => ShaderKind::AnyHit,
        "closest_hit" => ShaderKind::ClosestHit,
        "miss" => ShaderKind::Miss,
        "intersection" => ShaderKind::Intersection,
        "callable" => ShaderKind::Callable,
        other => bail!(
            lit,
            "expected `vertex`, `fragment`, `compute`, `geometry`, `tess_ctrl`, `tess_eval`, \
            `task`, `mesh`, `raygen`, `any_hit`, `closest_hit`, `miss`, `intersection` or \
            `callable, found `{other}`",
        ),
    })
}

fn parse_lang(
    input: ParseStream<'_>,
    field: Ident,
    source_language: &mut Option<SourceLanguage>,
) -> Result<()> {
    if source_language.is_some() {
        bail!(field, "field `lang` was already defined");
    }

    let lit = input.parse::<LitStr>()?;

    *source_language = Some(match lit.value().as_str() {
        "glsl" => SourceLanguage::GLSL,
        "hlsl" => SourceLanguage::HLSL,
        other => bail!(lit, "expected `glsl` or `hlsl`, found `{other}`"),
    });

    Ok(())
}

fn parse_vulkan_version(
    input: ParseStream<'_>,
    field: Ident,
    vulkan_version: &mut Option<EnvVersion>,
) -> Result<()> {
    if vulkan_version.is_some() {
        bail!(field, "field `vulkan_version` was already defined");
    }

    let lit = input.parse::<LitStr>()?;

    *vulkan_version = Some(match lit.value().as_str() {
        "1.0" => EnvVersion::Vulkan1_0,
        "1.1" => EnvVersion::Vulkan1_1,
        "1.2" => EnvVersion::Vulkan1_2,
        "1.3" => EnvVersion::Vulkan1_3,
        other => bail!(
            lit,
            "expected `1.0`, `1.1`, `1.2` or `1.3`, found `{other}`"
        ),
    });

    Ok(())
}

fn parse_spirv_version(
    input: ParseStream<'_>,
    field: Ident,
    spirv_version: &mut Option<SpirvVersion>,
) -> Result<()> {
    if spirv_version.is_some() {
        bail!(field, "field `spirv_version` was already defined");
    }

    let lit = input.parse::<LitStr>()?;

    *spirv_version = Some(match lit.value().as_str() {
        "1.0" => SpirvVersion::V1_0,
        "1.1" => SpirvVersion::V1_1,
        "1.2" => SpirvVersion::V1_2,
        "1.3" => SpirvVersion::V1_3,
        "1.4" => SpirvVersion::V1_4,
        "1.5" => SpirvVersion::V1_5,
        "1.6" => SpirvVersion::V1_6,
        other => bail!(
            lit,
            "expected `1.0`, `1.1`, `1.2`, `1.3`, `1.4`, `1.5` or `1.6`, found `{other}`",
        ),
    });

    Ok(())
}

fn parse_base_path(
    input: ParseStream<'_>,
    field: Ident,
    base_path: &mut Option<PathBuf>,
) -> Result<()> {
    if base_path.is_some() {
        bail!(field, "field `base_path` was already defined");
    }

    *base_path = Some(input.parse::<LitStr>()?.value().into());
    Ok(())
}

fn parse_base_path_env(
    input: ParseStream<'_>,
    field: Ident,
    base_path_env: &mut Option<LitStr>,
) -> Result<()> {
    if base_path_env.is_some() {
        bail!(field, "field `base_path_env` was already defined");
    }

    *base_path_env = Some(input.parse::<LitStr>()?);
    Ok(())
}

fn parse_include(
    input: ParseStream<'_>,
    field: Ident,
    include_paths: &mut Option<Vec<PathBuf>>,
) -> Result<()> {
    if include_paths.is_some() {
        bail!(field, "field `include` was already defined");
    }

    let include_paths = include_paths.insert(Vec::new());

    let in_brackets;
    bracketed!(in_brackets in input);

    while !in_brackets.is_empty() {
        include_paths.push(in_brackets.parse::<LitStr>()?.value().into());

        if !in_brackets.is_empty() {
            in_brackets.parse::<Token![,]>()?;
        }
    }

    Ok(())
}

fn parse_define(
    input: ParseStream<'_>,
    field: Ident,
    macro_defines: &mut Option<Vec<(String, Option<String>)>>,
) -> Result<()> {
    if macro_defines.is_some() {
        bail!(field, "field `define` was already defined");
    }

    let macro_defines = macro_defines.insert(Vec::new());

    let in_brackets;
    bracketed!(in_brackets in input);

    while !in_brackets.is_empty() {
        if in_brackets.peek(LitStr) {
            let name = in_brackets.parse::<LitStr>()?;
            macro_defines.push((name.value(), None));
        } else if in_brackets.peek(Paren) {
            let in_parens;
            parenthesized!(in_parens in in_brackets);

            let name = in_parens.parse::<LitStr>()?;
            in_parens.parse::<Token![,]>()?;
            let value = in_parens.parse::<LitStr>()?;

            macro_defines.push((name.value(), Some(value.value())));
        } else {
            return Err(in_brackets.error("expected a string literal or `(`"));
        }

        if !in_brackets.is_empty() {
            in_brackets.parse::<Token![,]>()?;
        }
    }

    Ok(())
}

fn parse_generate_structs(
    input: ParseStream<'_>,
    field: Ident,
    generate_structs: &mut Option<bool>,
) -> Result<()> {
    if generate_structs.is_some() {
        bail!(field, "field `generate_structs` was already defined");
    }

    *generate_structs = Some(input.parse::<LitBool>()?.value);
    Ok(())
}

fn parse_custom_derives(
    input: ParseStream<'_>,
    field: Ident,
    custom_derives: &mut Option<Vec<syn::Path>>,
) -> Result<()> {
    if custom_derives.is_some() {
        bail!(field, "field `custom_derives` was already defined");
    }

    let custom_derives = custom_derives.insert(Vec::new());

    let in_brackets;
    bracketed!(in_brackets in input);

    while !in_brackets.is_empty() {
        custom_derives.push(in_brackets.parse::<syn::Path>()?);

        if !in_brackets.is_empty() {
            in_brackets.parse::<Token![,]>()?;
        }
    }

    Ok(())
}

fn parse_linalg_types(
    input: ParseStream<'_>,
    field: Ident,
    linalg_types: &mut Option<LinAlgTypes>,
) -> Result<()> {
    if linalg_types.is_some() {
        bail!(field, "field `linalg_types` was already defined");
    }

    let lit = input.parse::<LitStr>()?;

    *linalg_types = Some(match lit.value().as_str() {
        "std" => LinAlgTypes::Std,
        "cgmath" => LinAlgTypes::Cgmath,
        "nalgebra" => LinAlgTypes::Nalgebra,
        other => bail!(
            lit,
            "expected `std`, `cgmath` or `nalgebra`, found `{other}`"
        ),
    });

    Ok(())
}

macro_rules! bail {
    ($msg:literal $(,)?) => {
        return Err(syn::Error::new(
            proc_macro2::Span::call_site(),
            format!($msg),
        ))
    };
    ($span:expr, $msg:literal $(,)?) => {
        return Err(syn::Error::new_spanned(&$span, format!($msg)))
    };
}
use bail;
