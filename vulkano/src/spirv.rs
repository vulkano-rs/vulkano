// Copyright (c) 2021 The Vulkano developers
// Licensed under the Apache License, Version 2.0
// <LICENSE-APACHE or
// https://www.apache.org/licenses/LICENSE-2.0> or the MIT
// license <LICENSE-MIT or https://opensource.org/licenses/MIT>,
// at your option. All files in the project carrying such
// notice may not be copied, modified, or distributed except
// according to those terms.

use crate::Version;
use std::{
    error::Error,
    fmt::{self, Display, Formatter},
    string::FromUtf8Error,
};

// Generated by build.rs
include!(concat!(env!("OUT_DIR"), "/spirv.rs"));

/// A parsed and analyzed SPIR-V module.
#[derive(Clone, Debug)]
pub struct Spirv {
    version: Version,
    bound: u32,
    instructions: Vec<Instruction>,
}

impl Spirv {
    /// Parses a SPIR-V document from a list of words.
    pub fn new(words: &[u32]) -> Result<Spirv, SpirvError> {
        if words.len() < 5 {
            return Err(SpirvError::InvalidHeader);
        }

        if words[0] != 0x07230203 {
            return Err(SpirvError::InvalidHeader);
        }

        let version = Version {
            major: (words[1] & 0x00ff0000) >> 16,
            minor: (words[1] & 0x0000ff00) >> 8,
            patch: words[1] & 0x000000ff,
        };

        let bound = words[3];

        let instructions = {
            let mut ret = Vec::new();
            let mut rest = &words[5..];
            while !rest.is_empty() {
                let word_count = (rest[0] >> 16) as usize;
                assert!(word_count >= 1);

                if rest.len() < word_count {
                    return Err(ParseError {
                        instruction: ret.len(),
                        word: rest.len(),
                        error: ParseErrors::UnexpectedEOF,
                        words: rest.to_owned(),
                    }
                    .into());
                }

                let mut reader = InstructionReader::new(&rest[0..word_count], ret.len());
                let instruction = Instruction::parse(&mut reader)?;

                if !reader.is_empty() {
                    return Err(reader.map_err(ParseErrors::LeftoverOperands).into());
                }

                ret.push(instruction);
                rest = &rest[word_count..];
            }
            ret
        };

        Ok(Spirv {
            version,
            bound,
            instructions,
        })
    }

    /// Returns a reference to the instructions in the module.
    #[inline]
    pub fn instructions(&self) -> &[Instruction] {
        &self.instructions
    }

    /// Returns the SPIR-V version that this module is compiled for.
    #[inline]
    pub fn version(&self) -> Version {
        self.version
    }

    /// Returns the upper bound of `Id`s in this module.
    ///
    /// All `Id`s should have a numeric value strictly less than this value. It can be used to
    /// pre-allocate an array of the appropriate size to hold all `Id`s.
    #[inline]
    pub fn bound(&self) -> u32 {
        self.bound
    }
}

/// Used in SPIR-V to refer to the result of another instruction.
///
/// Ids are global across a module, and are immutable once assigned.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct Id(u32);

impl From<Id> for u32 {
    #[inline]
    fn from(id: Id) -> u32 {
        id.0
    }
}

impl Display for Id {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        write!(f, "%{}", self.0)
    }
}

/// Helper type for parsing the words of an instruction.
#[derive(Debug)]
struct InstructionReader<'a> {
    words: &'a [u32],
    next_word: usize,
    instruction: usize,
}

impl<'a> InstructionReader<'a> {
    /// Constructs a new reader from a slice of words for a single instruction, including the opcode
    /// word. `instruction` is the number of the instruction currently being read, and is used for
    /// error reporting.
    #[inline]
    fn new(words: &'a [u32], instruction: usize) -> Self {
        debug_assert!(!words.is_empty());
        Self {
            words,
            next_word: 0,
            instruction,
        }
    }

    /// Returns whether the reader has reached the end of the current instruction.
    #[inline]
    fn is_empty(&self) -> bool {
        self.next_word >= self.words.len()
    }

    /// Converts the `ParseErrors` enum to the `ParseError` struct, adding contextual information.
    #[inline]
    fn map_err(&self, error: ParseErrors) -> ParseError {
        ParseError {
            instruction: self.instruction,
            word: self.next_word - 1, // -1 because the word has already been read
            error,
            words: self.words.to_owned(),
        }
    }

    /// Returns the next word in the sequence.
    #[inline]
    fn next_u32(&mut self) -> Result<u32, ParseError> {
        let word = *self.words.get(self.next_word).ok_or(ParseError {
            instruction: self.instruction,
            word: self.next_word, // No -1 because we didn't advance yet
            error: ParseErrors::MissingOperands,
            words: self.words.to_owned(),
        })?;
        self.next_word += 1;
        Ok(word)
    }

    /// Returns the next two words as a single `u64`.
    #[inline]
    fn next_u64(&mut self) -> Result<u64, ParseError> {
        Ok(self.next_u32()? as u64 | (self.next_u32()? as u64) << 32)
    }

    /// Reads a nul-terminated string.
    fn next_string(&mut self) -> Result<String, ParseError> {
        let mut bytes = Vec::new();
        loop {
            let word = self.next_u32()?.to_le_bytes();

            if let Some(nul) = word.iter().position(|&b| b == 0) {
                bytes.extend(&word[0..nul]);
                break;
            } else {
                bytes.extend(word);
            }
        }
        String::from_utf8(bytes).map_err(|err| self.map_err(ParseErrors::FromUtf8Error(err)))
    }

    /// Reads all remaining words.
    #[inline]
    fn remainder(&mut self) -> Vec<u32> {
        let vec = self.words[self.next_word..].to_owned();
        self.next_word = self.words.len();
        vec
    }
}

/// Error that can happen when reading a SPIR-V module.
#[derive(Clone, Debug)]
pub enum SpirvError {
    InvalidHeader,
    ParseError(ParseError),
}

impl Display for SpirvError {
    #[inline]
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        match self {
            Self::InvalidHeader => write!(f, "the SPIR-V module header was invalid"),
            Self::ParseError(_) => write!(f, "parse error"),
        }
    }
}

impl Error for SpirvError {
    #[inline]
    fn source(&self) -> Option<&(dyn Error + 'static)> {
        match self {
            Self::ParseError(err) => Some(err),
            _ => None,
        }
    }
}

impl From<ParseError> for SpirvError {
    #[inline]
    fn from(err: ParseError) -> Self {
        Self::ParseError(err)
    }
}

/// Error that can happen when parsing SPIR-V instructions into Rust data structures.
#[derive(Clone, Debug)]
pub struct ParseError {
    /// The instruction number the error happened at, starting from 0.
    pub instruction: usize,
    /// The word from the start of the instruction that the error happened at, starting from 0.
    pub word: usize,
    /// The error.
    pub error: ParseErrors,
    /// The words of the instruction.
    pub words: Vec<u32>,
}

impl Display for ParseError {
    #[inline]
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        write!(
            f,
            "at instruction {}, word {}: {}",
            self.instruction, self.word, self.error
        )
    }
}

impl Error for ParseError {}

#[derive(Clone, Debug)]
pub enum ParseErrors {
    FromUtf8Error(FromUtf8Error),
    LeftoverOperands,
    MissingOperands,
    UnexpectedEOF,
    UnknownEnumerant(&'static str, u32),
    UnknownOpcode(u16),
    UnknownSpecConstantOpcode(u16),
}

impl Display for ParseErrors {
    #[inline]
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        match self {
            Self::FromUtf8Error(err) => write!(f, "invalid UTF-8 in string literal"),
            Self::LeftoverOperands => write!(f, "unparsed operands remaining"),
            Self::MissingOperands => write!(f, "the instruction and its operands require more words than are present in the instruction"),
            Self::UnexpectedEOF => write!(f, "encountered unexpected end of file"),
            Self::UnknownEnumerant(ty, enumerant) => write!(f, "invalid enumerant {} for enum {}", enumerant, ty),
            Self::UnknownOpcode(opcode) => write!(f, "invalid instruction opcode {}", opcode),
            Self::UnknownSpecConstantOpcode(opcode) => write!(f, "invalid spec constant instruction opcode {}", opcode),
        }
    }
}

pub struct FoundDecoration<'a> {
    pub target_id: Id,
    pub decoration: &'a Decoration,
}

impl Spirv {
    /// Returns the params and the id of all decorations that match the passed Decoration type
    ///
    /// for each matching OpDecorate:
    ///     if it points at a regular target:
    ///         creates a FoundDecoration with its params and target_id
    ///     if it points at a group:
    ///         the OpDecorate's target_id is ignored and a seperate FoundDecoration is created only for each target_id given in matching OpGroupDecorate instructions.
    pub fn get_decorations(
        &self,
        find_decoration: impl Fn(&Decoration) -> bool,
    ) -> Vec<FoundDecoration> {
        let mut decorations = vec![];
        for instruction in &self.instructions {
            if let Instruction::Decorate {
                target,
                ref decoration,
            } = instruction
            {
                if find_decoration(decoration) {
                    // assume by default it is just pointing at the target_id
                    let mut target_ids = vec![*target];

                    // however it might be pointing at a group, which can have multiple target_ids
                    for inner_instruction in &self.instructions {
                        if let Instruction::DecorationGroup { result_id } = inner_instruction {
                            if *result_id == *target {
                                target_ids.clear();

                                for inner_instruction in &self.instructions {
                                    if let Instruction::GroupDecorate {
                                        decoration_group,
                                        targets,
                                    } = inner_instruction
                                    {
                                        if *decoration_group == *target {
                                            target_ids.extend(targets);
                                        }
                                    }
                                }

                                // result_id must be unique so we can safely break here
                                break;
                            }
                        }
                    }

                    // create for all target_ids found
                    for target_id in target_ids {
                        decorations.push(FoundDecoration {
                            target_id,
                            decoration,
                        });
                    }
                }
            }
        }
        decorations
    }

    /// Returns the params held by the decoration for the specified id and type
    /// Searches OpDecorate and OpGroupMemberDecorate
    /// Returns None if such a decoration does not exist
    pub fn get_decoration_params(
        &self,
        id: Id,
        find_decoration: impl Fn(&Decoration) -> bool,
    ) -> Option<&Decoration> {
        for instruction in &self.instructions {
            match instruction {
                Instruction::Decorate {
                    target,
                    ref decoration,
                } if *target == id && find_decoration(decoration) => {
                    return Some(decoration);
                }
                Instruction::GroupDecorate {
                    decoration_group,
                    ref targets,
                } => {
                    for group_target_id in targets {
                        if *group_target_id == id {
                            for instruction in &self.instructions {
                                if let Instruction::Decorate {
                                    target,
                                    ref decoration,
                                } = instruction
                                {
                                    if target == decoration_group && find_decoration(decoration) {
                                        return Some(decoration);
                                    }
                                }
                            }
                        }
                    }
                }
                _ => (),
            };
        }
        None
    }

    /// Returns the params held by the decoration for the member specified by id, member and type
    /// Searches OpMemberDecorate and OpGroupMemberDecorate
    /// Returns None if such a decoration does not exist
    pub fn get_member_decoration_params(
        &self,
        struct_id: Id,
        member_literal: u32,
        find_decoration: impl Fn(&Decoration) -> bool,
    ) -> Option<&Decoration> {
        for instruction in &self.instructions {
            match instruction {
                Instruction::MemberDecorate {
                    structure_type,
                    member,
                    ref decoration,
                } if *structure_type == struct_id
                    && *member == member_literal
                    && find_decoration(decoration) =>
                {
                    return Some(decoration);
                }
                Instruction::GroupMemberDecorate {
                    decoration_group,
                    ref targets,
                } => {
                    for (group_target_struct_id, group_target_member_literal) in targets {
                        if *group_target_struct_id == struct_id
                            && *group_target_member_literal == member_literal
                        {
                            for instruction in &self.instructions {
                                if let Instruction::Decorate {
                                    target,
                                    ref decoration,
                                } = instruction
                                {
                                    if target == decoration_group && find_decoration(decoration) {
                                        return Some(decoration);
                                    }
                                }
                            }
                        }
                    }
                }
                _ => (),
            };
        }
        None
    }

    /// Returns the params held by the Decoration::BuiltIn for the specified struct id
    /// Searches OpMemberDecorate and OpGroupMemberDecorate
    /// Returns None if such a decoration does not exist
    ///
    /// This function does not need a member_literal argument because the spirv spec requires that a
    /// struct must contain either all builtin or all non-builtin members.
    pub fn get_member_decoration_builtin_params(&self, struct_id: Id) -> Option<&BuiltIn> {
        for instruction in &self.instructions {
            match instruction {
                Instruction::MemberDecorate {
                    structure_type,
                    decoration: Decoration::BuiltIn { built_in },
                    ..
                } if *structure_type == struct_id => {
                    return Some(built_in);
                }
                Instruction::GroupMemberDecorate {
                    decoration_group,
                    ref targets,
                } => {
                    for (group_target_struct_id, _) in targets {
                        if *group_target_struct_id == struct_id {
                            for instruction in &self.instructions {
                                if let Instruction::Decorate {
                                    target,
                                    decoration: Decoration::BuiltIn { built_in },
                                } = instruction
                                {
                                    if target == decoration_group {
                                        return Some(built_in);
                                    }
                                }
                            }
                        }
                    }
                }
                _ => (),
            };
        }
        None
    }
}
