use super::physical::{
    ConformanceVersion, DriverId, MemoryDecompressionMethods, OpticalFlowGridSizes,
    PhysicalDeviceType, PipelineRobustnessBufferBehavior, PipelineRobustnessImageBehavior,
    PointClippingBehavior, RayTracingInvocationReorderMode, ShaderCoreProperties,
    ShaderFloatControlsIndependence, SubgroupFeatures,
};
use crate::{
    buffer::BufferUsage,
    device::{
        physical::{LayeredDriverUnderlyingApi, PhysicalDeviceSchedulingControlsFlags},
        DeviceExtensions, QueueFlags,
    },
    image::{sampler::ycbcr::ChromaLocation, ImageLayout, ImageUsage, SampleCount, SampleCounts},
    instance::InstanceExtensions,
    memory::DeviceAlignment,
    render_pass::ResolveModes,
    shader::ShaderStages,
    DeviceSize, Version,
};
use std::ffi::c_char;

// Generated by build.rs
include!(concat!(env!("OUT_DIR"), "/properties.rs"));

// A bit of a hack...
// TODO: integrate into autogen?
pub(crate) trait FromVulkan<F>
where
    Self: Sized,
{
    fn from_vulkan(val: F) -> Option<Self>;
}

impl FromVulkan<u8> for u8 {
    #[inline]
    fn from_vulkan(val: u8) -> Option<Self> {
        Some(val)
    }
}

impl<const N: usize> FromVulkan<[u8; N]> for [u8; N] {
    #[inline]
    fn from_vulkan(val: [u8; N]) -> Option<Self> {
        Some(val)
    }
}

impl FromVulkan<u32> for u32 {
    #[inline]
    fn from_vulkan(val: u32) -> Option<Self> {
        Some(val)
    }
}

impl<const N: usize> FromVulkan<[u32; N]> for [u32; N] {
    #[inline]
    fn from_vulkan(val: [u32; N]) -> Option<Self> {
        Some(val)
    }
}

impl FromVulkan<u64> for u64 {
    #[inline]
    fn from_vulkan(val: u64) -> Option<Self> {
        Some(val)
    }
}

impl FromVulkan<u64> for DeviceAlignment {
    #[inline]
    fn from_vulkan(val: u64) -> Option<Self> {
        DeviceAlignment::new(val)
    }
}

impl FromVulkan<usize> for usize {
    #[inline]
    fn from_vulkan(val: usize) -> Option<Self> {
        Some(val)
    }
}

impl FromVulkan<i32> for i32 {
    #[inline]
    fn from_vulkan(val: i32) -> Option<Self> {
        Some(val)
    }
}

impl FromVulkan<i64> for i64 {
    #[inline]
    fn from_vulkan(val: i64) -> Option<Self> {
        Some(val)
    }
}

impl FromVulkan<f32> for f32 {
    #[inline]
    fn from_vulkan(val: f32) -> Option<Self> {
        Some(val)
    }
}

impl<const N: usize> FromVulkan<[f32; N]> for [f32; N] {
    #[inline]
    fn from_vulkan(val: [f32; N]) -> Option<Self> {
        Some(val)
    }
}

impl<const N: usize> FromVulkan<[c_char; N]> for String {
    /// <https://github.com/ash-rs/ash/blob/b724b78dac8d83879ed7a1aad2b91bb9f2beb5cf/ash/src/vk/prelude.rs#L66-L73>
    #[inline]
    fn from_vulkan(val: [c_char; N]) -> Option<Self> {
        // SAFETY: The cast from c_char to u8 is ok because a c_char is always one byte.
        let bytes = unsafe { core::slice::from_raw_parts(val.as_ptr().cast(), val.len()) };
        Some(
            core::ffi::CStr::from_bytes_until_nul(bytes)
                .unwrap()
                .to_string_lossy()
                .into_owned(),
        )
    }
}

impl FromVulkan<u32> for Version {
    #[inline]
    fn from_vulkan(val: u32) -> Option<Self> {
        Some(val.into())
    }
}

impl FromVulkan<ash::vk::Bool32> for bool {
    #[inline]
    fn from_vulkan(val: ash::vk::Bool32) -> Option<Self> {
        Some(val != 0)
    }
}

impl FromVulkan<ash::vk::ConformanceVersion> for ConformanceVersion {
    #[inline]
    fn from_vulkan(val: ash::vk::ConformanceVersion) -> Option<Self> {
        Some(val.into())
    }
}

impl FromVulkan<ash::vk::DriverId> for DriverId {
    #[inline]
    fn from_vulkan(val: ash::vk::DriverId) -> Option<Self> {
        val.try_into().ok()
    }
}

impl FromVulkan<ash::vk::Extent2D> for [u32; 2] {
    #[inline]
    fn from_vulkan(val: ash::vk::Extent2D) -> Option<Self> {
        Some([val.width, val.height])
    }
}

impl FromVulkan<ash::vk::MemoryDecompressionMethodFlagsNV> for MemoryDecompressionMethods {
    #[inline]
    fn from_vulkan(val: ash::vk::MemoryDecompressionMethodFlagsNV) -> Option<Self> {
        Some(val.into())
    }
}

impl FromVulkan<ash::vk::OpticalFlowGridSizeFlagsNV> for OpticalFlowGridSizes {
    #[inline]
    fn from_vulkan(val: ash::vk::OpticalFlowGridSizeFlagsNV) -> Option<Self> {
        Some(val.into())
    }
}

impl FromVulkan<ash::vk::PhysicalDeviceType> for PhysicalDeviceType {
    #[inline]
    fn from_vulkan(val: ash::vk::PhysicalDeviceType) -> Option<Self> {
        val.try_into().ok()
    }
}

impl FromVulkan<ash::vk::PipelineRobustnessBufferBehaviorEXT> for PipelineRobustnessBufferBehavior {
    #[inline]
    fn from_vulkan(val: ash::vk::PipelineRobustnessBufferBehaviorEXT) -> Option<Self> {
        val.try_into().ok()
    }
}

impl FromVulkan<ash::vk::PipelineRobustnessImageBehaviorEXT> for PipelineRobustnessImageBehavior {
    #[inline]
    fn from_vulkan(val: ash::vk::PipelineRobustnessImageBehaviorEXT) -> Option<Self> {
        val.try_into().ok()
    }
}

impl FromVulkan<ash::vk::PointClippingBehavior> for PointClippingBehavior {
    #[inline]
    fn from_vulkan(val: ash::vk::PointClippingBehavior) -> Option<Self> {
        val.try_into().ok()
    }
}

impl FromVulkan<ash::vk::QueueFlags> for QueueFlags {
    #[inline]
    fn from_vulkan(val: ash::vk::QueueFlags) -> Option<Self> {
        Some(val.into())
    }
}

impl FromVulkan<ash::vk::RayTracingInvocationReorderModeNV> for RayTracingInvocationReorderMode {
    #[inline]
    fn from_vulkan(val: ash::vk::RayTracingInvocationReorderModeNV) -> Option<Self> {
        val.try_into().ok()
    }
}

impl FromVulkan<ash::vk::ResolveModeFlags> for ResolveModes {
    #[inline]
    fn from_vulkan(val: ash::vk::ResolveModeFlags) -> Option<Self> {
        Some(val.into())
    }
}

impl FromVulkan<ash::vk::SampleCountFlags> for SampleCounts {
    #[inline]
    fn from_vulkan(val: ash::vk::SampleCountFlags) -> Option<Self> {
        Some(val.into())
    }
}

impl FromVulkan<ash::vk::SampleCountFlags> for SampleCount {
    #[inline]
    fn from_vulkan(val: ash::vk::SampleCountFlags) -> Option<Self> {
        val.try_into().ok()
    }
}

impl FromVulkan<ash::vk::ShaderCorePropertiesFlagsAMD> for ShaderCoreProperties {
    #[inline]
    fn from_vulkan(val: ash::vk::ShaderCorePropertiesFlagsAMD) -> Option<Self> {
        Some(val.into())
    }
}

impl FromVulkan<ash::vk::ShaderFloatControlsIndependence> for ShaderFloatControlsIndependence {
    #[inline]
    fn from_vulkan(val: ash::vk::ShaderFloatControlsIndependence) -> Option<Self> {
        val.try_into().ok()
    }
}

impl FromVulkan<ash::vk::ShaderStageFlags> for ShaderStages {
    #[inline]
    fn from_vulkan(val: ash::vk::ShaderStageFlags) -> Option<Self> {
        Some(val.into())
    }
}

impl FromVulkan<ash::vk::SubgroupFeatureFlags> for SubgroupFeatures {
    #[inline]
    fn from_vulkan(val: ash::vk::SubgroupFeatureFlags) -> Option<Self> {
        Some(val.into())
    }
}

impl FromVulkan<ash::vk::BufferUsageFlags> for BufferUsage {
    #[inline]
    fn from_vulkan(val: ash::vk::BufferUsageFlags) -> Option<Self> {
        Some(val.into())
    }
}

impl FromVulkan<ash::vk::ImageUsageFlags> for ImageUsage {
    #[inline]
    fn from_vulkan(val: ash::vk::ImageUsageFlags) -> Option<Self> {
        Some(val.into())
    }
}

impl FromVulkan<ash::vk::ChromaLocation> for ChromaLocation {
    #[inline]
    fn from_vulkan(val: ash::vk::ChromaLocation) -> Option<Self> {
        val.try_into().ok()
    }
}

impl FromVulkan<ash::vk::PhysicalDeviceSchedulingControlsFlagsARM>
    for PhysicalDeviceSchedulingControlsFlags
{
    #[inline]
    fn from_vulkan(val: ash::vk::PhysicalDeviceSchedulingControlsFlagsARM) -> Option<Self> {
        Some(val.into())
    }
}

impl FromVulkan<ash::vk::LayeredDriverUnderlyingApiMSFT> for LayeredDriverUnderlyingApi {
    #[inline]
    fn from_vulkan(val: ash::vk::LayeredDriverUnderlyingApiMSFT) -> Option<Self> {
        Some(val.into())
    }
}

impl FromVulkan<ash::vk::ImageLayout> for ImageLayout {
    #[inline]
    fn from_vulkan(val: ash::vk::ImageLayout) -> Option<Self> {
        val.try_into().ok()
    }
}

impl<U: for<'a> FromVulkan<&'a T>, T> FromVulkan<&[T]> for Vec<U> {
    #[inline]
    fn from_vulkan(val: &[T]) -> Option<Vec<U>> {
        val.iter()
            .map(|it| U::from_vulkan(it))
            .collect::<Option<Vec<_>>>()
    }
}

impl<U: FromVulkan<T>, T: Copy> FromVulkan<&T> for U {
    #[inline]
    fn from_vulkan(val: &T) -> Option<Self> {
        U::from_vulkan(*val)
    }
}
