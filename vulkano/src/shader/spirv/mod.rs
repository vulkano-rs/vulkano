// Copyright (c) 2021 The Vulkano developers
// Licensed under the Apache License, Version 2.0
// <LICENSE-APACHE or
// https://www.apache.org/licenses/LICENSE-2.0> or the MIT
// license <LICENSE-MIT or https://opensource.org/licenses/MIT>,
// at your option. All files in the project carrying such
// notice may not be copied, modified, or distributed except
// according to those terms.

//! Parsing and analysis utilities for SPIR-V shader binaries.
//!
//! This can be used to inspect and validate a SPIR-V module at runtime. The `Spirv` type does some
//! validation, but you should not assume that code that is read successfully is valid.
//!
//! For more information about SPIR-V modules, instructions and types, see the
//! [SPIR-V specification](https://registry.khronos.org/SPIR-V/specs/unified1/SPIRV.html).

use crate::{shader::SpecializationConstant, Version};
use ahash::{HashMap, HashMapExt};
use std::{
    borrow::Cow,
    error::Error,
    fmt::{Display, Error as FmtError, Formatter},
    string::FromUtf8Error,
    sync::Arc,
};

mod specialization;

// Generated by build.rs
include!(concat!(env!("OUT_DIR"), "/spirv_parse.rs"));

/// A parsed and analyzed SPIR-V module.
#[derive(Clone, Debug)]
pub struct Spirv {
    version: Version,
    bound: u32,
    ids: HashMap<Id, IdInfo>,

    // Items described in the spec section "Logical Layout of a Module"
    instructions_capability: Vec<Arc<Instruction>>,
    instructions_extension: Vec<Arc<Instruction>>,
    instructions_ext_inst_import: Vec<Arc<Instruction>>,
    instruction_memory_model: Arc<Instruction>,
    instructions_entry_point: Vec<Arc<Instruction>>,
    instructions_execution_mode: Vec<Arc<Instruction>>,
    instructions_name: Vec<Arc<Instruction>>,
    instructions_decoration: Vec<Arc<Instruction>>,
    instructions_global: Vec<Arc<Instruction>>,
    functions: HashMap<Id, FunctionInfo>,
}

impl Spirv {
    /// Parses a SPIR-V document from a list of words.
    pub fn new(words: &[u32]) -> Result<Spirv, SpirvError> {
        if words.len() < 5 {
            return Err(SpirvError::InvalidHeader);
        }

        if words[0] != 0x07230203 {
            return Err(SpirvError::InvalidHeader);
        }

        let version = Version {
            major: (words[1] & 0x00ff0000) >> 16,
            minor: (words[1] & 0x0000ff00) >> 8,
            patch: words[1] & 0x000000ff,
        };

        let bound = words[3];
        let instructions: Vec<_> = iter_instructions(&words[5..]).collect::<Result<_, _>>()?;

        // It is impossible for a valid SPIR-V file to contain more Ids than instructions, so put
        // a sane upper limit on the allocation. This prevents a malicious file from causing huge
        // memory allocations.
        let mut ids = HashMap::with_capacity(instructions.len().min(bound as usize));

        // For safety, we recalculate the bound ourselves.
        let mut actual_bound = 0;

        let mut instructions_capability = Vec::new();
        let mut instructions_extension = Vec::new();
        let mut instructions_ext_inst_import = Vec::new();
        let mut instructions_memory_model = Vec::new();
        let mut instructions_entry_point = Vec::new();
        let mut instructions_execution_mode = Vec::new();
        let mut instructions_name = Vec::new();
        let mut instructions_decoration = Vec::new();
        let mut instructions_global = Vec::new();

        let mut functions = HashMap::default();
        let mut current_function: Option<&mut Vec<Arc<Instruction>>> = None;

        for instruction in instructions {
            if let Some(id) = instruction.result_id() {
                if u32::from(id) >= bound {
                    return Err(SpirvError::IdOutOfBounds { id, bound });
                }

                actual_bound = actual_bound.max(u32::from(id) + 1);

                let members =
                    if let Instruction::TypeStruct { member_types, .. } = instruction.as_ref() {
                        member_types
                            .iter()
                            .map(|_| StructMemberInfo::default())
                            .collect()
                    } else {
                        Vec::new()
                    };

                let data = IdInfo {
                    instruction: instruction.clone(),
                    names: Vec::new(),
                    decorations: Vec::new(),
                    members,
                };

                if ids.insert(id, data).is_some() {
                    return Err(SpirvError::DuplicateId { id });
                }
            }

            if matches!(
                instruction.as_ref(),
                Instruction::Line { .. } | Instruction::NoLine { .. }
            ) {
                continue;
            }

            if current_function.is_some() {
                match *instruction.as_ref() {
                    Instruction::FunctionEnd { .. } => {
                        current_function.take().unwrap().push(instruction);
                    }
                    _ => current_function.as_mut().unwrap().push(instruction),
                }
            } else {
                let destination = match *instruction.as_ref() {
                    Instruction::Function { result_id, .. } => {
                        current_function = None;
                        let function = functions.entry(result_id).or_insert(FunctionInfo {
                            instructions: Vec::new(),
                        });
                        current_function.insert(&mut function.instructions)
                    }
                    Instruction::Capability { .. } => &mut instructions_capability,
                    Instruction::Extension { .. } => &mut instructions_extension,
                    Instruction::ExtInstImport { .. } => &mut instructions_ext_inst_import,
                    Instruction::MemoryModel { .. } => &mut instructions_memory_model,
                    Instruction::EntryPoint { .. } => &mut instructions_entry_point,
                    Instruction::ExecutionMode { .. } | Instruction::ExecutionModeId { .. } => {
                        &mut instructions_execution_mode
                    }
                    Instruction::Name { .. } | Instruction::MemberName { .. } => {
                        &mut instructions_name
                    }
                    Instruction::Decorate { .. }
                    | Instruction::MemberDecorate { .. }
                    | Instruction::DecorationGroup { .. }
                    | Instruction::GroupDecorate { .. }
                    | Instruction::GroupMemberDecorate { .. }
                    | Instruction::DecorateId { .. }
                    | Instruction::DecorateString { .. }
                    | Instruction::MemberDecorateString { .. } => &mut instructions_decoration,
                    Instruction::TypeVoid { .. }
                    | Instruction::TypeBool { .. }
                    | Instruction::TypeInt { .. }
                    | Instruction::TypeFloat { .. }
                    | Instruction::TypeVector { .. }
                    | Instruction::TypeMatrix { .. }
                    | Instruction::TypeImage { .. }
                    | Instruction::TypeSampler { .. }
                    | Instruction::TypeSampledImage { .. }
                    | Instruction::TypeArray { .. }
                    | Instruction::TypeRuntimeArray { .. }
                    | Instruction::TypeStruct { .. }
                    | Instruction::TypeOpaque { .. }
                    | Instruction::TypePointer { .. }
                    | Instruction::TypeFunction { .. }
                    | Instruction::TypeEvent { .. }
                    | Instruction::TypeDeviceEvent { .. }
                    | Instruction::TypeReserveId { .. }
                    | Instruction::TypeQueue { .. }
                    | Instruction::TypePipe { .. }
                    | Instruction::TypeForwardPointer { .. }
                    | Instruction::TypePipeStorage { .. }
                    | Instruction::TypeNamedBarrier { .. }
                    | Instruction::TypeRayQueryKHR { .. }
                    | Instruction::TypeAccelerationStructureKHR { .. }
                    | Instruction::TypeCooperativeMatrixNV { .. }
                    | Instruction::TypeVmeImageINTEL { .. }
                    | Instruction::TypeAvcImePayloadINTEL { .. }
                    | Instruction::TypeAvcRefPayloadINTEL { .. }
                    | Instruction::TypeAvcSicPayloadINTEL { .. }
                    | Instruction::TypeAvcMcePayloadINTEL { .. }
                    | Instruction::TypeAvcMceResultINTEL { .. }
                    | Instruction::TypeAvcImeResultINTEL { .. }
                    | Instruction::TypeAvcImeResultSingleReferenceStreamoutINTEL { .. }
                    | Instruction::TypeAvcImeResultDualReferenceStreamoutINTEL { .. }
                    | Instruction::TypeAvcImeSingleReferenceStreaminINTEL { .. }
                    | Instruction::TypeAvcImeDualReferenceStreaminINTEL { .. }
                    | Instruction::TypeAvcRefResultINTEL { .. }
                    | Instruction::TypeAvcSicResultINTEL { .. }
                    | Instruction::ConstantTrue { .. }
                    | Instruction::ConstantFalse { .. }
                    | Instruction::Constant { .. }
                    | Instruction::ConstantComposite { .. }
                    | Instruction::ConstantSampler { .. }
                    | Instruction::ConstantNull { .. }
                    | Instruction::ConstantPipeStorage { .. }
                    | Instruction::SpecConstantTrue { .. }
                    | Instruction::SpecConstantFalse { .. }
                    | Instruction::SpecConstant { .. }
                    | Instruction::SpecConstantComposite { .. }
                    | Instruction::SpecConstantOp { .. }
                    | Instruction::Variable { .. }
                    | Instruction::Undef { .. } => &mut instructions_global,
                    _ => continue,
                };

                destination.push(instruction);
            }
        }

        let mut spirv = Spirv {
            version,
            bound: actual_bound,
            ids,

            instructions_capability,
            instructions_extension,
            instructions_ext_inst_import,
            instruction_memory_model: instructions_memory_model.drain(..).next().unwrap(),
            instructions_entry_point,
            instructions_execution_mode,
            instructions_name,
            instructions_decoration,
            instructions_global,
            functions,
        };

        for instruction in &spirv.instructions_name {
            match instruction.as_ref() {
                Instruction::Name { target, .. } => {
                    spirv
                        .ids
                        .get_mut(target)
                        .unwrap()
                        .names
                        .push(instruction.clone());
                }
                Instruction::MemberName { ty, member, .. } => {
                    spirv.ids.get_mut(ty).unwrap().members[*member as usize]
                        .names
                        .push(instruction.clone());
                }
                _ => unreachable!(),
            }
        }

        // First handle all regular decorations, including those targeting decoration groups.
        for instruction in &spirv.instructions_decoration {
            match instruction.as_ref() {
                Instruction::Decorate { target, .. }
                | Instruction::DecorateId { target, .. }
                | Instruction::DecorateString { target, .. } => {
                    spirv
                        .ids
                        .get_mut(target)
                        .unwrap()
                        .decorations
                        .push(instruction.clone());
                }
                Instruction::MemberDecorate {
                    structure_type: target,
                    member,
                    ..
                }
                | Instruction::MemberDecorateString {
                    struct_type: target,
                    member,
                    ..
                } => {
                    spirv.ids.get_mut(target).unwrap().members[*member as usize]
                        .decorations
                        .push(instruction.clone());
                }
                _ => (),
            }
        }

        // Then, with decoration groups having their lists complete, handle group decorates.
        for instruction in &spirv.instructions_decoration {
            match *instruction.as_ref() {
                Instruction::GroupDecorate {
                    decoration_group,
                    ref targets,
                    ..
                } => {
                    let instructions = {
                        let data = &spirv.ids[&decoration_group];
                        if !matches!(
                            data.instruction.as_ref(),
                            Instruction::DecorationGroup { .. }
                        ) {
                            return Err(SpirvError::GroupDecorateNotGroup {
                                id: decoration_group,
                            });
                        };
                        data.decorations.clone()
                    };

                    for target in targets {
                        spirv
                            .ids
                            .get_mut(target)
                            .unwrap()
                            .decorations
                            .extend(instructions.iter().cloned());
                    }
                }
                Instruction::GroupMemberDecorate {
                    decoration_group,
                    ref targets,
                    ..
                } => {
                    let instructions = {
                        let data = &spirv.ids[&decoration_group];
                        if !matches!(
                            data.instruction.as_ref(),
                            Instruction::DecorationGroup { .. }
                        ) {
                            return Err(SpirvError::GroupDecorateNotGroup {
                                id: decoration_group,
                            });
                        };
                        data.decorations.clone()
                    };

                    for (target, member) in targets {
                        spirv.ids.get_mut(target).unwrap().members[*member as usize]
                            .decorations
                            .extend(instructions.iter().cloned());
                    }
                }
                _ => (),
            }
        }

        Ok(spirv)
    }

    /// Returns the SPIR-V version that the module is compiled for.
    #[inline]
    pub fn version(&self) -> Version {
        self.version
    }

    /// Returns information about an `Id`.
    ///
    /// # Panics
    ///
    /// - Panics if `id` is not defined in this module. This can in theory only happpen if you are
    ///   mixing `Id`s from different modules.
    #[inline]
    pub fn id(&self, id: Id) -> &IdInfo {
        &self.ids[&id]
    }

    /// Returns the function with the given `id`, if it exists.
    ///
    /// # Panics
    ///
    /// - Panics if `id` is not defined in this module. This can in theory only happpen if you are
    ///   mixing `Id`s from different modules.
    #[inline]
    pub fn function(&self, id: Id) -> &FunctionInfo {
        &self.functions[&id]
    }

    /// Returns an iterator over all `Capability` instructions.
    #[inline]
    pub fn iter_capability(&self) -> impl ExactSizeIterator<Item = &Arc<Instruction>> {
        self.instructions_capability.iter()
    }

    /// Returns an iterator over all `Extension` instructions.
    #[inline]
    pub fn iter_extension(&self) -> impl ExactSizeIterator<Item = &Arc<Instruction>> {
        self.instructions_extension.iter()
    }

    /// Returns an iterator over all `ExtInstImport` instructions.
    #[inline]
    pub fn iter_ext_inst_import(&self) -> impl ExactSizeIterator<Item = &Arc<Instruction>> {
        self.instructions_ext_inst_import.iter()
    }

    /// Returns the `MemoryModel` instruction.
    #[inline]
    pub fn memory_model(&self) -> &Arc<Instruction> {
        &self.instruction_memory_model
    }

    /// Returns an iterator over all `EntryPoint` instructions.
    #[inline]
    pub fn iter_entry_point(&self) -> impl ExactSizeIterator<Item = &Arc<Instruction>> {
        self.instructions_entry_point.iter()
    }

    /// Returns an iterator over all execution mode instructions.
    #[inline]
    pub fn iter_execution_mode(&self) -> impl ExactSizeIterator<Item = &Arc<Instruction>> {
        self.instructions_execution_mode.iter()
    }

    /// Returns an iterator over all name debug instructions.
    #[inline]
    pub fn iter_name(&self) -> impl ExactSizeIterator<Item = &Arc<Instruction>> {
        self.instructions_name.iter()
    }

    /// Returns an iterator over all decoration instructions.
    #[inline]
    pub fn iter_decoration(&self) -> impl ExactSizeIterator<Item = &Arc<Instruction>> {
        self.instructions_decoration.iter()
    }

    /// Returns an iterator over all global declaration instructions: types,
    /// constants and global variables.
    #[inline]
    pub fn iter_global(&self) -> impl ExactSizeIterator<Item = &Arc<Instruction>> {
        self.instructions_global.iter()
    }

    /// Returns an iterator over all functions.
    #[inline]
    pub fn iter_functions(&self) -> impl ExactSizeIterator<Item = &FunctionInfo> {
        self.functions.values()
    }

    pub fn apply_specialization(
        &mut self,
        specialization_info: &HashMap<u32, SpecializationConstant>,
    ) {
        self.instructions_global = specialization::replace_specialization_instructions(
            specialization_info,
            self.instructions_global.drain(..),
            &self.ids,
            self.bound,
        );

        for instruction in &self.instructions_global {
            if let Some(id) = instruction.result_id() {
                if let Some(id_info) = self.ids.get_mut(&id) {
                    id_info.instruction = instruction.clone();
                    id_info.decorations.retain(|instruction| {
                        !matches!(
                            instruction.as_ref(),
                            Instruction::Decorate {
                                decoration: Decoration::SpecId { .. },
                                ..
                            }
                        )
                    });
                } else {
                    self.ids.insert(
                        id,
                        IdInfo {
                            instruction: instruction.clone(),
                            names: Vec::new(),
                            decorations: Vec::new(),
                            members: Vec::new(),
                        },
                    );
                    self.bound = self.bound.max(u32::from(id) + 1);
                }
            }
        }

        self.instructions_decoration.retain(|instruction| {
            !matches!(
                instruction.as_ref(),
                Instruction::Decorate {
                    decoration: Decoration::SpecId { .. },
                    ..
                }
            )
        });
    }
}

/// Used in SPIR-V to refer to the result of another instruction.
///
/// Ids are global across a module, and are always assigned by exactly one instruction.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct Id(u32);

impl Id {
    // Returns the raw numeric value of this Id.
    #[inline]
    pub const fn as_raw(self) -> u32 {
        self.0
    }
}

impl From<Id> for u32 {
    #[inline]
    fn from(id: Id) -> u32 {
        id.as_raw()
    }
}

impl Display for Id {
    #[inline]
    fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), FmtError> {
        write!(f, "%{}", self.0)
    }
}

/// Information associated with an `Id`.
#[derive(Clone, Debug)]
pub struct IdInfo {
    instruction: Arc<Instruction>,
    names: Vec<Arc<Instruction>>,
    decorations: Vec<Arc<Instruction>>,
    members: Vec<StructMemberInfo>,
}

impl IdInfo {
    /// Returns the instruction that defines this `Id` with a `result_id` operand.
    #[inline]
    pub fn instruction(&self) -> &Arc<Instruction> {
        &self.instruction
    }

    /// Returns an iterator over all name debug instructions that target this `Id`.
    #[inline]
    pub fn iter_name(&self) -> impl ExactSizeIterator<Item = &Arc<Instruction>> {
        self.names.iter()
    }

    /// Returns an iterator over all decorate instructions, that target this `Id`. This includes any
    /// decorate instructions that target this `Id` indirectly via a `DecorationGroup`.
    #[inline]
    pub fn iter_decoration(&self) -> impl ExactSizeIterator<Item = &Arc<Instruction>> {
        self.decorations.iter()
    }

    /// If this `Id` refers to a `TypeStruct`, returns an iterator of information about each member
    /// of the struct. Empty otherwise.
    #[inline]
    pub fn iter_members(&self) -> impl ExactSizeIterator<Item = &StructMemberInfo> {
        self.members.iter()
    }
}

/// Information associated with a member of a `TypeStruct` instruction.
#[derive(Clone, Debug, Default)]
pub struct StructMemberInfo {
    names: Vec<Arc<Instruction>>,
    decorations: Vec<Arc<Instruction>>,
}

impl StructMemberInfo {
    /// Returns an iterator over all name debug instructions that target this struct member.
    #[inline]
    pub fn iter_name(&self) -> impl ExactSizeIterator<Item = &Arc<Instruction>> {
        self.names.iter()
    }

    /// Returns an iterator over all decorate instructions that target this struct member. This
    /// includes any decorate instructions that target this member indirectly via a
    /// `DecorationGroup`.
    #[inline]
    pub fn iter_decoration(&self) -> impl ExactSizeIterator<Item = &Arc<Instruction>> {
        self.decorations.iter()
    }
}

/// Information associated with a function.
#[derive(Clone, Debug, Default)]
pub struct FunctionInfo {
    instructions: Vec<Arc<Instruction>>,
}

impl FunctionInfo {
    /// Returns an iterator over all instructions in the function.
    #[inline]
    pub fn iter_instructions(&self) -> impl ExactSizeIterator<Item = &Arc<Instruction>> {
        self.instructions.iter()
    }
}

fn iter_instructions(
    mut words: &[u32],
) -> impl Iterator<Item = Result<Arc<Instruction>, ParseError>> + '_ {
    let mut index = 0;
    let next = move || -> Option<Result<Arc<Instruction>, ParseError>> {
        if words.is_empty() {
            return None;
        }

        let word_count = (words[0] >> 16) as usize;
        assert!(word_count >= 1);

        if words.len() < word_count {
            return Some(Err(ParseError {
                instruction: index,
                word: words.len(),
                error: ParseErrors::UnexpectedEOF,
                words: words.to_owned(),
            }));
        }

        let mut reader = InstructionReader::new(&words[0..word_count], index);
        let instruction = match Instruction::parse(&mut reader) {
            Ok(x) => x,
            Err(err) => return Some(Err(err)),
        };

        if !reader.is_empty() {
            return Some(Err(reader.map_err(ParseErrors::LeftoverOperands)));
        }

        words = &words[word_count..];
        index += 1;
        Some(Ok(Arc::new(instruction)))
    };

    std::iter::from_fn(next)
}

/// Helper type for parsing the words of an instruction.
#[derive(Debug)]
struct InstructionReader<'a> {
    words: &'a [u32],
    next_word: usize,
    instruction: usize,
}

impl<'a> InstructionReader<'a> {
    /// Constructs a new reader from a slice of words for a single instruction, including the opcode
    /// word. `instruction` is the number of the instruction currently being read, and is used for
    /// error reporting.
    fn new(words: &'a [u32], instruction: usize) -> Self {
        debug_assert!(!words.is_empty());
        Self {
            words,
            next_word: 0,
            instruction,
        }
    }

    /// Returns whether the reader has reached the end of the current instruction.
    fn is_empty(&self) -> bool {
        self.next_word >= self.words.len()
    }

    /// Converts the `ParseErrors` enum to the `ParseError` struct, adding contextual information.
    fn map_err(&self, error: ParseErrors) -> ParseError {
        ParseError {
            instruction: self.instruction,
            word: self.next_word - 1, // -1 because the word has already been read
            error,
            words: self.words.to_owned(),
        }
    }

    /// Returns the next word in the sequence.
    fn next_word(&mut self) -> Result<u32, ParseError> {
        let word = *self.words.get(self.next_word).ok_or(ParseError {
            instruction: self.instruction,
            word: self.next_word, // No -1 because we didn't advance yet
            error: ParseErrors::MissingOperands,
            words: self.words.to_owned(),
        })?;
        self.next_word += 1;

        Ok(word)
    }

    /*
    /// Returns the next two words as a single `u64`.
    #[inline]
    fn next_u64(&mut self) -> Result<u64, ParseError> {
        Ok(self.next_word()? as u64 | (self.next_word()? as u64) << 32)
    }
    */

    /// Reads a nul-terminated string.
    fn next_string(&mut self) -> Result<String, ParseError> {
        let mut bytes = Vec::new();
        loop {
            let word = self.next_word()?.to_le_bytes();

            if let Some(nul) = word.iter().position(|&b| b == 0) {
                bytes.extend(&word[0..nul]);
                break;
            } else {
                bytes.extend(word);
            }
        }
        String::from_utf8(bytes).map_err(|err| self.map_err(ParseErrors::FromUtf8Error(err)))
    }

    /// Reads all remaining words.
    fn remainder(&mut self) -> Vec<u32> {
        let vec = self.words[self.next_word..].to_owned();
        self.next_word = self.words.len();
        vec
    }
}

/// Error that can happen when reading a SPIR-V module.
#[derive(Clone, Debug)]
pub enum SpirvError {
    DuplicateId { id: Id },
    GroupDecorateNotGroup { id: Id },
    IdOutOfBounds { id: Id, bound: u32 },
    InvalidHeader,
    ParseError(ParseError),
}

impl Display for SpirvError {
    fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), FmtError> {
        match self {
            Self::DuplicateId { id } => write!(f, "id {} is assigned more than once", id,),
            Self::GroupDecorateNotGroup { id } => write!(
                f,
                "a GroupDecorate or GroupMemberDecorate instruction referred to Id {} \
                that was not a DecorationGroup",
                id,
            ),
            Self::IdOutOfBounds { id, bound } => {
                write!(f, "id {} is not below the maximum bound {}", id, bound,)
            }
            Self::InvalidHeader => write!(f, "the SPIR-V module header is invalid"),
            Self::ParseError(_) => write!(f, "parse error"),
        }
    }
}

impl Error for SpirvError {
    fn source(&self) -> Option<&(dyn Error + 'static)> {
        match self {
            Self::ParseError(err) => Some(err),
            _ => None,
        }
    }
}

impl From<ParseError> for SpirvError {
    fn from(err: ParseError) -> Self {
        Self::ParseError(err)
    }
}

/// Error that can happen when parsing SPIR-V instructions into Rust data structures.
#[derive(Clone, Debug)]
pub struct ParseError {
    /// The instruction number the error happened at, starting from 0.
    pub instruction: usize,
    /// The word from the start of the instruction that the error happened at, starting from 0.
    pub word: usize,
    /// The error.
    pub error: ParseErrors,
    /// The words of the instruction.
    pub words: Vec<u32>,
}

impl Display for ParseError {
    fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), FmtError> {
        write!(
            f,
            "at instruction {}, word {}: {}",
            self.instruction, self.word, self.error,
        )
    }
}

impl Error for ParseError {}

/// Individual types of parse error that can happen.
#[derive(Clone, Debug)]
pub enum ParseErrors {
    FromUtf8Error(FromUtf8Error),
    LeftoverOperands,
    MissingOperands,
    UnexpectedEOF,
    UnknownEnumerant(&'static str, u32),
    UnknownOpcode(u16),
    UnknownSpecConstantOpcode(u16),
}

impl Display for ParseErrors {
    fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), FmtError> {
        match self {
            Self::FromUtf8Error(_) => write!(f, "invalid UTF-8 in string literal"),
            Self::LeftoverOperands => write!(f, "unparsed operands remaining"),
            Self::MissingOperands => write!(
                f,
                "the instruction and its operands require more words than are present in the \
                instruction",
            ),
            Self::UnexpectedEOF => write!(f, "encountered unexpected end of file"),
            Self::UnknownEnumerant(ty, enumerant) => {
                write!(f, "invalid enumerant {} for enum {}", enumerant, ty)
            }
            Self::UnknownOpcode(opcode) => write!(f, "invalid instruction opcode {}", opcode),
            Self::UnknownSpecConstantOpcode(opcode) => {
                write!(f, "invalid spec constant instruction opcode {}", opcode)
            }
        }
    }
}

/// Converts SPIR-V bytes to words. If necessary, the byte order is swapped from little-endian
/// to native-endian.
pub fn bytes_to_words(bytes: &[u8]) -> Result<Cow<'_, [u32]>, SpirvBytesNotMultipleOf4> {
    // If the current target is little endian, and the slice already has the right size and
    // alignment, then we can just transmute the slice with bytemuck.
    #[cfg(target_endian = "little")]
    if let Ok(words) = bytemuck::try_cast_slice(bytes) {
        return Ok(Cow::Borrowed(words));
    }

    if bytes.len() % 4 != 0 {
        return Err(SpirvBytesNotMultipleOf4);
    }

    // TODO: Use `slice::array_chunks` once it's stable.
    let words: Vec<u32> = bytes
        .chunks_exact(4)
        .map(|chunk| u32::from_le_bytes(chunk.try_into().unwrap()))
        .collect();

    Ok(Cow::Owned(words))
}

#[derive(Clone, Copy, Debug, Default)]
pub struct SpirvBytesNotMultipleOf4;

impl Error for SpirvBytesNotMultipleOf4 {}

impl Display for SpirvBytesNotMultipleOf4 {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "the length of the provided slice is not a multiple of 4")
    }
}
