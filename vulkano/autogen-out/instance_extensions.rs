// This file is auto-generated by vulkano autogen from vk.xml header version 1.3.281.
// It should not be edited manually. Changes should be made by editing autogen.


///List of instance extensions that are enabled or available.
#[derive(Copy, Clone, PartialEq, Eq)]
#[repr(C)]
pub struct InstanceExtensions {
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_android_surface.html)
    ///- Requires:
    ///  - Instance extension [`khr_surface`](InstanceExtensions::khr_surface)
    pub khr_android_surface: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_device_group_creation.html)
    ///- Promoted to Vulkan 1.1
    pub khr_device_group_creation: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_display.html)
    ///- Requires:
    ///  - Instance extension [`khr_surface`](InstanceExtensions::khr_surface)
    pub khr_display: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_external_fence_capabilities.html)
    ///- Promoted to Vulkan 1.1
    ///- Requires:
    ///  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](InstanceExtensions::khr_get_physical_device_properties2)
    pub khr_external_fence_capabilities: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_external_memory_capabilities.html)
    ///- Promoted to Vulkan 1.1
    ///- Requires:
    ///  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](InstanceExtensions::khr_get_physical_device_properties2)
    pub khr_external_memory_capabilities: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_external_semaphore_capabilities.html)
    ///- Promoted to Vulkan 1.1
    ///- Requires:
    ///  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](InstanceExtensions::khr_get_physical_device_properties2)
    pub khr_external_semaphore_capabilities: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_get_display_properties2.html)
    ///- Requires:
    ///  - Instance extension [`khr_display`](InstanceExtensions::khr_display)
    pub khr_get_display_properties2: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_get_physical_device_properties2.html)
    ///- Promoted to Vulkan 1.1
    pub khr_get_physical_device_properties2: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_get_surface_capabilities2.html)
    ///- Requires:
    ///  - Instance extension [`khr_surface`](InstanceExtensions::khr_surface)
    pub khr_get_surface_capabilities2: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_portability_enumeration.html)
    pub khr_portability_enumeration: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_surface.html)
    pub khr_surface: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_surface_protected_capabilities.html)
    ///- Requires all of:
    ///  - Vulkan API version 1.1
    ///  - Instance extension [`khr_get_surface_capabilities2`](InstanceExtensions::khr_get_surface_capabilities2)
    pub khr_surface_protected_capabilities: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_wayland_surface.html)
    ///- Requires:
    ///  - Instance extension [`khr_surface`](InstanceExtensions::khr_surface)
    pub khr_wayland_surface: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_win32_surface.html)
    ///- Requires:
    ///  - Instance extension [`khr_surface`](InstanceExtensions::khr_surface)
    pub khr_win32_surface: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_xcb_surface.html)
    ///- Requires:
    ///  - Instance extension [`khr_surface`](InstanceExtensions::khr_surface)
    pub khr_xcb_surface: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_xlib_surface.html)
    ///- Requires:
    ///  - Instance extension [`khr_surface`](InstanceExtensions::khr_surface)
    pub khr_xlib_surface: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_acquire_drm_display.html)
    ///- Requires:
    ///  - Instance extension [`ext_direct_mode_display`](InstanceExtensions::ext_direct_mode_display)
    pub ext_acquire_drm_display: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_acquire_xlib_display.html)
    ///- Requires:
    ///  - Instance extension [`ext_direct_mode_display`](InstanceExtensions::ext_direct_mode_display)
    pub ext_acquire_xlib_display: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_debug_report.html)
    ///- Deprecated by [`ext_debug_utils`](InstanceExtensions::ext_debug_utils)
    pub ext_debug_report: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_debug_utils.html)
    pub ext_debug_utils: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_direct_mode_display.html)
    ///- Requires:
    ///  - Instance extension [`khr_display`](InstanceExtensions::khr_display)
    pub ext_direct_mode_display: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_directfb_surface.html)
    ///- Requires:
    ///  - Instance extension [`khr_surface`](InstanceExtensions::khr_surface)
    pub ext_directfb_surface: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_display_surface_counter.html)
    ///- Requires:
    ///  - Instance extension [`khr_display`](InstanceExtensions::khr_display)
    pub ext_display_surface_counter: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_headless_surface.html)
    ///- Requires:
    ///  - Instance extension [`khr_surface`](InstanceExtensions::khr_surface)
    pub ext_headless_surface: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_layer_settings.html)
    pub ext_layer_settings: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_metal_surface.html)
    ///- Requires:
    ///  - Instance extension [`khr_surface`](InstanceExtensions::khr_surface)
    pub ext_metal_surface: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_surface_maintenance1.html)
    ///- Requires all of:
    ///  - Instance extension [`khr_surface`](InstanceExtensions::khr_surface)
    ///  - Instance extension [`khr_get_surface_capabilities2`](InstanceExtensions::khr_get_surface_capabilities2)
    pub ext_surface_maintenance1: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_swapchain_colorspace.html)
    ///- Requires:
    ///  - Instance extension [`khr_surface`](InstanceExtensions::khr_surface)
    pub ext_swapchain_colorspace: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_validation_features.html)
    ///- Deprecated by [`ext_layer_settings`](InstanceExtensions::ext_layer_settings)
    pub ext_validation_features: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_validation_flags.html)
    ///- Deprecated by [`ext_layer_settings`](InstanceExtensions::ext_layer_settings)
    pub ext_validation_flags: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_FUCHSIA_imagepipe_surface.html)
    ///- Requires:
    ///  - Instance extension [`khr_surface`](InstanceExtensions::khr_surface)
    pub fuchsia_imagepipe_surface: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_GGP_stream_descriptor_surface.html)
    ///- Requires:
    ///  - Instance extension [`khr_surface`](InstanceExtensions::khr_surface)
    pub ggp_stream_descriptor_surface: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_GOOGLE_surfaceless_query.html)
    ///- Requires:
    ///  - Instance extension [`khr_surface`](InstanceExtensions::khr_surface)
    pub google_surfaceless_query: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_LUNARG_direct_driver_loading.html)
    pub lunarg_direct_driver_loading: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_MVK_ios_surface.html)
    ///- Deprecated by [`ext_metal_surface`](InstanceExtensions::ext_metal_surface)
    ///- Requires:
    ///  - Instance extension [`khr_surface`](InstanceExtensions::khr_surface)
    pub mvk_ios_surface: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_MVK_macos_surface.html)
    ///- Deprecated by [`ext_metal_surface`](InstanceExtensions::ext_metal_surface)
    ///- Requires:
    ///  - Instance extension [`khr_surface`](InstanceExtensions::khr_surface)
    pub mvk_macos_surface: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_NN_vi_surface.html)
    ///- Requires:
    ///  - Instance extension [`khr_surface`](InstanceExtensions::khr_surface)
    pub nn_vi_surface: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_NV_external_memory_capabilities.html)
    ///- Deprecated by [`khr_external_memory_capabilities`](InstanceExtensions::khr_external_memory_capabilities)
    pub nv_external_memory_capabilities: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_QNX_screen_surface.html)
    ///- Requires:
    ///  - Instance extension [`khr_surface`](InstanceExtensions::khr_surface)
    pub qnx_screen_surface: bool,
    pub _ne: crate::NonExhaustive<'static>,
}
impl InstanceExtensions {
    const COUNT: usize = 39usize;
    const NAMES_C: [&std::ffi::CStr; Self::COUNT] = [
        c"VK_KHR_android_surface",
        c"VK_KHR_device_group_creation",
        c"VK_KHR_display",
        c"VK_KHR_external_fence_capabilities",
        c"VK_KHR_external_memory_capabilities",
        c"VK_KHR_external_semaphore_capabilities",
        c"VK_KHR_get_display_properties2",
        c"VK_KHR_get_physical_device_properties2",
        c"VK_KHR_get_surface_capabilities2",
        c"VK_KHR_portability_enumeration",
        c"VK_KHR_surface",
        c"VK_KHR_surface_protected_capabilities",
        c"VK_KHR_wayland_surface",
        c"VK_KHR_win32_surface",
        c"VK_KHR_xcb_surface",
        c"VK_KHR_xlib_surface",
        c"VK_EXT_acquire_drm_display",
        c"VK_EXT_acquire_xlib_display",
        c"VK_EXT_debug_report",
        c"VK_EXT_debug_utils",
        c"VK_EXT_direct_mode_display",
        c"VK_EXT_directfb_surface",
        c"VK_EXT_display_surface_counter",
        c"VK_EXT_headless_surface",
        c"VK_EXT_layer_settings",
        c"VK_EXT_metal_surface",
        c"VK_EXT_surface_maintenance1",
        c"VK_EXT_swapchain_colorspace",
        c"VK_EXT_validation_features",
        c"VK_EXT_validation_flags",
        c"VK_FUCHSIA_imagepipe_surface",
        c"VK_GGP_stream_descriptor_surface",
        c"VK_GOOGLE_surfaceless_query",
        c"VK_LUNARG_direct_driver_loading",
        c"VK_MVK_ios_surface",
        c"VK_MVK_macos_surface",
        c"VK_NN_vi_surface",
        c"VK_NV_external_memory_capabilities",
        c"VK_QNX_screen_surface",
    ];
    ///Returns a `InstanceExtensions` with none of the members set.
    #[inline]
    pub const fn empty() -> Self {
        Self::from_array([false; Self::COUNT])
    }
    /// Returns the number of members set in self.
    #[inline]
    pub const fn count(self) -> u64 {
        crate::array_count(self.as_array()) as u64
    }
    /// Returns whether no members are set in `self`.
    #[inline]
    pub const fn is_empty(self) -> bool {
        crate::array_is_empty(self.as_array())
    }
    /// Returns whether any members are set in both `self` and `other`.
    #[inline]
    pub const fn intersects(&self, other: &Self) -> bool {
        crate::array_intersects(self.as_array(), other.as_array())
    }
    /// Returns whether all members in `other` are set in `self`.
    #[inline]
    pub const fn contains(&self, other: &Self) -> bool {
        crate::array_contains(self.as_array(), other.as_array())
    }
    /// Returns the union of `self` and `other`.
    #[inline]
    pub const fn union(&self, other: &Self) -> Self {
        Self::from_array(crate::array_union(self.as_array(), other.as_array()))
    }
    /// Returns the intersection of `self` and `other`.
    #[inline]
    pub const fn intersection(&self, other: &Self) -> Self {
        Self::from_array(crate::array_intersection(self.as_array(), other.as_array()))
    }
    /// Returns `self` without the members set in `other`.
    #[inline]
    pub const fn difference(&self, other: &Self) -> Self {
        Self::from_array(crate::array_difference(self.as_array(), other.as_array()))
    }
    /// Returns the members set in `self` or `other`, but not both.
    #[inline]
    pub const fn symmetric_difference(&self, other: &Self) -> Self {
        Self::from_array(
            crate::array_symmetric_difference(self.as_array(), other.as_array()),
        )
    }
    #[inline]
    const fn from_array(array: [bool; Self::COUNT]) -> Self {
        unsafe {
            ::std::mem::transmute::<[bool; Self::COUNT], InstanceExtensions>(array)
        }
    }
    #[inline]
    const fn as_array(&self) -> &[bool; Self::COUNT] {
        unsafe {
            ::std::mem::transmute::<&InstanceExtensions, &[bool; Self::COUNT]>(self)
        }
    }
    #[inline]
    const fn as_mut_array(&mut self) -> &mut [bool; Self::COUNT] {
        unsafe {
            ::std::mem::transmute::<
                &mut InstanceExtensions,
                &mut [bool; Self::COUNT],
            >(self)
        }
    }
    #[inline]
    fn iter(&self) -> extensions::Iter<'_> {
        extensions::Iter {
            inner: Self::NAMES_C.iter().copied().zip(self.as_array().iter().copied()),
        }
    }
    pub(crate) fn validate(
        &self,
        supported: &Self,
        api_version: Version,
    ) -> Result<(), Box<ValidationError>> {
        if self.khr_android_surface {
            if !supported.khr_android_surface {
                return Err(
                    Box::new(ValidationError {
                        problem: "contains `khr_android_surface`, but this extension is not supported by the library"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.khr_device_group_creation {
            if !supported.khr_device_group_creation {
                return Err(
                    Box::new(ValidationError {
                        problem: "contains `khr_device_group_creation`, but this extension is not supported by the library"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.khr_display {
            if !supported.khr_display {
                return Err(
                    Box::new(ValidationError {
                        problem: "contains `khr_display`, but this extension is not supported by the library"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.khr_external_fence_capabilities {
            if !supported.khr_external_fence_capabilities {
                return Err(
                    Box::new(ValidationError {
                        problem: "contains `khr_external_fence_capabilities`, but this extension is not supported by the library"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.khr_external_memory_capabilities {
            if !supported.khr_external_memory_capabilities {
                return Err(
                    Box::new(ValidationError {
                        problem: "contains `khr_external_memory_capabilities`, but this extension is not supported by the library"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.khr_external_semaphore_capabilities {
            if !supported.khr_external_semaphore_capabilities {
                return Err(
                    Box::new(ValidationError {
                        problem: "contains `khr_external_semaphore_capabilities`, but this extension is not supported by the library"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.khr_get_display_properties2 {
            if !supported.khr_get_display_properties2 {
                return Err(
                    Box::new(ValidationError {
                        problem: "contains `khr_get_display_properties2`, but this extension is not supported by the library"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.khr_get_physical_device_properties2 {
            if !supported.khr_get_physical_device_properties2 {
                return Err(
                    Box::new(ValidationError {
                        problem: "contains `khr_get_physical_device_properties2`, but this extension is not supported by the library"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.khr_get_surface_capabilities2 {
            if !supported.khr_get_surface_capabilities2 {
                return Err(
                    Box::new(ValidationError {
                        problem: "contains `khr_get_surface_capabilities2`, but this extension is not supported by the library"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.khr_portability_enumeration {
            if !supported.khr_portability_enumeration {
                return Err(
                    Box::new(ValidationError {
                        problem: "contains `khr_portability_enumeration`, but this extension is not supported by the library"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.khr_surface {
            if !supported.khr_surface {
                return Err(
                    Box::new(ValidationError {
                        problem: "contains `khr_surface`, but this extension is not supported by the library"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.khr_surface_protected_capabilities {
            if !supported.khr_surface_protected_capabilities {
                return Err(
                    Box::new(ValidationError {
                        problem: "contains `khr_surface_protected_capabilities`, but this extension is not supported by the library"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1) {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_surface_protected_capabilities`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.khr_wayland_surface {
            if !supported.khr_wayland_surface {
                return Err(
                    Box::new(ValidationError {
                        problem: "contains `khr_wayland_surface`, but this extension is not supported by the library"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.khr_win32_surface {
            if !supported.khr_win32_surface {
                return Err(
                    Box::new(ValidationError {
                        problem: "contains `khr_win32_surface`, but this extension is not supported by the library"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.khr_xcb_surface {
            if !supported.khr_xcb_surface {
                return Err(
                    Box::new(ValidationError {
                        problem: "contains `khr_xcb_surface`, but this extension is not supported by the library"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.khr_xlib_surface {
            if !supported.khr_xlib_surface {
                return Err(
                    Box::new(ValidationError {
                        problem: "contains `khr_xlib_surface`, but this extension is not supported by the library"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.ext_acquire_drm_display {
            if !supported.ext_acquire_drm_display {
                return Err(
                    Box::new(ValidationError {
                        problem: "contains `ext_acquire_drm_display`, but this extension is not supported by the library"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.ext_acquire_xlib_display {
            if !supported.ext_acquire_xlib_display {
                return Err(
                    Box::new(ValidationError {
                        problem: "contains `ext_acquire_xlib_display`, but this extension is not supported by the library"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.ext_debug_report {
            if !supported.ext_debug_report {
                return Err(
                    Box::new(ValidationError {
                        problem: "contains `ext_debug_report`, but this extension is not supported by the library"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.ext_debug_utils {
            if !supported.ext_debug_utils {
                return Err(
                    Box::new(ValidationError {
                        problem: "contains `ext_debug_utils`, but this extension is not supported by the library"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.ext_direct_mode_display {
            if !supported.ext_direct_mode_display {
                return Err(
                    Box::new(ValidationError {
                        problem: "contains `ext_direct_mode_display`, but this extension is not supported by the library"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.ext_directfb_surface {
            if !supported.ext_directfb_surface {
                return Err(
                    Box::new(ValidationError {
                        problem: "contains `ext_directfb_surface`, but this extension is not supported by the library"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.ext_display_surface_counter {
            if !supported.ext_display_surface_counter {
                return Err(
                    Box::new(ValidationError {
                        problem: "contains `ext_display_surface_counter`, but this extension is not supported by the library"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.ext_headless_surface {
            if !supported.ext_headless_surface {
                return Err(
                    Box::new(ValidationError {
                        problem: "contains `ext_headless_surface`, but this extension is not supported by the library"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.ext_layer_settings {
            if !supported.ext_layer_settings {
                return Err(
                    Box::new(ValidationError {
                        problem: "contains `ext_layer_settings`, but this extension is not supported by the library"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.ext_metal_surface {
            if !supported.ext_metal_surface {
                return Err(
                    Box::new(ValidationError {
                        problem: "contains `ext_metal_surface`, but this extension is not supported by the library"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.ext_surface_maintenance1 {
            if !supported.ext_surface_maintenance1 {
                return Err(
                    Box::new(ValidationError {
                        problem: "contains `ext_surface_maintenance1`, but this extension is not supported by the library"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.ext_swapchain_colorspace {
            if !supported.ext_swapchain_colorspace {
                return Err(
                    Box::new(ValidationError {
                        problem: "contains `ext_swapchain_colorspace`, but this extension is not supported by the library"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.ext_validation_features {
            if !supported.ext_validation_features {
                return Err(
                    Box::new(ValidationError {
                        problem: "contains `ext_validation_features`, but this extension is not supported by the library"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.ext_validation_flags {
            if !supported.ext_validation_flags {
                return Err(
                    Box::new(ValidationError {
                        problem: "contains `ext_validation_flags`, but this extension is not supported by the library"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.fuchsia_imagepipe_surface {
            if !supported.fuchsia_imagepipe_surface {
                return Err(
                    Box::new(ValidationError {
                        problem: "contains `fuchsia_imagepipe_surface`, but this extension is not supported by the library"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.ggp_stream_descriptor_surface {
            if !supported.ggp_stream_descriptor_surface {
                return Err(
                    Box::new(ValidationError {
                        problem: "contains `ggp_stream_descriptor_surface`, but this extension is not supported by the library"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.google_surfaceless_query {
            if !supported.google_surfaceless_query {
                return Err(
                    Box::new(ValidationError {
                        problem: "contains `google_surfaceless_query`, but this extension is not supported by the library"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.lunarg_direct_driver_loading {
            if !supported.lunarg_direct_driver_loading {
                return Err(
                    Box::new(ValidationError {
                        problem: "contains `lunarg_direct_driver_loading`, but this extension is not supported by the library"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.mvk_ios_surface {
            if !supported.mvk_ios_surface {
                return Err(
                    Box::new(ValidationError {
                        problem: "contains `mvk_ios_surface`, but this extension is not supported by the library"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.mvk_macos_surface {
            if !supported.mvk_macos_surface {
                return Err(
                    Box::new(ValidationError {
                        problem: "contains `mvk_macos_surface`, but this extension is not supported by the library"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.nn_vi_surface {
            if !supported.nn_vi_surface {
                return Err(
                    Box::new(ValidationError {
                        problem: "contains `nn_vi_surface`, but this extension is not supported by the library"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.nv_external_memory_capabilities {
            if !supported.nv_external_memory_capabilities {
                return Err(
                    Box::new(ValidationError {
                        problem: "contains `nv_external_memory_capabilities`, but this extension is not supported by the library"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.qnx_screen_surface {
            if !supported.qnx_screen_surface {
                return Err(
                    Box::new(ValidationError {
                        problem: "contains `qnx_screen_surface`, but this extension is not supported by the library"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        Ok(())
    }
    pub(crate) fn enable_dependencies(
        &self,
        #[allow(unused_variables)]
        api_version: Version,
        #[allow(unused_variables)]
        supported: &Self,
    ) -> Self {
        let mut enabled = *self;
        if self.khr_android_surface {
            if !(self.khr_surface) {
                enabled.khr_surface = true;
            }
        }
        if self.khr_display {
            if !(self.khr_surface) {
                enabled.khr_surface = true;
            }
        }
        if self.khr_external_fence_capabilities {
            if !(api_version >= crate::Version::V1_1
                || self.khr_get_physical_device_properties2)
            {
                enabled.khr_get_physical_device_properties2 = true;
            }
        }
        if self.khr_external_memory_capabilities {
            if !(api_version >= crate::Version::V1_1
                || self.khr_get_physical_device_properties2)
            {
                enabled.khr_get_physical_device_properties2 = true;
            }
        }
        if self.khr_external_semaphore_capabilities {
            if !(api_version >= crate::Version::V1_1
                || self.khr_get_physical_device_properties2)
            {
                enabled.khr_get_physical_device_properties2 = true;
            }
        }
        if self.khr_get_display_properties2 {
            if !(self.khr_display) {
                enabled.khr_display = true;
            }
        }
        if self.khr_get_surface_capabilities2 {
            if !(self.khr_surface) {
                enabled.khr_surface = true;
            }
        }
        if self.khr_surface_protected_capabilities {
            if !(self.khr_get_surface_capabilities2) {
                enabled.khr_get_surface_capabilities2 = true;
            }
        }
        if self.khr_wayland_surface {
            if !(self.khr_surface) {
                enabled.khr_surface = true;
            }
        }
        if self.khr_win32_surface {
            if !(self.khr_surface) {
                enabled.khr_surface = true;
            }
        }
        if self.khr_xcb_surface {
            if !(self.khr_surface) {
                enabled.khr_surface = true;
            }
        }
        if self.khr_xlib_surface {
            if !(self.khr_surface) {
                enabled.khr_surface = true;
            }
        }
        if self.ext_acquire_drm_display {
            if !(self.ext_direct_mode_display) {
                enabled.ext_direct_mode_display = true;
            }
        }
        if self.ext_acquire_xlib_display {
            if !(self.ext_direct_mode_display) {
                enabled.ext_direct_mode_display = true;
            }
        }
        if self.ext_direct_mode_display {
            if !(self.khr_display) {
                enabled.khr_display = true;
            }
        }
        if self.ext_directfb_surface {
            if !(self.khr_surface) {
                enabled.khr_surface = true;
            }
        }
        if self.ext_display_surface_counter {
            if !(self.khr_display) {
                enabled.khr_display = true;
            }
        }
        if self.ext_headless_surface {
            if !(self.khr_surface) {
                enabled.khr_surface = true;
            }
        }
        if self.ext_metal_surface {
            if !(self.khr_surface) {
                enabled.khr_surface = true;
            }
        }
        if self.ext_surface_maintenance1 {
            if !(self.khr_surface) {
                enabled.khr_surface = true;
            }
            if !(self.khr_get_surface_capabilities2) {
                enabled.khr_get_surface_capabilities2 = true;
            }
        }
        if self.ext_swapchain_colorspace {
            if !(self.khr_surface) {
                enabled.khr_surface = true;
            }
        }
        if self.fuchsia_imagepipe_surface {
            if !(self.khr_surface) {
                enabled.khr_surface = true;
            }
        }
        if self.ggp_stream_descriptor_surface {
            if !(self.khr_surface) {
                enabled.khr_surface = true;
            }
        }
        if self.google_surfaceless_query {
            if !(self.khr_surface) {
                enabled.khr_surface = true;
            }
        }
        if self.mvk_ios_surface {
            if !(self.khr_surface) {
                enabled.khr_surface = true;
            }
        }
        if self.mvk_macos_surface {
            if !(self.khr_surface) {
                enabled.khr_surface = true;
            }
        }
        if self.nn_vi_surface {
            if !(self.khr_surface) {
                enabled.khr_surface = true;
            }
        }
        if self.qnx_screen_surface {
            if !(self.khr_surface) {
                enabled.khr_surface = true;
            }
        }
        enabled
    }
    pub(crate) fn from_vk<'a>(iter: impl IntoIterator<Item = &'a str>) -> Self {
        let names = Self::NAMES_C
            .iter()
            .map(|name| unsafe { std::str::from_utf8_unchecked(name.to_bytes()) });
        let mut val = Self::empty();
        for name in iter {
            if let Some(index) = names.clone().position(|n| n == name) {
                val.as_mut_array()[index] = true;
            }
        }
        val
    }
    #[allow(clippy::wrong_self_convention)]
    pub(crate) fn to_vk(&self) -> Vec<&'static CStr> {
        let mut val_vk = Vec::new();
        for index in 0..Self::COUNT {
            if self.as_array()[index] {
                val_vk.push(Self::NAMES_C[index]);
            }
        }
        val_vk
    }
}
impl std::fmt::Debug for InstanceExtensions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        f.debug_list()
            .entries(
                self
                    .iter()
                    .flat_map(|(extension_name_c, enabled)| {
                        enabled.then_some(extension_name_c)
                    }),
            )
            .finish()
    }
}
impl Default for InstanceExtensions {
    #[inline]
    fn default() -> Self {
        Self::empty()
    }
}
impl std::ops::BitAnd for InstanceExtensions {
    type Output = InstanceExtensions;
    #[inline]
    fn bitand(self, rhs: Self) -> Self::Output {
        self.intersection(&rhs)
    }
}
impl std::ops::BitAndAssign for InstanceExtensions {
    #[inline]
    fn bitand_assign(&mut self, rhs: Self) {
        *self = self.intersection(&rhs);
    }
}
impl std::ops::BitOr for InstanceExtensions {
    type Output = InstanceExtensions;
    #[inline]
    fn bitor(self, rhs: Self) -> Self::Output {
        self.union(&rhs)
    }
}
impl std::ops::BitOrAssign for InstanceExtensions {
    #[inline]
    fn bitor_assign(&mut self, rhs: Self) {
        *self = self.union(&rhs);
    }
}
impl std::ops::BitXor for InstanceExtensions {
    type Output = InstanceExtensions;
    #[inline]
    fn bitxor(self, rhs: Self) -> Self::Output {
        self.symmetric_difference(&rhs)
    }
}
impl std::ops::BitXorAssign for InstanceExtensions {
    #[inline]
    fn bitxor_assign(&mut self, rhs: Self) {
        *self = self.symmetric_difference(&rhs);
    }
}
impl std::ops::Sub for InstanceExtensions {
    type Output = InstanceExtensions;
    #[inline]
    fn sub(self, rhs: Self) -> Self::Output {
        self.difference(&rhs)
    }
}
impl std::ops::SubAssign for InstanceExtensions {
    #[inline]
    fn sub_assign(&mut self, rhs: Self) {
        *self = self.difference(&rhs);
    }
}
impl<'a> IntoIterator for &'a InstanceExtensions {
    type Item = (&'static str, bool);
    type IntoIter = extensions::Iter<'a>;
    #[inline]
    fn into_iter(self) -> Self::IntoIter {
        self.iter()
    }
}
mod extensions {
    pub struct Iter<'a> {
        pub(crate) inner: std::iter::Zip<
            std::iter::Copied<std::slice::Iter<'a, &'static std::ffi::CStr>>,
            std::iter::Copied<std::slice::Iter<'a, bool>>,
        >,
    }
    impl<'a> Iterator for Iter<'a> {
        type Item = (&'static str, bool);
        #[inline]
        fn next(&mut self) -> Option<Self::Item> {
            self.inner
                .next()
                .map(|(name, enabled)| {
                    (unsafe { std::str::from_utf8_unchecked(name.to_bytes()) }, enabled)
                })
        }
        #[inline]
        fn size_hint(&self) -> (usize, Option<usize>) {
            self.inner.size_hint()
        }
        #[inline]
        fn nth(&mut self, n: usize) -> Option<Self::Item> {
            self.inner
                .nth(n)
                .map(|(name, enabled)| {
                    (unsafe { std::str::from_utf8_unchecked(name.to_bytes()) }, enabled)
                })
        }
    }
    impl<'a> DoubleEndedIterator for Iter<'a> {
        #[inline]
        fn next_back(&mut self) -> Option<Self::Item> {
            self.inner
                .next_back()
                .map(|(name, enabled)| {
                    (unsafe { std::str::from_utf8_unchecked(name.to_bytes()) }, enabled)
                })
        }
    }
    impl ExactSizeIterator for Iter<'_> {
        #[inline]
        fn len(&self) -> usize {
            self.inner.len()
        }
    }
    impl std::iter::FusedIterator for Iter<'_> {}
}
