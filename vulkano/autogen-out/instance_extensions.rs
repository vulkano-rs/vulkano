// This file is auto-generated by vulkano autogen from vk.xml header version 1.3.281.
// It should not be edited manually. Changes should be made by editing autogen.


/// List of extensions that are enabled or available.
#[derive(Copy, Clone, PartialEq, Eq)]
pub struct InstanceExtensions {
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_android_surface.html)
- Requires all of:
  - instance extension [`khr_surface`](crate::instance::InstanceExtensions::khr_surface)*/
    pub khr_android_surface: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_device_group_creation.html)
- Promoted to Vulkan 1.1*/
    pub khr_device_group_creation: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_display.html)
- Requires all of:
  - instance extension [`khr_surface`](crate::instance::InstanceExtensions::khr_surface)*/
    pub khr_display: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_external_fence_capabilities.html)
- Promoted to Vulkan 1.1
- Requires all of:
  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](crate::instance::InstanceExtensions::khr_get_physical_device_properties2)*/
    pub khr_external_fence_capabilities: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_external_memory_capabilities.html)
- Promoted to Vulkan 1.1
- Requires all of:
  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](crate::instance::InstanceExtensions::khr_get_physical_device_properties2)*/
    pub khr_external_memory_capabilities: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_external_semaphore_capabilities.html)
- Promoted to Vulkan 1.1
- Requires all of:
  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](crate::instance::InstanceExtensions::khr_get_physical_device_properties2)*/
    pub khr_external_semaphore_capabilities: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_get_display_properties2.html)
- Requires all of:
  - instance extension [`khr_display`](crate::instance::InstanceExtensions::khr_display)*/
    pub khr_get_display_properties2: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_get_physical_device_properties2.html)
- Promoted to Vulkan 1.1*/
    pub khr_get_physical_device_properties2: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_get_surface_capabilities2.html)
- Requires all of:
  - instance extension [`khr_surface`](crate::instance::InstanceExtensions::khr_surface)*/
    pub khr_get_surface_capabilities2: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_portability_enumeration.html)
    pub khr_portability_enumeration: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_surface.html)
    pub khr_surface: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_surface_protected_capabilities.html)
- Requires all of:
  - Vulkan API version 1.1
  - instance extension [`khr_get_surface_capabilities2`](crate::instance::InstanceExtensions::khr_get_surface_capabilities2)*/
    pub khr_surface_protected_capabilities: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_wayland_surface.html)
- Requires all of:
  - instance extension [`khr_surface`](crate::instance::InstanceExtensions::khr_surface)*/
    pub khr_wayland_surface: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_win32_surface.html)
- Requires all of:
  - instance extension [`khr_surface`](crate::instance::InstanceExtensions::khr_surface)*/
    pub khr_win32_surface: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_xcb_surface.html)
- Requires all of:
  - instance extension [`khr_surface`](crate::instance::InstanceExtensions::khr_surface)*/
    pub khr_xcb_surface: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_xlib_surface.html)
- Requires all of:
  - instance extension [`khr_surface`](crate::instance::InstanceExtensions::khr_surface)*/
    pub khr_xlib_surface: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_acquire_drm_display.html)
- Requires all of:
  - instance extension [`ext_direct_mode_display`](crate::instance::InstanceExtensions::ext_direct_mode_display)*/
    pub ext_acquire_drm_display: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_acquire_xlib_display.html)
- Requires all of:
  - instance extension [`ext_direct_mode_display`](crate::instance::InstanceExtensions::ext_direct_mode_display)*/
    pub ext_acquire_xlib_display: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_debug_report.html)
- Deprecated by [`ext_debug_utils`](crate::instance::InstanceExtensions::ext_debug_utils)*/
    pub ext_debug_report: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_debug_utils.html)
    pub ext_debug_utils: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_direct_mode_display.html)
- Requires all of:
  - instance extension [`khr_display`](crate::instance::InstanceExtensions::khr_display)*/
    pub ext_direct_mode_display: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_directfb_surface.html)
- Requires all of:
  - instance extension [`khr_surface`](crate::instance::InstanceExtensions::khr_surface)*/
    pub ext_directfb_surface: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_display_surface_counter.html)
- Requires all of:
  - instance extension [`khr_display`](crate::instance::InstanceExtensions::khr_display)*/
    pub ext_display_surface_counter: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_headless_surface.html)
- Requires all of:
  - instance extension [`khr_surface`](crate::instance::InstanceExtensions::khr_surface)*/
    pub ext_headless_surface: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_layer_settings.html)
    pub ext_layer_settings: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_metal_surface.html)
- Requires all of:
  - instance extension [`khr_surface`](crate::instance::InstanceExtensions::khr_surface)*/
    pub ext_metal_surface: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_surface_maintenance1.html)
- Requires all of:
  - instance extension [`khr_surface`](crate::instance::InstanceExtensions::khr_surface)
  - instance extension [`khr_get_surface_capabilities2`](crate::instance::InstanceExtensions::khr_get_surface_capabilities2)*/
    pub ext_surface_maintenance1: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_swapchain_colorspace.html)
- Requires all of:
  - instance extension [`khr_surface`](crate::instance::InstanceExtensions::khr_surface)*/
    pub ext_swapchain_colorspace: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_validation_features.html)
- Deprecated by [`ext_layer_settings`](crate::instance::InstanceExtensions::ext_layer_settings)*/
    pub ext_validation_features: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_validation_flags.html)
- Deprecated by [`ext_layer_settings`](crate::instance::InstanceExtensions::ext_layer_settings)*/
    pub ext_validation_flags: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_FUCHSIA_imagepipe_surface.html)
- Requires all of:
  - instance extension [`khr_surface`](crate::instance::InstanceExtensions::khr_surface)*/
    pub fuchsia_imagepipe_surface: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_GGP_stream_descriptor_surface.html)
- Requires all of:
  - instance extension [`khr_surface`](crate::instance::InstanceExtensions::khr_surface)*/
    pub ggp_stream_descriptor_surface: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_GOOGLE_surfaceless_query.html)
- Requires all of:
  - instance extension [`khr_surface`](crate::instance::InstanceExtensions::khr_surface)*/
    pub google_surfaceless_query: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_LUNARG_direct_driver_loading.html)
    pub lunarg_direct_driver_loading: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_MVK_ios_surface.html)
- Deprecated by [`ext_metal_surface`](crate::instance::InstanceExtensions::ext_metal_surface)
- Requires all of:
  - instance extension [`khr_surface`](crate::instance::InstanceExtensions::khr_surface)*/
    pub mvk_ios_surface: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_MVK_macos_surface.html)
- Deprecated by [`ext_metal_surface`](crate::instance::InstanceExtensions::ext_metal_surface)
- Requires all of:
  - instance extension [`khr_surface`](crate::instance::InstanceExtensions::khr_surface)*/
    pub mvk_macos_surface: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_NN_vi_surface.html)
- Requires all of:
  - instance extension [`khr_surface`](crate::instance::InstanceExtensions::khr_surface)*/
    pub nn_vi_surface: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_NV_external_memory_capabilities.html)
- Deprecated by [`khr_external_memory_capabilities`](crate::instance::InstanceExtensions::khr_external_memory_capabilities)*/
    pub nv_external_memory_capabilities: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_QNX_screen_surface.html)
- Requires all of:
  - instance extension [`khr_surface`](crate::instance::InstanceExtensions::khr_surface)*/
    pub qnx_screen_surface: bool,
    pub _ne: crate::NonExhaustive<'static>,
}
impl Default for InstanceExtensions {
    #[inline]
    fn default() -> Self {
        Self::empty()
    }
}
impl InstanceExtensions {
    /// Returns an `Extensions` object with none of the members set.
    #[inline]
    pub const fn empty() -> Self {
        Self {
            khr_android_surface: false,
            khr_device_group_creation: false,
            khr_display: false,
            khr_external_fence_capabilities: false,
            khr_external_memory_capabilities: false,
            khr_external_semaphore_capabilities: false,
            khr_get_display_properties2: false,
            khr_get_physical_device_properties2: false,
            khr_get_surface_capabilities2: false,
            khr_portability_enumeration: false,
            khr_surface: false,
            khr_surface_protected_capabilities: false,
            khr_wayland_surface: false,
            khr_win32_surface: false,
            khr_xcb_surface: false,
            khr_xlib_surface: false,
            ext_acquire_drm_display: false,
            ext_acquire_xlib_display: false,
            ext_debug_report: false,
            ext_debug_utils: false,
            ext_direct_mode_display: false,
            ext_directfb_surface: false,
            ext_display_surface_counter: false,
            ext_headless_surface: false,
            ext_layer_settings: false,
            ext_metal_surface: false,
            ext_surface_maintenance1: false,
            ext_swapchain_colorspace: false,
            ext_validation_features: false,
            ext_validation_flags: false,
            fuchsia_imagepipe_surface: false,
            ggp_stream_descriptor_surface: false,
            google_surfaceless_query: false,
            lunarg_direct_driver_loading: false,
            mvk_ios_surface: false,
            mvk_macos_surface: false,
            nn_vi_surface: false,
            nv_external_memory_capabilities: false,
            qnx_screen_surface: false,
            _ne: crate::NE,
        }
    }
    /// Returns the number of members set in self.
    #[inline]
    pub const fn count(self) -> u64 {
        self.khr_android_surface as u64 + self.khr_device_group_creation as u64
            + self.khr_display as u64 + self.khr_external_fence_capabilities as u64
            + self.khr_external_memory_capabilities as u64
            + self.khr_external_semaphore_capabilities as u64
            + self.khr_get_display_properties2 as u64
            + self.khr_get_physical_device_properties2 as u64
            + self.khr_get_surface_capabilities2 as u64
            + self.khr_portability_enumeration as u64 + self.khr_surface as u64
            + self.khr_surface_protected_capabilities as u64
            + self.khr_wayland_surface as u64 + self.khr_win32_surface as u64
            + self.khr_xcb_surface as u64 + self.khr_xlib_surface as u64
            + self.ext_acquire_drm_display as u64 + self.ext_acquire_xlib_display as u64
            + self.ext_debug_report as u64 + self.ext_debug_utils as u64
            + self.ext_direct_mode_display as u64 + self.ext_directfb_surface as u64
            + self.ext_display_surface_counter as u64 + self.ext_headless_surface as u64
            + self.ext_layer_settings as u64 + self.ext_metal_surface as u64
            + self.ext_surface_maintenance1 as u64 + self.ext_swapchain_colorspace as u64
            + self.ext_validation_features as u64 + self.ext_validation_flags as u64
            + self.fuchsia_imagepipe_surface as u64
            + self.ggp_stream_descriptor_surface as u64
            + self.google_surfaceless_query as u64
            + self.lunarg_direct_driver_loading as u64 + self.mvk_ios_surface as u64
            + self.mvk_macos_surface as u64 + self.nn_vi_surface as u64
            + self.nv_external_memory_capabilities as u64
            + self.qnx_screen_surface as u64
    }
    /// Returns whether no members are set in `self`.
    #[inline]
    pub const fn is_empty(self) -> bool {
        !(self.khr_android_surface || self.khr_device_group_creation || self.khr_display
            || self.khr_external_fence_capabilities
            || self.khr_external_memory_capabilities
            || self.khr_external_semaphore_capabilities
            || self.khr_get_display_properties2
            || self.khr_get_physical_device_properties2
            || self.khr_get_surface_capabilities2 || self.khr_portability_enumeration
            || self.khr_surface || self.khr_surface_protected_capabilities
            || self.khr_wayland_surface || self.khr_win32_surface || self.khr_xcb_surface
            || self.khr_xlib_surface || self.ext_acquire_drm_display
            || self.ext_acquire_xlib_display || self.ext_debug_report
            || self.ext_debug_utils || self.ext_direct_mode_display
            || self.ext_directfb_surface || self.ext_display_surface_counter
            || self.ext_headless_surface || self.ext_layer_settings
            || self.ext_metal_surface || self.ext_surface_maintenance1
            || self.ext_swapchain_colorspace || self.ext_validation_features
            || self.ext_validation_flags || self.fuchsia_imagepipe_surface
            || self.ggp_stream_descriptor_surface || self.google_surfaceless_query
            || self.lunarg_direct_driver_loading || self.mvk_ios_surface
            || self.mvk_macos_surface || self.nn_vi_surface
            || self.nv_external_memory_capabilities || self.qnx_screen_surface)
    }
    /// Returns whether any members are set in both `self` and `other`.
    #[inline]
    pub const fn intersects(&self, other: &Self) -> bool {
        (self.khr_android_surface && other.khr_android_surface)
            || (self.khr_device_group_creation && other.khr_device_group_creation)
            || (self.khr_display && other.khr_display)
            || (self.khr_external_fence_capabilities
                && other.khr_external_fence_capabilities)
            || (self.khr_external_memory_capabilities
                && other.khr_external_memory_capabilities)
            || (self.khr_external_semaphore_capabilities
                && other.khr_external_semaphore_capabilities)
            || (self.khr_get_display_properties2 && other.khr_get_display_properties2)
            || (self.khr_get_physical_device_properties2
                && other.khr_get_physical_device_properties2)
            || (self.khr_get_surface_capabilities2
                && other.khr_get_surface_capabilities2)
            || (self.khr_portability_enumeration && other.khr_portability_enumeration)
            || (self.khr_surface && other.khr_surface)
            || (self.khr_surface_protected_capabilities
                && other.khr_surface_protected_capabilities)
            || (self.khr_wayland_surface && other.khr_wayland_surface)
            || (self.khr_win32_surface && other.khr_win32_surface)
            || (self.khr_xcb_surface && other.khr_xcb_surface)
            || (self.khr_xlib_surface && other.khr_xlib_surface)
            || (self.ext_acquire_drm_display && other.ext_acquire_drm_display)
            || (self.ext_acquire_xlib_display && other.ext_acquire_xlib_display)
            || (self.ext_debug_report && other.ext_debug_report)
            || (self.ext_debug_utils && other.ext_debug_utils)
            || (self.ext_direct_mode_display && other.ext_direct_mode_display)
            || (self.ext_directfb_surface && other.ext_directfb_surface)
            || (self.ext_display_surface_counter && other.ext_display_surface_counter)
            || (self.ext_headless_surface && other.ext_headless_surface)
            || (self.ext_layer_settings && other.ext_layer_settings)
            || (self.ext_metal_surface && other.ext_metal_surface)
            || (self.ext_surface_maintenance1 && other.ext_surface_maintenance1)
            || (self.ext_swapchain_colorspace && other.ext_swapchain_colorspace)
            || (self.ext_validation_features && other.ext_validation_features)
            || (self.ext_validation_flags && other.ext_validation_flags)
            || (self.fuchsia_imagepipe_surface && other.fuchsia_imagepipe_surface)
            || (self.ggp_stream_descriptor_surface
                && other.ggp_stream_descriptor_surface)
            || (self.google_surfaceless_query && other.google_surfaceless_query)
            || (self.lunarg_direct_driver_loading && other.lunarg_direct_driver_loading)
            || (self.mvk_ios_surface && other.mvk_ios_surface)
            || (self.mvk_macos_surface && other.mvk_macos_surface)
            || (self.nn_vi_surface && other.nn_vi_surface)
            || (self.nv_external_memory_capabilities
                && other.nv_external_memory_capabilities)
            || (self.qnx_screen_surface && other.qnx_screen_surface)
    }
    /// Returns whether all members in `other` are set in `self`.
    #[inline]
    pub const fn contains(&self, other: &Self) -> bool {
        (self.khr_android_surface || !other.khr_android_surface)
            && (self.khr_device_group_creation || !other.khr_device_group_creation)
            && (self.khr_display || !other.khr_display)
            && (self.khr_external_fence_capabilities
                || !other.khr_external_fence_capabilities)
            && (self.khr_external_memory_capabilities
                || !other.khr_external_memory_capabilities)
            && (self.khr_external_semaphore_capabilities
                || !other.khr_external_semaphore_capabilities)
            && (self.khr_get_display_properties2 || !other.khr_get_display_properties2)
            && (self.khr_get_physical_device_properties2
                || !other.khr_get_physical_device_properties2)
            && (self.khr_get_surface_capabilities2
                || !other.khr_get_surface_capabilities2)
            && (self.khr_portability_enumeration || !other.khr_portability_enumeration)
            && (self.khr_surface || !other.khr_surface)
            && (self.khr_surface_protected_capabilities
                || !other.khr_surface_protected_capabilities)
            && (self.khr_wayland_surface || !other.khr_wayland_surface)
            && (self.khr_win32_surface || !other.khr_win32_surface)
            && (self.khr_xcb_surface || !other.khr_xcb_surface)
            && (self.khr_xlib_surface || !other.khr_xlib_surface)
            && (self.ext_acquire_drm_display || !other.ext_acquire_drm_display)
            && (self.ext_acquire_xlib_display || !other.ext_acquire_xlib_display)
            && (self.ext_debug_report || !other.ext_debug_report)
            && (self.ext_debug_utils || !other.ext_debug_utils)
            && (self.ext_direct_mode_display || !other.ext_direct_mode_display)
            && (self.ext_directfb_surface || !other.ext_directfb_surface)
            && (self.ext_display_surface_counter || !other.ext_display_surface_counter)
            && (self.ext_headless_surface || !other.ext_headless_surface)
            && (self.ext_layer_settings || !other.ext_layer_settings)
            && (self.ext_metal_surface || !other.ext_metal_surface)
            && (self.ext_surface_maintenance1 || !other.ext_surface_maintenance1)
            && (self.ext_swapchain_colorspace || !other.ext_swapchain_colorspace)
            && (self.ext_validation_features || !other.ext_validation_features)
            && (self.ext_validation_flags || !other.ext_validation_flags)
            && (self.fuchsia_imagepipe_surface || !other.fuchsia_imagepipe_surface)
            && (self.ggp_stream_descriptor_surface
                || !other.ggp_stream_descriptor_surface)
            && (self.google_surfaceless_query || !other.google_surfaceless_query)
            && (self.lunarg_direct_driver_loading || !other.lunarg_direct_driver_loading)
            && (self.mvk_ios_surface || !other.mvk_ios_surface)
            && (self.mvk_macos_surface || !other.mvk_macos_surface)
            && (self.nn_vi_surface || !other.nn_vi_surface)
            && (self.nv_external_memory_capabilities
                || !other.nv_external_memory_capabilities)
            && (self.qnx_screen_surface || !other.qnx_screen_surface)
    }
    /// Returns the union of `self` and `other`.
    #[inline]
    pub const fn union(&self, other: &Self) -> Self {
        Self {
            khr_android_surface: self.khr_android_surface || other.khr_android_surface,
            khr_device_group_creation: self.khr_device_group_creation
                || other.khr_device_group_creation,
            khr_display: self.khr_display || other.khr_display,
            khr_external_fence_capabilities: self.khr_external_fence_capabilities
                || other.khr_external_fence_capabilities,
            khr_external_memory_capabilities: self.khr_external_memory_capabilities
                || other.khr_external_memory_capabilities,
            khr_external_semaphore_capabilities: self.khr_external_semaphore_capabilities
                || other.khr_external_semaphore_capabilities,
            khr_get_display_properties2: self.khr_get_display_properties2
                || other.khr_get_display_properties2,
            khr_get_physical_device_properties2: self.khr_get_physical_device_properties2
                || other.khr_get_physical_device_properties2,
            khr_get_surface_capabilities2: self.khr_get_surface_capabilities2
                || other.khr_get_surface_capabilities2,
            khr_portability_enumeration: self.khr_portability_enumeration
                || other.khr_portability_enumeration,
            khr_surface: self.khr_surface || other.khr_surface,
            khr_surface_protected_capabilities: self.khr_surface_protected_capabilities
                || other.khr_surface_protected_capabilities,
            khr_wayland_surface: self.khr_wayland_surface || other.khr_wayland_surface,
            khr_win32_surface: self.khr_win32_surface || other.khr_win32_surface,
            khr_xcb_surface: self.khr_xcb_surface || other.khr_xcb_surface,
            khr_xlib_surface: self.khr_xlib_surface || other.khr_xlib_surface,
            ext_acquire_drm_display: self.ext_acquire_drm_display
                || other.ext_acquire_drm_display,
            ext_acquire_xlib_display: self.ext_acquire_xlib_display
                || other.ext_acquire_xlib_display,
            ext_debug_report: self.ext_debug_report || other.ext_debug_report,
            ext_debug_utils: self.ext_debug_utils || other.ext_debug_utils,
            ext_direct_mode_display: self.ext_direct_mode_display
                || other.ext_direct_mode_display,
            ext_directfb_surface: self.ext_directfb_surface
                || other.ext_directfb_surface,
            ext_display_surface_counter: self.ext_display_surface_counter
                || other.ext_display_surface_counter,
            ext_headless_surface: self.ext_headless_surface
                || other.ext_headless_surface,
            ext_layer_settings: self.ext_layer_settings || other.ext_layer_settings,
            ext_metal_surface: self.ext_metal_surface || other.ext_metal_surface,
            ext_surface_maintenance1: self.ext_surface_maintenance1
                || other.ext_surface_maintenance1,
            ext_swapchain_colorspace: self.ext_swapchain_colorspace
                || other.ext_swapchain_colorspace,
            ext_validation_features: self.ext_validation_features
                || other.ext_validation_features,
            ext_validation_flags: self.ext_validation_flags
                || other.ext_validation_flags,
            fuchsia_imagepipe_surface: self.fuchsia_imagepipe_surface
                || other.fuchsia_imagepipe_surface,
            ggp_stream_descriptor_surface: self.ggp_stream_descriptor_surface
                || other.ggp_stream_descriptor_surface,
            google_surfaceless_query: self.google_surfaceless_query
                || other.google_surfaceless_query,
            lunarg_direct_driver_loading: self.lunarg_direct_driver_loading
                || other.lunarg_direct_driver_loading,
            mvk_ios_surface: self.mvk_ios_surface || other.mvk_ios_surface,
            mvk_macos_surface: self.mvk_macos_surface || other.mvk_macos_surface,
            nn_vi_surface: self.nn_vi_surface || other.nn_vi_surface,
            nv_external_memory_capabilities: self.nv_external_memory_capabilities
                || other.nv_external_memory_capabilities,
            qnx_screen_surface: self.qnx_screen_surface || other.qnx_screen_surface,
            _ne: crate::NE,
        }
    }
    /// Returns the intersection of `self` and `other`.
    #[inline]
    pub const fn intersection(&self, other: &Self) -> Self {
        Self {
            khr_android_surface: self.khr_android_surface && other.khr_android_surface,
            khr_device_group_creation: self.khr_device_group_creation
                && other.khr_device_group_creation,
            khr_display: self.khr_display && other.khr_display,
            khr_external_fence_capabilities: self.khr_external_fence_capabilities
                && other.khr_external_fence_capabilities,
            khr_external_memory_capabilities: self.khr_external_memory_capabilities
                && other.khr_external_memory_capabilities,
            khr_external_semaphore_capabilities: self.khr_external_semaphore_capabilities
                && other.khr_external_semaphore_capabilities,
            khr_get_display_properties2: self.khr_get_display_properties2
                && other.khr_get_display_properties2,
            khr_get_physical_device_properties2: self.khr_get_physical_device_properties2
                && other.khr_get_physical_device_properties2,
            khr_get_surface_capabilities2: self.khr_get_surface_capabilities2
                && other.khr_get_surface_capabilities2,
            khr_portability_enumeration: self.khr_portability_enumeration
                && other.khr_portability_enumeration,
            khr_surface: self.khr_surface && other.khr_surface,
            khr_surface_protected_capabilities: self.khr_surface_protected_capabilities
                && other.khr_surface_protected_capabilities,
            khr_wayland_surface: self.khr_wayland_surface && other.khr_wayland_surface,
            khr_win32_surface: self.khr_win32_surface && other.khr_win32_surface,
            khr_xcb_surface: self.khr_xcb_surface && other.khr_xcb_surface,
            khr_xlib_surface: self.khr_xlib_surface && other.khr_xlib_surface,
            ext_acquire_drm_display: self.ext_acquire_drm_display
                && other.ext_acquire_drm_display,
            ext_acquire_xlib_display: self.ext_acquire_xlib_display
                && other.ext_acquire_xlib_display,
            ext_debug_report: self.ext_debug_report && other.ext_debug_report,
            ext_debug_utils: self.ext_debug_utils && other.ext_debug_utils,
            ext_direct_mode_display: self.ext_direct_mode_display
                && other.ext_direct_mode_display,
            ext_directfb_surface: self.ext_directfb_surface
                && other.ext_directfb_surface,
            ext_display_surface_counter: self.ext_display_surface_counter
                && other.ext_display_surface_counter,
            ext_headless_surface: self.ext_headless_surface
                && other.ext_headless_surface,
            ext_layer_settings: self.ext_layer_settings && other.ext_layer_settings,
            ext_metal_surface: self.ext_metal_surface && other.ext_metal_surface,
            ext_surface_maintenance1: self.ext_surface_maintenance1
                && other.ext_surface_maintenance1,
            ext_swapchain_colorspace: self.ext_swapchain_colorspace
                && other.ext_swapchain_colorspace,
            ext_validation_features: self.ext_validation_features
                && other.ext_validation_features,
            ext_validation_flags: self.ext_validation_flags
                && other.ext_validation_flags,
            fuchsia_imagepipe_surface: self.fuchsia_imagepipe_surface
                && other.fuchsia_imagepipe_surface,
            ggp_stream_descriptor_surface: self.ggp_stream_descriptor_surface
                && other.ggp_stream_descriptor_surface,
            google_surfaceless_query: self.google_surfaceless_query
                && other.google_surfaceless_query,
            lunarg_direct_driver_loading: self.lunarg_direct_driver_loading
                && other.lunarg_direct_driver_loading,
            mvk_ios_surface: self.mvk_ios_surface && other.mvk_ios_surface,
            mvk_macos_surface: self.mvk_macos_surface && other.mvk_macos_surface,
            nn_vi_surface: self.nn_vi_surface && other.nn_vi_surface,
            nv_external_memory_capabilities: self.nv_external_memory_capabilities
                && other.nv_external_memory_capabilities,
            qnx_screen_surface: self.qnx_screen_surface && other.qnx_screen_surface,
            _ne: crate::NE,
        }
    }
    /// Returns `self` without the members set in `other`.
    #[inline]
    pub const fn difference(&self, other: &Self) -> Self {
        Self {
            khr_android_surface: self.khr_android_surface && !other.khr_android_surface,
            khr_device_group_creation: self.khr_device_group_creation
                && !other.khr_device_group_creation,
            khr_display: self.khr_display && !other.khr_display,
            khr_external_fence_capabilities: self.khr_external_fence_capabilities
                && !other.khr_external_fence_capabilities,
            khr_external_memory_capabilities: self.khr_external_memory_capabilities
                && !other.khr_external_memory_capabilities,
            khr_external_semaphore_capabilities: self.khr_external_semaphore_capabilities
                && !other.khr_external_semaphore_capabilities,
            khr_get_display_properties2: self.khr_get_display_properties2
                && !other.khr_get_display_properties2,
            khr_get_physical_device_properties2: self.khr_get_physical_device_properties2
                && !other.khr_get_physical_device_properties2,
            khr_get_surface_capabilities2: self.khr_get_surface_capabilities2
                && !other.khr_get_surface_capabilities2,
            khr_portability_enumeration: self.khr_portability_enumeration
                && !other.khr_portability_enumeration,
            khr_surface: self.khr_surface && !other.khr_surface,
            khr_surface_protected_capabilities: self.khr_surface_protected_capabilities
                && !other.khr_surface_protected_capabilities,
            khr_wayland_surface: self.khr_wayland_surface && !other.khr_wayland_surface,
            khr_win32_surface: self.khr_win32_surface && !other.khr_win32_surface,
            khr_xcb_surface: self.khr_xcb_surface && !other.khr_xcb_surface,
            khr_xlib_surface: self.khr_xlib_surface && !other.khr_xlib_surface,
            ext_acquire_drm_display: self.ext_acquire_drm_display
                && !other.ext_acquire_drm_display,
            ext_acquire_xlib_display: self.ext_acquire_xlib_display
                && !other.ext_acquire_xlib_display,
            ext_debug_report: self.ext_debug_report && !other.ext_debug_report,
            ext_debug_utils: self.ext_debug_utils && !other.ext_debug_utils,
            ext_direct_mode_display: self.ext_direct_mode_display
                && !other.ext_direct_mode_display,
            ext_directfb_surface: self.ext_directfb_surface
                && !other.ext_directfb_surface,
            ext_display_surface_counter: self.ext_display_surface_counter
                && !other.ext_display_surface_counter,
            ext_headless_surface: self.ext_headless_surface
                && !other.ext_headless_surface,
            ext_layer_settings: self.ext_layer_settings && !other.ext_layer_settings,
            ext_metal_surface: self.ext_metal_surface && !other.ext_metal_surface,
            ext_surface_maintenance1: self.ext_surface_maintenance1
                && !other.ext_surface_maintenance1,
            ext_swapchain_colorspace: self.ext_swapchain_colorspace
                && !other.ext_swapchain_colorspace,
            ext_validation_features: self.ext_validation_features
                && !other.ext_validation_features,
            ext_validation_flags: self.ext_validation_flags
                && !other.ext_validation_flags,
            fuchsia_imagepipe_surface: self.fuchsia_imagepipe_surface
                && !other.fuchsia_imagepipe_surface,
            ggp_stream_descriptor_surface: self.ggp_stream_descriptor_surface
                && !other.ggp_stream_descriptor_surface,
            google_surfaceless_query: self.google_surfaceless_query
                && !other.google_surfaceless_query,
            lunarg_direct_driver_loading: self.lunarg_direct_driver_loading
                && !other.lunarg_direct_driver_loading,
            mvk_ios_surface: self.mvk_ios_surface && !other.mvk_ios_surface,
            mvk_macos_surface: self.mvk_macos_surface && !other.mvk_macos_surface,
            nn_vi_surface: self.nn_vi_surface && !other.nn_vi_surface,
            nv_external_memory_capabilities: self.nv_external_memory_capabilities
                && !other.nv_external_memory_capabilities,
            qnx_screen_surface: self.qnx_screen_surface && !other.qnx_screen_surface,
            _ne: crate::NE,
        }
    }
    /// Returns the members set in `self` or `other`, but not both.
    #[inline]
    pub const fn symmetric_difference(&self, other: &Self) -> Self {
        Self {
            khr_android_surface: self.khr_android_surface ^ other.khr_android_surface,
            khr_device_group_creation: self.khr_device_group_creation
                ^ other.khr_device_group_creation,
            khr_display: self.khr_display ^ other.khr_display,
            khr_external_fence_capabilities: self.khr_external_fence_capabilities
                ^ other.khr_external_fence_capabilities,
            khr_external_memory_capabilities: self.khr_external_memory_capabilities
                ^ other.khr_external_memory_capabilities,
            khr_external_semaphore_capabilities: self.khr_external_semaphore_capabilities
                ^ other.khr_external_semaphore_capabilities,
            khr_get_display_properties2: self.khr_get_display_properties2
                ^ other.khr_get_display_properties2,
            khr_get_physical_device_properties2: self.khr_get_physical_device_properties2
                ^ other.khr_get_physical_device_properties2,
            khr_get_surface_capabilities2: self.khr_get_surface_capabilities2
                ^ other.khr_get_surface_capabilities2,
            khr_portability_enumeration: self.khr_portability_enumeration
                ^ other.khr_portability_enumeration,
            khr_surface: self.khr_surface ^ other.khr_surface,
            khr_surface_protected_capabilities: self.khr_surface_protected_capabilities
                ^ other.khr_surface_protected_capabilities,
            khr_wayland_surface: self.khr_wayland_surface ^ other.khr_wayland_surface,
            khr_win32_surface: self.khr_win32_surface ^ other.khr_win32_surface,
            khr_xcb_surface: self.khr_xcb_surface ^ other.khr_xcb_surface,
            khr_xlib_surface: self.khr_xlib_surface ^ other.khr_xlib_surface,
            ext_acquire_drm_display: self.ext_acquire_drm_display
                ^ other.ext_acquire_drm_display,
            ext_acquire_xlib_display: self.ext_acquire_xlib_display
                ^ other.ext_acquire_xlib_display,
            ext_debug_report: self.ext_debug_report ^ other.ext_debug_report,
            ext_debug_utils: self.ext_debug_utils ^ other.ext_debug_utils,
            ext_direct_mode_display: self.ext_direct_mode_display
                ^ other.ext_direct_mode_display,
            ext_directfb_surface: self.ext_directfb_surface ^ other.ext_directfb_surface,
            ext_display_surface_counter: self.ext_display_surface_counter
                ^ other.ext_display_surface_counter,
            ext_headless_surface: self.ext_headless_surface ^ other.ext_headless_surface,
            ext_layer_settings: self.ext_layer_settings ^ other.ext_layer_settings,
            ext_metal_surface: self.ext_metal_surface ^ other.ext_metal_surface,
            ext_surface_maintenance1: self.ext_surface_maintenance1
                ^ other.ext_surface_maintenance1,
            ext_swapchain_colorspace: self.ext_swapchain_colorspace
                ^ other.ext_swapchain_colorspace,
            ext_validation_features: self.ext_validation_features
                ^ other.ext_validation_features,
            ext_validation_flags: self.ext_validation_flags ^ other.ext_validation_flags,
            fuchsia_imagepipe_surface: self.fuchsia_imagepipe_surface
                ^ other.fuchsia_imagepipe_surface,
            ggp_stream_descriptor_surface: self.ggp_stream_descriptor_surface
                ^ other.ggp_stream_descriptor_surface,
            google_surfaceless_query: self.google_surfaceless_query
                ^ other.google_surfaceless_query,
            lunarg_direct_driver_loading: self.lunarg_direct_driver_loading
                ^ other.lunarg_direct_driver_loading,
            mvk_ios_surface: self.mvk_ios_surface ^ other.mvk_ios_surface,
            mvk_macos_surface: self.mvk_macos_surface ^ other.mvk_macos_surface,
            nn_vi_surface: self.nn_vi_surface ^ other.nn_vi_surface,
            nv_external_memory_capabilities: self.nv_external_memory_capabilities
                ^ other.nv_external_memory_capabilities,
            qnx_screen_surface: self.qnx_screen_surface ^ other.qnx_screen_surface,
            _ne: crate::NE,
        }
    }
}
impl std::ops::BitAnd for InstanceExtensions {
    type Output = InstanceExtensions;
    #[inline]
    fn bitand(self, rhs: Self) -> Self::Output {
        self.intersection(&rhs)
    }
}
impl std::ops::BitAndAssign for InstanceExtensions {
    #[inline]
    fn bitand_assign(&mut self, rhs: Self) {
        *self = self.intersection(&rhs);
    }
}
impl std::ops::BitOr for InstanceExtensions {
    type Output = InstanceExtensions;
    #[inline]
    fn bitor(self, rhs: Self) -> Self::Output {
        self.union(&rhs)
    }
}
impl std::ops::BitOrAssign for InstanceExtensions {
    #[inline]
    fn bitor_assign(&mut self, rhs: Self) {
        *self = self.union(&rhs);
    }
}
impl std::ops::BitXor for InstanceExtensions {
    type Output = InstanceExtensions;
    #[inline]
    fn bitxor(self, rhs: Self) -> Self::Output {
        self.symmetric_difference(&rhs)
    }
}
impl std::ops::BitXorAssign for InstanceExtensions {
    #[inline]
    fn bitxor_assign(&mut self, rhs: Self) {
        *self = self.symmetric_difference(&rhs);
    }
}
impl std::ops::Sub for InstanceExtensions {
    type Output = InstanceExtensions;
    #[inline]
    fn sub(self, rhs: Self) -> Self::Output {
        self.difference(&rhs)
    }
}
impl std::ops::SubAssign for InstanceExtensions {
    #[inline]
    fn sub_assign(&mut self, rhs: Self) {
        *self = self.difference(&rhs);
    }
}
impl std::fmt::Debug for InstanceExtensions {
    #[allow(unused_assignments)]
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(f, "[")?;
        let mut first = true;
        if self.khr_android_surface {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_KHR_android_surface")?;
        }
        if self.khr_device_group_creation {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_KHR_device_group_creation")?;
        }
        if self.khr_display {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_KHR_display")?;
        }
        if self.khr_external_fence_capabilities {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_KHR_external_fence_capabilities")?;
        }
        if self.khr_external_memory_capabilities {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_KHR_external_memory_capabilities")?;
        }
        if self.khr_external_semaphore_capabilities {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_KHR_external_semaphore_capabilities")?;
        }
        if self.khr_get_display_properties2 {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_KHR_get_display_properties2")?;
        }
        if self.khr_get_physical_device_properties2 {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_KHR_get_physical_device_properties2")?;
        }
        if self.khr_get_surface_capabilities2 {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_KHR_get_surface_capabilities2")?;
        }
        if self.khr_portability_enumeration {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_KHR_portability_enumeration")?;
        }
        if self.khr_surface {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_KHR_surface")?;
        }
        if self.khr_surface_protected_capabilities {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_KHR_surface_protected_capabilities")?;
        }
        if self.khr_wayland_surface {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_KHR_wayland_surface")?;
        }
        if self.khr_win32_surface {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_KHR_win32_surface")?;
        }
        if self.khr_xcb_surface {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_KHR_xcb_surface")?;
        }
        if self.khr_xlib_surface {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_KHR_xlib_surface")?;
        }
        if self.ext_acquire_drm_display {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_EXT_acquire_drm_display")?;
        }
        if self.ext_acquire_xlib_display {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_EXT_acquire_xlib_display")?;
        }
        if self.ext_debug_report {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_EXT_debug_report")?;
        }
        if self.ext_debug_utils {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_EXT_debug_utils")?;
        }
        if self.ext_direct_mode_display {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_EXT_direct_mode_display")?;
        }
        if self.ext_directfb_surface {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_EXT_directfb_surface")?;
        }
        if self.ext_display_surface_counter {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_EXT_display_surface_counter")?;
        }
        if self.ext_headless_surface {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_EXT_headless_surface")?;
        }
        if self.ext_layer_settings {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_EXT_layer_settings")?;
        }
        if self.ext_metal_surface {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_EXT_metal_surface")?;
        }
        if self.ext_surface_maintenance1 {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_EXT_surface_maintenance1")?;
        }
        if self.ext_swapchain_colorspace {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_EXT_swapchain_colorspace")?;
        }
        if self.ext_validation_features {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_EXT_validation_features")?;
        }
        if self.ext_validation_flags {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_EXT_validation_flags")?;
        }
        if self.fuchsia_imagepipe_surface {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_FUCHSIA_imagepipe_surface")?;
        }
        if self.ggp_stream_descriptor_surface {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_GGP_stream_descriptor_surface")?;
        }
        if self.google_surfaceless_query {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_GOOGLE_surfaceless_query")?;
        }
        if self.lunarg_direct_driver_loading {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_LUNARG_direct_driver_loading")?;
        }
        if self.mvk_ios_surface {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_MVK_ios_surface")?;
        }
        if self.mvk_macos_surface {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_MVK_macos_surface")?;
        }
        if self.nn_vi_surface {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_NN_vi_surface")?;
        }
        if self.nv_external_memory_capabilities {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_NV_external_memory_capabilities")?;
        }
        if self.qnx_screen_surface {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_QNX_screen_surface")?;
        }
        write!(f, "]")
    }
}
impl<'a> FromIterator<&'a str> for InstanceExtensions {
    fn from_iter<I>(iter: I) -> Self
    where
        I: IntoIterator<Item = &'a str>,
    {
        let mut extensions = Self::empty();
        for name in iter {
            match name {
                "VK_KHR_android_surface" => {
                    extensions.khr_android_surface = true;
                }
                "VK_KHR_device_group_creation" => {
                    extensions.khr_device_group_creation = true;
                }
                "VK_KHR_display" => {
                    extensions.khr_display = true;
                }
                "VK_KHR_external_fence_capabilities" => {
                    extensions.khr_external_fence_capabilities = true;
                }
                "VK_KHR_external_memory_capabilities" => {
                    extensions.khr_external_memory_capabilities = true;
                }
                "VK_KHR_external_semaphore_capabilities" => {
                    extensions.khr_external_semaphore_capabilities = true;
                }
                "VK_KHR_get_display_properties2" => {
                    extensions.khr_get_display_properties2 = true;
                }
                "VK_KHR_get_physical_device_properties2" => {
                    extensions.khr_get_physical_device_properties2 = true;
                }
                "VK_KHR_get_surface_capabilities2" => {
                    extensions.khr_get_surface_capabilities2 = true;
                }
                "VK_KHR_portability_enumeration" => {
                    extensions.khr_portability_enumeration = true;
                }
                "VK_KHR_surface" => {
                    extensions.khr_surface = true;
                }
                "VK_KHR_surface_protected_capabilities" => {
                    extensions.khr_surface_protected_capabilities = true;
                }
                "VK_KHR_wayland_surface" => {
                    extensions.khr_wayland_surface = true;
                }
                "VK_KHR_win32_surface" => {
                    extensions.khr_win32_surface = true;
                }
                "VK_KHR_xcb_surface" => {
                    extensions.khr_xcb_surface = true;
                }
                "VK_KHR_xlib_surface" => {
                    extensions.khr_xlib_surface = true;
                }
                "VK_EXT_acquire_drm_display" => {
                    extensions.ext_acquire_drm_display = true;
                }
                "VK_EXT_acquire_xlib_display" => {
                    extensions.ext_acquire_xlib_display = true;
                }
                "VK_EXT_debug_report" => {
                    extensions.ext_debug_report = true;
                }
                "VK_EXT_debug_utils" => {
                    extensions.ext_debug_utils = true;
                }
                "VK_EXT_direct_mode_display" => {
                    extensions.ext_direct_mode_display = true;
                }
                "VK_EXT_directfb_surface" => {
                    extensions.ext_directfb_surface = true;
                }
                "VK_EXT_display_surface_counter" => {
                    extensions.ext_display_surface_counter = true;
                }
                "VK_EXT_headless_surface" => {
                    extensions.ext_headless_surface = true;
                }
                "VK_EXT_layer_settings" => {
                    extensions.ext_layer_settings = true;
                }
                "VK_EXT_metal_surface" => {
                    extensions.ext_metal_surface = true;
                }
                "VK_EXT_surface_maintenance1" => {
                    extensions.ext_surface_maintenance1 = true;
                }
                "VK_EXT_swapchain_colorspace" => {
                    extensions.ext_swapchain_colorspace = true;
                }
                "VK_EXT_validation_features" => {
                    extensions.ext_validation_features = true;
                }
                "VK_EXT_validation_flags" => {
                    extensions.ext_validation_flags = true;
                }
                "VK_FUCHSIA_imagepipe_surface" => {
                    extensions.fuchsia_imagepipe_surface = true;
                }
                "VK_GGP_stream_descriptor_surface" => {
                    extensions.ggp_stream_descriptor_surface = true;
                }
                "VK_GOOGLE_surfaceless_query" => {
                    extensions.google_surfaceless_query = true;
                }
                "VK_LUNARG_direct_driver_loading" => {
                    extensions.lunarg_direct_driver_loading = true;
                }
                "VK_MVK_ios_surface" => {
                    extensions.mvk_ios_surface = true;
                }
                "VK_MVK_macos_surface" => {
                    extensions.mvk_macos_surface = true;
                }
                "VK_NN_vi_surface" => {
                    extensions.nn_vi_surface = true;
                }
                "VK_NV_external_memory_capabilities" => {
                    extensions.nv_external_memory_capabilities = true;
                }
                "VK_QNX_screen_surface" => {
                    extensions.qnx_screen_surface = true;
                }
                _ => {}
            }
        }
        extensions
    }
}
impl<'a> From<&'a InstanceExtensions> for Vec<std::ffi::CString> {
    fn from(x: &'a InstanceExtensions) -> Self {
        let mut data = Self::new();
        if x.khr_android_surface {
            data.push(std::ffi::CString::new("VK_KHR_android_surface").unwrap());
        }
        if x.khr_device_group_creation {
            data.push(std::ffi::CString::new("VK_KHR_device_group_creation").unwrap());
        }
        if x.khr_display {
            data.push(std::ffi::CString::new("VK_KHR_display").unwrap());
        }
        if x.khr_external_fence_capabilities {
            data.push(
                std::ffi::CString::new("VK_KHR_external_fence_capabilities").unwrap(),
            );
        }
        if x.khr_external_memory_capabilities {
            data.push(
                std::ffi::CString::new("VK_KHR_external_memory_capabilities").unwrap(),
            );
        }
        if x.khr_external_semaphore_capabilities {
            data.push(
                std::ffi::CString::new("VK_KHR_external_semaphore_capabilities").unwrap(),
            );
        }
        if x.khr_get_display_properties2 {
            data.push(std::ffi::CString::new("VK_KHR_get_display_properties2").unwrap());
        }
        if x.khr_get_physical_device_properties2 {
            data.push(
                std::ffi::CString::new("VK_KHR_get_physical_device_properties2").unwrap(),
            );
        }
        if x.khr_get_surface_capabilities2 {
            data.push(
                std::ffi::CString::new("VK_KHR_get_surface_capabilities2").unwrap(),
            );
        }
        if x.khr_portability_enumeration {
            data.push(std::ffi::CString::new("VK_KHR_portability_enumeration").unwrap());
        }
        if x.khr_surface {
            data.push(std::ffi::CString::new("VK_KHR_surface").unwrap());
        }
        if x.khr_surface_protected_capabilities {
            data.push(
                std::ffi::CString::new("VK_KHR_surface_protected_capabilities").unwrap(),
            );
        }
        if x.khr_wayland_surface {
            data.push(std::ffi::CString::new("VK_KHR_wayland_surface").unwrap());
        }
        if x.khr_win32_surface {
            data.push(std::ffi::CString::new("VK_KHR_win32_surface").unwrap());
        }
        if x.khr_xcb_surface {
            data.push(std::ffi::CString::new("VK_KHR_xcb_surface").unwrap());
        }
        if x.khr_xlib_surface {
            data.push(std::ffi::CString::new("VK_KHR_xlib_surface").unwrap());
        }
        if x.ext_acquire_drm_display {
            data.push(std::ffi::CString::new("VK_EXT_acquire_drm_display").unwrap());
        }
        if x.ext_acquire_xlib_display {
            data.push(std::ffi::CString::new("VK_EXT_acquire_xlib_display").unwrap());
        }
        if x.ext_debug_report {
            data.push(std::ffi::CString::new("VK_EXT_debug_report").unwrap());
        }
        if x.ext_debug_utils {
            data.push(std::ffi::CString::new("VK_EXT_debug_utils").unwrap());
        }
        if x.ext_direct_mode_display {
            data.push(std::ffi::CString::new("VK_EXT_direct_mode_display").unwrap());
        }
        if x.ext_directfb_surface {
            data.push(std::ffi::CString::new("VK_EXT_directfb_surface").unwrap());
        }
        if x.ext_display_surface_counter {
            data.push(std::ffi::CString::new("VK_EXT_display_surface_counter").unwrap());
        }
        if x.ext_headless_surface {
            data.push(std::ffi::CString::new("VK_EXT_headless_surface").unwrap());
        }
        if x.ext_layer_settings {
            data.push(std::ffi::CString::new("VK_EXT_layer_settings").unwrap());
        }
        if x.ext_metal_surface {
            data.push(std::ffi::CString::new("VK_EXT_metal_surface").unwrap());
        }
        if x.ext_surface_maintenance1 {
            data.push(std::ffi::CString::new("VK_EXT_surface_maintenance1").unwrap());
        }
        if x.ext_swapchain_colorspace {
            data.push(std::ffi::CString::new("VK_EXT_swapchain_colorspace").unwrap());
        }
        if x.ext_validation_features {
            data.push(std::ffi::CString::new("VK_EXT_validation_features").unwrap());
        }
        if x.ext_validation_flags {
            data.push(std::ffi::CString::new("VK_EXT_validation_flags").unwrap());
        }
        if x.fuchsia_imagepipe_surface {
            data.push(std::ffi::CString::new("VK_FUCHSIA_imagepipe_surface").unwrap());
        }
        if x.ggp_stream_descriptor_surface {
            data.push(
                std::ffi::CString::new("VK_GGP_stream_descriptor_surface").unwrap(),
            );
        }
        if x.google_surfaceless_query {
            data.push(std::ffi::CString::new("VK_GOOGLE_surfaceless_query").unwrap());
        }
        if x.lunarg_direct_driver_loading {
            data.push(
                std::ffi::CString::new("VK_LUNARG_direct_driver_loading").unwrap(),
            );
        }
        if x.mvk_ios_surface {
            data.push(std::ffi::CString::new("VK_MVK_ios_surface").unwrap());
        }
        if x.mvk_macos_surface {
            data.push(std::ffi::CString::new("VK_MVK_macos_surface").unwrap());
        }
        if x.nn_vi_surface {
            data.push(std::ffi::CString::new("VK_NN_vi_surface").unwrap());
        }
        if x.nv_external_memory_capabilities {
            data.push(
                std::ffi::CString::new("VK_NV_external_memory_capabilities").unwrap(),
            );
        }
        if x.qnx_screen_surface {
            data.push(std::ffi::CString::new("VK_QNX_screen_surface").unwrap());
        }
        data
    }
}
impl IntoIterator for InstanceExtensions {
    type Item = (&'static str, bool);
    type IntoIter = std::array::IntoIter<Self::Item, 39usize>;
    #[inline]
    fn into_iter(self) -> Self::IntoIter {
        [
            ("VK_KHR_android_surface", self.khr_android_surface),
            ("VK_KHR_device_group_creation", self.khr_device_group_creation),
            ("VK_KHR_display", self.khr_display),
            ("VK_KHR_external_fence_capabilities", self.khr_external_fence_capabilities),
            (
                "VK_KHR_external_memory_capabilities",
                self.khr_external_memory_capabilities,
            ),
            (
                "VK_KHR_external_semaphore_capabilities",
                self.khr_external_semaphore_capabilities,
            ),
            ("VK_KHR_get_display_properties2", self.khr_get_display_properties2),
            (
                "VK_KHR_get_physical_device_properties2",
                self.khr_get_physical_device_properties2,
            ),
            ("VK_KHR_get_surface_capabilities2", self.khr_get_surface_capabilities2),
            ("VK_KHR_portability_enumeration", self.khr_portability_enumeration),
            ("VK_KHR_surface", self.khr_surface),
            (
                "VK_KHR_surface_protected_capabilities",
                self.khr_surface_protected_capabilities,
            ),
            ("VK_KHR_wayland_surface", self.khr_wayland_surface),
            ("VK_KHR_win32_surface", self.khr_win32_surface),
            ("VK_KHR_xcb_surface", self.khr_xcb_surface),
            ("VK_KHR_xlib_surface", self.khr_xlib_surface),
            ("VK_EXT_acquire_drm_display", self.ext_acquire_drm_display),
            ("VK_EXT_acquire_xlib_display", self.ext_acquire_xlib_display),
            ("VK_EXT_debug_report", self.ext_debug_report),
            ("VK_EXT_debug_utils", self.ext_debug_utils),
            ("VK_EXT_direct_mode_display", self.ext_direct_mode_display),
            ("VK_EXT_directfb_surface", self.ext_directfb_surface),
            ("VK_EXT_display_surface_counter", self.ext_display_surface_counter),
            ("VK_EXT_headless_surface", self.ext_headless_surface),
            ("VK_EXT_layer_settings", self.ext_layer_settings),
            ("VK_EXT_metal_surface", self.ext_metal_surface),
            ("VK_EXT_surface_maintenance1", self.ext_surface_maintenance1),
            ("VK_EXT_swapchain_colorspace", self.ext_swapchain_colorspace),
            ("VK_EXT_validation_features", self.ext_validation_features),
            ("VK_EXT_validation_flags", self.ext_validation_flags),
            ("VK_FUCHSIA_imagepipe_surface", self.fuchsia_imagepipe_surface),
            ("VK_GGP_stream_descriptor_surface", self.ggp_stream_descriptor_surface),
            ("VK_GOOGLE_surfaceless_query", self.google_surfaceless_query),
            ("VK_LUNARG_direct_driver_loading", self.lunarg_direct_driver_loading),
            ("VK_MVK_ios_surface", self.mvk_ios_surface),
            ("VK_MVK_macos_surface", self.mvk_macos_surface),
            ("VK_NN_vi_surface", self.nn_vi_surface),
            ("VK_NV_external_memory_capabilities", self.nv_external_memory_capabilities),
            ("VK_QNX_screen_surface", self.qnx_screen_surface),
        ]
            .into_iter()
    }
}
impl InstanceExtensions {
    /// Checks enabled extensions against the library support,
    /// and checks for required API version.
    pub(super) fn check_requirements(
        &self,
        supported: &InstanceExtensions,
        api_version: crate::Version,
    ) -> Result<(), Box<crate::ValidationError>> {
        if self.khr_android_surface {
            if !supported.khr_android_surface {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_android_surface`, but this extension is not supported by the library"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.khr_device_group_creation {
            if !supported.khr_device_group_creation {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_device_group_creation`, but this extension is not supported by the library"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.khr_display {
            if !supported.khr_display {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_display`, but this extension is not supported by the library"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.khr_external_fence_capabilities {
            if !supported.khr_external_fence_capabilities {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_external_fence_capabilities`, but this extension is not supported by the library"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.khr_external_memory_capabilities {
            if !supported.khr_external_memory_capabilities {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_external_memory_capabilities`, but this extension is not supported by the library"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.khr_external_semaphore_capabilities {
            if !supported.khr_external_semaphore_capabilities {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_external_semaphore_capabilities`, but this extension is not supported by the library"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.khr_get_display_properties2 {
            if !supported.khr_get_display_properties2 {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_get_display_properties2`, but this extension is not supported by the library"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.khr_get_physical_device_properties2 {
            if !supported.khr_get_physical_device_properties2 {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_get_physical_device_properties2`, but this extension is not supported by the library"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.khr_get_surface_capabilities2 {
            if !supported.khr_get_surface_capabilities2 {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_get_surface_capabilities2`, but this extension is not supported by the library"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.khr_portability_enumeration {
            if !supported.khr_portability_enumeration {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_portability_enumeration`, but this extension is not supported by the library"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.khr_surface {
            if !supported.khr_surface {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_surface`, but this extension is not supported by the library"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.khr_surface_protected_capabilities {
            if !supported.khr_surface_protected_capabilities {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_surface_protected_capabilities`, but this extension is not supported by the library"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1) {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_surface_protected_capabilities`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.khr_wayland_surface {
            if !supported.khr_wayland_surface {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_wayland_surface`, but this extension is not supported by the library"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.khr_win32_surface {
            if !supported.khr_win32_surface {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_win32_surface`, but this extension is not supported by the library"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.khr_xcb_surface {
            if !supported.khr_xcb_surface {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_xcb_surface`, but this extension is not supported by the library"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.khr_xlib_surface {
            if !supported.khr_xlib_surface {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_xlib_surface`, but this extension is not supported by the library"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.ext_acquire_drm_display {
            if !supported.ext_acquire_drm_display {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_acquire_drm_display`, but this extension is not supported by the library"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.ext_acquire_xlib_display {
            if !supported.ext_acquire_xlib_display {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_acquire_xlib_display`, but this extension is not supported by the library"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.ext_debug_report {
            if !supported.ext_debug_report {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_debug_report`, but this extension is not supported by the library"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.ext_debug_utils {
            if !supported.ext_debug_utils {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_debug_utils`, but this extension is not supported by the library"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.ext_direct_mode_display {
            if !supported.ext_direct_mode_display {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_direct_mode_display`, but this extension is not supported by the library"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.ext_directfb_surface {
            if !supported.ext_directfb_surface {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_directfb_surface`, but this extension is not supported by the library"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.ext_display_surface_counter {
            if !supported.ext_display_surface_counter {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_display_surface_counter`, but this extension is not supported by the library"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.ext_headless_surface {
            if !supported.ext_headless_surface {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_headless_surface`, but this extension is not supported by the library"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.ext_layer_settings {
            if !supported.ext_layer_settings {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_layer_settings`, but this extension is not supported by the library"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.ext_metal_surface {
            if !supported.ext_metal_surface {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_metal_surface`, but this extension is not supported by the library"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.ext_surface_maintenance1 {
            if !supported.ext_surface_maintenance1 {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_surface_maintenance1`, but this extension is not supported by the library"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.ext_swapchain_colorspace {
            if !supported.ext_swapchain_colorspace {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_swapchain_colorspace`, but this extension is not supported by the library"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.ext_validation_features {
            if !supported.ext_validation_features {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_validation_features`, but this extension is not supported by the library"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.ext_validation_flags {
            if !supported.ext_validation_flags {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_validation_flags`, but this extension is not supported by the library"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.fuchsia_imagepipe_surface {
            if !supported.fuchsia_imagepipe_surface {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `fuchsia_imagepipe_surface`, but this extension is not supported by the library"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.ggp_stream_descriptor_surface {
            if !supported.ggp_stream_descriptor_surface {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ggp_stream_descriptor_surface`, but this extension is not supported by the library"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.google_surfaceless_query {
            if !supported.google_surfaceless_query {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `google_surfaceless_query`, but this extension is not supported by the library"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.lunarg_direct_driver_loading {
            if !supported.lunarg_direct_driver_loading {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `lunarg_direct_driver_loading`, but this extension is not supported by the library"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.mvk_ios_surface {
            if !supported.mvk_ios_surface {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `mvk_ios_surface`, but this extension is not supported by the library"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.mvk_macos_surface {
            if !supported.mvk_macos_surface {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `mvk_macos_surface`, but this extension is not supported by the library"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.nn_vi_surface {
            if !supported.nn_vi_surface {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `nn_vi_surface`, but this extension is not supported by the library"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.nv_external_memory_capabilities {
            if !supported.nv_external_memory_capabilities {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `nv_external_memory_capabilities`, but this extension is not supported by the library"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.qnx_screen_surface {
            if !supported.qnx_screen_surface {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `qnx_screen_surface`, but this extension is not supported by the library"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        Ok(())
    }
    /// Enables all the extensions that the extensions in `self` currently depend on.
    pub(super) fn enable_dependencies(
        &mut self,
        #[allow(unused_variables)]
        api_version: crate::Version,
        #[allow(unused_variables)]
        supported: &InstanceExtensions,
    ) {
        if self.khr_android_surface {
            if !(self.khr_surface) {
                assert!(
                    supported.khr_surface,
                    "The instance extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver.",
                    "khr_android_surface", "khr_surface",
                );
                self.khr_surface = true;
            }
        }
        if self.khr_display {
            if !(self.khr_surface) {
                assert!(
                    supported.khr_surface,
                    "The instance extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver.",
                    "khr_display", "khr_surface",
                );
                self.khr_surface = true;
            }
        }
        if self.khr_external_fence_capabilities {
            if !(api_version >= crate::Version::V1_1
                || self.khr_get_physical_device_properties2)
            {
                assert!(
                    supported.khr_get_physical_device_properties2,
                    "The instance extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver.",
                    "khr_external_fence_capabilities",
                    "khr_get_physical_device_properties2",
                );
                self.khr_get_physical_device_properties2 = true;
            }
        }
        if self.khr_external_memory_capabilities {
            if !(api_version >= crate::Version::V1_1
                || self.khr_get_physical_device_properties2)
            {
                assert!(
                    supported.khr_get_physical_device_properties2,
                    "The instance extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver.",
                    "khr_external_memory_capabilities",
                    "khr_get_physical_device_properties2",
                );
                self.khr_get_physical_device_properties2 = true;
            }
        }
        if self.khr_external_semaphore_capabilities {
            if !(api_version >= crate::Version::V1_1
                || self.khr_get_physical_device_properties2)
            {
                assert!(
                    supported.khr_get_physical_device_properties2,
                    "The instance extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver.",
                    "khr_external_semaphore_capabilities",
                    "khr_get_physical_device_properties2",
                );
                self.khr_get_physical_device_properties2 = true;
            }
        }
        if self.khr_get_display_properties2 {
            if !(self.khr_display) {
                assert!(
                    supported.khr_display,
                    "The instance extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver.",
                    "khr_get_display_properties2", "khr_display",
                );
                self.khr_display = true;
            }
        }
        if self.khr_get_surface_capabilities2 {
            if !(self.khr_surface) {
                assert!(
                    supported.khr_surface,
                    "The instance extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver.",
                    "khr_get_surface_capabilities2", "khr_surface",
                );
                self.khr_surface = true;
            }
        }
        if self.khr_surface_protected_capabilities {
            if !(self.khr_get_surface_capabilities2) {
                assert!(
                    supported.khr_get_surface_capabilities2,
                    "The instance extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver.",
                    "khr_surface_protected_capabilities",
                    "khr_get_surface_capabilities2",
                );
                self.khr_get_surface_capabilities2 = true;
            }
        }
        if self.khr_wayland_surface {
            if !(self.khr_surface) {
                assert!(
                    supported.khr_surface,
                    "The instance extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver.",
                    "khr_wayland_surface", "khr_surface",
                );
                self.khr_surface = true;
            }
        }
        if self.khr_win32_surface {
            if !(self.khr_surface) {
                assert!(
                    supported.khr_surface,
                    "The instance extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver.",
                    "khr_win32_surface", "khr_surface",
                );
                self.khr_surface = true;
            }
        }
        if self.khr_xcb_surface {
            if !(self.khr_surface) {
                assert!(
                    supported.khr_surface,
                    "The instance extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver.",
                    "khr_xcb_surface", "khr_surface",
                );
                self.khr_surface = true;
            }
        }
        if self.khr_xlib_surface {
            if !(self.khr_surface) {
                assert!(
                    supported.khr_surface,
                    "The instance extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver.",
                    "khr_xlib_surface", "khr_surface",
                );
                self.khr_surface = true;
            }
        }
        if self.ext_acquire_drm_display {
            if !(self.ext_direct_mode_display) {
                assert!(
                    supported.ext_direct_mode_display,
                    "The instance extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver.",
                    "ext_acquire_drm_display", "ext_direct_mode_display",
                );
                self.ext_direct_mode_display = true;
            }
        }
        if self.ext_acquire_xlib_display {
            if !(self.ext_direct_mode_display) {
                assert!(
                    supported.ext_direct_mode_display,
                    "The instance extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver.",
                    "ext_acquire_xlib_display", "ext_direct_mode_display",
                );
                self.ext_direct_mode_display = true;
            }
        }
        if self.ext_direct_mode_display {
            if !(self.khr_display) {
                assert!(
                    supported.khr_display,
                    "The instance extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver.",
                    "ext_direct_mode_display", "khr_display",
                );
                self.khr_display = true;
            }
        }
        if self.ext_directfb_surface {
            if !(self.khr_surface) {
                assert!(
                    supported.khr_surface,
                    "The instance extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver.",
                    "ext_directfb_surface", "khr_surface",
                );
                self.khr_surface = true;
            }
        }
        if self.ext_display_surface_counter {
            if !(self.khr_display) {
                assert!(
                    supported.khr_display,
                    "The instance extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver.",
                    "ext_display_surface_counter", "khr_display",
                );
                self.khr_display = true;
            }
        }
        if self.ext_headless_surface {
            if !(self.khr_surface) {
                assert!(
                    supported.khr_surface,
                    "The instance extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver.",
                    "ext_headless_surface", "khr_surface",
                );
                self.khr_surface = true;
            }
        }
        if self.ext_metal_surface {
            if !(self.khr_surface) {
                assert!(
                    supported.khr_surface,
                    "The instance extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver.",
                    "ext_metal_surface", "khr_surface",
                );
                self.khr_surface = true;
            }
        }
        if self.ext_surface_maintenance1 {
            if !(self.khr_surface) {
                assert!(
                    supported.khr_surface,
                    "The instance extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver.",
                    "ext_surface_maintenance1", "khr_surface",
                );
                self.khr_surface = true;
            }
            if !(self.khr_get_surface_capabilities2) {
                assert!(
                    supported.khr_get_surface_capabilities2,
                    "The instance extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver.",
                    "ext_surface_maintenance1", "khr_get_surface_capabilities2",
                );
                self.khr_get_surface_capabilities2 = true;
            }
        }
        if self.ext_swapchain_colorspace {
            if !(self.khr_surface) {
                assert!(
                    supported.khr_surface,
                    "The instance extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver.",
                    "ext_swapchain_colorspace", "khr_surface",
                );
                self.khr_surface = true;
            }
        }
        if self.fuchsia_imagepipe_surface {
            if !(self.khr_surface) {
                assert!(
                    supported.khr_surface,
                    "The instance extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver.",
                    "fuchsia_imagepipe_surface", "khr_surface",
                );
                self.khr_surface = true;
            }
        }
        if self.ggp_stream_descriptor_surface {
            if !(self.khr_surface) {
                assert!(
                    supported.khr_surface,
                    "The instance extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver.",
                    "ggp_stream_descriptor_surface", "khr_surface",
                );
                self.khr_surface = true;
            }
        }
        if self.google_surfaceless_query {
            if !(self.khr_surface) {
                assert!(
                    supported.khr_surface,
                    "The instance extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver.",
                    "google_surfaceless_query", "khr_surface",
                );
                self.khr_surface = true;
            }
        }
        if self.mvk_ios_surface {
            if !(self.khr_surface) {
                assert!(
                    supported.khr_surface,
                    "The instance extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver.",
                    "mvk_ios_surface", "khr_surface",
                );
                self.khr_surface = true;
            }
        }
        if self.mvk_macos_surface {
            if !(self.khr_surface) {
                assert!(
                    supported.khr_surface,
                    "The instance extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver.",
                    "mvk_macos_surface", "khr_surface",
                );
                self.khr_surface = true;
            }
        }
        if self.nn_vi_surface {
            if !(self.khr_surface) {
                assert!(
                    supported.khr_surface,
                    "The instance extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver.",
                    "nn_vi_surface", "khr_surface",
                );
                self.khr_surface = true;
            }
        }
        if self.qnx_screen_surface {
            if !(self.khr_surface) {
                assert!(
                    supported.khr_surface,
                    "The instance extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver.",
                    "qnx_screen_surface", "khr_surface",
                );
                self.khr_surface = true;
            }
        }
    }
}
