// This file is auto-generated by vulkano autogen from SPIR-V grammar version 1.6.1.
// It should not be edited manually. Changes should be made by editing autogen.


#[derive(Clone, Debug, PartialEq)]
///A parsed SPIR-V instruction.
pub enum Instruction {
    Nop,
    Undef { result_type_id: Id, result_id: Id },
    SourceContinued { continued_source: String },
    Source {
        source_language: SourceLanguage,
        version: u32,
        file: Option<Id>,
        source: Option<String>,
    },
    SourceExtension { extension: String },
    Name { target: Id, name: String },
    MemberName { ty: Id, member: u32, name: String },
    String { result_id: Id, string: String },
    Line { file: Id, line: u32, column: u32 },
    Extension { name: String },
    ExtInstImport { result_id: Id, name: String },
    ExtInst {
        result_type_id: Id,
        result_id: Id,
        set: Id,
        instruction: u32,
        operands: Vec<Id>,
    },
    MemoryModel { addressing_model: AddressingModel, memory_model: MemoryModel },
    EntryPoint {
        execution_model: ExecutionModel,
        entry_point: Id,
        name: String,
        interface: Vec<Id>,
    },
    ExecutionMode { entry_point: Id, mode: ExecutionMode },
    Capability { capability: Capability },
    TypeVoid { result_id: Id },
    TypeBool { result_id: Id },
    TypeInt { result_id: Id, width: u32, signedness: u32 },
    TypeFloat { result_id: Id, width: u32 },
    TypeVector { result_id: Id, component_type: Id, component_count: u32 },
    TypeMatrix { result_id: Id, column_type: Id, column_count: u32 },
    TypeImage {
        result_id: Id,
        sampled_type: Id,
        dim: Dim,
        depth: u32,
        arrayed: u32,
        ms: u32,
        sampled: u32,
        image_format: ImageFormat,
        access_qualifier: Option<AccessQualifier>,
    },
    TypeSampler { result_id: Id },
    TypeSampledImage { result_id: Id, image_type: Id },
    TypeArray { result_id: Id, element_type: Id, length: Id },
    TypeRuntimeArray { result_id: Id, element_type: Id },
    TypeStruct { result_id: Id, member_types: Vec<Id> },
    TypeOpaque { result_id: Id, name: String },
    TypePointer { result_id: Id, storage_class: StorageClass, ty: Id },
    TypeFunction { result_id: Id, return_type: Id, parameter_types: Vec<Id> },
    TypeEvent { result_id: Id },
    TypeDeviceEvent { result_id: Id },
    TypeReserveId { result_id: Id },
    TypeQueue { result_id: Id },
    TypePipe { result_id: Id, qualifier: AccessQualifier },
    TypeForwardPointer { pointer_type: Id, storage_class: StorageClass },
    ConstantTrue { result_type_id: Id, result_id: Id },
    ConstantFalse { result_type_id: Id, result_id: Id },
    Constant { result_type_id: Id, result_id: Id, value: Vec<u32> },
    ConstantComposite { result_type_id: Id, result_id: Id, constituents: Vec<Id> },
    ConstantSampler {
        result_type_id: Id,
        result_id: Id,
        sampler_addressing_mode: SamplerAddressingMode,
        param: u32,
        sampler_filter_mode: SamplerFilterMode,
    },
    ConstantNull { result_type_id: Id, result_id: Id },
    SpecConstantTrue { result_type_id: Id, result_id: Id },
    SpecConstantFalse { result_type_id: Id, result_id: Id },
    SpecConstant { result_type_id: Id, result_id: Id, value: Vec<u32> },
    SpecConstantComposite { result_type_id: Id, result_id: Id, constituents: Vec<Id> },
    SpecConstantOp {
        result_type_id: Id,
        result_id: Id,
        opcode: SpecConstantInstruction,
    },
    Function {
        result_type_id: Id,
        result_id: Id,
        function_control: FunctionControl,
        function_type: Id,
    },
    FunctionParameter { result_type_id: Id, result_id: Id },
    FunctionEnd,
    FunctionCall { result_type_id: Id, result_id: Id, function: Id, arguments: Vec<Id> },
    Variable {
        result_type_id: Id,
        result_id: Id,
        storage_class: StorageClass,
        initializer: Option<Id>,
    },
    ImageTexelPointer {
        result_type_id: Id,
        result_id: Id,
        image: Id,
        coordinate: Id,
        sample: Id,
    },
    Load {
        result_type_id: Id,
        result_id: Id,
        pointer: Id,
        memory_access: Option<MemoryAccess>,
    },
    Store { pointer: Id, object: Id, memory_access: Option<MemoryAccess> },
    CopyMemory {
        target: Id,
        source: Id,
        memory_access1: Option<MemoryAccess>,
        memory_access2: Option<MemoryAccess>,
    },
    CopyMemorySized {
        target: Id,
        source: Id,
        size: Id,
        memory_access1: Option<MemoryAccess>,
        memory_access2: Option<MemoryAccess>,
    },
    AccessChain { result_type_id: Id, result_id: Id, base: Id, indexes: Vec<Id> },
    InBoundsAccessChain {
        result_type_id: Id,
        result_id: Id,
        base: Id,
        indexes: Vec<Id>,
    },
    PtrAccessChain {
        result_type_id: Id,
        result_id: Id,
        base: Id,
        element: Id,
        indexes: Vec<Id>,
    },
    ArrayLength { result_type_id: Id, result_id: Id, structure: Id, array_member: u32 },
    GenericPtrMemSemantics { result_type_id: Id, result_id: Id, pointer: Id },
    InBoundsPtrAccessChain {
        result_type_id: Id,
        result_id: Id,
        base: Id,
        element: Id,
        indexes: Vec<Id>,
    },
    Decorate { target: Id, decoration: Decoration },
    MemberDecorate { structure_type: Id, member: u32, decoration: Decoration },
    DecorationGroup { result_id: Id },
    GroupDecorate { decoration_group: Id, targets: Vec<Id> },
    GroupMemberDecorate { decoration_group: Id, targets: Vec<(Id, u32)> },
    VectorExtractDynamic { result_type_id: Id, result_id: Id, vector: Id, index: Id },
    VectorInsertDynamic {
        result_type_id: Id,
        result_id: Id,
        vector: Id,
        component: Id,
        index: Id,
    },
    VectorShuffle {
        result_type_id: Id,
        result_id: Id,
        vector_1: Id,
        vector_2: Id,
        components: Vec<u32>,
    },
    CompositeConstruct { result_type_id: Id, result_id: Id, constituents: Vec<Id> },
    CompositeExtract {
        result_type_id: Id,
        result_id: Id,
        composite: Id,
        indexes: Vec<u32>,
    },
    CompositeInsert {
        result_type_id: Id,
        result_id: Id,
        object: Id,
        composite: Id,
        indexes: Vec<u32>,
    },
    CopyObject { result_type_id: Id, result_id: Id, operand: Id },
    Transpose { result_type_id: Id, result_id: Id, matrix: Id },
    SampledImage { result_type_id: Id, result_id: Id, image: Id, sampler: Id },
    ImageSampleImplicitLod {
        result_type_id: Id,
        result_id: Id,
        sampled_image: Id,
        coordinate: Id,
        image_operands: Option<ImageOperands>,
    },
    ImageSampleExplicitLod {
        result_type_id: Id,
        result_id: Id,
        sampled_image: Id,
        coordinate: Id,
        image_operands: ImageOperands,
    },
    ImageSampleDrefImplicitLod {
        result_type_id: Id,
        result_id: Id,
        sampled_image: Id,
        coordinate: Id,
        dref: Id,
        image_operands: Option<ImageOperands>,
    },
    ImageSampleDrefExplicitLod {
        result_type_id: Id,
        result_id: Id,
        sampled_image: Id,
        coordinate: Id,
        dref: Id,
        image_operands: ImageOperands,
    },
    ImageSampleProjImplicitLod {
        result_type_id: Id,
        result_id: Id,
        sampled_image: Id,
        coordinate: Id,
        image_operands: Option<ImageOperands>,
    },
    ImageSampleProjExplicitLod {
        result_type_id: Id,
        result_id: Id,
        sampled_image: Id,
        coordinate: Id,
        image_operands: ImageOperands,
    },
    ImageSampleProjDrefImplicitLod {
        result_type_id: Id,
        result_id: Id,
        sampled_image: Id,
        coordinate: Id,
        dref: Id,
        image_operands: Option<ImageOperands>,
    },
    ImageSampleProjDrefExplicitLod {
        result_type_id: Id,
        result_id: Id,
        sampled_image: Id,
        coordinate: Id,
        dref: Id,
        image_operands: ImageOperands,
    },
    ImageFetch {
        result_type_id: Id,
        result_id: Id,
        image: Id,
        coordinate: Id,
        image_operands: Option<ImageOperands>,
    },
    ImageGather {
        result_type_id: Id,
        result_id: Id,
        sampled_image: Id,
        coordinate: Id,
        component: Id,
        image_operands: Option<ImageOperands>,
    },
    ImageDrefGather {
        result_type_id: Id,
        result_id: Id,
        sampled_image: Id,
        coordinate: Id,
        dref: Id,
        image_operands: Option<ImageOperands>,
    },
    ImageRead {
        result_type_id: Id,
        result_id: Id,
        image: Id,
        coordinate: Id,
        image_operands: Option<ImageOperands>,
    },
    ImageWrite {
        image: Id,
        coordinate: Id,
        texel: Id,
        image_operands: Option<ImageOperands>,
    },
    Image { result_type_id: Id, result_id: Id, sampled_image: Id },
    ImageQueryFormat { result_type_id: Id, result_id: Id, image: Id },
    ImageQueryOrder { result_type_id: Id, result_id: Id, image: Id },
    ImageQuerySizeLod {
        result_type_id: Id,
        result_id: Id,
        image: Id,
        level_of_detail: Id,
    },
    ImageQuerySize { result_type_id: Id, result_id: Id, image: Id },
    ImageQueryLod {
        result_type_id: Id,
        result_id: Id,
        sampled_image: Id,
        coordinate: Id,
    },
    ImageQueryLevels { result_type_id: Id, result_id: Id, image: Id },
    ImageQuerySamples { result_type_id: Id, result_id: Id, image: Id },
    ConvertFToU { result_type_id: Id, result_id: Id, float_value: Id },
    ConvertFToS { result_type_id: Id, result_id: Id, float_value: Id },
    ConvertSToF { result_type_id: Id, result_id: Id, signed_value: Id },
    ConvertUToF { result_type_id: Id, result_id: Id, unsigned_value: Id },
    UConvert { result_type_id: Id, result_id: Id, unsigned_value: Id },
    SConvert { result_type_id: Id, result_id: Id, signed_value: Id },
    FConvert { result_type_id: Id, result_id: Id, float_value: Id },
    QuantizeToF16 { result_type_id: Id, result_id: Id, value: Id },
    ConvertPtrToU { result_type_id: Id, result_id: Id, pointer: Id },
    SatConvertSToU { result_type_id: Id, result_id: Id, signed_value: Id },
    SatConvertUToS { result_type_id: Id, result_id: Id, unsigned_value: Id },
    ConvertUToPtr { result_type_id: Id, result_id: Id, integer_value: Id },
    PtrCastToGeneric { result_type_id: Id, result_id: Id, pointer: Id },
    GenericCastToPtr { result_type_id: Id, result_id: Id, pointer: Id },
    GenericCastToPtrExplicit {
        result_type_id: Id,
        result_id: Id,
        pointer: Id,
        storage: StorageClass,
    },
    Bitcast { result_type_id: Id, result_id: Id, operand: Id },
    SNegate { result_type_id: Id, result_id: Id, operand: Id },
    FNegate { result_type_id: Id, result_id: Id, operand: Id },
    IAdd { result_type_id: Id, result_id: Id, operand1: Id, operand2: Id },
    FAdd { result_type_id: Id, result_id: Id, operand1: Id, operand2: Id },
    ISub { result_type_id: Id, result_id: Id, operand1: Id, operand2: Id },
    FSub { result_type_id: Id, result_id: Id, operand1: Id, operand2: Id },
    IMul { result_type_id: Id, result_id: Id, operand1: Id, operand2: Id },
    FMul { result_type_id: Id, result_id: Id, operand1: Id, operand2: Id },
    UDiv { result_type_id: Id, result_id: Id, operand1: Id, operand2: Id },
    SDiv { result_type_id: Id, result_id: Id, operand1: Id, operand2: Id },
    FDiv { result_type_id: Id, result_id: Id, operand1: Id, operand2: Id },
    UMod { result_type_id: Id, result_id: Id, operand1: Id, operand2: Id },
    SRem { result_type_id: Id, result_id: Id, operand1: Id, operand2: Id },
    SMod { result_type_id: Id, result_id: Id, operand1: Id, operand2: Id },
    FRem { result_type_id: Id, result_id: Id, operand1: Id, operand2: Id },
    FMod { result_type_id: Id, result_id: Id, operand1: Id, operand2: Id },
    VectorTimesScalar { result_type_id: Id, result_id: Id, vector: Id, scalar: Id },
    MatrixTimesScalar { result_type_id: Id, result_id: Id, matrix: Id, scalar: Id },
    VectorTimesMatrix { result_type_id: Id, result_id: Id, vector: Id, matrix: Id },
    MatrixTimesVector { result_type_id: Id, result_id: Id, matrix: Id, vector: Id },
    MatrixTimesMatrix {
        result_type_id: Id,
        result_id: Id,
        left_matrix: Id,
        right_matrix: Id,
    },
    OuterProduct { result_type_id: Id, result_id: Id, vector_1: Id, vector_2: Id },
    Dot { result_type_id: Id, result_id: Id, vector_1: Id, vector_2: Id },
    IAddCarry { result_type_id: Id, result_id: Id, operand1: Id, operand2: Id },
    ISubBorrow { result_type_id: Id, result_id: Id, operand1: Id, operand2: Id },
    UMulExtended { result_type_id: Id, result_id: Id, operand1: Id, operand2: Id },
    SMulExtended { result_type_id: Id, result_id: Id, operand1: Id, operand2: Id },
    Any { result_type_id: Id, result_id: Id, vector: Id },
    All { result_type_id: Id, result_id: Id, vector: Id },
    IsNan { result_type_id: Id, result_id: Id, x: Id },
    IsInf { result_type_id: Id, result_id: Id, x: Id },
    IsFinite { result_type_id: Id, result_id: Id, x: Id },
    IsNormal { result_type_id: Id, result_id: Id, x: Id },
    SignBitSet { result_type_id: Id, result_id: Id, x: Id },
    LessOrGreater { result_type_id: Id, result_id: Id, x: Id, y: Id },
    Ordered { result_type_id: Id, result_id: Id, x: Id, y: Id },
    Unordered { result_type_id: Id, result_id: Id, x: Id, y: Id },
    LogicalEqual { result_type_id: Id, result_id: Id, operand1: Id, operand2: Id },
    LogicalNotEqual { result_type_id: Id, result_id: Id, operand1: Id, operand2: Id },
    LogicalOr { result_type_id: Id, result_id: Id, operand1: Id, operand2: Id },
    LogicalAnd { result_type_id: Id, result_id: Id, operand1: Id, operand2: Id },
    LogicalNot { result_type_id: Id, result_id: Id, operand: Id },
    Select {
        result_type_id: Id,
        result_id: Id,
        condition: Id,
        object_1: Id,
        object_2: Id,
    },
    IEqual { result_type_id: Id, result_id: Id, operand1: Id, operand2: Id },
    INotEqual { result_type_id: Id, result_id: Id, operand1: Id, operand2: Id },
    UGreaterThan { result_type_id: Id, result_id: Id, operand1: Id, operand2: Id },
    SGreaterThan { result_type_id: Id, result_id: Id, operand1: Id, operand2: Id },
    UGreaterThanEqual { result_type_id: Id, result_id: Id, operand1: Id, operand2: Id },
    SGreaterThanEqual { result_type_id: Id, result_id: Id, operand1: Id, operand2: Id },
    ULessThan { result_type_id: Id, result_id: Id, operand1: Id, operand2: Id },
    SLessThan { result_type_id: Id, result_id: Id, operand1: Id, operand2: Id },
    ULessThanEqual { result_type_id: Id, result_id: Id, operand1: Id, operand2: Id },
    SLessThanEqual { result_type_id: Id, result_id: Id, operand1: Id, operand2: Id },
    FOrdEqual { result_type_id: Id, result_id: Id, operand1: Id, operand2: Id },
    FUnordEqual { result_type_id: Id, result_id: Id, operand1: Id, operand2: Id },
    FOrdNotEqual { result_type_id: Id, result_id: Id, operand1: Id, operand2: Id },
    FUnordNotEqual { result_type_id: Id, result_id: Id, operand1: Id, operand2: Id },
    FOrdLessThan { result_type_id: Id, result_id: Id, operand1: Id, operand2: Id },
    FUnordLessThan { result_type_id: Id, result_id: Id, operand1: Id, operand2: Id },
    FOrdGreaterThan { result_type_id: Id, result_id: Id, operand1: Id, operand2: Id },
    FUnordGreaterThan { result_type_id: Id, result_id: Id, operand1: Id, operand2: Id },
    FOrdLessThanEqual { result_type_id: Id, result_id: Id, operand1: Id, operand2: Id },
    FUnordLessThanEqual {
        result_type_id: Id,
        result_id: Id,
        operand1: Id,
        operand2: Id,
    },
    FOrdGreaterThanEqual {
        result_type_id: Id,
        result_id: Id,
        operand1: Id,
        operand2: Id,
    },
    FUnordGreaterThanEqual {
        result_type_id: Id,
        result_id: Id,
        operand1: Id,
        operand2: Id,
    },
    ShiftRightLogical { result_type_id: Id, result_id: Id, base: Id, shift: Id },
    ShiftRightArithmetic { result_type_id: Id, result_id: Id, base: Id, shift: Id },
    ShiftLeftLogical { result_type_id: Id, result_id: Id, base: Id, shift: Id },
    BitwiseOr { result_type_id: Id, result_id: Id, operand1: Id, operand2: Id },
    BitwiseXor { result_type_id: Id, result_id: Id, operand1: Id, operand2: Id },
    BitwiseAnd { result_type_id: Id, result_id: Id, operand1: Id, operand2: Id },
    Not { result_type_id: Id, result_id: Id, operand: Id },
    BitFieldInsert {
        result_type_id: Id,
        result_id: Id,
        base: Id,
        insert: Id,
        offset: Id,
        count: Id,
    },
    BitFieldSExtract {
        result_type_id: Id,
        result_id: Id,
        base: Id,
        offset: Id,
        count: Id,
    },
    BitFieldUExtract {
        result_type_id: Id,
        result_id: Id,
        base: Id,
        offset: Id,
        count: Id,
    },
    BitReverse { result_type_id: Id, result_id: Id, base: Id },
    BitCount { result_type_id: Id, result_id: Id, base: Id },
    DPdx { result_type_id: Id, result_id: Id, p: Id },
    DPdy { result_type_id: Id, result_id: Id, p: Id },
    Fwidth { result_type_id: Id, result_id: Id, p: Id },
    DPdxFine { result_type_id: Id, result_id: Id, p: Id },
    DPdyFine { result_type_id: Id, result_id: Id, p: Id },
    FwidthFine { result_type_id: Id, result_id: Id, p: Id },
    DPdxCoarse { result_type_id: Id, result_id: Id, p: Id },
    DPdyCoarse { result_type_id: Id, result_id: Id, p: Id },
    FwidthCoarse { result_type_id: Id, result_id: Id, p: Id },
    EmitVertex,
    EndPrimitive,
    EmitStreamVertex { stream: Id },
    EndStreamPrimitive { stream: Id },
    ControlBarrier { execution: Id, memory: Id, semantics: Id },
    MemoryBarrier { memory: Id, semantics: Id },
    AtomicLoad {
        result_type_id: Id,
        result_id: Id,
        pointer: Id,
        memory: Id,
        semantics: Id,
    },
    AtomicStore { pointer: Id, memory: Id, semantics: Id, value: Id },
    AtomicExchange {
        result_type_id: Id,
        result_id: Id,
        pointer: Id,
        memory: Id,
        semantics: Id,
        value: Id,
    },
    AtomicCompareExchange {
        result_type_id: Id,
        result_id: Id,
        pointer: Id,
        memory: Id,
        equal: Id,
        unequal: Id,
        value: Id,
        comparator: Id,
    },
    AtomicCompareExchangeWeak {
        result_type_id: Id,
        result_id: Id,
        pointer: Id,
        memory: Id,
        equal: Id,
        unequal: Id,
        value: Id,
        comparator: Id,
    },
    AtomicIIncrement {
        result_type_id: Id,
        result_id: Id,
        pointer: Id,
        memory: Id,
        semantics: Id,
    },
    AtomicIDecrement {
        result_type_id: Id,
        result_id: Id,
        pointer: Id,
        memory: Id,
        semantics: Id,
    },
    AtomicIAdd {
        result_type_id: Id,
        result_id: Id,
        pointer: Id,
        memory: Id,
        semantics: Id,
        value: Id,
    },
    AtomicISub {
        result_type_id: Id,
        result_id: Id,
        pointer: Id,
        memory: Id,
        semantics: Id,
        value: Id,
    },
    AtomicSMin {
        result_type_id: Id,
        result_id: Id,
        pointer: Id,
        memory: Id,
        semantics: Id,
        value: Id,
    },
    AtomicUMin {
        result_type_id: Id,
        result_id: Id,
        pointer: Id,
        memory: Id,
        semantics: Id,
        value: Id,
    },
    AtomicSMax {
        result_type_id: Id,
        result_id: Id,
        pointer: Id,
        memory: Id,
        semantics: Id,
        value: Id,
    },
    AtomicUMax {
        result_type_id: Id,
        result_id: Id,
        pointer: Id,
        memory: Id,
        semantics: Id,
        value: Id,
    },
    AtomicAnd {
        result_type_id: Id,
        result_id: Id,
        pointer: Id,
        memory: Id,
        semantics: Id,
        value: Id,
    },
    AtomicOr {
        result_type_id: Id,
        result_id: Id,
        pointer: Id,
        memory: Id,
        semantics: Id,
        value: Id,
    },
    AtomicXor {
        result_type_id: Id,
        result_id: Id,
        pointer: Id,
        memory: Id,
        semantics: Id,
        value: Id,
    },
    Phi { result_type_id: Id, result_id: Id, variable_parent: Vec<(Id, Id)> },
    LoopMerge { merge_block: Id, continue_target: Id, loop_control: LoopControl },
    SelectionMerge { merge_block: Id, selection_control: SelectionControl },
    Label { result_id: Id },
    Branch { target_label: Id },
    BranchConditional {
        condition: Id,
        true_label: Id,
        false_label: Id,
        branch_weights: Vec<u32>,
    },
    Switch { selector: Id, default: Id, target: Vec<(u32, Id)> },
    Kill,
    Return,
    ReturnValue { value: Id },
    Unreachable,
    LifetimeStart { pointer: Id, size: u32 },
    LifetimeStop { pointer: Id, size: u32 },
    GroupAsyncCopy {
        result_type_id: Id,
        result_id: Id,
        execution: Id,
        destination: Id,
        source: Id,
        num_elements: Id,
        stride: Id,
        event: Id,
    },
    GroupWaitEvents { execution: Id, num_events: Id, events_list: Id },
    GroupAll { result_type_id: Id, result_id: Id, execution: Id, predicate: Id },
    GroupAny { result_type_id: Id, result_id: Id, execution: Id, predicate: Id },
    GroupBroadcast {
        result_type_id: Id,
        result_id: Id,
        execution: Id,
        value: Id,
        local_id: Id,
    },
    GroupIAdd {
        result_type_id: Id,
        result_id: Id,
        execution: Id,
        operation: GroupOperation,
        x: Id,
    },
    GroupFAdd {
        result_type_id: Id,
        result_id: Id,
        execution: Id,
        operation: GroupOperation,
        x: Id,
    },
    GroupFMin {
        result_type_id: Id,
        result_id: Id,
        execution: Id,
        operation: GroupOperation,
        x: Id,
    },
    GroupUMin {
        result_type_id: Id,
        result_id: Id,
        execution: Id,
        operation: GroupOperation,
        x: Id,
    },
    GroupSMin {
        result_type_id: Id,
        result_id: Id,
        execution: Id,
        operation: GroupOperation,
        x: Id,
    },
    GroupFMax {
        result_type_id: Id,
        result_id: Id,
        execution: Id,
        operation: GroupOperation,
        x: Id,
    },
    GroupUMax {
        result_type_id: Id,
        result_id: Id,
        execution: Id,
        operation: GroupOperation,
        x: Id,
    },
    GroupSMax {
        result_type_id: Id,
        result_id: Id,
        execution: Id,
        operation: GroupOperation,
        x: Id,
    },
    ReadPipe {
        result_type_id: Id,
        result_id: Id,
        pipe: Id,
        pointer: Id,
        packet_size: Id,
        packet_alignment: Id,
    },
    WritePipe {
        result_type_id: Id,
        result_id: Id,
        pipe: Id,
        pointer: Id,
        packet_size: Id,
        packet_alignment: Id,
    },
    ReservedReadPipe {
        result_type_id: Id,
        result_id: Id,
        pipe: Id,
        reserve_id: Id,
        index: Id,
        pointer: Id,
        packet_size: Id,
        packet_alignment: Id,
    },
    ReservedWritePipe {
        result_type_id: Id,
        result_id: Id,
        pipe: Id,
        reserve_id: Id,
        index: Id,
        pointer: Id,
        packet_size: Id,
        packet_alignment: Id,
    },
    ReserveReadPipePackets {
        result_type_id: Id,
        result_id: Id,
        pipe: Id,
        num_packets: Id,
        packet_size: Id,
        packet_alignment: Id,
    },
    ReserveWritePipePackets {
        result_type_id: Id,
        result_id: Id,
        pipe: Id,
        num_packets: Id,
        packet_size: Id,
        packet_alignment: Id,
    },
    CommitReadPipe { pipe: Id, reserve_id: Id, packet_size: Id, packet_alignment: Id },
    CommitWritePipe { pipe: Id, reserve_id: Id, packet_size: Id, packet_alignment: Id },
    IsValidReserveId { result_type_id: Id, result_id: Id, reserve_id: Id },
    GetNumPipePackets {
        result_type_id: Id,
        result_id: Id,
        pipe: Id,
        packet_size: Id,
        packet_alignment: Id,
    },
    GetMaxPipePackets {
        result_type_id: Id,
        result_id: Id,
        pipe: Id,
        packet_size: Id,
        packet_alignment: Id,
    },
    GroupReserveReadPipePackets {
        result_type_id: Id,
        result_id: Id,
        execution: Id,
        pipe: Id,
        num_packets: Id,
        packet_size: Id,
        packet_alignment: Id,
    },
    GroupReserveWritePipePackets {
        result_type_id: Id,
        result_id: Id,
        execution: Id,
        pipe: Id,
        num_packets: Id,
        packet_size: Id,
        packet_alignment: Id,
    },
    GroupCommitReadPipe {
        execution: Id,
        pipe: Id,
        reserve_id: Id,
        packet_size: Id,
        packet_alignment: Id,
    },
    GroupCommitWritePipe {
        execution: Id,
        pipe: Id,
        reserve_id: Id,
        packet_size: Id,
        packet_alignment: Id,
    },
    EnqueueMarker {
        result_type_id: Id,
        result_id: Id,
        queue: Id,
        num_events: Id,
        wait_events: Id,
        ret_event: Id,
    },
    EnqueueKernel {
        result_type_id: Id,
        result_id: Id,
        queue: Id,
        flags: Id,
        nd_range: Id,
        num_events: Id,
        wait_events: Id,
        ret_event: Id,
        invoke: Id,
        param: Id,
        param_size: Id,
        param_align: Id,
        local_size: Vec<Id>,
    },
    GetKernelNDrangeSubGroupCount {
        result_type_id: Id,
        result_id: Id,
        nd_range: Id,
        invoke: Id,
        param: Id,
        param_size: Id,
        param_align: Id,
    },
    GetKernelNDrangeMaxSubGroupSize {
        result_type_id: Id,
        result_id: Id,
        nd_range: Id,
        invoke: Id,
        param: Id,
        param_size: Id,
        param_align: Id,
    },
    GetKernelWorkGroupSize {
        result_type_id: Id,
        result_id: Id,
        invoke: Id,
        param: Id,
        param_size: Id,
        param_align: Id,
    },
    GetKernelPreferredWorkGroupSizeMultiple {
        result_type_id: Id,
        result_id: Id,
        invoke: Id,
        param: Id,
        param_size: Id,
        param_align: Id,
    },
    RetainEvent { event: Id },
    ReleaseEvent { event: Id },
    CreateUserEvent { result_type_id: Id, result_id: Id },
    IsValidEvent { result_type_id: Id, result_id: Id, event: Id },
    SetUserEventStatus { event: Id, status: Id },
    CaptureEventProfilingInfo { event: Id, profiling_info: Id, value: Id },
    GetDefaultQueue { result_type_id: Id, result_id: Id },
    BuildNDRange {
        result_type_id: Id,
        result_id: Id,
        global_work_size: Id,
        local_work_size: Id,
        global_work_offset: Id,
    },
    ImageSparseSampleImplicitLod {
        result_type_id: Id,
        result_id: Id,
        sampled_image: Id,
        coordinate: Id,
        image_operands: Option<ImageOperands>,
    },
    ImageSparseSampleExplicitLod {
        result_type_id: Id,
        result_id: Id,
        sampled_image: Id,
        coordinate: Id,
        image_operands: ImageOperands,
    },
    ImageSparseSampleDrefImplicitLod {
        result_type_id: Id,
        result_id: Id,
        sampled_image: Id,
        coordinate: Id,
        dref: Id,
        image_operands: Option<ImageOperands>,
    },
    ImageSparseSampleDrefExplicitLod {
        result_type_id: Id,
        result_id: Id,
        sampled_image: Id,
        coordinate: Id,
        dref: Id,
        image_operands: ImageOperands,
    },
    ImageSparseSampleProjImplicitLod {
        result_type_id: Id,
        result_id: Id,
        sampled_image: Id,
        coordinate: Id,
        image_operands: Option<ImageOperands>,
    },
    ImageSparseSampleProjExplicitLod {
        result_type_id: Id,
        result_id: Id,
        sampled_image: Id,
        coordinate: Id,
        image_operands: ImageOperands,
    },
    ImageSparseSampleProjDrefImplicitLod {
        result_type_id: Id,
        result_id: Id,
        sampled_image: Id,
        coordinate: Id,
        dref: Id,
        image_operands: Option<ImageOperands>,
    },
    ImageSparseSampleProjDrefExplicitLod {
        result_type_id: Id,
        result_id: Id,
        sampled_image: Id,
        coordinate: Id,
        dref: Id,
        image_operands: ImageOperands,
    },
    ImageSparseFetch {
        result_type_id: Id,
        result_id: Id,
        image: Id,
        coordinate: Id,
        image_operands: Option<ImageOperands>,
    },
    ImageSparseGather {
        result_type_id: Id,
        result_id: Id,
        sampled_image: Id,
        coordinate: Id,
        component: Id,
        image_operands: Option<ImageOperands>,
    },
    ImageSparseDrefGather {
        result_type_id: Id,
        result_id: Id,
        sampled_image: Id,
        coordinate: Id,
        dref: Id,
        image_operands: Option<ImageOperands>,
    },
    ImageSparseTexelsResident { result_type_id: Id, result_id: Id, resident_code: Id },
    NoLine,
    AtomicFlagTestAndSet {
        result_type_id: Id,
        result_id: Id,
        pointer: Id,
        memory: Id,
        semantics: Id,
    },
    AtomicFlagClear { pointer: Id, memory: Id, semantics: Id },
    ImageSparseRead {
        result_type_id: Id,
        result_id: Id,
        image: Id,
        coordinate: Id,
        image_operands: Option<ImageOperands>,
    },
    SizeOf { result_type_id: Id, result_id: Id, pointer: Id },
    TypePipeStorage { result_id: Id },
    ConstantPipeStorage {
        result_type_id: Id,
        result_id: Id,
        packet_size: u32,
        packet_alignment: u32,
        capacity: u32,
    },
    CreatePipeFromPipeStorage { result_type_id: Id, result_id: Id, pipe_storage: Id },
    GetKernelLocalSizeForSubgroupCount {
        result_type_id: Id,
        result_id: Id,
        subgroup_count: Id,
        invoke: Id,
        param: Id,
        param_size: Id,
        param_align: Id,
    },
    GetKernelMaxNumSubgroups {
        result_type_id: Id,
        result_id: Id,
        invoke: Id,
        param: Id,
        param_size: Id,
        param_align: Id,
    },
    TypeNamedBarrier { result_id: Id },
    NamedBarrierInitialize { result_type_id: Id, result_id: Id, subgroup_count: Id },
    MemoryNamedBarrier { named_barrier: Id, memory: Id, semantics: Id },
    ModuleProcessed { process: String },
    ExecutionModeId { entry_point: Id, mode: ExecutionMode },
    DecorateId { target: Id, decoration: Decoration },
    GroupNonUniformElect { result_type_id: Id, result_id: Id, execution: Id },
    GroupNonUniformAll {
        result_type_id: Id,
        result_id: Id,
        execution: Id,
        predicate: Id,
    },
    GroupNonUniformAny {
        result_type_id: Id,
        result_id: Id,
        execution: Id,
        predicate: Id,
    },
    GroupNonUniformAllEqual {
        result_type_id: Id,
        result_id: Id,
        execution: Id,
        value: Id,
    },
    GroupNonUniformBroadcast {
        result_type_id: Id,
        result_id: Id,
        execution: Id,
        value: Id,
        id: Id,
    },
    GroupNonUniformBroadcastFirst {
        result_type_id: Id,
        result_id: Id,
        execution: Id,
        value: Id,
    },
    GroupNonUniformBallot {
        result_type_id: Id,
        result_id: Id,
        execution: Id,
        predicate: Id,
    },
    GroupNonUniformInverseBallot {
        result_type_id: Id,
        result_id: Id,
        execution: Id,
        value: Id,
    },
    GroupNonUniformBallotBitExtract {
        result_type_id: Id,
        result_id: Id,
        execution: Id,
        value: Id,
        index: Id,
    },
    GroupNonUniformBallotBitCount {
        result_type_id: Id,
        result_id: Id,
        execution: Id,
        operation: GroupOperation,
        value: Id,
    },
    GroupNonUniformBallotFindLSB {
        result_type_id: Id,
        result_id: Id,
        execution: Id,
        value: Id,
    },
    GroupNonUniformBallotFindMSB {
        result_type_id: Id,
        result_id: Id,
        execution: Id,
        value: Id,
    },
    GroupNonUniformShuffle {
        result_type_id: Id,
        result_id: Id,
        execution: Id,
        value: Id,
        id: Id,
    },
    GroupNonUniformShuffleXor {
        result_type_id: Id,
        result_id: Id,
        execution: Id,
        value: Id,
        mask: Id,
    },
    GroupNonUniformShuffleUp {
        result_type_id: Id,
        result_id: Id,
        execution: Id,
        value: Id,
        delta: Id,
    },
    GroupNonUniformShuffleDown {
        result_type_id: Id,
        result_id: Id,
        execution: Id,
        value: Id,
        delta: Id,
    },
    GroupNonUniformIAdd {
        result_type_id: Id,
        result_id: Id,
        execution: Id,
        operation: GroupOperation,
        value: Id,
        cluster_size: Option<Id>,
    },
    GroupNonUniformFAdd {
        result_type_id: Id,
        result_id: Id,
        execution: Id,
        operation: GroupOperation,
        value: Id,
        cluster_size: Option<Id>,
    },
    GroupNonUniformIMul {
        result_type_id: Id,
        result_id: Id,
        execution: Id,
        operation: GroupOperation,
        value: Id,
        cluster_size: Option<Id>,
    },
    GroupNonUniformFMul {
        result_type_id: Id,
        result_id: Id,
        execution: Id,
        operation: GroupOperation,
        value: Id,
        cluster_size: Option<Id>,
    },
    GroupNonUniformSMin {
        result_type_id: Id,
        result_id: Id,
        execution: Id,
        operation: GroupOperation,
        value: Id,
        cluster_size: Option<Id>,
    },
    GroupNonUniformUMin {
        result_type_id: Id,
        result_id: Id,
        execution: Id,
        operation: GroupOperation,
        value: Id,
        cluster_size: Option<Id>,
    },
    GroupNonUniformFMin {
        result_type_id: Id,
        result_id: Id,
        execution: Id,
        operation: GroupOperation,
        value: Id,
        cluster_size: Option<Id>,
    },
    GroupNonUniformSMax {
        result_type_id: Id,
        result_id: Id,
        execution: Id,
        operation: GroupOperation,
        value: Id,
        cluster_size: Option<Id>,
    },
    GroupNonUniformUMax {
        result_type_id: Id,
        result_id: Id,
        execution: Id,
        operation: GroupOperation,
        value: Id,
        cluster_size: Option<Id>,
    },
    GroupNonUniformFMax {
        result_type_id: Id,
        result_id: Id,
        execution: Id,
        operation: GroupOperation,
        value: Id,
        cluster_size: Option<Id>,
    },
    GroupNonUniformBitwiseAnd {
        result_type_id: Id,
        result_id: Id,
        execution: Id,
        operation: GroupOperation,
        value: Id,
        cluster_size: Option<Id>,
    },
    GroupNonUniformBitwiseOr {
        result_type_id: Id,
        result_id: Id,
        execution: Id,
        operation: GroupOperation,
        value: Id,
        cluster_size: Option<Id>,
    },
    GroupNonUniformBitwiseXor {
        result_type_id: Id,
        result_id: Id,
        execution: Id,
        operation: GroupOperation,
        value: Id,
        cluster_size: Option<Id>,
    },
    GroupNonUniformLogicalAnd {
        result_type_id: Id,
        result_id: Id,
        execution: Id,
        operation: GroupOperation,
        value: Id,
        cluster_size: Option<Id>,
    },
    GroupNonUniformLogicalOr {
        result_type_id: Id,
        result_id: Id,
        execution: Id,
        operation: GroupOperation,
        value: Id,
        cluster_size: Option<Id>,
    },
    GroupNonUniformLogicalXor {
        result_type_id: Id,
        result_id: Id,
        execution: Id,
        operation: GroupOperation,
        value: Id,
        cluster_size: Option<Id>,
    },
    GroupNonUniformQuadBroadcast {
        result_type_id: Id,
        result_id: Id,
        execution: Id,
        value: Id,
        index: Id,
    },
    GroupNonUniformQuadSwap {
        result_type_id: Id,
        result_id: Id,
        execution: Id,
        value: Id,
        direction: Id,
    },
    CopyLogical { result_type_id: Id, result_id: Id, operand: Id },
    PtrEqual { result_type_id: Id, result_id: Id, operand1: Id, operand2: Id },
    PtrNotEqual { result_type_id: Id, result_id: Id, operand1: Id, operand2: Id },
    PtrDiff { result_type_id: Id, result_id: Id, operand1: Id, operand2: Id },
    ColorAttachmentReadEXT {
        result_type_id: Id,
        result_id: Id,
        attachment: Id,
        sample: Option<Id>,
    },
    DepthAttachmentReadEXT { result_type_id: Id, result_id: Id, sample: Option<Id> },
    StencilAttachmentReadEXT { result_type_id: Id, result_id: Id, sample: Option<Id> },
    TerminateInvocation,
    SubgroupBallotKHR { result_type_id: Id, result_id: Id, predicate: Id },
    SubgroupFirstInvocationKHR { result_type_id: Id, result_id: Id, value: Id },
    SubgroupAllKHR { result_type_id: Id, result_id: Id, predicate: Id },
    SubgroupAnyKHR { result_type_id: Id, result_id: Id, predicate: Id },
    SubgroupAllEqualKHR { result_type_id: Id, result_id: Id, predicate: Id },
    GroupNonUniformRotateKHR {
        result_type_id: Id,
        result_id: Id,
        execution: Id,
        value: Id,
        delta: Id,
        cluster_size: Option<Id>,
    },
    SubgroupReadInvocationKHR {
        result_type_id: Id,
        result_id: Id,
        value: Id,
        index: Id,
    },
    TraceRayKHR {
        accel: Id,
        ray_flags: Id,
        cull_mask: Id,
        sbt_offset: Id,
        sbt_stride: Id,
        miss_index: Id,
        ray_origin: Id,
        ray_tmin: Id,
        ray_direction: Id,
        ray_tmax: Id,
        payload: Id,
    },
    ExecuteCallableKHR { sbt_index: Id, callable_data: Id },
    ConvertUToAccelerationStructureKHR { result_type_id: Id, result_id: Id, accel: Id },
    IgnoreIntersectionKHR,
    TerminateRayKHR,
    SDot {
        result_type_id: Id,
        result_id: Id,
        vector_1: Id,
        vector_2: Id,
        packed_vector_format: Option<PackedVectorFormat>,
    },
    UDot {
        result_type_id: Id,
        result_id: Id,
        vector_1: Id,
        vector_2: Id,
        packed_vector_format: Option<PackedVectorFormat>,
    },
    SUDot {
        result_type_id: Id,
        result_id: Id,
        vector_1: Id,
        vector_2: Id,
        packed_vector_format: Option<PackedVectorFormat>,
    },
    SDotAccSat {
        result_type_id: Id,
        result_id: Id,
        vector_1: Id,
        vector_2: Id,
        accumulator: Id,
        packed_vector_format: Option<PackedVectorFormat>,
    },
    UDotAccSat {
        result_type_id: Id,
        result_id: Id,
        vector_1: Id,
        vector_2: Id,
        accumulator: Id,
        packed_vector_format: Option<PackedVectorFormat>,
    },
    SUDotAccSat {
        result_type_id: Id,
        result_id: Id,
        vector_1: Id,
        vector_2: Id,
        accumulator: Id,
        packed_vector_format: Option<PackedVectorFormat>,
    },
    TypeCooperativeMatrixKHR {
        result_id: Id,
        component_type: Id,
        scope: Id,
        rows: Id,
        columns: Id,
        usage: Id,
    },
    CooperativeMatrixLoadKHR {
        result_type_id: Id,
        result_id: Id,
        pointer: Id,
        memory_layout: Id,
        stride: Option<Id>,
        memory_operand: Option<MemoryAccess>,
    },
    CooperativeMatrixStoreKHR {
        pointer: Id,
        object: Id,
        memory_layout: Id,
        stride: Option<Id>,
        memory_operand: Option<MemoryAccess>,
    },
    CooperativeMatrixMulAddKHR {
        result_type_id: Id,
        result_id: Id,
        a: Id,
        b: Id,
        c: Id,
        cooperative_matrix_operands: Option<CooperativeMatrixOperands>,
    },
    CooperativeMatrixLengthKHR { result_type_id: Id, result_id: Id, ty: Id },
    TypeRayQueryKHR { result_id: Id },
    RayQueryInitializeKHR {
        ray_query: Id,
        accel: Id,
        ray_flags: Id,
        cull_mask: Id,
        ray_origin: Id,
        ray_t_min: Id,
        ray_direction: Id,
        ray_t_max: Id,
    },
    RayQueryTerminateKHR { ray_query: Id },
    RayQueryGenerateIntersectionKHR { ray_query: Id, hit_t: Id },
    RayQueryConfirmIntersectionKHR { ray_query: Id },
    RayQueryProceedKHR { result_type_id: Id, result_id: Id, ray_query: Id },
    RayQueryGetIntersectionTypeKHR {
        result_type_id: Id,
        result_id: Id,
        ray_query: Id,
        intersection: Id,
    },
    ImageSampleWeightedQCOM {
        result_type_id: Id,
        result_id: Id,
        texture: Id,
        coordinates: Id,
        weights: Id,
    },
    ImageBoxFilterQCOM {
        result_type_id: Id,
        result_id: Id,
        texture: Id,
        coordinates: Id,
        box_size: Id,
    },
    ImageBlockMatchSSDQCOM {
        result_type_id: Id,
        result_id: Id,
        target: Id,
        target_coordinates: Id,
        reference: Id,
        reference_coordinates: Id,
        block_size: Id,
    },
    ImageBlockMatchSADQCOM {
        result_type_id: Id,
        result_id: Id,
        target: Id,
        target_coordinates: Id,
        reference: Id,
        reference_coordinates: Id,
        block_size: Id,
    },
    ImageBlockMatchWindowSSDQCOM {
        result_type_id: Id,
        result_id: Id,
        target_sampled_image: Id,
        target_coordinates: Id,
        reference_sampled_image: Id,
        reference_coordinates: Id,
        block_size: Id,
    },
    ImageBlockMatchWindowSADQCOM {
        result_type_id: Id,
        result_id: Id,
        target_sampled_image: Id,
        target_coordinates: Id,
        reference_sampled_image: Id,
        reference_coordinates: Id,
        block_size: Id,
    },
    ImageBlockMatchGatherSSDQCOM {
        result_type_id: Id,
        result_id: Id,
        target_sampled_image: Id,
        target_coordinates: Id,
        reference_sampled_image: Id,
        reference_coordinates: Id,
        block_size: Id,
    },
    ImageBlockMatchGatherSADQCOM {
        result_type_id: Id,
        result_id: Id,
        target_sampled_image: Id,
        target_coordinates: Id,
        reference_sampled_image: Id,
        reference_coordinates: Id,
        block_size: Id,
    },
    GroupIAddNonUniformAMD {
        result_type_id: Id,
        result_id: Id,
        execution: Id,
        operation: GroupOperation,
        x: Id,
    },
    GroupFAddNonUniformAMD {
        result_type_id: Id,
        result_id: Id,
        execution: Id,
        operation: GroupOperation,
        x: Id,
    },
    GroupFMinNonUniformAMD {
        result_type_id: Id,
        result_id: Id,
        execution: Id,
        operation: GroupOperation,
        x: Id,
    },
    GroupUMinNonUniformAMD {
        result_type_id: Id,
        result_id: Id,
        execution: Id,
        operation: GroupOperation,
        x: Id,
    },
    GroupSMinNonUniformAMD {
        result_type_id: Id,
        result_id: Id,
        execution: Id,
        operation: GroupOperation,
        x: Id,
    },
    GroupFMaxNonUniformAMD {
        result_type_id: Id,
        result_id: Id,
        execution: Id,
        operation: GroupOperation,
        x: Id,
    },
    GroupUMaxNonUniformAMD {
        result_type_id: Id,
        result_id: Id,
        execution: Id,
        operation: GroupOperation,
        x: Id,
    },
    GroupSMaxNonUniformAMD {
        result_type_id: Id,
        result_id: Id,
        execution: Id,
        operation: GroupOperation,
        x: Id,
    },
    FragmentMaskFetchAMD {
        result_type_id: Id,
        result_id: Id,
        image: Id,
        coordinate: Id,
    },
    FragmentFetchAMD {
        result_type_id: Id,
        result_id: Id,
        image: Id,
        coordinate: Id,
        fragment_index: Id,
    },
    ReadClockKHR { result_type_id: Id, result_id: Id, scope: Id },
    FinalizeNodePayloadsAMDX { payload_array: Id },
    FinishWritingNodePayloadAMDX { result_type_id: Id, result_id: Id, payload: Id },
    InitializeNodePayloadsAMDX {
        payload_array: Id,
        visibility: Id,
        payload_count: Id,
        node_index: Id,
    },
    GroupNonUniformQuadAllKHR { result_type_id: Id, result_id: Id, predicate: Id },
    GroupNonUniformQuadAnyKHR { result_type_id: Id, result_id: Id, predicate: Id },
    HitObjectRecordHitMotionNV {
        hit_object: Id,
        acceleration_structure: Id,
        instance_id: Id,
        primitive_id: Id,
        geometry_index: Id,
        hit_kind: Id,
        sbt_record_offset: Id,
        sbt_record_stride: Id,
        origin: Id,
        t_min: Id,
        direction: Id,
        t_max: Id,
        current_time: Id,
        hit_object_attributes: Id,
    },
    HitObjectRecordHitWithIndexMotionNV {
        hit_object: Id,
        acceleration_structure: Id,
        instance_id: Id,
        primitive_id: Id,
        geometry_index: Id,
        hit_kind: Id,
        sbt_record_index: Id,
        origin: Id,
        t_min: Id,
        direction: Id,
        t_max: Id,
        current_time: Id,
        hit_object_attributes: Id,
    },
    HitObjectRecordMissMotionNV {
        hit_object: Id,
        sbt_index: Id,
        origin: Id,
        t_min: Id,
        direction: Id,
        t_max: Id,
        current_time: Id,
    },
    HitObjectGetWorldToObjectNV { result_type_id: Id, result_id: Id, hit_object: Id },
    HitObjectGetObjectToWorldNV { result_type_id: Id, result_id: Id, hit_object: Id },
    HitObjectGetObjectRayDirectionNV {
        result_type_id: Id,
        result_id: Id,
        hit_object: Id,
    },
    HitObjectGetObjectRayOriginNV { result_type_id: Id, result_id: Id, hit_object: Id },
    HitObjectTraceRayMotionNV {
        hit_object: Id,
        acceleration_structure: Id,
        ray_flags: Id,
        cullmask: Id,
        sbt_record_offset: Id,
        sbt_record_stride: Id,
        miss_index: Id,
        origin: Id,
        t_min: Id,
        direction: Id,
        t_max: Id,
        time: Id,
        payload: Id,
    },
    HitObjectGetShaderRecordBufferHandleNV {
        result_type_id: Id,
        result_id: Id,
        hit_object: Id,
    },
    HitObjectGetShaderBindingTableRecordIndexNV {
        result_type_id: Id,
        result_id: Id,
        hit_object: Id,
    },
    HitObjectRecordEmptyNV { hit_object: Id },
    HitObjectTraceRayNV {
        hit_object: Id,
        acceleration_structure: Id,
        ray_flags: Id,
        cullmask: Id,
        sbt_record_offset: Id,
        sbt_record_stride: Id,
        miss_index: Id,
        origin: Id,
        t_min: Id,
        direction: Id,
        t_max: Id,
        payload: Id,
    },
    HitObjectRecordHitNV {
        hit_object: Id,
        acceleration_structure: Id,
        instance_id: Id,
        primitive_id: Id,
        geometry_index: Id,
        hit_kind: Id,
        sbt_record_offset: Id,
        sbt_record_stride: Id,
        origin: Id,
        t_min: Id,
        direction: Id,
        t_max: Id,
        hit_object_attributes: Id,
    },
    HitObjectRecordHitWithIndexNV {
        hit_object: Id,
        acceleration_structure: Id,
        instance_id: Id,
        primitive_id: Id,
        geometry_index: Id,
        hit_kind: Id,
        sbt_record_index: Id,
        origin: Id,
        t_min: Id,
        direction: Id,
        t_max: Id,
        hit_object_attributes: Id,
    },
    HitObjectRecordMissNV {
        hit_object: Id,
        sbt_index: Id,
        origin: Id,
        t_min: Id,
        direction: Id,
        t_max: Id,
    },
    HitObjectExecuteShaderNV { hit_object: Id, payload: Id },
    HitObjectGetCurrentTimeNV { result_type_id: Id, result_id: Id, hit_object: Id },
    HitObjectGetAttributesNV { hit_object: Id, hit_object_attribute: Id },
    HitObjectGetHitKindNV { result_type_id: Id, result_id: Id, hit_object: Id },
    HitObjectGetPrimitiveIndexNV { result_type_id: Id, result_id: Id, hit_object: Id },
    HitObjectGetGeometryIndexNV { result_type_id: Id, result_id: Id, hit_object: Id },
    HitObjectGetInstanceIdNV { result_type_id: Id, result_id: Id, hit_object: Id },
    HitObjectGetInstanceCustomIndexNV {
        result_type_id: Id,
        result_id: Id,
        hit_object: Id,
    },
    HitObjectGetWorldRayDirectionNV {
        result_type_id: Id,
        result_id: Id,
        hit_object: Id,
    },
    HitObjectGetWorldRayOriginNV { result_type_id: Id, result_id: Id, hit_object: Id },
    HitObjectGetRayTMaxNV { result_type_id: Id, result_id: Id, hit_object: Id },
    HitObjectGetRayTMinNV { result_type_id: Id, result_id: Id, hit_object: Id },
    HitObjectIsEmptyNV { result_type_id: Id, result_id: Id, hit_object: Id },
    HitObjectIsHitNV { result_type_id: Id, result_id: Id, hit_object: Id },
    HitObjectIsMissNV { result_type_id: Id, result_id: Id, hit_object: Id },
    ReorderThreadWithHitObjectNV { hit_object: Id, hint: Option<Id>, bits: Option<Id> },
    ReorderThreadWithHintNV { hint: Id, bits: Id },
    TypeHitObjectNV { result_id: Id },
    ImageSampleFootprintNV {
        result_type_id: Id,
        result_id: Id,
        sampled_image: Id,
        coordinate: Id,
        granularity: Id,
        coarse: Id,
        image_operands: Option<ImageOperands>,
    },
    EmitMeshTasksEXT {
        group_count_x: Id,
        group_count_y: Id,
        group_count_z: Id,
        payload: Option<Id>,
    },
    SetMeshOutputsEXT { vertex_count: Id, primitive_count: Id },
    GroupNonUniformPartitionNV { result_type_id: Id, result_id: Id, value: Id },
    WritePackedPrimitiveIndices4x8NV { index_offset: Id, packed_indices: Id },
    FetchMicroTriangleVertexPositionNV {
        result_type_id: Id,
        result_id: Id,
        accel: Id,
        instance_id: Id,
        geometry_index: Id,
        primitive_index: Id,
        barycentric: Id,
    },
    FetchMicroTriangleVertexBarycentricNV {
        result_type_id: Id,
        result_id: Id,
        accel: Id,
        instance_id: Id,
        geometry_index: Id,
        primitive_index: Id,
        barycentric: Id,
    },
    ReportIntersectionKHR { result_type_id: Id, result_id: Id, hit: Id, hit_kind: Id },
    IgnoreIntersectionNV,
    TerminateRayNV,
    TraceNV {
        accel: Id,
        ray_flags: Id,
        cull_mask: Id,
        sbt_offset: Id,
        sbt_stride: Id,
        miss_index: Id,
        ray_origin: Id,
        ray_tmin: Id,
        ray_direction: Id,
        ray_tmax: Id,
        payload_id: Id,
    },
    TraceMotionNV {
        accel: Id,
        ray_flags: Id,
        cull_mask: Id,
        sbt_offset: Id,
        sbt_stride: Id,
        miss_index: Id,
        ray_origin: Id,
        ray_tmin: Id,
        ray_direction: Id,
        ray_tmax: Id,
        time: Id,
        payload_id: Id,
    },
    TraceRayMotionNV {
        accel: Id,
        ray_flags: Id,
        cull_mask: Id,
        sbt_offset: Id,
        sbt_stride: Id,
        miss_index: Id,
        ray_origin: Id,
        ray_tmin: Id,
        ray_direction: Id,
        ray_tmax: Id,
        time: Id,
        payload: Id,
    },
    RayQueryGetIntersectionTriangleVertexPositionsKHR {
        result_type_id: Id,
        result_id: Id,
        ray_query: Id,
        intersection: Id,
    },
    TypeAccelerationStructureKHR { result_id: Id },
    ExecuteCallableNV { sbt_index: Id, callable_data_id: Id },
    TypeCooperativeMatrixNV {
        result_id: Id,
        component_type: Id,
        execution: Id,
        rows: Id,
        columns: Id,
    },
    CooperativeMatrixLoadNV {
        result_type_id: Id,
        result_id: Id,
        pointer: Id,
        stride: Id,
        column_major: Id,
        memory_access: Option<MemoryAccess>,
    },
    CooperativeMatrixStoreNV {
        pointer: Id,
        object: Id,
        stride: Id,
        column_major: Id,
        memory_access: Option<MemoryAccess>,
    },
    CooperativeMatrixMulAddNV { result_type_id: Id, result_id: Id, a: Id, b: Id, c: Id },
    CooperativeMatrixLengthNV { result_type_id: Id, result_id: Id, ty: Id },
    BeginInvocationInterlockEXT,
    EndInvocationInterlockEXT,
    DemoteToHelperInvocation,
    IsHelperInvocationEXT { result_type_id: Id, result_id: Id },
    ConvertUToImageNV { result_type_id: Id, result_id: Id, operand: Id },
    ConvertUToSamplerNV { result_type_id: Id, result_id: Id, operand: Id },
    ConvertImageToUNV { result_type_id: Id, result_id: Id, operand: Id },
    ConvertSamplerToUNV { result_type_id: Id, result_id: Id, operand: Id },
    ConvertUToSampledImageNV { result_type_id: Id, result_id: Id, operand: Id },
    ConvertSampledImageToUNV { result_type_id: Id, result_id: Id, operand: Id },
    SamplerImageAddressingModeNV { bit_width: u32 },
    RawAccessChainNV {
        result_type_id: Id,
        result_id: Id,
        base: Id,
        byte_stride: Id,
        element_index: Id,
        byte_offset: Id,
        raw_access_chain_operands: Option<RawAccessChainOperands>,
    },
    SubgroupShuffleINTEL {
        result_type_id: Id,
        result_id: Id,
        data: Id,
        invocation_id: Id,
    },
    SubgroupShuffleDownINTEL {
        result_type_id: Id,
        result_id: Id,
        current: Id,
        next: Id,
        delta: Id,
    },
    SubgroupShuffleUpINTEL {
        result_type_id: Id,
        result_id: Id,
        previous: Id,
        current: Id,
        delta: Id,
    },
    SubgroupShuffleXorINTEL { result_type_id: Id, result_id: Id, data: Id, value: Id },
    SubgroupBlockReadINTEL { result_type_id: Id, result_id: Id, ptr: Id },
    SubgroupBlockWriteINTEL { ptr: Id, data: Id },
    SubgroupImageBlockReadINTEL {
        result_type_id: Id,
        result_id: Id,
        image: Id,
        coordinate: Id,
    },
    SubgroupImageBlockWriteINTEL { image: Id, coordinate: Id, data: Id },
    SubgroupImageMediaBlockReadINTEL {
        result_type_id: Id,
        result_id: Id,
        image: Id,
        coordinate: Id,
        width: Id,
        height: Id,
    },
    SubgroupImageMediaBlockWriteINTEL {
        image: Id,
        coordinate: Id,
        width: Id,
        height: Id,
        data: Id,
    },
    UCountLeadingZerosINTEL { result_type_id: Id, result_id: Id, operand: Id },
    UCountTrailingZerosINTEL { result_type_id: Id, result_id: Id, operand: Id },
    AbsISubINTEL { result_type_id: Id, result_id: Id, operand1: Id, operand2: Id },
    AbsUSubINTEL { result_type_id: Id, result_id: Id, operand1: Id, operand2: Id },
    IAddSatINTEL { result_type_id: Id, result_id: Id, operand1: Id, operand2: Id },
    UAddSatINTEL { result_type_id: Id, result_id: Id, operand1: Id, operand2: Id },
    IAverageINTEL { result_type_id: Id, result_id: Id, operand1: Id, operand2: Id },
    UAverageINTEL { result_type_id: Id, result_id: Id, operand1: Id, operand2: Id },
    IAverageRoundedINTEL {
        result_type_id: Id,
        result_id: Id,
        operand1: Id,
        operand2: Id,
    },
    UAverageRoundedINTEL {
        result_type_id: Id,
        result_id: Id,
        operand1: Id,
        operand2: Id,
    },
    ISubSatINTEL { result_type_id: Id, result_id: Id, operand1: Id, operand2: Id },
    USubSatINTEL { result_type_id: Id, result_id: Id, operand1: Id, operand2: Id },
    IMul32x16INTEL { result_type_id: Id, result_id: Id, operand1: Id, operand2: Id },
    UMul32x16INTEL { result_type_id: Id, result_id: Id, operand1: Id, operand2: Id },
    ConstantFunctionPointerINTEL { result_type_id: Id, result_id: Id, function: Id },
    FunctionPointerCallINTEL { result_type_id: Id, result_id: Id, operand1: Vec<Id> },
    AsmTargetINTEL { result_type_id: Id, result_id: Id, asm_target: String },
    AsmINTEL {
        result_type_id: Id,
        result_id: Id,
        asm_type: Id,
        target: Id,
        asm_instructions: String,
        constraints: String,
    },
    AsmCallINTEL { result_type_id: Id, result_id: Id, asm: Id, argument_0: Vec<Id> },
    AtomicFMinEXT {
        result_type_id: Id,
        result_id: Id,
        pointer: Id,
        memory: Id,
        semantics: Id,
        value: Id,
    },
    AtomicFMaxEXT {
        result_type_id: Id,
        result_id: Id,
        pointer: Id,
        memory: Id,
        semantics: Id,
        value: Id,
    },
    AssumeTrueKHR { condition: Id },
    ExpectKHR { result_type_id: Id, result_id: Id, value: Id, expected_value: Id },
    DecorateString { target: Id, decoration: Decoration },
    MemberDecorateString { struct_type: Id, member: u32, decoration: Decoration },
    VmeImageINTEL { result_type_id: Id, result_id: Id, image_type: Id, sampler: Id },
    TypeVmeImageINTEL { result_id: Id, image_type: Id },
    TypeAvcImePayloadINTEL { result_id: Id },
    TypeAvcRefPayloadINTEL { result_id: Id },
    TypeAvcSicPayloadINTEL { result_id: Id },
    TypeAvcMcePayloadINTEL { result_id: Id },
    TypeAvcMceResultINTEL { result_id: Id },
    TypeAvcImeResultINTEL { result_id: Id },
    TypeAvcImeResultSingleReferenceStreamoutINTEL { result_id: Id },
    TypeAvcImeResultDualReferenceStreamoutINTEL { result_id: Id },
    TypeAvcImeSingleReferenceStreaminINTEL { result_id: Id },
    TypeAvcImeDualReferenceStreaminINTEL { result_id: Id },
    TypeAvcRefResultINTEL { result_id: Id },
    TypeAvcSicResultINTEL { result_id: Id },
    SubgroupAvcMceGetDefaultInterBaseMultiReferencePenaltyINTEL {
        result_type_id: Id,
        result_id: Id,
        slice_type: Id,
        qp: Id,
    },
    SubgroupAvcMceSetInterBaseMultiReferencePenaltyINTEL {
        result_type_id: Id,
        result_id: Id,
        reference_base_penalty: Id,
        payload: Id,
    },
    SubgroupAvcMceGetDefaultInterShapePenaltyINTEL {
        result_type_id: Id,
        result_id: Id,
        slice_type: Id,
        qp: Id,
    },
    SubgroupAvcMceSetInterShapePenaltyINTEL {
        result_type_id: Id,
        result_id: Id,
        packed_shape_penalty: Id,
        payload: Id,
    },
    SubgroupAvcMceGetDefaultInterDirectionPenaltyINTEL {
        result_type_id: Id,
        result_id: Id,
        slice_type: Id,
        qp: Id,
    },
    SubgroupAvcMceSetInterDirectionPenaltyINTEL {
        result_type_id: Id,
        result_id: Id,
        direction_cost: Id,
        payload: Id,
    },
    SubgroupAvcMceGetDefaultIntraLumaShapePenaltyINTEL {
        result_type_id: Id,
        result_id: Id,
        slice_type: Id,
        qp: Id,
    },
    SubgroupAvcMceGetDefaultInterMotionVectorCostTableINTEL {
        result_type_id: Id,
        result_id: Id,
        slice_type: Id,
        qp: Id,
    },
    SubgroupAvcMceGetDefaultHighPenaltyCostTableINTEL {
        result_type_id: Id,
        result_id: Id,
    },
    SubgroupAvcMceGetDefaultMediumPenaltyCostTableINTEL {
        result_type_id: Id,
        result_id: Id,
    },
    SubgroupAvcMceGetDefaultLowPenaltyCostTableINTEL {
        result_type_id: Id,
        result_id: Id,
    },
    SubgroupAvcMceSetMotionVectorCostFunctionINTEL {
        result_type_id: Id,
        result_id: Id,
        packed_cost_center_delta: Id,
        packed_cost_table: Id,
        cost_precision: Id,
        payload: Id,
    },
    SubgroupAvcMceGetDefaultIntraLumaModePenaltyINTEL {
        result_type_id: Id,
        result_id: Id,
        slice_type: Id,
        qp: Id,
    },
    SubgroupAvcMceGetDefaultNonDcLumaIntraPenaltyINTEL {
        result_type_id: Id,
        result_id: Id,
    },
    SubgroupAvcMceGetDefaultIntraChromaModeBasePenaltyINTEL {
        result_type_id: Id,
        result_id: Id,
    },
    SubgroupAvcMceSetAcOnlyHaarINTEL { result_type_id: Id, result_id: Id, payload: Id },
    SubgroupAvcMceSetSourceInterlacedFieldPolarityINTEL {
        result_type_id: Id,
        result_id: Id,
        source_field_polarity: Id,
        payload: Id,
    },
    SubgroupAvcMceSetSingleReferenceInterlacedFieldPolarityINTEL {
        result_type_id: Id,
        result_id: Id,
        reference_field_polarity: Id,
        payload: Id,
    },
    SubgroupAvcMceSetDualReferenceInterlacedFieldPolaritiesINTEL {
        result_type_id: Id,
        result_id: Id,
        forward_reference_field_polarity: Id,
        backward_reference_field_polarity: Id,
        payload: Id,
    },
    SubgroupAvcMceConvertToImePayloadINTEL {
        result_type_id: Id,
        result_id: Id,
        payload: Id,
    },
    SubgroupAvcMceConvertToImeResultINTEL {
        result_type_id: Id,
        result_id: Id,
        payload: Id,
    },
    SubgroupAvcMceConvertToRefPayloadINTEL {
        result_type_id: Id,
        result_id: Id,
        payload: Id,
    },
    SubgroupAvcMceConvertToRefResultINTEL {
        result_type_id: Id,
        result_id: Id,
        payload: Id,
    },
    SubgroupAvcMceConvertToSicPayloadINTEL {
        result_type_id: Id,
        result_id: Id,
        payload: Id,
    },
    SubgroupAvcMceConvertToSicResultINTEL {
        result_type_id: Id,
        result_id: Id,
        payload: Id,
    },
    SubgroupAvcMceGetMotionVectorsINTEL {
        result_type_id: Id,
        result_id: Id,
        payload: Id,
    },
    SubgroupAvcMceGetInterDistortionsINTEL {
        result_type_id: Id,
        result_id: Id,
        payload: Id,
    },
    SubgroupAvcMceGetBestInterDistortionsINTEL {
        result_type_id: Id,
        result_id: Id,
        payload: Id,
    },
    SubgroupAvcMceGetInterMajorShapeINTEL {
        result_type_id: Id,
        result_id: Id,
        payload: Id,
    },
    SubgroupAvcMceGetInterMinorShapeINTEL {
        result_type_id: Id,
        result_id: Id,
        payload: Id,
    },
    SubgroupAvcMceGetInterDirectionsINTEL {
        result_type_id: Id,
        result_id: Id,
        payload: Id,
    },
    SubgroupAvcMceGetInterMotionVectorCountINTEL {
        result_type_id: Id,
        result_id: Id,
        payload: Id,
    },
    SubgroupAvcMceGetInterReferenceIdsINTEL {
        result_type_id: Id,
        result_id: Id,
        payload: Id,
    },
    SubgroupAvcMceGetInterReferenceInterlacedFieldPolaritiesINTEL {
        result_type_id: Id,
        result_id: Id,
        packed_reference_ids: Id,
        packed_reference_parameter_field_polarities: Id,
        payload: Id,
    },
    SubgroupAvcImeInitializeINTEL {
        result_type_id: Id,
        result_id: Id,
        src_coord: Id,
        partition_mask: Id,
        sad_adjustment: Id,
    },
    SubgroupAvcImeSetSingleReferenceINTEL {
        result_type_id: Id,
        result_id: Id,
        ref_offset: Id,
        search_window_config: Id,
        payload: Id,
    },
    SubgroupAvcImeSetDualReferenceINTEL {
        result_type_id: Id,
        result_id: Id,
        fwd_ref_offset: Id,
        bwd_ref_offset: Id,
        id_search_window_config: Id,
        payload: Id,
    },
    SubgroupAvcImeRefWindowSizeINTEL {
        result_type_id: Id,
        result_id: Id,
        search_window_config: Id,
        dual_ref: Id,
    },
    SubgroupAvcImeAdjustRefOffsetINTEL {
        result_type_id: Id,
        result_id: Id,
        ref_offset: Id,
        src_coord: Id,
        ref_window_size: Id,
        image_size: Id,
    },
    SubgroupAvcImeConvertToMcePayloadINTEL {
        result_type_id: Id,
        result_id: Id,
        payload: Id,
    },
    SubgroupAvcImeSetMaxMotionVectorCountINTEL {
        result_type_id: Id,
        result_id: Id,
        max_motion_vector_count: Id,
        payload: Id,
    },
    SubgroupAvcImeSetUnidirectionalMixDisableINTEL {
        result_type_id: Id,
        result_id: Id,
        payload: Id,
    },
    SubgroupAvcImeSetEarlySearchTerminationThresholdINTEL {
        result_type_id: Id,
        result_id: Id,
        threshold: Id,
        payload: Id,
    },
    SubgroupAvcImeSetWeightedSadINTEL {
        result_type_id: Id,
        result_id: Id,
        packed_sad_weights: Id,
        payload: Id,
    },
    SubgroupAvcImeEvaluateWithSingleReferenceINTEL {
        result_type_id: Id,
        result_id: Id,
        src_image: Id,
        ref_image: Id,
        payload: Id,
    },
    SubgroupAvcImeEvaluateWithDualReferenceINTEL {
        result_type_id: Id,
        result_id: Id,
        src_image: Id,
        fwd_ref_image: Id,
        bwd_ref_image: Id,
        payload: Id,
    },
    SubgroupAvcImeEvaluateWithSingleReferenceStreaminINTEL {
        result_type_id: Id,
        result_id: Id,
        src_image: Id,
        ref_image: Id,
        payload: Id,
        streamin_components: Id,
    },
    SubgroupAvcImeEvaluateWithDualReferenceStreaminINTEL {
        result_type_id: Id,
        result_id: Id,
        src_image: Id,
        fwd_ref_image: Id,
        bwd_ref_image: Id,
        payload: Id,
        streamin_components: Id,
    },
    SubgroupAvcImeEvaluateWithSingleReferenceStreamoutINTEL {
        result_type_id: Id,
        result_id: Id,
        src_image: Id,
        ref_image: Id,
        payload: Id,
    },
    SubgroupAvcImeEvaluateWithDualReferenceStreamoutINTEL {
        result_type_id: Id,
        result_id: Id,
        src_image: Id,
        fwd_ref_image: Id,
        bwd_ref_image: Id,
        payload: Id,
    },
    SubgroupAvcImeEvaluateWithSingleReferenceStreaminoutINTEL {
        result_type_id: Id,
        result_id: Id,
        src_image: Id,
        ref_image: Id,
        payload: Id,
        streamin_components: Id,
    },
    SubgroupAvcImeEvaluateWithDualReferenceStreaminoutINTEL {
        result_type_id: Id,
        result_id: Id,
        src_image: Id,
        fwd_ref_image: Id,
        bwd_ref_image: Id,
        payload: Id,
        streamin_components: Id,
    },
    SubgroupAvcImeConvertToMceResultINTEL {
        result_type_id: Id,
        result_id: Id,
        payload: Id,
    },
    SubgroupAvcImeGetSingleReferenceStreaminINTEL {
        result_type_id: Id,
        result_id: Id,
        payload: Id,
    },
    SubgroupAvcImeGetDualReferenceStreaminINTEL {
        result_type_id: Id,
        result_id: Id,
        payload: Id,
    },
    SubgroupAvcImeStripSingleReferenceStreamoutINTEL {
        result_type_id: Id,
        result_id: Id,
        payload: Id,
    },
    SubgroupAvcImeStripDualReferenceStreamoutINTEL {
        result_type_id: Id,
        result_id: Id,
        payload: Id,
    },
    SubgroupAvcImeGetStreamoutSingleReferenceMajorShapeMotionVectorsINTEL {
        result_type_id: Id,
        result_id: Id,
        payload: Id,
        major_shape: Id,
    },
    SubgroupAvcImeGetStreamoutSingleReferenceMajorShapeDistortionsINTEL {
        result_type_id: Id,
        result_id: Id,
        payload: Id,
        major_shape: Id,
    },
    SubgroupAvcImeGetStreamoutSingleReferenceMajorShapeReferenceIdsINTEL {
        result_type_id: Id,
        result_id: Id,
        payload: Id,
        major_shape: Id,
    },
    SubgroupAvcImeGetStreamoutDualReferenceMajorShapeMotionVectorsINTEL {
        result_type_id: Id,
        result_id: Id,
        payload: Id,
        major_shape: Id,
        direction: Id,
    },
    SubgroupAvcImeGetStreamoutDualReferenceMajorShapeDistortionsINTEL {
        result_type_id: Id,
        result_id: Id,
        payload: Id,
        major_shape: Id,
        direction: Id,
    },
    SubgroupAvcImeGetStreamoutDualReferenceMajorShapeReferenceIdsINTEL {
        result_type_id: Id,
        result_id: Id,
        payload: Id,
        major_shape: Id,
        direction: Id,
    },
    SubgroupAvcImeGetBorderReachedINTEL {
        result_type_id: Id,
        result_id: Id,
        image_select: Id,
        payload: Id,
    },
    SubgroupAvcImeGetTruncatedSearchIndicationINTEL {
        result_type_id: Id,
        result_id: Id,
        payload: Id,
    },
    SubgroupAvcImeGetUnidirectionalEarlySearchTerminationINTEL {
        result_type_id: Id,
        result_id: Id,
        payload: Id,
    },
    SubgroupAvcImeGetWeightingPatternMinimumMotionVectorINTEL {
        result_type_id: Id,
        result_id: Id,
        payload: Id,
    },
    SubgroupAvcImeGetWeightingPatternMinimumDistortionINTEL {
        result_type_id: Id,
        result_id: Id,
        payload: Id,
    },
    SubgroupAvcFmeInitializeINTEL {
        result_type_id: Id,
        result_id: Id,
        src_coord: Id,
        motion_vectors: Id,
        major_shapes: Id,
        minor_shapes: Id,
        direction: Id,
        pixel_resolution: Id,
        sad_adjustment: Id,
    },
    SubgroupAvcBmeInitializeINTEL {
        result_type_id: Id,
        result_id: Id,
        src_coord: Id,
        motion_vectors: Id,
        major_shapes: Id,
        minor_shapes: Id,
        direction: Id,
        pixel_resolution: Id,
        bidirectional_weight: Id,
        sad_adjustment: Id,
    },
    SubgroupAvcRefConvertToMcePayloadINTEL {
        result_type_id: Id,
        result_id: Id,
        payload: Id,
    },
    SubgroupAvcRefSetBidirectionalMixDisableINTEL {
        result_type_id: Id,
        result_id: Id,
        payload: Id,
    },
    SubgroupAvcRefSetBilinearFilterEnableINTEL {
        result_type_id: Id,
        result_id: Id,
        payload: Id,
    },
    SubgroupAvcRefEvaluateWithSingleReferenceINTEL {
        result_type_id: Id,
        result_id: Id,
        src_image: Id,
        ref_image: Id,
        payload: Id,
    },
    SubgroupAvcRefEvaluateWithDualReferenceINTEL {
        result_type_id: Id,
        result_id: Id,
        src_image: Id,
        fwd_ref_image: Id,
        bwd_ref_image: Id,
        payload: Id,
    },
    SubgroupAvcRefEvaluateWithMultiReferenceINTEL {
        result_type_id: Id,
        result_id: Id,
        src_image: Id,
        packed_reference_ids: Id,
        payload: Id,
    },
    SubgroupAvcRefEvaluateWithMultiReferenceInterlacedINTEL {
        result_type_id: Id,
        result_id: Id,
        src_image: Id,
        packed_reference_ids: Id,
        packed_reference_field_polarities: Id,
        payload: Id,
    },
    SubgroupAvcRefConvertToMceResultINTEL {
        result_type_id: Id,
        result_id: Id,
        payload: Id,
    },
    SubgroupAvcSicInitializeINTEL { result_type_id: Id, result_id: Id, src_coord: Id },
    SubgroupAvcSicConfigureSkcINTEL {
        result_type_id: Id,
        result_id: Id,
        skip_block_partition_type: Id,
        skip_motion_vector_mask: Id,
        motion_vectors: Id,
        bidirectional_weight: Id,
        sad_adjustment: Id,
        payload: Id,
    },
    SubgroupAvcSicConfigureIpeLumaINTEL {
        result_type_id: Id,
        result_id: Id,
        luma_intra_partition_mask: Id,
        intra_neighbour_availabilty: Id,
        left_edge_luma_pixels: Id,
        upper_left_corner_luma_pixel: Id,
        upper_edge_luma_pixels: Id,
        upper_right_edge_luma_pixels: Id,
        sad_adjustment: Id,
        payload: Id,
    },
    SubgroupAvcSicConfigureIpeLumaChromaINTEL {
        result_type_id: Id,
        result_id: Id,
        luma_intra_partition_mask: Id,
        intra_neighbour_availabilty: Id,
        left_edge_luma_pixels: Id,
        upper_left_corner_luma_pixel: Id,
        upper_edge_luma_pixels: Id,
        upper_right_edge_luma_pixels: Id,
        left_edge_chroma_pixels: Id,
        upper_left_corner_chroma_pixel: Id,
        upper_edge_chroma_pixels: Id,
        sad_adjustment: Id,
        payload: Id,
    },
    SubgroupAvcSicGetMotionVectorMaskINTEL {
        result_type_id: Id,
        result_id: Id,
        skip_block_partition_type: Id,
        direction: Id,
    },
    SubgroupAvcSicConvertToMcePayloadINTEL {
        result_type_id: Id,
        result_id: Id,
        payload: Id,
    },
    SubgroupAvcSicSetIntraLumaShapePenaltyINTEL {
        result_type_id: Id,
        result_id: Id,
        packed_shape_penalty: Id,
        payload: Id,
    },
    SubgroupAvcSicSetIntraLumaModeCostFunctionINTEL {
        result_type_id: Id,
        result_id: Id,
        luma_mode_penalty: Id,
        luma_packed_neighbor_modes: Id,
        luma_packed_non_dc_penalty: Id,
        payload: Id,
    },
    SubgroupAvcSicSetIntraChromaModeCostFunctionINTEL {
        result_type_id: Id,
        result_id: Id,
        chroma_mode_base_penalty: Id,
        payload: Id,
    },
    SubgroupAvcSicSetBilinearFilterEnableINTEL {
        result_type_id: Id,
        result_id: Id,
        payload: Id,
    },
    SubgroupAvcSicSetSkcForwardTransformEnableINTEL {
        result_type_id: Id,
        result_id: Id,
        packed_sad_coefficients: Id,
        payload: Id,
    },
    SubgroupAvcSicSetBlockBasedRawSkipSadINTEL {
        result_type_id: Id,
        result_id: Id,
        block_based_skip_type: Id,
        payload: Id,
    },
    SubgroupAvcSicEvaluateIpeINTEL {
        result_type_id: Id,
        result_id: Id,
        src_image: Id,
        payload: Id,
    },
    SubgroupAvcSicEvaluateWithSingleReferenceINTEL {
        result_type_id: Id,
        result_id: Id,
        src_image: Id,
        ref_image: Id,
        payload: Id,
    },
    SubgroupAvcSicEvaluateWithDualReferenceINTEL {
        result_type_id: Id,
        result_id: Id,
        src_image: Id,
        fwd_ref_image: Id,
        bwd_ref_image: Id,
        payload: Id,
    },
    SubgroupAvcSicEvaluateWithMultiReferenceINTEL {
        result_type_id: Id,
        result_id: Id,
        src_image: Id,
        packed_reference_ids: Id,
        payload: Id,
    },
    SubgroupAvcSicEvaluateWithMultiReferenceInterlacedINTEL {
        result_type_id: Id,
        result_id: Id,
        src_image: Id,
        packed_reference_ids: Id,
        packed_reference_field_polarities: Id,
        payload: Id,
    },
    SubgroupAvcSicConvertToMceResultINTEL {
        result_type_id: Id,
        result_id: Id,
        payload: Id,
    },
    SubgroupAvcSicGetIpeLumaShapeINTEL {
        result_type_id: Id,
        result_id: Id,
        payload: Id,
    },
    SubgroupAvcSicGetBestIpeLumaDistortionINTEL {
        result_type_id: Id,
        result_id: Id,
        payload: Id,
    },
    SubgroupAvcSicGetBestIpeChromaDistortionINTEL {
        result_type_id: Id,
        result_id: Id,
        payload: Id,
    },
    SubgroupAvcSicGetPackedIpeLumaModesINTEL {
        result_type_id: Id,
        result_id: Id,
        payload: Id,
    },
    SubgroupAvcSicGetIpeChromaModeINTEL {
        result_type_id: Id,
        result_id: Id,
        payload: Id,
    },
    SubgroupAvcSicGetPackedSkcLumaCountThresholdINTEL {
        result_type_id: Id,
        result_id: Id,
        payload: Id,
    },
    SubgroupAvcSicGetPackedSkcLumaSumThresholdINTEL {
        result_type_id: Id,
        result_id: Id,
        payload: Id,
    },
    SubgroupAvcSicGetInterRawSadsINTEL {
        result_type_id: Id,
        result_id: Id,
        payload: Id,
    },
    VariableLengthArrayINTEL { result_type_id: Id, result_id: Id, lenght: Id },
    SaveMemoryINTEL { result_type_id: Id, result_id: Id },
    RestoreMemoryINTEL { ptr: Id },
    ArbitraryFloatSinCosPiINTEL {
        result_type_id: Id,
        result_id: Id,
        a: Id,
        m1: u32,
        mout: u32,
        from_sign: u32,
        enable_subnormals: u32,
        rounding_mode: u32,
        rounding_accuracy: u32,
    },
    ArbitraryFloatCastINTEL {
        result_type_id: Id,
        result_id: Id,
        a: Id,
        m1: u32,
        mout: u32,
        enable_subnormals: u32,
        rounding_mode: u32,
        rounding_accuracy: u32,
    },
    ArbitraryFloatCastFromIntINTEL {
        result_type_id: Id,
        result_id: Id,
        a: Id,
        mout: u32,
        from_sign: u32,
        enable_subnormals: u32,
        rounding_mode: u32,
        rounding_accuracy: u32,
    },
    ArbitraryFloatCastToIntINTEL {
        result_type_id: Id,
        result_id: Id,
        a: Id,
        m1: u32,
        enable_subnormals: u32,
        rounding_mode: u32,
        rounding_accuracy: u32,
    },
    ArbitraryFloatAddINTEL {
        result_type_id: Id,
        result_id: Id,
        a: Id,
        m1: u32,
        b: Id,
        m2: u32,
        mout: u32,
        enable_subnormals: u32,
        rounding_mode: u32,
        rounding_accuracy: u32,
    },
    ArbitraryFloatSubINTEL {
        result_type_id: Id,
        result_id: Id,
        a: Id,
        m1: u32,
        b: Id,
        m2: u32,
        mout: u32,
        enable_subnormals: u32,
        rounding_mode: u32,
        rounding_accuracy: u32,
    },
    ArbitraryFloatMulINTEL {
        result_type_id: Id,
        result_id: Id,
        a: Id,
        m1: u32,
        b: Id,
        m2: u32,
        mout: u32,
        enable_subnormals: u32,
        rounding_mode: u32,
        rounding_accuracy: u32,
    },
    ArbitraryFloatDivINTEL {
        result_type_id: Id,
        result_id: Id,
        a: Id,
        m1: u32,
        b: Id,
        m2: u32,
        mout: u32,
        enable_subnormals: u32,
        rounding_mode: u32,
        rounding_accuracy: u32,
    },
    ArbitraryFloatGTINTEL {
        result_type_id: Id,
        result_id: Id,
        a: Id,
        m1: u32,
        b: Id,
        m2: u32,
    },
    ArbitraryFloatGEINTEL {
        result_type_id: Id,
        result_id: Id,
        a: Id,
        m1: u32,
        b: Id,
        m2: u32,
    },
    ArbitraryFloatLTINTEL {
        result_type_id: Id,
        result_id: Id,
        a: Id,
        m1: u32,
        b: Id,
        m2: u32,
    },
    ArbitraryFloatLEINTEL {
        result_type_id: Id,
        result_id: Id,
        a: Id,
        m1: u32,
        b: Id,
        m2: u32,
    },
    ArbitraryFloatEQINTEL {
        result_type_id: Id,
        result_id: Id,
        a: Id,
        m1: u32,
        b: Id,
        m2: u32,
    },
    ArbitraryFloatRecipINTEL {
        result_type_id: Id,
        result_id: Id,
        a: Id,
        m1: u32,
        mout: u32,
        enable_subnormals: u32,
        rounding_mode: u32,
        rounding_accuracy: u32,
    },
    ArbitraryFloatRSqrtINTEL {
        result_type_id: Id,
        result_id: Id,
        a: Id,
        m1: u32,
        mout: u32,
        enable_subnormals: u32,
        rounding_mode: u32,
        rounding_accuracy: u32,
    },
    ArbitraryFloatCbrtINTEL {
        result_type_id: Id,
        result_id: Id,
        a: Id,
        m1: u32,
        mout: u32,
        enable_subnormals: u32,
        rounding_mode: u32,
        rounding_accuracy: u32,
    },
    ArbitraryFloatHypotINTEL {
        result_type_id: Id,
        result_id: Id,
        a: Id,
        m1: u32,
        b: Id,
        m2: u32,
        mout: u32,
        enable_subnormals: u32,
        rounding_mode: u32,
        rounding_accuracy: u32,
    },
    ArbitraryFloatSqrtINTEL {
        result_type_id: Id,
        result_id: Id,
        a: Id,
        m1: u32,
        mout: u32,
        enable_subnormals: u32,
        rounding_mode: u32,
        rounding_accuracy: u32,
    },
    ArbitraryFloatLogINTEL {
        result_type_id: Id,
        result_id: Id,
        a: Id,
        m1: u32,
        mout: u32,
        enable_subnormals: u32,
        rounding_mode: u32,
        rounding_accuracy: u32,
    },
    ArbitraryFloatLog2INTEL {
        result_type_id: Id,
        result_id: Id,
        a: Id,
        m1: u32,
        mout: u32,
        enable_subnormals: u32,
        rounding_mode: u32,
        rounding_accuracy: u32,
    },
    ArbitraryFloatLog10INTEL {
        result_type_id: Id,
        result_id: Id,
        a: Id,
        m1: u32,
        mout: u32,
        enable_subnormals: u32,
        rounding_mode: u32,
        rounding_accuracy: u32,
    },
    ArbitraryFloatLog1pINTEL {
        result_type_id: Id,
        result_id: Id,
        a: Id,
        m1: u32,
        mout: u32,
        enable_subnormals: u32,
        rounding_mode: u32,
        rounding_accuracy: u32,
    },
    ArbitraryFloatExpINTEL {
        result_type_id: Id,
        result_id: Id,
        a: Id,
        m1: u32,
        mout: u32,
        enable_subnormals: u32,
        rounding_mode: u32,
        rounding_accuracy: u32,
    },
    ArbitraryFloatExp2INTEL {
        result_type_id: Id,
        result_id: Id,
        a: Id,
        m1: u32,
        mout: u32,
        enable_subnormals: u32,
        rounding_mode: u32,
        rounding_accuracy: u32,
    },
    ArbitraryFloatExp10INTEL {
        result_type_id: Id,
        result_id: Id,
        a: Id,
        m1: u32,
        mout: u32,
        enable_subnormals: u32,
        rounding_mode: u32,
        rounding_accuracy: u32,
    },
    ArbitraryFloatExpm1INTEL {
        result_type_id: Id,
        result_id: Id,
        a: Id,
        m1: u32,
        mout: u32,
        enable_subnormals: u32,
        rounding_mode: u32,
        rounding_accuracy: u32,
    },
    ArbitraryFloatSinINTEL {
        result_type_id: Id,
        result_id: Id,
        a: Id,
        m1: u32,
        mout: u32,
        enable_subnormals: u32,
        rounding_mode: u32,
        rounding_accuracy: u32,
    },
    ArbitraryFloatCosINTEL {
        result_type_id: Id,
        result_id: Id,
        a: Id,
        m1: u32,
        mout: u32,
        enable_subnormals: u32,
        rounding_mode: u32,
        rounding_accuracy: u32,
    },
    ArbitraryFloatSinCosINTEL {
        result_type_id: Id,
        result_id: Id,
        a: Id,
        m1: u32,
        mout: u32,
        enable_subnormals: u32,
        rounding_mode: u32,
        rounding_accuracy: u32,
    },
    ArbitraryFloatSinPiINTEL {
        result_type_id: Id,
        result_id: Id,
        a: Id,
        m1: u32,
        mout: u32,
        enable_subnormals: u32,
        rounding_mode: u32,
        rounding_accuracy: u32,
    },
    ArbitraryFloatCosPiINTEL {
        result_type_id: Id,
        result_id: Id,
        a: Id,
        m1: u32,
        mout: u32,
        enable_subnormals: u32,
        rounding_mode: u32,
        rounding_accuracy: u32,
    },
    ArbitraryFloatASinINTEL {
        result_type_id: Id,
        result_id: Id,
        a: Id,
        m1: u32,
        mout: u32,
        enable_subnormals: u32,
        rounding_mode: u32,
        rounding_accuracy: u32,
    },
    ArbitraryFloatASinPiINTEL {
        result_type_id: Id,
        result_id: Id,
        a: Id,
        m1: u32,
        mout: u32,
        enable_subnormals: u32,
        rounding_mode: u32,
        rounding_accuracy: u32,
    },
    ArbitraryFloatACosINTEL {
        result_type_id: Id,
        result_id: Id,
        a: Id,
        m1: u32,
        mout: u32,
        enable_subnormals: u32,
        rounding_mode: u32,
        rounding_accuracy: u32,
    },
    ArbitraryFloatACosPiINTEL {
        result_type_id: Id,
        result_id: Id,
        a: Id,
        m1: u32,
        mout: u32,
        enable_subnormals: u32,
        rounding_mode: u32,
        rounding_accuracy: u32,
    },
    ArbitraryFloatATanINTEL {
        result_type_id: Id,
        result_id: Id,
        a: Id,
        m1: u32,
        mout: u32,
        enable_subnormals: u32,
        rounding_mode: u32,
        rounding_accuracy: u32,
    },
    ArbitraryFloatATanPiINTEL {
        result_type_id: Id,
        result_id: Id,
        a: Id,
        m1: u32,
        mout: u32,
        enable_subnormals: u32,
        rounding_mode: u32,
        rounding_accuracy: u32,
    },
    ArbitraryFloatATan2INTEL {
        result_type_id: Id,
        result_id: Id,
        a: Id,
        m1: u32,
        b: Id,
        m2: u32,
        mout: u32,
        enable_subnormals: u32,
        rounding_mode: u32,
        rounding_accuracy: u32,
    },
    ArbitraryFloatPowINTEL {
        result_type_id: Id,
        result_id: Id,
        a: Id,
        m1: u32,
        b: Id,
        m2: u32,
        mout: u32,
        enable_subnormals: u32,
        rounding_mode: u32,
        rounding_accuracy: u32,
    },
    ArbitraryFloatPowRINTEL {
        result_type_id: Id,
        result_id: Id,
        a: Id,
        m1: u32,
        b: Id,
        m2: u32,
        mout: u32,
        enable_subnormals: u32,
        rounding_mode: u32,
        rounding_accuracy: u32,
    },
    ArbitraryFloatPowNINTEL {
        result_type_id: Id,
        result_id: Id,
        a: Id,
        m1: u32,
        b: Id,
        mout: u32,
        enable_subnormals: u32,
        rounding_mode: u32,
        rounding_accuracy: u32,
    },
    LoopControlINTEL { loop_control_parameters: Vec<u32> },
    AliasDomainDeclINTEL { result_id: Id, name: Option<Id> },
    AliasScopeDeclINTEL { result_id: Id, alias_domain: Id, name: Option<Id> },
    AliasScopeListDeclINTEL { result_id: Id, alias_scope1_alias_scope2: Vec<Id> },
    FixedSqrtINTEL {
        result_type_id: Id,
        result_id: Id,
        input_type: Id,
        input: Id,
        s: u32,
        i: u32,
        r_i: u32,
        q: u32,
        o: u32,
    },
    FixedRecipINTEL {
        result_type_id: Id,
        result_id: Id,
        input_type: Id,
        input: Id,
        s: u32,
        i: u32,
        r_i: u32,
        q: u32,
        o: u32,
    },
    FixedRsqrtINTEL {
        result_type_id: Id,
        result_id: Id,
        input_type: Id,
        input: Id,
        s: u32,
        i: u32,
        r_i: u32,
        q: u32,
        o: u32,
    },
    FixedSinINTEL {
        result_type_id: Id,
        result_id: Id,
        input_type: Id,
        input: Id,
        s: u32,
        i: u32,
        r_i: u32,
        q: u32,
        o: u32,
    },
    FixedCosINTEL {
        result_type_id: Id,
        result_id: Id,
        input_type: Id,
        input: Id,
        s: u32,
        i: u32,
        r_i: u32,
        q: u32,
        o: u32,
    },
    FixedSinCosINTEL {
        result_type_id: Id,
        result_id: Id,
        input_type: Id,
        input: Id,
        s: u32,
        i: u32,
        r_i: u32,
        q: u32,
        o: u32,
    },
    FixedSinPiINTEL {
        result_type_id: Id,
        result_id: Id,
        input_type: Id,
        input: Id,
        s: u32,
        i: u32,
        r_i: u32,
        q: u32,
        o: u32,
    },
    FixedCosPiINTEL {
        result_type_id: Id,
        result_id: Id,
        input_type: Id,
        input: Id,
        s: u32,
        i: u32,
        r_i: u32,
        q: u32,
        o: u32,
    },
    FixedSinCosPiINTEL {
        result_type_id: Id,
        result_id: Id,
        input_type: Id,
        input: Id,
        s: u32,
        i: u32,
        r_i: u32,
        q: u32,
        o: u32,
    },
    FixedLogINTEL {
        result_type_id: Id,
        result_id: Id,
        input_type: Id,
        input: Id,
        s: u32,
        i: u32,
        r_i: u32,
        q: u32,
        o: u32,
    },
    FixedExpINTEL {
        result_type_id: Id,
        result_id: Id,
        input_type: Id,
        input: Id,
        s: u32,
        i: u32,
        r_i: u32,
        q: u32,
        o: u32,
    },
    PtrCastToCrossWorkgroupINTEL { result_type_id: Id, result_id: Id, pointer: Id },
    CrossWorkgroupCastToPtrINTEL { result_type_id: Id, result_id: Id, pointer: Id },
    ReadPipeBlockingINTEL {
        result_type_id: Id,
        result_id: Id,
        packet_size: Id,
        packet_alignment: Id,
    },
    WritePipeBlockingINTEL {
        result_type_id: Id,
        result_id: Id,
        packet_size: Id,
        packet_alignment: Id,
    },
    FPGARegINTEL { result_type_id: Id, result_id: Id, result: Id, input: Id },
    RayQueryGetRayTMinKHR { result_type_id: Id, result_id: Id, ray_query: Id },
    RayQueryGetRayFlagsKHR { result_type_id: Id, result_id: Id, ray_query: Id },
    RayQueryGetIntersectionTKHR {
        result_type_id: Id,
        result_id: Id,
        ray_query: Id,
        intersection: Id,
    },
    RayQueryGetIntersectionInstanceCustomIndexKHR {
        result_type_id: Id,
        result_id: Id,
        ray_query: Id,
        intersection: Id,
    },
    RayQueryGetIntersectionInstanceIdKHR {
        result_type_id: Id,
        result_id: Id,
        ray_query: Id,
        intersection: Id,
    },
    RayQueryGetIntersectionInstanceShaderBindingTableRecordOffsetKHR {
        result_type_id: Id,
        result_id: Id,
        ray_query: Id,
        intersection: Id,
    },
    RayQueryGetIntersectionGeometryIndexKHR {
        result_type_id: Id,
        result_id: Id,
        ray_query: Id,
        intersection: Id,
    },
    RayQueryGetIntersectionPrimitiveIndexKHR {
        result_type_id: Id,
        result_id: Id,
        ray_query: Id,
        intersection: Id,
    },
    RayQueryGetIntersectionBarycentricsKHR {
        result_type_id: Id,
        result_id: Id,
        ray_query: Id,
        intersection: Id,
    },
    RayQueryGetIntersectionFrontFaceKHR {
        result_type_id: Id,
        result_id: Id,
        ray_query: Id,
        intersection: Id,
    },
    RayQueryGetIntersectionCandidateAABBOpaqueKHR {
        result_type_id: Id,
        result_id: Id,
        ray_query: Id,
    },
    RayQueryGetIntersectionObjectRayDirectionKHR {
        result_type_id: Id,
        result_id: Id,
        ray_query: Id,
        intersection: Id,
    },
    RayQueryGetIntersectionObjectRayOriginKHR {
        result_type_id: Id,
        result_id: Id,
        ray_query: Id,
        intersection: Id,
    },
    RayQueryGetWorldRayDirectionKHR { result_type_id: Id, result_id: Id, ray_query: Id },
    RayQueryGetWorldRayOriginKHR { result_type_id: Id, result_id: Id, ray_query: Id },
    RayQueryGetIntersectionObjectToWorldKHR {
        result_type_id: Id,
        result_id: Id,
        ray_query: Id,
        intersection: Id,
    },
    RayQueryGetIntersectionWorldToObjectKHR {
        result_type_id: Id,
        result_id: Id,
        ray_query: Id,
        intersection: Id,
    },
    AtomicFAddEXT {
        result_type_id: Id,
        result_id: Id,
        pointer: Id,
        memory: Id,
        semantics: Id,
        value: Id,
    },
    TypeBufferSurfaceINTEL { result_id: Id, access_qualifier: AccessQualifier },
    TypeStructContinuedINTEL { member_types: Vec<Id> },
    ConstantCompositeContinuedINTEL { constituents: Vec<Id> },
    SpecConstantCompositeContinuedINTEL { constituents: Vec<Id> },
    CompositeConstructContinuedINTEL {
        result_type_id: Id,
        result_id: Id,
        constituents: Vec<Id>,
    },
    ConvertFToBF16INTEL { result_type_id: Id, result_id: Id, float_value: Id },
    ConvertBF16ToFINTEL { result_type_id: Id, result_id: Id, b_float16_value: Id },
    ControlBarrierArriveINTEL { execution: Id, memory: Id, semantics: Id },
    ControlBarrierWaitINTEL { execution: Id, memory: Id, semantics: Id },
    GroupIMulKHR {
        result_type_id: Id,
        result_id: Id,
        execution: Id,
        operation: GroupOperation,
        x: Id,
    },
    GroupFMulKHR {
        result_type_id: Id,
        result_id: Id,
        execution: Id,
        operation: GroupOperation,
        x: Id,
    },
    GroupBitwiseAndKHR {
        result_type_id: Id,
        result_id: Id,
        execution: Id,
        operation: GroupOperation,
        x: Id,
    },
    GroupBitwiseOrKHR {
        result_type_id: Id,
        result_id: Id,
        execution: Id,
        operation: GroupOperation,
        x: Id,
    },
    GroupBitwiseXorKHR {
        result_type_id: Id,
        result_id: Id,
        execution: Id,
        operation: GroupOperation,
        x: Id,
    },
    GroupLogicalAndKHR {
        result_type_id: Id,
        result_id: Id,
        execution: Id,
        operation: GroupOperation,
        x: Id,
    },
    GroupLogicalOrKHR {
        result_type_id: Id,
        result_id: Id,
        execution: Id,
        operation: GroupOperation,
        x: Id,
    },
    GroupLogicalXorKHR {
        result_type_id: Id,
        result_id: Id,
        execution: Id,
        operation: GroupOperation,
        x: Id,
    },
    MaskedGatherINTEL {
        result_type_id: Id,
        result_id: Id,
        ptr_vector: Id,
        alignment: u32,
        mask: Id,
        fill_empty: Id,
    },
    MaskedScatterINTEL { input_vector: Id, ptr_vector: Id, alignment: u32, mask: Id },
}
impl Instruction {
    #[allow(dead_code)]
    fn parse(reader: &mut InstructionReader<'_>) -> Result<Self, ParseError> {
        let opcode = (reader.next_word()? & 0xffff) as u16;
        Ok(
            match opcode {
                0u16 => Self::Nop,
                1u16 => {
                    Self::Undef {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                    }
                }
                2u16 => {
                    Self::SourceContinued {
                        continued_source: reader.next_string()?,
                    }
                }
                3u16 => {
                    Self::Source {
                        source_language: SourceLanguage::parse(reader)?,
                        version: reader.next_word()?,
                        file: if !reader.is_empty() {
                            Some(Id(reader.next_word()?))
                        } else {
                            None
                        },
                        source: if !reader.is_empty() {
                            Some(reader.next_string()?)
                        } else {
                            None
                        },
                    }
                }
                4u16 => {
                    Self::SourceExtension {
                        extension: reader.next_string()?,
                    }
                }
                5u16 => {
                    Self::Name {
                        target: Id(reader.next_word()?),
                        name: reader.next_string()?,
                    }
                }
                6u16 => {
                    Self::MemberName {
                        ty: Id(reader.next_word()?),
                        member: reader.next_word()?,
                        name: reader.next_string()?,
                    }
                }
                7u16 => {
                    Self::String {
                        result_id: Id(reader.next_word()?),
                        string: reader.next_string()?,
                    }
                }
                8u16 => {
                    Self::Line {
                        file: Id(reader.next_word()?),
                        line: reader.next_word()?,
                        column: reader.next_word()?,
                    }
                }
                10u16 => {
                    Self::Extension {
                        name: reader.next_string()?,
                    }
                }
                11u16 => {
                    Self::ExtInstImport {
                        result_id: Id(reader.next_word()?),
                        name: reader.next_string()?,
                    }
                }
                12u16 => {
                    Self::ExtInst {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        set: Id(reader.next_word()?),
                        instruction: reader.next_word()?,
                        operands: {
                            let mut vec = Vec::new();
                            while !reader.is_empty() {
                                vec.push(Id(reader.next_word()?));
                            }
                            vec
                        },
                    }
                }
                14u16 => {
                    Self::MemoryModel {
                        addressing_model: AddressingModel::parse(reader)?,
                        memory_model: MemoryModel::parse(reader)?,
                    }
                }
                15u16 => {
                    Self::EntryPoint {
                        execution_model: ExecutionModel::parse(reader)?,
                        entry_point: Id(reader.next_word()?),
                        name: reader.next_string()?,
                        interface: {
                            let mut vec = Vec::new();
                            while !reader.is_empty() {
                                vec.push(Id(reader.next_word()?));
                            }
                            vec
                        },
                    }
                }
                16u16 => {
                    Self::ExecutionMode {
                        entry_point: Id(reader.next_word()?),
                        mode: ExecutionMode::parse(reader)?,
                    }
                }
                17u16 => {
                    Self::Capability {
                        capability: Capability::parse(reader)?,
                    }
                }
                19u16 => {
                    Self::TypeVoid {
                        result_id: Id(reader.next_word()?),
                    }
                }
                20u16 => {
                    Self::TypeBool {
                        result_id: Id(reader.next_word()?),
                    }
                }
                21u16 => {
                    Self::TypeInt {
                        result_id: Id(reader.next_word()?),
                        width: reader.next_word()?,
                        signedness: reader.next_word()?,
                    }
                }
                22u16 => {
                    Self::TypeFloat {
                        result_id: Id(reader.next_word()?),
                        width: reader.next_word()?,
                    }
                }
                23u16 => {
                    Self::TypeVector {
                        result_id: Id(reader.next_word()?),
                        component_type: Id(reader.next_word()?),
                        component_count: reader.next_word()?,
                    }
                }
                24u16 => {
                    Self::TypeMatrix {
                        result_id: Id(reader.next_word()?),
                        column_type: Id(reader.next_word()?),
                        column_count: reader.next_word()?,
                    }
                }
                25u16 => {
                    Self::TypeImage {
                        result_id: Id(reader.next_word()?),
                        sampled_type: Id(reader.next_word()?),
                        dim: Dim::parse(reader)?,
                        depth: reader.next_word()?,
                        arrayed: reader.next_word()?,
                        ms: reader.next_word()?,
                        sampled: reader.next_word()?,
                        image_format: ImageFormat::parse(reader)?,
                        access_qualifier: if !reader.is_empty() {
                            Some(AccessQualifier::parse(reader)?)
                        } else {
                            None
                        },
                    }
                }
                26u16 => {
                    Self::TypeSampler {
                        result_id: Id(reader.next_word()?),
                    }
                }
                27u16 => {
                    Self::TypeSampledImage {
                        result_id: Id(reader.next_word()?),
                        image_type: Id(reader.next_word()?),
                    }
                }
                28u16 => {
                    Self::TypeArray {
                        result_id: Id(reader.next_word()?),
                        element_type: Id(reader.next_word()?),
                        length: Id(reader.next_word()?),
                    }
                }
                29u16 => {
                    Self::TypeRuntimeArray {
                        result_id: Id(reader.next_word()?),
                        element_type: Id(reader.next_word()?),
                    }
                }
                30u16 => {
                    Self::TypeStruct {
                        result_id: Id(reader.next_word()?),
                        member_types: {
                            let mut vec = Vec::new();
                            while !reader.is_empty() {
                                vec.push(Id(reader.next_word()?));
                            }
                            vec
                        },
                    }
                }
                31u16 => {
                    Self::TypeOpaque {
                        result_id: Id(reader.next_word()?),
                        name: reader.next_string()?,
                    }
                }
                32u16 => {
                    Self::TypePointer {
                        result_id: Id(reader.next_word()?),
                        storage_class: StorageClass::parse(reader)?,
                        ty: Id(reader.next_word()?),
                    }
                }
                33u16 => {
                    Self::TypeFunction {
                        result_id: Id(reader.next_word()?),
                        return_type: Id(reader.next_word()?),
                        parameter_types: {
                            let mut vec = Vec::new();
                            while !reader.is_empty() {
                                vec.push(Id(reader.next_word()?));
                            }
                            vec
                        },
                    }
                }
                34u16 => {
                    Self::TypeEvent {
                        result_id: Id(reader.next_word()?),
                    }
                }
                35u16 => {
                    Self::TypeDeviceEvent {
                        result_id: Id(reader.next_word()?),
                    }
                }
                36u16 => {
                    Self::TypeReserveId {
                        result_id: Id(reader.next_word()?),
                    }
                }
                37u16 => {
                    Self::TypeQueue {
                        result_id: Id(reader.next_word()?),
                    }
                }
                38u16 => {
                    Self::TypePipe {
                        result_id: Id(reader.next_word()?),
                        qualifier: AccessQualifier::parse(reader)?,
                    }
                }
                39u16 => {
                    Self::TypeForwardPointer {
                        pointer_type: Id(reader.next_word()?),
                        storage_class: StorageClass::parse(reader)?,
                    }
                }
                41u16 => {
                    Self::ConstantTrue {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                    }
                }
                42u16 => {
                    Self::ConstantFalse {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                    }
                }
                43u16 => {
                    Self::Constant {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        value: reader.remainder(),
                    }
                }
                44u16 => {
                    Self::ConstantComposite {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        constituents: {
                            let mut vec = Vec::new();
                            while !reader.is_empty() {
                                vec.push(Id(reader.next_word()?));
                            }
                            vec
                        },
                    }
                }
                45u16 => {
                    Self::ConstantSampler {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        sampler_addressing_mode: SamplerAddressingMode::parse(reader)?,
                        param: reader.next_word()?,
                        sampler_filter_mode: SamplerFilterMode::parse(reader)?,
                    }
                }
                46u16 => {
                    Self::ConstantNull {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                    }
                }
                48u16 => {
                    Self::SpecConstantTrue {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                    }
                }
                49u16 => {
                    Self::SpecConstantFalse {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                    }
                }
                50u16 => {
                    Self::SpecConstant {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        value: reader.remainder(),
                    }
                }
                51u16 => {
                    Self::SpecConstantComposite {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        constituents: {
                            let mut vec = Vec::new();
                            while !reader.is_empty() {
                                vec.push(Id(reader.next_word()?));
                            }
                            vec
                        },
                    }
                }
                52u16 => {
                    Self::SpecConstantOp {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        opcode: SpecConstantInstruction::parse(reader)?,
                    }
                }
                54u16 => {
                    Self::Function {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        function_control: FunctionControl::parse(reader)?,
                        function_type: Id(reader.next_word()?),
                    }
                }
                55u16 => {
                    Self::FunctionParameter {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                    }
                }
                56u16 => Self::FunctionEnd,
                57u16 => {
                    Self::FunctionCall {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        function: Id(reader.next_word()?),
                        arguments: {
                            let mut vec = Vec::new();
                            while !reader.is_empty() {
                                vec.push(Id(reader.next_word()?));
                            }
                            vec
                        },
                    }
                }
                59u16 => {
                    Self::Variable {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        storage_class: StorageClass::parse(reader)?,
                        initializer: if !reader.is_empty() {
                            Some(Id(reader.next_word()?))
                        } else {
                            None
                        },
                    }
                }
                60u16 => {
                    Self::ImageTexelPointer {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        image: Id(reader.next_word()?),
                        coordinate: Id(reader.next_word()?),
                        sample: Id(reader.next_word()?),
                    }
                }
                61u16 => {
                    Self::Load {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        pointer: Id(reader.next_word()?),
                        memory_access: if !reader.is_empty() {
                            Some(MemoryAccess::parse(reader)?)
                        } else {
                            None
                        },
                    }
                }
                62u16 => {
                    Self::Store {
                        pointer: Id(reader.next_word()?),
                        object: Id(reader.next_word()?),
                        memory_access: if !reader.is_empty() {
                            Some(MemoryAccess::parse(reader)?)
                        } else {
                            None
                        },
                    }
                }
                63u16 => {
                    Self::CopyMemory {
                        target: Id(reader.next_word()?),
                        source: Id(reader.next_word()?),
                        memory_access1: if !reader.is_empty() {
                            Some(MemoryAccess::parse(reader)?)
                        } else {
                            None
                        },
                        memory_access2: if !reader.is_empty() {
                            Some(MemoryAccess::parse(reader)?)
                        } else {
                            None
                        },
                    }
                }
                64u16 => {
                    Self::CopyMemorySized {
                        target: Id(reader.next_word()?),
                        source: Id(reader.next_word()?),
                        size: Id(reader.next_word()?),
                        memory_access1: if !reader.is_empty() {
                            Some(MemoryAccess::parse(reader)?)
                        } else {
                            None
                        },
                        memory_access2: if !reader.is_empty() {
                            Some(MemoryAccess::parse(reader)?)
                        } else {
                            None
                        },
                    }
                }
                65u16 => {
                    Self::AccessChain {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        base: Id(reader.next_word()?),
                        indexes: {
                            let mut vec = Vec::new();
                            while !reader.is_empty() {
                                vec.push(Id(reader.next_word()?));
                            }
                            vec
                        },
                    }
                }
                66u16 => {
                    Self::InBoundsAccessChain {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        base: Id(reader.next_word()?),
                        indexes: {
                            let mut vec = Vec::new();
                            while !reader.is_empty() {
                                vec.push(Id(reader.next_word()?));
                            }
                            vec
                        },
                    }
                }
                67u16 => {
                    Self::PtrAccessChain {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        base: Id(reader.next_word()?),
                        element: Id(reader.next_word()?),
                        indexes: {
                            let mut vec = Vec::new();
                            while !reader.is_empty() {
                                vec.push(Id(reader.next_word()?));
                            }
                            vec
                        },
                    }
                }
                68u16 => {
                    Self::ArrayLength {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        structure: Id(reader.next_word()?),
                        array_member: reader.next_word()?,
                    }
                }
                69u16 => {
                    Self::GenericPtrMemSemantics {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        pointer: Id(reader.next_word()?),
                    }
                }
                70u16 => {
                    Self::InBoundsPtrAccessChain {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        base: Id(reader.next_word()?),
                        element: Id(reader.next_word()?),
                        indexes: {
                            let mut vec = Vec::new();
                            while !reader.is_empty() {
                                vec.push(Id(reader.next_word()?));
                            }
                            vec
                        },
                    }
                }
                71u16 => {
                    Self::Decorate {
                        target: Id(reader.next_word()?),
                        decoration: Decoration::parse(reader)?,
                    }
                }
                72u16 => {
                    Self::MemberDecorate {
                        structure_type: Id(reader.next_word()?),
                        member: reader.next_word()?,
                        decoration: Decoration::parse(reader)?,
                    }
                }
                73u16 => {
                    Self::DecorationGroup {
                        result_id: Id(reader.next_word()?),
                    }
                }
                74u16 => {
                    Self::GroupDecorate {
                        decoration_group: Id(reader.next_word()?),
                        targets: {
                            let mut vec = Vec::new();
                            while !reader.is_empty() {
                                vec.push(Id(reader.next_word()?));
                            }
                            vec
                        },
                    }
                }
                75u16 => {
                    Self::GroupMemberDecorate {
                        decoration_group: Id(reader.next_word()?),
                        targets: {
                            let mut vec = Vec::new();
                            while !reader.is_empty() {
                                vec.push((Id(reader.next_word()?), reader.next_word()?));
                            }
                            vec
                        },
                    }
                }
                77u16 => {
                    Self::VectorExtractDynamic {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        vector: Id(reader.next_word()?),
                        index: Id(reader.next_word()?),
                    }
                }
                78u16 => {
                    Self::VectorInsertDynamic {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        vector: Id(reader.next_word()?),
                        component: Id(reader.next_word()?),
                        index: Id(reader.next_word()?),
                    }
                }
                79u16 => {
                    Self::VectorShuffle {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        vector_1: Id(reader.next_word()?),
                        vector_2: Id(reader.next_word()?),
                        components: {
                            let mut vec = Vec::new();
                            while !reader.is_empty() {
                                vec.push(reader.next_word()?);
                            }
                            vec
                        },
                    }
                }
                80u16 => {
                    Self::CompositeConstruct {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        constituents: {
                            let mut vec = Vec::new();
                            while !reader.is_empty() {
                                vec.push(Id(reader.next_word()?));
                            }
                            vec
                        },
                    }
                }
                81u16 => {
                    Self::CompositeExtract {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        composite: Id(reader.next_word()?),
                        indexes: {
                            let mut vec = Vec::new();
                            while !reader.is_empty() {
                                vec.push(reader.next_word()?);
                            }
                            vec
                        },
                    }
                }
                82u16 => {
                    Self::CompositeInsert {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        object: Id(reader.next_word()?),
                        composite: Id(reader.next_word()?),
                        indexes: {
                            let mut vec = Vec::new();
                            while !reader.is_empty() {
                                vec.push(reader.next_word()?);
                            }
                            vec
                        },
                    }
                }
                83u16 => {
                    Self::CopyObject {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        operand: Id(reader.next_word()?),
                    }
                }
                84u16 => {
                    Self::Transpose {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        matrix: Id(reader.next_word()?),
                    }
                }
                86u16 => {
                    Self::SampledImage {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        image: Id(reader.next_word()?),
                        sampler: Id(reader.next_word()?),
                    }
                }
                87u16 => {
                    Self::ImageSampleImplicitLod {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        sampled_image: Id(reader.next_word()?),
                        coordinate: Id(reader.next_word()?),
                        image_operands: if !reader.is_empty() {
                            Some(ImageOperands::parse(reader)?)
                        } else {
                            None
                        },
                    }
                }
                88u16 => {
                    Self::ImageSampleExplicitLod {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        sampled_image: Id(reader.next_word()?),
                        coordinate: Id(reader.next_word()?),
                        image_operands: ImageOperands::parse(reader)?,
                    }
                }
                89u16 => {
                    Self::ImageSampleDrefImplicitLod {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        sampled_image: Id(reader.next_word()?),
                        coordinate: Id(reader.next_word()?),
                        dref: Id(reader.next_word()?),
                        image_operands: if !reader.is_empty() {
                            Some(ImageOperands::parse(reader)?)
                        } else {
                            None
                        },
                    }
                }
                90u16 => {
                    Self::ImageSampleDrefExplicitLod {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        sampled_image: Id(reader.next_word()?),
                        coordinate: Id(reader.next_word()?),
                        dref: Id(reader.next_word()?),
                        image_operands: ImageOperands::parse(reader)?,
                    }
                }
                91u16 => {
                    Self::ImageSampleProjImplicitLod {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        sampled_image: Id(reader.next_word()?),
                        coordinate: Id(reader.next_word()?),
                        image_operands: if !reader.is_empty() {
                            Some(ImageOperands::parse(reader)?)
                        } else {
                            None
                        },
                    }
                }
                92u16 => {
                    Self::ImageSampleProjExplicitLod {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        sampled_image: Id(reader.next_word()?),
                        coordinate: Id(reader.next_word()?),
                        image_operands: ImageOperands::parse(reader)?,
                    }
                }
                93u16 => {
                    Self::ImageSampleProjDrefImplicitLod {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        sampled_image: Id(reader.next_word()?),
                        coordinate: Id(reader.next_word()?),
                        dref: Id(reader.next_word()?),
                        image_operands: if !reader.is_empty() {
                            Some(ImageOperands::parse(reader)?)
                        } else {
                            None
                        },
                    }
                }
                94u16 => {
                    Self::ImageSampleProjDrefExplicitLod {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        sampled_image: Id(reader.next_word()?),
                        coordinate: Id(reader.next_word()?),
                        dref: Id(reader.next_word()?),
                        image_operands: ImageOperands::parse(reader)?,
                    }
                }
                95u16 => {
                    Self::ImageFetch {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        image: Id(reader.next_word()?),
                        coordinate: Id(reader.next_word()?),
                        image_operands: if !reader.is_empty() {
                            Some(ImageOperands::parse(reader)?)
                        } else {
                            None
                        },
                    }
                }
                96u16 => {
                    Self::ImageGather {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        sampled_image: Id(reader.next_word()?),
                        coordinate: Id(reader.next_word()?),
                        component: Id(reader.next_word()?),
                        image_operands: if !reader.is_empty() {
                            Some(ImageOperands::parse(reader)?)
                        } else {
                            None
                        },
                    }
                }
                97u16 => {
                    Self::ImageDrefGather {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        sampled_image: Id(reader.next_word()?),
                        coordinate: Id(reader.next_word()?),
                        dref: Id(reader.next_word()?),
                        image_operands: if !reader.is_empty() {
                            Some(ImageOperands::parse(reader)?)
                        } else {
                            None
                        },
                    }
                }
                98u16 => {
                    Self::ImageRead {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        image: Id(reader.next_word()?),
                        coordinate: Id(reader.next_word()?),
                        image_operands: if !reader.is_empty() {
                            Some(ImageOperands::parse(reader)?)
                        } else {
                            None
                        },
                    }
                }
                99u16 => {
                    Self::ImageWrite {
                        image: Id(reader.next_word()?),
                        coordinate: Id(reader.next_word()?),
                        texel: Id(reader.next_word()?),
                        image_operands: if !reader.is_empty() {
                            Some(ImageOperands::parse(reader)?)
                        } else {
                            None
                        },
                    }
                }
                100u16 => {
                    Self::Image {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        sampled_image: Id(reader.next_word()?),
                    }
                }
                101u16 => {
                    Self::ImageQueryFormat {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        image: Id(reader.next_word()?),
                    }
                }
                102u16 => {
                    Self::ImageQueryOrder {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        image: Id(reader.next_word()?),
                    }
                }
                103u16 => {
                    Self::ImageQuerySizeLod {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        image: Id(reader.next_word()?),
                        level_of_detail: Id(reader.next_word()?),
                    }
                }
                104u16 => {
                    Self::ImageQuerySize {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        image: Id(reader.next_word()?),
                    }
                }
                105u16 => {
                    Self::ImageQueryLod {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        sampled_image: Id(reader.next_word()?),
                        coordinate: Id(reader.next_word()?),
                    }
                }
                106u16 => {
                    Self::ImageQueryLevels {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        image: Id(reader.next_word()?),
                    }
                }
                107u16 => {
                    Self::ImageQuerySamples {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        image: Id(reader.next_word()?),
                    }
                }
                109u16 => {
                    Self::ConvertFToU {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        float_value: Id(reader.next_word()?),
                    }
                }
                110u16 => {
                    Self::ConvertFToS {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        float_value: Id(reader.next_word()?),
                    }
                }
                111u16 => {
                    Self::ConvertSToF {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        signed_value: Id(reader.next_word()?),
                    }
                }
                112u16 => {
                    Self::ConvertUToF {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        unsigned_value: Id(reader.next_word()?),
                    }
                }
                113u16 => {
                    Self::UConvert {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        unsigned_value: Id(reader.next_word()?),
                    }
                }
                114u16 => {
                    Self::SConvert {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        signed_value: Id(reader.next_word()?),
                    }
                }
                115u16 => {
                    Self::FConvert {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        float_value: Id(reader.next_word()?),
                    }
                }
                116u16 => {
                    Self::QuantizeToF16 {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        value: Id(reader.next_word()?),
                    }
                }
                117u16 => {
                    Self::ConvertPtrToU {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        pointer: Id(reader.next_word()?),
                    }
                }
                118u16 => {
                    Self::SatConvertSToU {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        signed_value: Id(reader.next_word()?),
                    }
                }
                119u16 => {
                    Self::SatConvertUToS {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        unsigned_value: Id(reader.next_word()?),
                    }
                }
                120u16 => {
                    Self::ConvertUToPtr {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        integer_value: Id(reader.next_word()?),
                    }
                }
                121u16 => {
                    Self::PtrCastToGeneric {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        pointer: Id(reader.next_word()?),
                    }
                }
                122u16 => {
                    Self::GenericCastToPtr {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        pointer: Id(reader.next_word()?),
                    }
                }
                123u16 => {
                    Self::GenericCastToPtrExplicit {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        pointer: Id(reader.next_word()?),
                        storage: StorageClass::parse(reader)?,
                    }
                }
                124u16 => {
                    Self::Bitcast {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        operand: Id(reader.next_word()?),
                    }
                }
                126u16 => {
                    Self::SNegate {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        operand: Id(reader.next_word()?),
                    }
                }
                127u16 => {
                    Self::FNegate {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        operand: Id(reader.next_word()?),
                    }
                }
                128u16 => {
                    Self::IAdd {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        operand1: Id(reader.next_word()?),
                        operand2: Id(reader.next_word()?),
                    }
                }
                129u16 => {
                    Self::FAdd {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        operand1: Id(reader.next_word()?),
                        operand2: Id(reader.next_word()?),
                    }
                }
                130u16 => {
                    Self::ISub {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        operand1: Id(reader.next_word()?),
                        operand2: Id(reader.next_word()?),
                    }
                }
                131u16 => {
                    Self::FSub {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        operand1: Id(reader.next_word()?),
                        operand2: Id(reader.next_word()?),
                    }
                }
                132u16 => {
                    Self::IMul {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        operand1: Id(reader.next_word()?),
                        operand2: Id(reader.next_word()?),
                    }
                }
                133u16 => {
                    Self::FMul {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        operand1: Id(reader.next_word()?),
                        operand2: Id(reader.next_word()?),
                    }
                }
                134u16 => {
                    Self::UDiv {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        operand1: Id(reader.next_word()?),
                        operand2: Id(reader.next_word()?),
                    }
                }
                135u16 => {
                    Self::SDiv {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        operand1: Id(reader.next_word()?),
                        operand2: Id(reader.next_word()?),
                    }
                }
                136u16 => {
                    Self::FDiv {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        operand1: Id(reader.next_word()?),
                        operand2: Id(reader.next_word()?),
                    }
                }
                137u16 => {
                    Self::UMod {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        operand1: Id(reader.next_word()?),
                        operand2: Id(reader.next_word()?),
                    }
                }
                138u16 => {
                    Self::SRem {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        operand1: Id(reader.next_word()?),
                        operand2: Id(reader.next_word()?),
                    }
                }
                139u16 => {
                    Self::SMod {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        operand1: Id(reader.next_word()?),
                        operand2: Id(reader.next_word()?),
                    }
                }
                140u16 => {
                    Self::FRem {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        operand1: Id(reader.next_word()?),
                        operand2: Id(reader.next_word()?),
                    }
                }
                141u16 => {
                    Self::FMod {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        operand1: Id(reader.next_word()?),
                        operand2: Id(reader.next_word()?),
                    }
                }
                142u16 => {
                    Self::VectorTimesScalar {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        vector: Id(reader.next_word()?),
                        scalar: Id(reader.next_word()?),
                    }
                }
                143u16 => {
                    Self::MatrixTimesScalar {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        matrix: Id(reader.next_word()?),
                        scalar: Id(reader.next_word()?),
                    }
                }
                144u16 => {
                    Self::VectorTimesMatrix {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        vector: Id(reader.next_word()?),
                        matrix: Id(reader.next_word()?),
                    }
                }
                145u16 => {
                    Self::MatrixTimesVector {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        matrix: Id(reader.next_word()?),
                        vector: Id(reader.next_word()?),
                    }
                }
                146u16 => {
                    Self::MatrixTimesMatrix {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        left_matrix: Id(reader.next_word()?),
                        right_matrix: Id(reader.next_word()?),
                    }
                }
                147u16 => {
                    Self::OuterProduct {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        vector_1: Id(reader.next_word()?),
                        vector_2: Id(reader.next_word()?),
                    }
                }
                148u16 => {
                    Self::Dot {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        vector_1: Id(reader.next_word()?),
                        vector_2: Id(reader.next_word()?),
                    }
                }
                149u16 => {
                    Self::IAddCarry {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        operand1: Id(reader.next_word()?),
                        operand2: Id(reader.next_word()?),
                    }
                }
                150u16 => {
                    Self::ISubBorrow {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        operand1: Id(reader.next_word()?),
                        operand2: Id(reader.next_word()?),
                    }
                }
                151u16 => {
                    Self::UMulExtended {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        operand1: Id(reader.next_word()?),
                        operand2: Id(reader.next_word()?),
                    }
                }
                152u16 => {
                    Self::SMulExtended {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        operand1: Id(reader.next_word()?),
                        operand2: Id(reader.next_word()?),
                    }
                }
                154u16 => {
                    Self::Any {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        vector: Id(reader.next_word()?),
                    }
                }
                155u16 => {
                    Self::All {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        vector: Id(reader.next_word()?),
                    }
                }
                156u16 => {
                    Self::IsNan {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        x: Id(reader.next_word()?),
                    }
                }
                157u16 => {
                    Self::IsInf {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        x: Id(reader.next_word()?),
                    }
                }
                158u16 => {
                    Self::IsFinite {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        x: Id(reader.next_word()?),
                    }
                }
                159u16 => {
                    Self::IsNormal {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        x: Id(reader.next_word()?),
                    }
                }
                160u16 => {
                    Self::SignBitSet {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        x: Id(reader.next_word()?),
                    }
                }
                161u16 => {
                    Self::LessOrGreater {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        x: Id(reader.next_word()?),
                        y: Id(reader.next_word()?),
                    }
                }
                162u16 => {
                    Self::Ordered {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        x: Id(reader.next_word()?),
                        y: Id(reader.next_word()?),
                    }
                }
                163u16 => {
                    Self::Unordered {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        x: Id(reader.next_word()?),
                        y: Id(reader.next_word()?),
                    }
                }
                164u16 => {
                    Self::LogicalEqual {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        operand1: Id(reader.next_word()?),
                        operand2: Id(reader.next_word()?),
                    }
                }
                165u16 => {
                    Self::LogicalNotEqual {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        operand1: Id(reader.next_word()?),
                        operand2: Id(reader.next_word()?),
                    }
                }
                166u16 => {
                    Self::LogicalOr {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        operand1: Id(reader.next_word()?),
                        operand2: Id(reader.next_word()?),
                    }
                }
                167u16 => {
                    Self::LogicalAnd {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        operand1: Id(reader.next_word()?),
                        operand2: Id(reader.next_word()?),
                    }
                }
                168u16 => {
                    Self::LogicalNot {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        operand: Id(reader.next_word()?),
                    }
                }
                169u16 => {
                    Self::Select {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        condition: Id(reader.next_word()?),
                        object_1: Id(reader.next_word()?),
                        object_2: Id(reader.next_word()?),
                    }
                }
                170u16 => {
                    Self::IEqual {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        operand1: Id(reader.next_word()?),
                        operand2: Id(reader.next_word()?),
                    }
                }
                171u16 => {
                    Self::INotEqual {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        operand1: Id(reader.next_word()?),
                        operand2: Id(reader.next_word()?),
                    }
                }
                172u16 => {
                    Self::UGreaterThan {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        operand1: Id(reader.next_word()?),
                        operand2: Id(reader.next_word()?),
                    }
                }
                173u16 => {
                    Self::SGreaterThan {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        operand1: Id(reader.next_word()?),
                        operand2: Id(reader.next_word()?),
                    }
                }
                174u16 => {
                    Self::UGreaterThanEqual {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        operand1: Id(reader.next_word()?),
                        operand2: Id(reader.next_word()?),
                    }
                }
                175u16 => {
                    Self::SGreaterThanEqual {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        operand1: Id(reader.next_word()?),
                        operand2: Id(reader.next_word()?),
                    }
                }
                176u16 => {
                    Self::ULessThan {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        operand1: Id(reader.next_word()?),
                        operand2: Id(reader.next_word()?),
                    }
                }
                177u16 => {
                    Self::SLessThan {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        operand1: Id(reader.next_word()?),
                        operand2: Id(reader.next_word()?),
                    }
                }
                178u16 => {
                    Self::ULessThanEqual {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        operand1: Id(reader.next_word()?),
                        operand2: Id(reader.next_word()?),
                    }
                }
                179u16 => {
                    Self::SLessThanEqual {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        operand1: Id(reader.next_word()?),
                        operand2: Id(reader.next_word()?),
                    }
                }
                180u16 => {
                    Self::FOrdEqual {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        operand1: Id(reader.next_word()?),
                        operand2: Id(reader.next_word()?),
                    }
                }
                181u16 => {
                    Self::FUnordEqual {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        operand1: Id(reader.next_word()?),
                        operand2: Id(reader.next_word()?),
                    }
                }
                182u16 => {
                    Self::FOrdNotEqual {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        operand1: Id(reader.next_word()?),
                        operand2: Id(reader.next_word()?),
                    }
                }
                183u16 => {
                    Self::FUnordNotEqual {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        operand1: Id(reader.next_word()?),
                        operand2: Id(reader.next_word()?),
                    }
                }
                184u16 => {
                    Self::FOrdLessThan {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        operand1: Id(reader.next_word()?),
                        operand2: Id(reader.next_word()?),
                    }
                }
                185u16 => {
                    Self::FUnordLessThan {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        operand1: Id(reader.next_word()?),
                        operand2: Id(reader.next_word()?),
                    }
                }
                186u16 => {
                    Self::FOrdGreaterThan {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        operand1: Id(reader.next_word()?),
                        operand2: Id(reader.next_word()?),
                    }
                }
                187u16 => {
                    Self::FUnordGreaterThan {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        operand1: Id(reader.next_word()?),
                        operand2: Id(reader.next_word()?),
                    }
                }
                188u16 => {
                    Self::FOrdLessThanEqual {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        operand1: Id(reader.next_word()?),
                        operand2: Id(reader.next_word()?),
                    }
                }
                189u16 => {
                    Self::FUnordLessThanEqual {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        operand1: Id(reader.next_word()?),
                        operand2: Id(reader.next_word()?),
                    }
                }
                190u16 => {
                    Self::FOrdGreaterThanEqual {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        operand1: Id(reader.next_word()?),
                        operand2: Id(reader.next_word()?),
                    }
                }
                191u16 => {
                    Self::FUnordGreaterThanEqual {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        operand1: Id(reader.next_word()?),
                        operand2: Id(reader.next_word()?),
                    }
                }
                194u16 => {
                    Self::ShiftRightLogical {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        base: Id(reader.next_word()?),
                        shift: Id(reader.next_word()?),
                    }
                }
                195u16 => {
                    Self::ShiftRightArithmetic {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        base: Id(reader.next_word()?),
                        shift: Id(reader.next_word()?),
                    }
                }
                196u16 => {
                    Self::ShiftLeftLogical {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        base: Id(reader.next_word()?),
                        shift: Id(reader.next_word()?),
                    }
                }
                197u16 => {
                    Self::BitwiseOr {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        operand1: Id(reader.next_word()?),
                        operand2: Id(reader.next_word()?),
                    }
                }
                198u16 => {
                    Self::BitwiseXor {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        operand1: Id(reader.next_word()?),
                        operand2: Id(reader.next_word()?),
                    }
                }
                199u16 => {
                    Self::BitwiseAnd {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        operand1: Id(reader.next_word()?),
                        operand2: Id(reader.next_word()?),
                    }
                }
                200u16 => {
                    Self::Not {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        operand: Id(reader.next_word()?),
                    }
                }
                201u16 => {
                    Self::BitFieldInsert {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        base: Id(reader.next_word()?),
                        insert: Id(reader.next_word()?),
                        offset: Id(reader.next_word()?),
                        count: Id(reader.next_word()?),
                    }
                }
                202u16 => {
                    Self::BitFieldSExtract {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        base: Id(reader.next_word()?),
                        offset: Id(reader.next_word()?),
                        count: Id(reader.next_word()?),
                    }
                }
                203u16 => {
                    Self::BitFieldUExtract {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        base: Id(reader.next_word()?),
                        offset: Id(reader.next_word()?),
                        count: Id(reader.next_word()?),
                    }
                }
                204u16 => {
                    Self::BitReverse {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        base: Id(reader.next_word()?),
                    }
                }
                205u16 => {
                    Self::BitCount {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        base: Id(reader.next_word()?),
                    }
                }
                207u16 => {
                    Self::DPdx {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        p: Id(reader.next_word()?),
                    }
                }
                208u16 => {
                    Self::DPdy {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        p: Id(reader.next_word()?),
                    }
                }
                209u16 => {
                    Self::Fwidth {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        p: Id(reader.next_word()?),
                    }
                }
                210u16 => {
                    Self::DPdxFine {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        p: Id(reader.next_word()?),
                    }
                }
                211u16 => {
                    Self::DPdyFine {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        p: Id(reader.next_word()?),
                    }
                }
                212u16 => {
                    Self::FwidthFine {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        p: Id(reader.next_word()?),
                    }
                }
                213u16 => {
                    Self::DPdxCoarse {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        p: Id(reader.next_word()?),
                    }
                }
                214u16 => {
                    Self::DPdyCoarse {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        p: Id(reader.next_word()?),
                    }
                }
                215u16 => {
                    Self::FwidthCoarse {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        p: Id(reader.next_word()?),
                    }
                }
                218u16 => Self::EmitVertex,
                219u16 => Self::EndPrimitive,
                220u16 => {
                    Self::EmitStreamVertex {
                        stream: Id(reader.next_word()?),
                    }
                }
                221u16 => {
                    Self::EndStreamPrimitive {
                        stream: Id(reader.next_word()?),
                    }
                }
                224u16 => {
                    Self::ControlBarrier {
                        execution: Id(reader.next_word()?),
                        memory: Id(reader.next_word()?),
                        semantics: Id(reader.next_word()?),
                    }
                }
                225u16 => {
                    Self::MemoryBarrier {
                        memory: Id(reader.next_word()?),
                        semantics: Id(reader.next_word()?),
                    }
                }
                227u16 => {
                    Self::AtomicLoad {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        pointer: Id(reader.next_word()?),
                        memory: Id(reader.next_word()?),
                        semantics: Id(reader.next_word()?),
                    }
                }
                228u16 => {
                    Self::AtomicStore {
                        pointer: Id(reader.next_word()?),
                        memory: Id(reader.next_word()?),
                        semantics: Id(reader.next_word()?),
                        value: Id(reader.next_word()?),
                    }
                }
                229u16 => {
                    Self::AtomicExchange {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        pointer: Id(reader.next_word()?),
                        memory: Id(reader.next_word()?),
                        semantics: Id(reader.next_word()?),
                        value: Id(reader.next_word()?),
                    }
                }
                230u16 => {
                    Self::AtomicCompareExchange {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        pointer: Id(reader.next_word()?),
                        memory: Id(reader.next_word()?),
                        equal: Id(reader.next_word()?),
                        unequal: Id(reader.next_word()?),
                        value: Id(reader.next_word()?),
                        comparator: Id(reader.next_word()?),
                    }
                }
                231u16 => {
                    Self::AtomicCompareExchangeWeak {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        pointer: Id(reader.next_word()?),
                        memory: Id(reader.next_word()?),
                        equal: Id(reader.next_word()?),
                        unequal: Id(reader.next_word()?),
                        value: Id(reader.next_word()?),
                        comparator: Id(reader.next_word()?),
                    }
                }
                232u16 => {
                    Self::AtomicIIncrement {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        pointer: Id(reader.next_word()?),
                        memory: Id(reader.next_word()?),
                        semantics: Id(reader.next_word()?),
                    }
                }
                233u16 => {
                    Self::AtomicIDecrement {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        pointer: Id(reader.next_word()?),
                        memory: Id(reader.next_word()?),
                        semantics: Id(reader.next_word()?),
                    }
                }
                234u16 => {
                    Self::AtomicIAdd {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        pointer: Id(reader.next_word()?),
                        memory: Id(reader.next_word()?),
                        semantics: Id(reader.next_word()?),
                        value: Id(reader.next_word()?),
                    }
                }
                235u16 => {
                    Self::AtomicISub {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        pointer: Id(reader.next_word()?),
                        memory: Id(reader.next_word()?),
                        semantics: Id(reader.next_word()?),
                        value: Id(reader.next_word()?),
                    }
                }
                236u16 => {
                    Self::AtomicSMin {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        pointer: Id(reader.next_word()?),
                        memory: Id(reader.next_word()?),
                        semantics: Id(reader.next_word()?),
                        value: Id(reader.next_word()?),
                    }
                }
                237u16 => {
                    Self::AtomicUMin {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        pointer: Id(reader.next_word()?),
                        memory: Id(reader.next_word()?),
                        semantics: Id(reader.next_word()?),
                        value: Id(reader.next_word()?),
                    }
                }
                238u16 => {
                    Self::AtomicSMax {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        pointer: Id(reader.next_word()?),
                        memory: Id(reader.next_word()?),
                        semantics: Id(reader.next_word()?),
                        value: Id(reader.next_word()?),
                    }
                }
                239u16 => {
                    Self::AtomicUMax {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        pointer: Id(reader.next_word()?),
                        memory: Id(reader.next_word()?),
                        semantics: Id(reader.next_word()?),
                        value: Id(reader.next_word()?),
                    }
                }
                240u16 => {
                    Self::AtomicAnd {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        pointer: Id(reader.next_word()?),
                        memory: Id(reader.next_word()?),
                        semantics: Id(reader.next_word()?),
                        value: Id(reader.next_word()?),
                    }
                }
                241u16 => {
                    Self::AtomicOr {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        pointer: Id(reader.next_word()?),
                        memory: Id(reader.next_word()?),
                        semantics: Id(reader.next_word()?),
                        value: Id(reader.next_word()?),
                    }
                }
                242u16 => {
                    Self::AtomicXor {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        pointer: Id(reader.next_word()?),
                        memory: Id(reader.next_word()?),
                        semantics: Id(reader.next_word()?),
                        value: Id(reader.next_word()?),
                    }
                }
                245u16 => {
                    Self::Phi {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        variable_parent: {
                            let mut vec = Vec::new();
                            while !reader.is_empty() {
                                vec.push((
                                    Id(reader.next_word()?),
                                    Id(reader.next_word()?),
                                ));
                            }
                            vec
                        },
                    }
                }
                246u16 => {
                    Self::LoopMerge {
                        merge_block: Id(reader.next_word()?),
                        continue_target: Id(reader.next_word()?),
                        loop_control: LoopControl::parse(reader)?,
                    }
                }
                247u16 => {
                    Self::SelectionMerge {
                        merge_block: Id(reader.next_word()?),
                        selection_control: SelectionControl::parse(reader)?,
                    }
                }
                248u16 => {
                    Self::Label {
                        result_id: Id(reader.next_word()?),
                    }
                }
                249u16 => {
                    Self::Branch {
                        target_label: Id(reader.next_word()?),
                    }
                }
                250u16 => {
                    Self::BranchConditional {
                        condition: Id(reader.next_word()?),
                        true_label: Id(reader.next_word()?),
                        false_label: Id(reader.next_word()?),
                        branch_weights: {
                            let mut vec = Vec::new();
                            while !reader.is_empty() {
                                vec.push(reader.next_word()?);
                            }
                            vec
                        },
                    }
                }
                251u16 => {
                    Self::Switch {
                        selector: Id(reader.next_word()?),
                        default: Id(reader.next_word()?),
                        target: {
                            let mut vec = Vec::new();
                            while !reader.is_empty() {
                                vec.push((reader.next_word()?, Id(reader.next_word()?)));
                            }
                            vec
                        },
                    }
                }
                252u16 => Self::Kill,
                253u16 => Self::Return,
                254u16 => {
                    Self::ReturnValue {
                        value: Id(reader.next_word()?),
                    }
                }
                255u16 => Self::Unreachable,
                256u16 => {
                    Self::LifetimeStart {
                        pointer: Id(reader.next_word()?),
                        size: reader.next_word()?,
                    }
                }
                257u16 => {
                    Self::LifetimeStop {
                        pointer: Id(reader.next_word()?),
                        size: reader.next_word()?,
                    }
                }
                259u16 => {
                    Self::GroupAsyncCopy {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        execution: Id(reader.next_word()?),
                        destination: Id(reader.next_word()?),
                        source: Id(reader.next_word()?),
                        num_elements: Id(reader.next_word()?),
                        stride: Id(reader.next_word()?),
                        event: Id(reader.next_word()?),
                    }
                }
                260u16 => {
                    Self::GroupWaitEvents {
                        execution: Id(reader.next_word()?),
                        num_events: Id(reader.next_word()?),
                        events_list: Id(reader.next_word()?),
                    }
                }
                261u16 => {
                    Self::GroupAll {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        execution: Id(reader.next_word()?),
                        predicate: Id(reader.next_word()?),
                    }
                }
                262u16 => {
                    Self::GroupAny {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        execution: Id(reader.next_word()?),
                        predicate: Id(reader.next_word()?),
                    }
                }
                263u16 => {
                    Self::GroupBroadcast {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        execution: Id(reader.next_word()?),
                        value: Id(reader.next_word()?),
                        local_id: Id(reader.next_word()?),
                    }
                }
                264u16 => {
                    Self::GroupIAdd {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        execution: Id(reader.next_word()?),
                        operation: GroupOperation::parse(reader)?,
                        x: Id(reader.next_word()?),
                    }
                }
                265u16 => {
                    Self::GroupFAdd {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        execution: Id(reader.next_word()?),
                        operation: GroupOperation::parse(reader)?,
                        x: Id(reader.next_word()?),
                    }
                }
                266u16 => {
                    Self::GroupFMin {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        execution: Id(reader.next_word()?),
                        operation: GroupOperation::parse(reader)?,
                        x: Id(reader.next_word()?),
                    }
                }
                267u16 => {
                    Self::GroupUMin {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        execution: Id(reader.next_word()?),
                        operation: GroupOperation::parse(reader)?,
                        x: Id(reader.next_word()?),
                    }
                }
                268u16 => {
                    Self::GroupSMin {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        execution: Id(reader.next_word()?),
                        operation: GroupOperation::parse(reader)?,
                        x: Id(reader.next_word()?),
                    }
                }
                269u16 => {
                    Self::GroupFMax {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        execution: Id(reader.next_word()?),
                        operation: GroupOperation::parse(reader)?,
                        x: Id(reader.next_word()?),
                    }
                }
                270u16 => {
                    Self::GroupUMax {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        execution: Id(reader.next_word()?),
                        operation: GroupOperation::parse(reader)?,
                        x: Id(reader.next_word()?),
                    }
                }
                271u16 => {
                    Self::GroupSMax {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        execution: Id(reader.next_word()?),
                        operation: GroupOperation::parse(reader)?,
                        x: Id(reader.next_word()?),
                    }
                }
                274u16 => {
                    Self::ReadPipe {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        pipe: Id(reader.next_word()?),
                        pointer: Id(reader.next_word()?),
                        packet_size: Id(reader.next_word()?),
                        packet_alignment: Id(reader.next_word()?),
                    }
                }
                275u16 => {
                    Self::WritePipe {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        pipe: Id(reader.next_word()?),
                        pointer: Id(reader.next_word()?),
                        packet_size: Id(reader.next_word()?),
                        packet_alignment: Id(reader.next_word()?),
                    }
                }
                276u16 => {
                    Self::ReservedReadPipe {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        pipe: Id(reader.next_word()?),
                        reserve_id: Id(reader.next_word()?),
                        index: Id(reader.next_word()?),
                        pointer: Id(reader.next_word()?),
                        packet_size: Id(reader.next_word()?),
                        packet_alignment: Id(reader.next_word()?),
                    }
                }
                277u16 => {
                    Self::ReservedWritePipe {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        pipe: Id(reader.next_word()?),
                        reserve_id: Id(reader.next_word()?),
                        index: Id(reader.next_word()?),
                        pointer: Id(reader.next_word()?),
                        packet_size: Id(reader.next_word()?),
                        packet_alignment: Id(reader.next_word()?),
                    }
                }
                278u16 => {
                    Self::ReserveReadPipePackets {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        pipe: Id(reader.next_word()?),
                        num_packets: Id(reader.next_word()?),
                        packet_size: Id(reader.next_word()?),
                        packet_alignment: Id(reader.next_word()?),
                    }
                }
                279u16 => {
                    Self::ReserveWritePipePackets {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        pipe: Id(reader.next_word()?),
                        num_packets: Id(reader.next_word()?),
                        packet_size: Id(reader.next_word()?),
                        packet_alignment: Id(reader.next_word()?),
                    }
                }
                280u16 => {
                    Self::CommitReadPipe {
                        pipe: Id(reader.next_word()?),
                        reserve_id: Id(reader.next_word()?),
                        packet_size: Id(reader.next_word()?),
                        packet_alignment: Id(reader.next_word()?),
                    }
                }
                281u16 => {
                    Self::CommitWritePipe {
                        pipe: Id(reader.next_word()?),
                        reserve_id: Id(reader.next_word()?),
                        packet_size: Id(reader.next_word()?),
                        packet_alignment: Id(reader.next_word()?),
                    }
                }
                282u16 => {
                    Self::IsValidReserveId {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        reserve_id: Id(reader.next_word()?),
                    }
                }
                283u16 => {
                    Self::GetNumPipePackets {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        pipe: Id(reader.next_word()?),
                        packet_size: Id(reader.next_word()?),
                        packet_alignment: Id(reader.next_word()?),
                    }
                }
                284u16 => {
                    Self::GetMaxPipePackets {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        pipe: Id(reader.next_word()?),
                        packet_size: Id(reader.next_word()?),
                        packet_alignment: Id(reader.next_word()?),
                    }
                }
                285u16 => {
                    Self::GroupReserveReadPipePackets {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        execution: Id(reader.next_word()?),
                        pipe: Id(reader.next_word()?),
                        num_packets: Id(reader.next_word()?),
                        packet_size: Id(reader.next_word()?),
                        packet_alignment: Id(reader.next_word()?),
                    }
                }
                286u16 => {
                    Self::GroupReserveWritePipePackets {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        execution: Id(reader.next_word()?),
                        pipe: Id(reader.next_word()?),
                        num_packets: Id(reader.next_word()?),
                        packet_size: Id(reader.next_word()?),
                        packet_alignment: Id(reader.next_word()?),
                    }
                }
                287u16 => {
                    Self::GroupCommitReadPipe {
                        execution: Id(reader.next_word()?),
                        pipe: Id(reader.next_word()?),
                        reserve_id: Id(reader.next_word()?),
                        packet_size: Id(reader.next_word()?),
                        packet_alignment: Id(reader.next_word()?),
                    }
                }
                288u16 => {
                    Self::GroupCommitWritePipe {
                        execution: Id(reader.next_word()?),
                        pipe: Id(reader.next_word()?),
                        reserve_id: Id(reader.next_word()?),
                        packet_size: Id(reader.next_word()?),
                        packet_alignment: Id(reader.next_word()?),
                    }
                }
                291u16 => {
                    Self::EnqueueMarker {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        queue: Id(reader.next_word()?),
                        num_events: Id(reader.next_word()?),
                        wait_events: Id(reader.next_word()?),
                        ret_event: Id(reader.next_word()?),
                    }
                }
                292u16 => {
                    Self::EnqueueKernel {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        queue: Id(reader.next_word()?),
                        flags: Id(reader.next_word()?),
                        nd_range: Id(reader.next_word()?),
                        num_events: Id(reader.next_word()?),
                        wait_events: Id(reader.next_word()?),
                        ret_event: Id(reader.next_word()?),
                        invoke: Id(reader.next_word()?),
                        param: Id(reader.next_word()?),
                        param_size: Id(reader.next_word()?),
                        param_align: Id(reader.next_word()?),
                        local_size: {
                            let mut vec = Vec::new();
                            while !reader.is_empty() {
                                vec.push(Id(reader.next_word()?));
                            }
                            vec
                        },
                    }
                }
                293u16 => {
                    Self::GetKernelNDrangeSubGroupCount {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        nd_range: Id(reader.next_word()?),
                        invoke: Id(reader.next_word()?),
                        param: Id(reader.next_word()?),
                        param_size: Id(reader.next_word()?),
                        param_align: Id(reader.next_word()?),
                    }
                }
                294u16 => {
                    Self::GetKernelNDrangeMaxSubGroupSize {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        nd_range: Id(reader.next_word()?),
                        invoke: Id(reader.next_word()?),
                        param: Id(reader.next_word()?),
                        param_size: Id(reader.next_word()?),
                        param_align: Id(reader.next_word()?),
                    }
                }
                295u16 => {
                    Self::GetKernelWorkGroupSize {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        invoke: Id(reader.next_word()?),
                        param: Id(reader.next_word()?),
                        param_size: Id(reader.next_word()?),
                        param_align: Id(reader.next_word()?),
                    }
                }
                296u16 => {
                    Self::GetKernelPreferredWorkGroupSizeMultiple {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        invoke: Id(reader.next_word()?),
                        param: Id(reader.next_word()?),
                        param_size: Id(reader.next_word()?),
                        param_align: Id(reader.next_word()?),
                    }
                }
                297u16 => {
                    Self::RetainEvent {
                        event: Id(reader.next_word()?),
                    }
                }
                298u16 => {
                    Self::ReleaseEvent {
                        event: Id(reader.next_word()?),
                    }
                }
                299u16 => {
                    Self::CreateUserEvent {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                    }
                }
                300u16 => {
                    Self::IsValidEvent {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        event: Id(reader.next_word()?),
                    }
                }
                301u16 => {
                    Self::SetUserEventStatus {
                        event: Id(reader.next_word()?),
                        status: Id(reader.next_word()?),
                    }
                }
                302u16 => {
                    Self::CaptureEventProfilingInfo {
                        event: Id(reader.next_word()?),
                        profiling_info: Id(reader.next_word()?),
                        value: Id(reader.next_word()?),
                    }
                }
                303u16 => {
                    Self::GetDefaultQueue {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                    }
                }
                304u16 => {
                    Self::BuildNDRange {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        global_work_size: Id(reader.next_word()?),
                        local_work_size: Id(reader.next_word()?),
                        global_work_offset: Id(reader.next_word()?),
                    }
                }
                305u16 => {
                    Self::ImageSparseSampleImplicitLod {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        sampled_image: Id(reader.next_word()?),
                        coordinate: Id(reader.next_word()?),
                        image_operands: if !reader.is_empty() {
                            Some(ImageOperands::parse(reader)?)
                        } else {
                            None
                        },
                    }
                }
                306u16 => {
                    Self::ImageSparseSampleExplicitLod {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        sampled_image: Id(reader.next_word()?),
                        coordinate: Id(reader.next_word()?),
                        image_operands: ImageOperands::parse(reader)?,
                    }
                }
                307u16 => {
                    Self::ImageSparseSampleDrefImplicitLod {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        sampled_image: Id(reader.next_word()?),
                        coordinate: Id(reader.next_word()?),
                        dref: Id(reader.next_word()?),
                        image_operands: if !reader.is_empty() {
                            Some(ImageOperands::parse(reader)?)
                        } else {
                            None
                        },
                    }
                }
                308u16 => {
                    Self::ImageSparseSampleDrefExplicitLod {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        sampled_image: Id(reader.next_word()?),
                        coordinate: Id(reader.next_word()?),
                        dref: Id(reader.next_word()?),
                        image_operands: ImageOperands::parse(reader)?,
                    }
                }
                309u16 => {
                    Self::ImageSparseSampleProjImplicitLod {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        sampled_image: Id(reader.next_word()?),
                        coordinate: Id(reader.next_word()?),
                        image_operands: if !reader.is_empty() {
                            Some(ImageOperands::parse(reader)?)
                        } else {
                            None
                        },
                    }
                }
                310u16 => {
                    Self::ImageSparseSampleProjExplicitLod {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        sampled_image: Id(reader.next_word()?),
                        coordinate: Id(reader.next_word()?),
                        image_operands: ImageOperands::parse(reader)?,
                    }
                }
                311u16 => {
                    Self::ImageSparseSampleProjDrefImplicitLod {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        sampled_image: Id(reader.next_word()?),
                        coordinate: Id(reader.next_word()?),
                        dref: Id(reader.next_word()?),
                        image_operands: if !reader.is_empty() {
                            Some(ImageOperands::parse(reader)?)
                        } else {
                            None
                        },
                    }
                }
                312u16 => {
                    Self::ImageSparseSampleProjDrefExplicitLod {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        sampled_image: Id(reader.next_word()?),
                        coordinate: Id(reader.next_word()?),
                        dref: Id(reader.next_word()?),
                        image_operands: ImageOperands::parse(reader)?,
                    }
                }
                313u16 => {
                    Self::ImageSparseFetch {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        image: Id(reader.next_word()?),
                        coordinate: Id(reader.next_word()?),
                        image_operands: if !reader.is_empty() {
                            Some(ImageOperands::parse(reader)?)
                        } else {
                            None
                        },
                    }
                }
                314u16 => {
                    Self::ImageSparseGather {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        sampled_image: Id(reader.next_word()?),
                        coordinate: Id(reader.next_word()?),
                        component: Id(reader.next_word()?),
                        image_operands: if !reader.is_empty() {
                            Some(ImageOperands::parse(reader)?)
                        } else {
                            None
                        },
                    }
                }
                315u16 => {
                    Self::ImageSparseDrefGather {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        sampled_image: Id(reader.next_word()?),
                        coordinate: Id(reader.next_word()?),
                        dref: Id(reader.next_word()?),
                        image_operands: if !reader.is_empty() {
                            Some(ImageOperands::parse(reader)?)
                        } else {
                            None
                        },
                    }
                }
                316u16 => {
                    Self::ImageSparseTexelsResident {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        resident_code: Id(reader.next_word()?),
                    }
                }
                317u16 => Self::NoLine,
                318u16 => {
                    Self::AtomicFlagTestAndSet {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        pointer: Id(reader.next_word()?),
                        memory: Id(reader.next_word()?),
                        semantics: Id(reader.next_word()?),
                    }
                }
                319u16 => {
                    Self::AtomicFlagClear {
                        pointer: Id(reader.next_word()?),
                        memory: Id(reader.next_word()?),
                        semantics: Id(reader.next_word()?),
                    }
                }
                320u16 => {
                    Self::ImageSparseRead {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        image: Id(reader.next_word()?),
                        coordinate: Id(reader.next_word()?),
                        image_operands: if !reader.is_empty() {
                            Some(ImageOperands::parse(reader)?)
                        } else {
                            None
                        },
                    }
                }
                321u16 => {
                    Self::SizeOf {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        pointer: Id(reader.next_word()?),
                    }
                }
                322u16 => {
                    Self::TypePipeStorage {
                        result_id: Id(reader.next_word()?),
                    }
                }
                323u16 => {
                    Self::ConstantPipeStorage {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        packet_size: reader.next_word()?,
                        packet_alignment: reader.next_word()?,
                        capacity: reader.next_word()?,
                    }
                }
                324u16 => {
                    Self::CreatePipeFromPipeStorage {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        pipe_storage: Id(reader.next_word()?),
                    }
                }
                325u16 => {
                    Self::GetKernelLocalSizeForSubgroupCount {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        subgroup_count: Id(reader.next_word()?),
                        invoke: Id(reader.next_word()?),
                        param: Id(reader.next_word()?),
                        param_size: Id(reader.next_word()?),
                        param_align: Id(reader.next_word()?),
                    }
                }
                326u16 => {
                    Self::GetKernelMaxNumSubgroups {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        invoke: Id(reader.next_word()?),
                        param: Id(reader.next_word()?),
                        param_size: Id(reader.next_word()?),
                        param_align: Id(reader.next_word()?),
                    }
                }
                327u16 => {
                    Self::TypeNamedBarrier {
                        result_id: Id(reader.next_word()?),
                    }
                }
                328u16 => {
                    Self::NamedBarrierInitialize {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        subgroup_count: Id(reader.next_word()?),
                    }
                }
                329u16 => {
                    Self::MemoryNamedBarrier {
                        named_barrier: Id(reader.next_word()?),
                        memory: Id(reader.next_word()?),
                        semantics: Id(reader.next_word()?),
                    }
                }
                330u16 => {
                    Self::ModuleProcessed {
                        process: reader.next_string()?,
                    }
                }
                331u16 => {
                    Self::ExecutionModeId {
                        entry_point: Id(reader.next_word()?),
                        mode: ExecutionMode::parse(reader)?,
                    }
                }
                332u16 => {
                    Self::DecorateId {
                        target: Id(reader.next_word()?),
                        decoration: Decoration::parse(reader)?,
                    }
                }
                333u16 => {
                    Self::GroupNonUniformElect {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        execution: Id(reader.next_word()?),
                    }
                }
                334u16 => {
                    Self::GroupNonUniformAll {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        execution: Id(reader.next_word()?),
                        predicate: Id(reader.next_word()?),
                    }
                }
                335u16 => {
                    Self::GroupNonUniformAny {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        execution: Id(reader.next_word()?),
                        predicate: Id(reader.next_word()?),
                    }
                }
                336u16 => {
                    Self::GroupNonUniformAllEqual {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        execution: Id(reader.next_word()?),
                        value: Id(reader.next_word()?),
                    }
                }
                337u16 => {
                    Self::GroupNonUniformBroadcast {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        execution: Id(reader.next_word()?),
                        value: Id(reader.next_word()?),
                        id: Id(reader.next_word()?),
                    }
                }
                338u16 => {
                    Self::GroupNonUniformBroadcastFirst {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        execution: Id(reader.next_word()?),
                        value: Id(reader.next_word()?),
                    }
                }
                339u16 => {
                    Self::GroupNonUniformBallot {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        execution: Id(reader.next_word()?),
                        predicate: Id(reader.next_word()?),
                    }
                }
                340u16 => {
                    Self::GroupNonUniformInverseBallot {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        execution: Id(reader.next_word()?),
                        value: Id(reader.next_word()?),
                    }
                }
                341u16 => {
                    Self::GroupNonUniformBallotBitExtract {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        execution: Id(reader.next_word()?),
                        value: Id(reader.next_word()?),
                        index: Id(reader.next_word()?),
                    }
                }
                342u16 => {
                    Self::GroupNonUniformBallotBitCount {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        execution: Id(reader.next_word()?),
                        operation: GroupOperation::parse(reader)?,
                        value: Id(reader.next_word()?),
                    }
                }
                343u16 => {
                    Self::GroupNonUniformBallotFindLSB {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        execution: Id(reader.next_word()?),
                        value: Id(reader.next_word()?),
                    }
                }
                344u16 => {
                    Self::GroupNonUniformBallotFindMSB {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        execution: Id(reader.next_word()?),
                        value: Id(reader.next_word()?),
                    }
                }
                345u16 => {
                    Self::GroupNonUniformShuffle {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        execution: Id(reader.next_word()?),
                        value: Id(reader.next_word()?),
                        id: Id(reader.next_word()?),
                    }
                }
                346u16 => {
                    Self::GroupNonUniformShuffleXor {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        execution: Id(reader.next_word()?),
                        value: Id(reader.next_word()?),
                        mask: Id(reader.next_word()?),
                    }
                }
                347u16 => {
                    Self::GroupNonUniformShuffleUp {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        execution: Id(reader.next_word()?),
                        value: Id(reader.next_word()?),
                        delta: Id(reader.next_word()?),
                    }
                }
                348u16 => {
                    Self::GroupNonUniformShuffleDown {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        execution: Id(reader.next_word()?),
                        value: Id(reader.next_word()?),
                        delta: Id(reader.next_word()?),
                    }
                }
                349u16 => {
                    Self::GroupNonUniformIAdd {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        execution: Id(reader.next_word()?),
                        operation: GroupOperation::parse(reader)?,
                        value: Id(reader.next_word()?),
                        cluster_size: if !reader.is_empty() {
                            Some(Id(reader.next_word()?))
                        } else {
                            None
                        },
                    }
                }
                350u16 => {
                    Self::GroupNonUniformFAdd {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        execution: Id(reader.next_word()?),
                        operation: GroupOperation::parse(reader)?,
                        value: Id(reader.next_word()?),
                        cluster_size: if !reader.is_empty() {
                            Some(Id(reader.next_word()?))
                        } else {
                            None
                        },
                    }
                }
                351u16 => {
                    Self::GroupNonUniformIMul {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        execution: Id(reader.next_word()?),
                        operation: GroupOperation::parse(reader)?,
                        value: Id(reader.next_word()?),
                        cluster_size: if !reader.is_empty() {
                            Some(Id(reader.next_word()?))
                        } else {
                            None
                        },
                    }
                }
                352u16 => {
                    Self::GroupNonUniformFMul {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        execution: Id(reader.next_word()?),
                        operation: GroupOperation::parse(reader)?,
                        value: Id(reader.next_word()?),
                        cluster_size: if !reader.is_empty() {
                            Some(Id(reader.next_word()?))
                        } else {
                            None
                        },
                    }
                }
                353u16 => {
                    Self::GroupNonUniformSMin {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        execution: Id(reader.next_word()?),
                        operation: GroupOperation::parse(reader)?,
                        value: Id(reader.next_word()?),
                        cluster_size: if !reader.is_empty() {
                            Some(Id(reader.next_word()?))
                        } else {
                            None
                        },
                    }
                }
                354u16 => {
                    Self::GroupNonUniformUMin {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        execution: Id(reader.next_word()?),
                        operation: GroupOperation::parse(reader)?,
                        value: Id(reader.next_word()?),
                        cluster_size: if !reader.is_empty() {
                            Some(Id(reader.next_word()?))
                        } else {
                            None
                        },
                    }
                }
                355u16 => {
                    Self::GroupNonUniformFMin {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        execution: Id(reader.next_word()?),
                        operation: GroupOperation::parse(reader)?,
                        value: Id(reader.next_word()?),
                        cluster_size: if !reader.is_empty() {
                            Some(Id(reader.next_word()?))
                        } else {
                            None
                        },
                    }
                }
                356u16 => {
                    Self::GroupNonUniformSMax {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        execution: Id(reader.next_word()?),
                        operation: GroupOperation::parse(reader)?,
                        value: Id(reader.next_word()?),
                        cluster_size: if !reader.is_empty() {
                            Some(Id(reader.next_word()?))
                        } else {
                            None
                        },
                    }
                }
                357u16 => {
                    Self::GroupNonUniformUMax {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        execution: Id(reader.next_word()?),
                        operation: GroupOperation::parse(reader)?,
                        value: Id(reader.next_word()?),
                        cluster_size: if !reader.is_empty() {
                            Some(Id(reader.next_word()?))
                        } else {
                            None
                        },
                    }
                }
                358u16 => {
                    Self::GroupNonUniformFMax {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        execution: Id(reader.next_word()?),
                        operation: GroupOperation::parse(reader)?,
                        value: Id(reader.next_word()?),
                        cluster_size: if !reader.is_empty() {
                            Some(Id(reader.next_word()?))
                        } else {
                            None
                        },
                    }
                }
                359u16 => {
                    Self::GroupNonUniformBitwiseAnd {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        execution: Id(reader.next_word()?),
                        operation: GroupOperation::parse(reader)?,
                        value: Id(reader.next_word()?),
                        cluster_size: if !reader.is_empty() {
                            Some(Id(reader.next_word()?))
                        } else {
                            None
                        },
                    }
                }
                360u16 => {
                    Self::GroupNonUniformBitwiseOr {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        execution: Id(reader.next_word()?),
                        operation: GroupOperation::parse(reader)?,
                        value: Id(reader.next_word()?),
                        cluster_size: if !reader.is_empty() {
                            Some(Id(reader.next_word()?))
                        } else {
                            None
                        },
                    }
                }
                361u16 => {
                    Self::GroupNonUniformBitwiseXor {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        execution: Id(reader.next_word()?),
                        operation: GroupOperation::parse(reader)?,
                        value: Id(reader.next_word()?),
                        cluster_size: if !reader.is_empty() {
                            Some(Id(reader.next_word()?))
                        } else {
                            None
                        },
                    }
                }
                362u16 => {
                    Self::GroupNonUniformLogicalAnd {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        execution: Id(reader.next_word()?),
                        operation: GroupOperation::parse(reader)?,
                        value: Id(reader.next_word()?),
                        cluster_size: if !reader.is_empty() {
                            Some(Id(reader.next_word()?))
                        } else {
                            None
                        },
                    }
                }
                363u16 => {
                    Self::GroupNonUniformLogicalOr {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        execution: Id(reader.next_word()?),
                        operation: GroupOperation::parse(reader)?,
                        value: Id(reader.next_word()?),
                        cluster_size: if !reader.is_empty() {
                            Some(Id(reader.next_word()?))
                        } else {
                            None
                        },
                    }
                }
                364u16 => {
                    Self::GroupNonUniformLogicalXor {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        execution: Id(reader.next_word()?),
                        operation: GroupOperation::parse(reader)?,
                        value: Id(reader.next_word()?),
                        cluster_size: if !reader.is_empty() {
                            Some(Id(reader.next_word()?))
                        } else {
                            None
                        },
                    }
                }
                365u16 => {
                    Self::GroupNonUniformQuadBroadcast {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        execution: Id(reader.next_word()?),
                        value: Id(reader.next_word()?),
                        index: Id(reader.next_word()?),
                    }
                }
                366u16 => {
                    Self::GroupNonUniformQuadSwap {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        execution: Id(reader.next_word()?),
                        value: Id(reader.next_word()?),
                        direction: Id(reader.next_word()?),
                    }
                }
                400u16 => {
                    Self::CopyLogical {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        operand: Id(reader.next_word()?),
                    }
                }
                401u16 => {
                    Self::PtrEqual {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        operand1: Id(reader.next_word()?),
                        operand2: Id(reader.next_word()?),
                    }
                }
                402u16 => {
                    Self::PtrNotEqual {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        operand1: Id(reader.next_word()?),
                        operand2: Id(reader.next_word()?),
                    }
                }
                403u16 => {
                    Self::PtrDiff {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        operand1: Id(reader.next_word()?),
                        operand2: Id(reader.next_word()?),
                    }
                }
                4160u16 => {
                    Self::ColorAttachmentReadEXT {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        attachment: Id(reader.next_word()?),
                        sample: if !reader.is_empty() {
                            Some(Id(reader.next_word()?))
                        } else {
                            None
                        },
                    }
                }
                4161u16 => {
                    Self::DepthAttachmentReadEXT {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        sample: if !reader.is_empty() {
                            Some(Id(reader.next_word()?))
                        } else {
                            None
                        },
                    }
                }
                4162u16 => {
                    Self::StencilAttachmentReadEXT {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        sample: if !reader.is_empty() {
                            Some(Id(reader.next_word()?))
                        } else {
                            None
                        },
                    }
                }
                4416u16 => Self::TerminateInvocation,
                4421u16 => {
                    Self::SubgroupBallotKHR {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        predicate: Id(reader.next_word()?),
                    }
                }
                4422u16 => {
                    Self::SubgroupFirstInvocationKHR {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        value: Id(reader.next_word()?),
                    }
                }
                4428u16 => {
                    Self::SubgroupAllKHR {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        predicate: Id(reader.next_word()?),
                    }
                }
                4429u16 => {
                    Self::SubgroupAnyKHR {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        predicate: Id(reader.next_word()?),
                    }
                }
                4430u16 => {
                    Self::SubgroupAllEqualKHR {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        predicate: Id(reader.next_word()?),
                    }
                }
                4431u16 => {
                    Self::GroupNonUniformRotateKHR {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        execution: Id(reader.next_word()?),
                        value: Id(reader.next_word()?),
                        delta: Id(reader.next_word()?),
                        cluster_size: if !reader.is_empty() {
                            Some(Id(reader.next_word()?))
                        } else {
                            None
                        },
                    }
                }
                4432u16 => {
                    Self::SubgroupReadInvocationKHR {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        value: Id(reader.next_word()?),
                        index: Id(reader.next_word()?),
                    }
                }
                4445u16 => {
                    Self::TraceRayKHR {
                        accel: Id(reader.next_word()?),
                        ray_flags: Id(reader.next_word()?),
                        cull_mask: Id(reader.next_word()?),
                        sbt_offset: Id(reader.next_word()?),
                        sbt_stride: Id(reader.next_word()?),
                        miss_index: Id(reader.next_word()?),
                        ray_origin: Id(reader.next_word()?),
                        ray_tmin: Id(reader.next_word()?),
                        ray_direction: Id(reader.next_word()?),
                        ray_tmax: Id(reader.next_word()?),
                        payload: Id(reader.next_word()?),
                    }
                }
                4446u16 => {
                    Self::ExecuteCallableKHR {
                        sbt_index: Id(reader.next_word()?),
                        callable_data: Id(reader.next_word()?),
                    }
                }
                4447u16 => {
                    Self::ConvertUToAccelerationStructureKHR {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        accel: Id(reader.next_word()?),
                    }
                }
                4448u16 => Self::IgnoreIntersectionKHR,
                4449u16 => Self::TerminateRayKHR,
                4450u16 => {
                    Self::SDot {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        vector_1: Id(reader.next_word()?),
                        vector_2: Id(reader.next_word()?),
                        packed_vector_format: if !reader.is_empty() {
                            Some(PackedVectorFormat::parse(reader)?)
                        } else {
                            None
                        },
                    }
                }
                4451u16 => {
                    Self::UDot {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        vector_1: Id(reader.next_word()?),
                        vector_2: Id(reader.next_word()?),
                        packed_vector_format: if !reader.is_empty() {
                            Some(PackedVectorFormat::parse(reader)?)
                        } else {
                            None
                        },
                    }
                }
                4452u16 => {
                    Self::SUDot {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        vector_1: Id(reader.next_word()?),
                        vector_2: Id(reader.next_word()?),
                        packed_vector_format: if !reader.is_empty() {
                            Some(PackedVectorFormat::parse(reader)?)
                        } else {
                            None
                        },
                    }
                }
                4453u16 => {
                    Self::SDotAccSat {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        vector_1: Id(reader.next_word()?),
                        vector_2: Id(reader.next_word()?),
                        accumulator: Id(reader.next_word()?),
                        packed_vector_format: if !reader.is_empty() {
                            Some(PackedVectorFormat::parse(reader)?)
                        } else {
                            None
                        },
                    }
                }
                4454u16 => {
                    Self::UDotAccSat {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        vector_1: Id(reader.next_word()?),
                        vector_2: Id(reader.next_word()?),
                        accumulator: Id(reader.next_word()?),
                        packed_vector_format: if !reader.is_empty() {
                            Some(PackedVectorFormat::parse(reader)?)
                        } else {
                            None
                        },
                    }
                }
                4455u16 => {
                    Self::SUDotAccSat {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        vector_1: Id(reader.next_word()?),
                        vector_2: Id(reader.next_word()?),
                        accumulator: Id(reader.next_word()?),
                        packed_vector_format: if !reader.is_empty() {
                            Some(PackedVectorFormat::parse(reader)?)
                        } else {
                            None
                        },
                    }
                }
                4456u16 => {
                    Self::TypeCooperativeMatrixKHR {
                        result_id: Id(reader.next_word()?),
                        component_type: Id(reader.next_word()?),
                        scope: Id(reader.next_word()?),
                        rows: Id(reader.next_word()?),
                        columns: Id(reader.next_word()?),
                        usage: Id(reader.next_word()?),
                    }
                }
                4457u16 => {
                    Self::CooperativeMatrixLoadKHR {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        pointer: Id(reader.next_word()?),
                        memory_layout: Id(reader.next_word()?),
                        stride: if !reader.is_empty() {
                            Some(Id(reader.next_word()?))
                        } else {
                            None
                        },
                        memory_operand: if !reader.is_empty() {
                            Some(MemoryAccess::parse(reader)?)
                        } else {
                            None
                        },
                    }
                }
                4458u16 => {
                    Self::CooperativeMatrixStoreKHR {
                        pointer: Id(reader.next_word()?),
                        object: Id(reader.next_word()?),
                        memory_layout: Id(reader.next_word()?),
                        stride: if !reader.is_empty() {
                            Some(Id(reader.next_word()?))
                        } else {
                            None
                        },
                        memory_operand: if !reader.is_empty() {
                            Some(MemoryAccess::parse(reader)?)
                        } else {
                            None
                        },
                    }
                }
                4459u16 => {
                    Self::CooperativeMatrixMulAddKHR {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        a: Id(reader.next_word()?),
                        b: Id(reader.next_word()?),
                        c: Id(reader.next_word()?),
                        cooperative_matrix_operands: if !reader.is_empty() {
                            Some(CooperativeMatrixOperands::parse(reader)?)
                        } else {
                            None
                        },
                    }
                }
                4460u16 => {
                    Self::CooperativeMatrixLengthKHR {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        ty: Id(reader.next_word()?),
                    }
                }
                4472u16 => {
                    Self::TypeRayQueryKHR {
                        result_id: Id(reader.next_word()?),
                    }
                }
                4473u16 => {
                    Self::RayQueryInitializeKHR {
                        ray_query: Id(reader.next_word()?),
                        accel: Id(reader.next_word()?),
                        ray_flags: Id(reader.next_word()?),
                        cull_mask: Id(reader.next_word()?),
                        ray_origin: Id(reader.next_word()?),
                        ray_t_min: Id(reader.next_word()?),
                        ray_direction: Id(reader.next_word()?),
                        ray_t_max: Id(reader.next_word()?),
                    }
                }
                4474u16 => {
                    Self::RayQueryTerminateKHR {
                        ray_query: Id(reader.next_word()?),
                    }
                }
                4475u16 => {
                    Self::RayQueryGenerateIntersectionKHR {
                        ray_query: Id(reader.next_word()?),
                        hit_t: Id(reader.next_word()?),
                    }
                }
                4476u16 => {
                    Self::RayQueryConfirmIntersectionKHR {
                        ray_query: Id(reader.next_word()?),
                    }
                }
                4477u16 => {
                    Self::RayQueryProceedKHR {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        ray_query: Id(reader.next_word()?),
                    }
                }
                4479u16 => {
                    Self::RayQueryGetIntersectionTypeKHR {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        ray_query: Id(reader.next_word()?),
                        intersection: Id(reader.next_word()?),
                    }
                }
                4480u16 => {
                    Self::ImageSampleWeightedQCOM {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        texture: Id(reader.next_word()?),
                        coordinates: Id(reader.next_word()?),
                        weights: Id(reader.next_word()?),
                    }
                }
                4481u16 => {
                    Self::ImageBoxFilterQCOM {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        texture: Id(reader.next_word()?),
                        coordinates: Id(reader.next_word()?),
                        box_size: Id(reader.next_word()?),
                    }
                }
                4482u16 => {
                    Self::ImageBlockMatchSSDQCOM {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        target: Id(reader.next_word()?),
                        target_coordinates: Id(reader.next_word()?),
                        reference: Id(reader.next_word()?),
                        reference_coordinates: Id(reader.next_word()?),
                        block_size: Id(reader.next_word()?),
                    }
                }
                4483u16 => {
                    Self::ImageBlockMatchSADQCOM {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        target: Id(reader.next_word()?),
                        target_coordinates: Id(reader.next_word()?),
                        reference: Id(reader.next_word()?),
                        reference_coordinates: Id(reader.next_word()?),
                        block_size: Id(reader.next_word()?),
                    }
                }
                4500u16 => {
                    Self::ImageBlockMatchWindowSSDQCOM {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        target_sampled_image: Id(reader.next_word()?),
                        target_coordinates: Id(reader.next_word()?),
                        reference_sampled_image: Id(reader.next_word()?),
                        reference_coordinates: Id(reader.next_word()?),
                        block_size: Id(reader.next_word()?),
                    }
                }
                4501u16 => {
                    Self::ImageBlockMatchWindowSADQCOM {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        target_sampled_image: Id(reader.next_word()?),
                        target_coordinates: Id(reader.next_word()?),
                        reference_sampled_image: Id(reader.next_word()?),
                        reference_coordinates: Id(reader.next_word()?),
                        block_size: Id(reader.next_word()?),
                    }
                }
                4502u16 => {
                    Self::ImageBlockMatchGatherSSDQCOM {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        target_sampled_image: Id(reader.next_word()?),
                        target_coordinates: Id(reader.next_word()?),
                        reference_sampled_image: Id(reader.next_word()?),
                        reference_coordinates: Id(reader.next_word()?),
                        block_size: Id(reader.next_word()?),
                    }
                }
                4503u16 => {
                    Self::ImageBlockMatchGatherSADQCOM {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        target_sampled_image: Id(reader.next_word()?),
                        target_coordinates: Id(reader.next_word()?),
                        reference_sampled_image: Id(reader.next_word()?),
                        reference_coordinates: Id(reader.next_word()?),
                        block_size: Id(reader.next_word()?),
                    }
                }
                5000u16 => {
                    Self::GroupIAddNonUniformAMD {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        execution: Id(reader.next_word()?),
                        operation: GroupOperation::parse(reader)?,
                        x: Id(reader.next_word()?),
                    }
                }
                5001u16 => {
                    Self::GroupFAddNonUniformAMD {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        execution: Id(reader.next_word()?),
                        operation: GroupOperation::parse(reader)?,
                        x: Id(reader.next_word()?),
                    }
                }
                5002u16 => {
                    Self::GroupFMinNonUniformAMD {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        execution: Id(reader.next_word()?),
                        operation: GroupOperation::parse(reader)?,
                        x: Id(reader.next_word()?),
                    }
                }
                5003u16 => {
                    Self::GroupUMinNonUniformAMD {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        execution: Id(reader.next_word()?),
                        operation: GroupOperation::parse(reader)?,
                        x: Id(reader.next_word()?),
                    }
                }
                5004u16 => {
                    Self::GroupSMinNonUniformAMD {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        execution: Id(reader.next_word()?),
                        operation: GroupOperation::parse(reader)?,
                        x: Id(reader.next_word()?),
                    }
                }
                5005u16 => {
                    Self::GroupFMaxNonUniformAMD {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        execution: Id(reader.next_word()?),
                        operation: GroupOperation::parse(reader)?,
                        x: Id(reader.next_word()?),
                    }
                }
                5006u16 => {
                    Self::GroupUMaxNonUniformAMD {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        execution: Id(reader.next_word()?),
                        operation: GroupOperation::parse(reader)?,
                        x: Id(reader.next_word()?),
                    }
                }
                5007u16 => {
                    Self::GroupSMaxNonUniformAMD {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        execution: Id(reader.next_word()?),
                        operation: GroupOperation::parse(reader)?,
                        x: Id(reader.next_word()?),
                    }
                }
                5011u16 => {
                    Self::FragmentMaskFetchAMD {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        image: Id(reader.next_word()?),
                        coordinate: Id(reader.next_word()?),
                    }
                }
                5012u16 => {
                    Self::FragmentFetchAMD {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        image: Id(reader.next_word()?),
                        coordinate: Id(reader.next_word()?),
                        fragment_index: Id(reader.next_word()?),
                    }
                }
                5056u16 => {
                    Self::ReadClockKHR {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        scope: Id(reader.next_word()?),
                    }
                }
                5075u16 => {
                    Self::FinalizeNodePayloadsAMDX {
                        payload_array: Id(reader.next_word()?),
                    }
                }
                5078u16 => {
                    Self::FinishWritingNodePayloadAMDX {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        payload: Id(reader.next_word()?),
                    }
                }
                5090u16 => {
                    Self::InitializeNodePayloadsAMDX {
                        payload_array: Id(reader.next_word()?),
                        visibility: Id(reader.next_word()?),
                        payload_count: Id(reader.next_word()?),
                        node_index: Id(reader.next_word()?),
                    }
                }
                5110u16 => {
                    Self::GroupNonUniformQuadAllKHR {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        predicate: Id(reader.next_word()?),
                    }
                }
                5111u16 => {
                    Self::GroupNonUniformQuadAnyKHR {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        predicate: Id(reader.next_word()?),
                    }
                }
                5249u16 => {
                    Self::HitObjectRecordHitMotionNV {
                        hit_object: Id(reader.next_word()?),
                        acceleration_structure: Id(reader.next_word()?),
                        instance_id: Id(reader.next_word()?),
                        primitive_id: Id(reader.next_word()?),
                        geometry_index: Id(reader.next_word()?),
                        hit_kind: Id(reader.next_word()?),
                        sbt_record_offset: Id(reader.next_word()?),
                        sbt_record_stride: Id(reader.next_word()?),
                        origin: Id(reader.next_word()?),
                        t_min: Id(reader.next_word()?),
                        direction: Id(reader.next_word()?),
                        t_max: Id(reader.next_word()?),
                        current_time: Id(reader.next_word()?),
                        hit_object_attributes: Id(reader.next_word()?),
                    }
                }
                5250u16 => {
                    Self::HitObjectRecordHitWithIndexMotionNV {
                        hit_object: Id(reader.next_word()?),
                        acceleration_structure: Id(reader.next_word()?),
                        instance_id: Id(reader.next_word()?),
                        primitive_id: Id(reader.next_word()?),
                        geometry_index: Id(reader.next_word()?),
                        hit_kind: Id(reader.next_word()?),
                        sbt_record_index: Id(reader.next_word()?),
                        origin: Id(reader.next_word()?),
                        t_min: Id(reader.next_word()?),
                        direction: Id(reader.next_word()?),
                        t_max: Id(reader.next_word()?),
                        current_time: Id(reader.next_word()?),
                        hit_object_attributes: Id(reader.next_word()?),
                    }
                }
                5251u16 => {
                    Self::HitObjectRecordMissMotionNV {
                        hit_object: Id(reader.next_word()?),
                        sbt_index: Id(reader.next_word()?),
                        origin: Id(reader.next_word()?),
                        t_min: Id(reader.next_word()?),
                        direction: Id(reader.next_word()?),
                        t_max: Id(reader.next_word()?),
                        current_time: Id(reader.next_word()?),
                    }
                }
                5252u16 => {
                    Self::HitObjectGetWorldToObjectNV {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        hit_object: Id(reader.next_word()?),
                    }
                }
                5253u16 => {
                    Self::HitObjectGetObjectToWorldNV {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        hit_object: Id(reader.next_word()?),
                    }
                }
                5254u16 => {
                    Self::HitObjectGetObjectRayDirectionNV {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        hit_object: Id(reader.next_word()?),
                    }
                }
                5255u16 => {
                    Self::HitObjectGetObjectRayOriginNV {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        hit_object: Id(reader.next_word()?),
                    }
                }
                5256u16 => {
                    Self::HitObjectTraceRayMotionNV {
                        hit_object: Id(reader.next_word()?),
                        acceleration_structure: Id(reader.next_word()?),
                        ray_flags: Id(reader.next_word()?),
                        cullmask: Id(reader.next_word()?),
                        sbt_record_offset: Id(reader.next_word()?),
                        sbt_record_stride: Id(reader.next_word()?),
                        miss_index: Id(reader.next_word()?),
                        origin: Id(reader.next_word()?),
                        t_min: Id(reader.next_word()?),
                        direction: Id(reader.next_word()?),
                        t_max: Id(reader.next_word()?),
                        time: Id(reader.next_word()?),
                        payload: Id(reader.next_word()?),
                    }
                }
                5257u16 => {
                    Self::HitObjectGetShaderRecordBufferHandleNV {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        hit_object: Id(reader.next_word()?),
                    }
                }
                5258u16 => {
                    Self::HitObjectGetShaderBindingTableRecordIndexNV {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        hit_object: Id(reader.next_word()?),
                    }
                }
                5259u16 => {
                    Self::HitObjectRecordEmptyNV {
                        hit_object: Id(reader.next_word()?),
                    }
                }
                5260u16 => {
                    Self::HitObjectTraceRayNV {
                        hit_object: Id(reader.next_word()?),
                        acceleration_structure: Id(reader.next_word()?),
                        ray_flags: Id(reader.next_word()?),
                        cullmask: Id(reader.next_word()?),
                        sbt_record_offset: Id(reader.next_word()?),
                        sbt_record_stride: Id(reader.next_word()?),
                        miss_index: Id(reader.next_word()?),
                        origin: Id(reader.next_word()?),
                        t_min: Id(reader.next_word()?),
                        direction: Id(reader.next_word()?),
                        t_max: Id(reader.next_word()?),
                        payload: Id(reader.next_word()?),
                    }
                }
                5261u16 => {
                    Self::HitObjectRecordHitNV {
                        hit_object: Id(reader.next_word()?),
                        acceleration_structure: Id(reader.next_word()?),
                        instance_id: Id(reader.next_word()?),
                        primitive_id: Id(reader.next_word()?),
                        geometry_index: Id(reader.next_word()?),
                        hit_kind: Id(reader.next_word()?),
                        sbt_record_offset: Id(reader.next_word()?),
                        sbt_record_stride: Id(reader.next_word()?),
                        origin: Id(reader.next_word()?),
                        t_min: Id(reader.next_word()?),
                        direction: Id(reader.next_word()?),
                        t_max: Id(reader.next_word()?),
                        hit_object_attributes: Id(reader.next_word()?),
                    }
                }
                5262u16 => {
                    Self::HitObjectRecordHitWithIndexNV {
                        hit_object: Id(reader.next_word()?),
                        acceleration_structure: Id(reader.next_word()?),
                        instance_id: Id(reader.next_word()?),
                        primitive_id: Id(reader.next_word()?),
                        geometry_index: Id(reader.next_word()?),
                        hit_kind: Id(reader.next_word()?),
                        sbt_record_index: Id(reader.next_word()?),
                        origin: Id(reader.next_word()?),
                        t_min: Id(reader.next_word()?),
                        direction: Id(reader.next_word()?),
                        t_max: Id(reader.next_word()?),
                        hit_object_attributes: Id(reader.next_word()?),
                    }
                }
                5263u16 => {
                    Self::HitObjectRecordMissNV {
                        hit_object: Id(reader.next_word()?),
                        sbt_index: Id(reader.next_word()?),
                        origin: Id(reader.next_word()?),
                        t_min: Id(reader.next_word()?),
                        direction: Id(reader.next_word()?),
                        t_max: Id(reader.next_word()?),
                    }
                }
                5264u16 => {
                    Self::HitObjectExecuteShaderNV {
                        hit_object: Id(reader.next_word()?),
                        payload: Id(reader.next_word()?),
                    }
                }
                5265u16 => {
                    Self::HitObjectGetCurrentTimeNV {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        hit_object: Id(reader.next_word()?),
                    }
                }
                5266u16 => {
                    Self::HitObjectGetAttributesNV {
                        hit_object: Id(reader.next_word()?),
                        hit_object_attribute: Id(reader.next_word()?),
                    }
                }
                5267u16 => {
                    Self::HitObjectGetHitKindNV {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        hit_object: Id(reader.next_word()?),
                    }
                }
                5268u16 => {
                    Self::HitObjectGetPrimitiveIndexNV {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        hit_object: Id(reader.next_word()?),
                    }
                }
                5269u16 => {
                    Self::HitObjectGetGeometryIndexNV {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        hit_object: Id(reader.next_word()?),
                    }
                }
                5270u16 => {
                    Self::HitObjectGetInstanceIdNV {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        hit_object: Id(reader.next_word()?),
                    }
                }
                5271u16 => {
                    Self::HitObjectGetInstanceCustomIndexNV {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        hit_object: Id(reader.next_word()?),
                    }
                }
                5272u16 => {
                    Self::HitObjectGetWorldRayDirectionNV {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        hit_object: Id(reader.next_word()?),
                    }
                }
                5273u16 => {
                    Self::HitObjectGetWorldRayOriginNV {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        hit_object: Id(reader.next_word()?),
                    }
                }
                5274u16 => {
                    Self::HitObjectGetRayTMaxNV {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        hit_object: Id(reader.next_word()?),
                    }
                }
                5275u16 => {
                    Self::HitObjectGetRayTMinNV {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        hit_object: Id(reader.next_word()?),
                    }
                }
                5276u16 => {
                    Self::HitObjectIsEmptyNV {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        hit_object: Id(reader.next_word()?),
                    }
                }
                5277u16 => {
                    Self::HitObjectIsHitNV {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        hit_object: Id(reader.next_word()?),
                    }
                }
                5278u16 => {
                    Self::HitObjectIsMissNV {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        hit_object: Id(reader.next_word()?),
                    }
                }
                5279u16 => {
                    Self::ReorderThreadWithHitObjectNV {
                        hit_object: Id(reader.next_word()?),
                        hint: if !reader.is_empty() {
                            Some(Id(reader.next_word()?))
                        } else {
                            None
                        },
                        bits: if !reader.is_empty() {
                            Some(Id(reader.next_word()?))
                        } else {
                            None
                        },
                    }
                }
                5280u16 => {
                    Self::ReorderThreadWithHintNV {
                        hint: Id(reader.next_word()?),
                        bits: Id(reader.next_word()?),
                    }
                }
                5281u16 => {
                    Self::TypeHitObjectNV {
                        result_id: Id(reader.next_word()?),
                    }
                }
                5283u16 => {
                    Self::ImageSampleFootprintNV {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        sampled_image: Id(reader.next_word()?),
                        coordinate: Id(reader.next_word()?),
                        granularity: Id(reader.next_word()?),
                        coarse: Id(reader.next_word()?),
                        image_operands: if !reader.is_empty() {
                            Some(ImageOperands::parse(reader)?)
                        } else {
                            None
                        },
                    }
                }
                5294u16 => {
                    Self::EmitMeshTasksEXT {
                        group_count_x: Id(reader.next_word()?),
                        group_count_y: Id(reader.next_word()?),
                        group_count_z: Id(reader.next_word()?),
                        payload: if !reader.is_empty() {
                            Some(Id(reader.next_word()?))
                        } else {
                            None
                        },
                    }
                }
                5295u16 => {
                    Self::SetMeshOutputsEXT {
                        vertex_count: Id(reader.next_word()?),
                        primitive_count: Id(reader.next_word()?),
                    }
                }
                5296u16 => {
                    Self::GroupNonUniformPartitionNV {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        value: Id(reader.next_word()?),
                    }
                }
                5299u16 => {
                    Self::WritePackedPrimitiveIndices4x8NV {
                        index_offset: Id(reader.next_word()?),
                        packed_indices: Id(reader.next_word()?),
                    }
                }
                5300u16 => {
                    Self::FetchMicroTriangleVertexPositionNV {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        accel: Id(reader.next_word()?),
                        instance_id: Id(reader.next_word()?),
                        geometry_index: Id(reader.next_word()?),
                        primitive_index: Id(reader.next_word()?),
                        barycentric: Id(reader.next_word()?),
                    }
                }
                5301u16 => {
                    Self::FetchMicroTriangleVertexBarycentricNV {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        accel: Id(reader.next_word()?),
                        instance_id: Id(reader.next_word()?),
                        geometry_index: Id(reader.next_word()?),
                        primitive_index: Id(reader.next_word()?),
                        barycentric: Id(reader.next_word()?),
                    }
                }
                5334u16 => {
                    Self::ReportIntersectionKHR {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        hit: Id(reader.next_word()?),
                        hit_kind: Id(reader.next_word()?),
                    }
                }
                5335u16 => Self::IgnoreIntersectionNV,
                5336u16 => Self::TerminateRayNV,
                5337u16 => {
                    Self::TraceNV {
                        accel: Id(reader.next_word()?),
                        ray_flags: Id(reader.next_word()?),
                        cull_mask: Id(reader.next_word()?),
                        sbt_offset: Id(reader.next_word()?),
                        sbt_stride: Id(reader.next_word()?),
                        miss_index: Id(reader.next_word()?),
                        ray_origin: Id(reader.next_word()?),
                        ray_tmin: Id(reader.next_word()?),
                        ray_direction: Id(reader.next_word()?),
                        ray_tmax: Id(reader.next_word()?),
                        payload_id: Id(reader.next_word()?),
                    }
                }
                5338u16 => {
                    Self::TraceMotionNV {
                        accel: Id(reader.next_word()?),
                        ray_flags: Id(reader.next_word()?),
                        cull_mask: Id(reader.next_word()?),
                        sbt_offset: Id(reader.next_word()?),
                        sbt_stride: Id(reader.next_word()?),
                        miss_index: Id(reader.next_word()?),
                        ray_origin: Id(reader.next_word()?),
                        ray_tmin: Id(reader.next_word()?),
                        ray_direction: Id(reader.next_word()?),
                        ray_tmax: Id(reader.next_word()?),
                        time: Id(reader.next_word()?),
                        payload_id: Id(reader.next_word()?),
                    }
                }
                5339u16 => {
                    Self::TraceRayMotionNV {
                        accel: Id(reader.next_word()?),
                        ray_flags: Id(reader.next_word()?),
                        cull_mask: Id(reader.next_word()?),
                        sbt_offset: Id(reader.next_word()?),
                        sbt_stride: Id(reader.next_word()?),
                        miss_index: Id(reader.next_word()?),
                        ray_origin: Id(reader.next_word()?),
                        ray_tmin: Id(reader.next_word()?),
                        ray_direction: Id(reader.next_word()?),
                        ray_tmax: Id(reader.next_word()?),
                        time: Id(reader.next_word()?),
                        payload: Id(reader.next_word()?),
                    }
                }
                5340u16 => {
                    Self::RayQueryGetIntersectionTriangleVertexPositionsKHR {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        ray_query: Id(reader.next_word()?),
                        intersection: Id(reader.next_word()?),
                    }
                }
                5341u16 => {
                    Self::TypeAccelerationStructureKHR {
                        result_id: Id(reader.next_word()?),
                    }
                }
                5344u16 => {
                    Self::ExecuteCallableNV {
                        sbt_index: Id(reader.next_word()?),
                        callable_data_id: Id(reader.next_word()?),
                    }
                }
                5358u16 => {
                    Self::TypeCooperativeMatrixNV {
                        result_id: Id(reader.next_word()?),
                        component_type: Id(reader.next_word()?),
                        execution: Id(reader.next_word()?),
                        rows: Id(reader.next_word()?),
                        columns: Id(reader.next_word()?),
                    }
                }
                5359u16 => {
                    Self::CooperativeMatrixLoadNV {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        pointer: Id(reader.next_word()?),
                        stride: Id(reader.next_word()?),
                        column_major: Id(reader.next_word()?),
                        memory_access: if !reader.is_empty() {
                            Some(MemoryAccess::parse(reader)?)
                        } else {
                            None
                        },
                    }
                }
                5360u16 => {
                    Self::CooperativeMatrixStoreNV {
                        pointer: Id(reader.next_word()?),
                        object: Id(reader.next_word()?),
                        stride: Id(reader.next_word()?),
                        column_major: Id(reader.next_word()?),
                        memory_access: if !reader.is_empty() {
                            Some(MemoryAccess::parse(reader)?)
                        } else {
                            None
                        },
                    }
                }
                5361u16 => {
                    Self::CooperativeMatrixMulAddNV {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        a: Id(reader.next_word()?),
                        b: Id(reader.next_word()?),
                        c: Id(reader.next_word()?),
                    }
                }
                5362u16 => {
                    Self::CooperativeMatrixLengthNV {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        ty: Id(reader.next_word()?),
                    }
                }
                5364u16 => Self::BeginInvocationInterlockEXT,
                5365u16 => Self::EndInvocationInterlockEXT,
                5380u16 => Self::DemoteToHelperInvocation,
                5381u16 => {
                    Self::IsHelperInvocationEXT {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                    }
                }
                5391u16 => {
                    Self::ConvertUToImageNV {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        operand: Id(reader.next_word()?),
                    }
                }
                5392u16 => {
                    Self::ConvertUToSamplerNV {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        operand: Id(reader.next_word()?),
                    }
                }
                5393u16 => {
                    Self::ConvertImageToUNV {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        operand: Id(reader.next_word()?),
                    }
                }
                5394u16 => {
                    Self::ConvertSamplerToUNV {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        operand: Id(reader.next_word()?),
                    }
                }
                5395u16 => {
                    Self::ConvertUToSampledImageNV {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        operand: Id(reader.next_word()?),
                    }
                }
                5396u16 => {
                    Self::ConvertSampledImageToUNV {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        operand: Id(reader.next_word()?),
                    }
                }
                5397u16 => {
                    Self::SamplerImageAddressingModeNV {
                        bit_width: reader.next_word()?,
                    }
                }
                5398u16 => {
                    Self::RawAccessChainNV {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        base: Id(reader.next_word()?),
                        byte_stride: Id(reader.next_word()?),
                        element_index: Id(reader.next_word()?),
                        byte_offset: Id(reader.next_word()?),
                        raw_access_chain_operands: if !reader.is_empty() {
                            Some(RawAccessChainOperands::parse(reader)?)
                        } else {
                            None
                        },
                    }
                }
                5571u16 => {
                    Self::SubgroupShuffleINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        data: Id(reader.next_word()?),
                        invocation_id: Id(reader.next_word()?),
                    }
                }
                5572u16 => {
                    Self::SubgroupShuffleDownINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        current: Id(reader.next_word()?),
                        next: Id(reader.next_word()?),
                        delta: Id(reader.next_word()?),
                    }
                }
                5573u16 => {
                    Self::SubgroupShuffleUpINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        previous: Id(reader.next_word()?),
                        current: Id(reader.next_word()?),
                        delta: Id(reader.next_word()?),
                    }
                }
                5574u16 => {
                    Self::SubgroupShuffleXorINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        data: Id(reader.next_word()?),
                        value: Id(reader.next_word()?),
                    }
                }
                5575u16 => {
                    Self::SubgroupBlockReadINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        ptr: Id(reader.next_word()?),
                    }
                }
                5576u16 => {
                    Self::SubgroupBlockWriteINTEL {
                        ptr: Id(reader.next_word()?),
                        data: Id(reader.next_word()?),
                    }
                }
                5577u16 => {
                    Self::SubgroupImageBlockReadINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        image: Id(reader.next_word()?),
                        coordinate: Id(reader.next_word()?),
                    }
                }
                5578u16 => {
                    Self::SubgroupImageBlockWriteINTEL {
                        image: Id(reader.next_word()?),
                        coordinate: Id(reader.next_word()?),
                        data: Id(reader.next_word()?),
                    }
                }
                5580u16 => {
                    Self::SubgroupImageMediaBlockReadINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        image: Id(reader.next_word()?),
                        coordinate: Id(reader.next_word()?),
                        width: Id(reader.next_word()?),
                        height: Id(reader.next_word()?),
                    }
                }
                5581u16 => {
                    Self::SubgroupImageMediaBlockWriteINTEL {
                        image: Id(reader.next_word()?),
                        coordinate: Id(reader.next_word()?),
                        width: Id(reader.next_word()?),
                        height: Id(reader.next_word()?),
                        data: Id(reader.next_word()?),
                    }
                }
                5585u16 => {
                    Self::UCountLeadingZerosINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        operand: Id(reader.next_word()?),
                    }
                }
                5586u16 => {
                    Self::UCountTrailingZerosINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        operand: Id(reader.next_word()?),
                    }
                }
                5587u16 => {
                    Self::AbsISubINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        operand1: Id(reader.next_word()?),
                        operand2: Id(reader.next_word()?),
                    }
                }
                5588u16 => {
                    Self::AbsUSubINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        operand1: Id(reader.next_word()?),
                        operand2: Id(reader.next_word()?),
                    }
                }
                5589u16 => {
                    Self::IAddSatINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        operand1: Id(reader.next_word()?),
                        operand2: Id(reader.next_word()?),
                    }
                }
                5590u16 => {
                    Self::UAddSatINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        operand1: Id(reader.next_word()?),
                        operand2: Id(reader.next_word()?),
                    }
                }
                5591u16 => {
                    Self::IAverageINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        operand1: Id(reader.next_word()?),
                        operand2: Id(reader.next_word()?),
                    }
                }
                5592u16 => {
                    Self::UAverageINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        operand1: Id(reader.next_word()?),
                        operand2: Id(reader.next_word()?),
                    }
                }
                5593u16 => {
                    Self::IAverageRoundedINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        operand1: Id(reader.next_word()?),
                        operand2: Id(reader.next_word()?),
                    }
                }
                5594u16 => {
                    Self::UAverageRoundedINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        operand1: Id(reader.next_word()?),
                        operand2: Id(reader.next_word()?),
                    }
                }
                5595u16 => {
                    Self::ISubSatINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        operand1: Id(reader.next_word()?),
                        operand2: Id(reader.next_word()?),
                    }
                }
                5596u16 => {
                    Self::USubSatINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        operand1: Id(reader.next_word()?),
                        operand2: Id(reader.next_word()?),
                    }
                }
                5597u16 => {
                    Self::IMul32x16INTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        operand1: Id(reader.next_word()?),
                        operand2: Id(reader.next_word()?),
                    }
                }
                5598u16 => {
                    Self::UMul32x16INTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        operand1: Id(reader.next_word()?),
                        operand2: Id(reader.next_word()?),
                    }
                }
                5600u16 => {
                    Self::ConstantFunctionPointerINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        function: Id(reader.next_word()?),
                    }
                }
                5601u16 => {
                    Self::FunctionPointerCallINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        operand1: {
                            let mut vec = Vec::new();
                            while !reader.is_empty() {
                                vec.push(Id(reader.next_word()?));
                            }
                            vec
                        },
                    }
                }
                5609u16 => {
                    Self::AsmTargetINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        asm_target: reader.next_string()?,
                    }
                }
                5610u16 => {
                    Self::AsmINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        asm_type: Id(reader.next_word()?),
                        target: Id(reader.next_word()?),
                        asm_instructions: reader.next_string()?,
                        constraints: reader.next_string()?,
                    }
                }
                5611u16 => {
                    Self::AsmCallINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        asm: Id(reader.next_word()?),
                        argument_0: {
                            let mut vec = Vec::new();
                            while !reader.is_empty() {
                                vec.push(Id(reader.next_word()?));
                            }
                            vec
                        },
                    }
                }
                5614u16 => {
                    Self::AtomicFMinEXT {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        pointer: Id(reader.next_word()?),
                        memory: Id(reader.next_word()?),
                        semantics: Id(reader.next_word()?),
                        value: Id(reader.next_word()?),
                    }
                }
                5615u16 => {
                    Self::AtomicFMaxEXT {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        pointer: Id(reader.next_word()?),
                        memory: Id(reader.next_word()?),
                        semantics: Id(reader.next_word()?),
                        value: Id(reader.next_word()?),
                    }
                }
                5630u16 => {
                    Self::AssumeTrueKHR {
                        condition: Id(reader.next_word()?),
                    }
                }
                5631u16 => {
                    Self::ExpectKHR {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        value: Id(reader.next_word()?),
                        expected_value: Id(reader.next_word()?),
                    }
                }
                5632u16 => {
                    Self::DecorateString {
                        target: Id(reader.next_word()?),
                        decoration: Decoration::parse(reader)?,
                    }
                }
                5633u16 => {
                    Self::MemberDecorateString {
                        struct_type: Id(reader.next_word()?),
                        member: reader.next_word()?,
                        decoration: Decoration::parse(reader)?,
                    }
                }
                5699u16 => {
                    Self::VmeImageINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        image_type: Id(reader.next_word()?),
                        sampler: Id(reader.next_word()?),
                    }
                }
                5700u16 => {
                    Self::TypeVmeImageINTEL {
                        result_id: Id(reader.next_word()?),
                        image_type: Id(reader.next_word()?),
                    }
                }
                5701u16 => {
                    Self::TypeAvcImePayloadINTEL {
                        result_id: Id(reader.next_word()?),
                    }
                }
                5702u16 => {
                    Self::TypeAvcRefPayloadINTEL {
                        result_id: Id(reader.next_word()?),
                    }
                }
                5703u16 => {
                    Self::TypeAvcSicPayloadINTEL {
                        result_id: Id(reader.next_word()?),
                    }
                }
                5704u16 => {
                    Self::TypeAvcMcePayloadINTEL {
                        result_id: Id(reader.next_word()?),
                    }
                }
                5705u16 => {
                    Self::TypeAvcMceResultINTEL {
                        result_id: Id(reader.next_word()?),
                    }
                }
                5706u16 => {
                    Self::TypeAvcImeResultINTEL {
                        result_id: Id(reader.next_word()?),
                    }
                }
                5707u16 => {
                    Self::TypeAvcImeResultSingleReferenceStreamoutINTEL {
                        result_id: Id(reader.next_word()?),
                    }
                }
                5708u16 => {
                    Self::TypeAvcImeResultDualReferenceStreamoutINTEL {
                        result_id: Id(reader.next_word()?),
                    }
                }
                5709u16 => {
                    Self::TypeAvcImeSingleReferenceStreaminINTEL {
                        result_id: Id(reader.next_word()?),
                    }
                }
                5710u16 => {
                    Self::TypeAvcImeDualReferenceStreaminINTEL {
                        result_id: Id(reader.next_word()?),
                    }
                }
                5711u16 => {
                    Self::TypeAvcRefResultINTEL {
                        result_id: Id(reader.next_word()?),
                    }
                }
                5712u16 => {
                    Self::TypeAvcSicResultINTEL {
                        result_id: Id(reader.next_word()?),
                    }
                }
                5713u16 => {
                    Self::SubgroupAvcMceGetDefaultInterBaseMultiReferencePenaltyINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        slice_type: Id(reader.next_word()?),
                        qp: Id(reader.next_word()?),
                    }
                }
                5714u16 => {
                    Self::SubgroupAvcMceSetInterBaseMultiReferencePenaltyINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        reference_base_penalty: Id(reader.next_word()?),
                        payload: Id(reader.next_word()?),
                    }
                }
                5715u16 => {
                    Self::SubgroupAvcMceGetDefaultInterShapePenaltyINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        slice_type: Id(reader.next_word()?),
                        qp: Id(reader.next_word()?),
                    }
                }
                5716u16 => {
                    Self::SubgroupAvcMceSetInterShapePenaltyINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        packed_shape_penalty: Id(reader.next_word()?),
                        payload: Id(reader.next_word()?),
                    }
                }
                5717u16 => {
                    Self::SubgroupAvcMceGetDefaultInterDirectionPenaltyINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        slice_type: Id(reader.next_word()?),
                        qp: Id(reader.next_word()?),
                    }
                }
                5718u16 => {
                    Self::SubgroupAvcMceSetInterDirectionPenaltyINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        direction_cost: Id(reader.next_word()?),
                        payload: Id(reader.next_word()?),
                    }
                }
                5719u16 => {
                    Self::SubgroupAvcMceGetDefaultIntraLumaShapePenaltyINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        slice_type: Id(reader.next_word()?),
                        qp: Id(reader.next_word()?),
                    }
                }
                5720u16 => {
                    Self::SubgroupAvcMceGetDefaultInterMotionVectorCostTableINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        slice_type: Id(reader.next_word()?),
                        qp: Id(reader.next_word()?),
                    }
                }
                5721u16 => {
                    Self::SubgroupAvcMceGetDefaultHighPenaltyCostTableINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                    }
                }
                5722u16 => {
                    Self::SubgroupAvcMceGetDefaultMediumPenaltyCostTableINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                    }
                }
                5723u16 => {
                    Self::SubgroupAvcMceGetDefaultLowPenaltyCostTableINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                    }
                }
                5724u16 => {
                    Self::SubgroupAvcMceSetMotionVectorCostFunctionINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        packed_cost_center_delta: Id(reader.next_word()?),
                        packed_cost_table: Id(reader.next_word()?),
                        cost_precision: Id(reader.next_word()?),
                        payload: Id(reader.next_word()?),
                    }
                }
                5725u16 => {
                    Self::SubgroupAvcMceGetDefaultIntraLumaModePenaltyINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        slice_type: Id(reader.next_word()?),
                        qp: Id(reader.next_word()?),
                    }
                }
                5726u16 => {
                    Self::SubgroupAvcMceGetDefaultNonDcLumaIntraPenaltyINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                    }
                }
                5727u16 => {
                    Self::SubgroupAvcMceGetDefaultIntraChromaModeBasePenaltyINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                    }
                }
                5728u16 => {
                    Self::SubgroupAvcMceSetAcOnlyHaarINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        payload: Id(reader.next_word()?),
                    }
                }
                5729u16 => {
                    Self::SubgroupAvcMceSetSourceInterlacedFieldPolarityINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        source_field_polarity: Id(reader.next_word()?),
                        payload: Id(reader.next_word()?),
                    }
                }
                5730u16 => {
                    Self::SubgroupAvcMceSetSingleReferenceInterlacedFieldPolarityINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        reference_field_polarity: Id(reader.next_word()?),
                        payload: Id(reader.next_word()?),
                    }
                }
                5731u16 => {
                    Self::SubgroupAvcMceSetDualReferenceInterlacedFieldPolaritiesINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        forward_reference_field_polarity: Id(reader.next_word()?),
                        backward_reference_field_polarity: Id(reader.next_word()?),
                        payload: Id(reader.next_word()?),
                    }
                }
                5732u16 => {
                    Self::SubgroupAvcMceConvertToImePayloadINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        payload: Id(reader.next_word()?),
                    }
                }
                5733u16 => {
                    Self::SubgroupAvcMceConvertToImeResultINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        payload: Id(reader.next_word()?),
                    }
                }
                5734u16 => {
                    Self::SubgroupAvcMceConvertToRefPayloadINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        payload: Id(reader.next_word()?),
                    }
                }
                5735u16 => {
                    Self::SubgroupAvcMceConvertToRefResultINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        payload: Id(reader.next_word()?),
                    }
                }
                5736u16 => {
                    Self::SubgroupAvcMceConvertToSicPayloadINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        payload: Id(reader.next_word()?),
                    }
                }
                5737u16 => {
                    Self::SubgroupAvcMceConvertToSicResultINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        payload: Id(reader.next_word()?),
                    }
                }
                5738u16 => {
                    Self::SubgroupAvcMceGetMotionVectorsINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        payload: Id(reader.next_word()?),
                    }
                }
                5739u16 => {
                    Self::SubgroupAvcMceGetInterDistortionsINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        payload: Id(reader.next_word()?),
                    }
                }
                5740u16 => {
                    Self::SubgroupAvcMceGetBestInterDistortionsINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        payload: Id(reader.next_word()?),
                    }
                }
                5741u16 => {
                    Self::SubgroupAvcMceGetInterMajorShapeINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        payload: Id(reader.next_word()?),
                    }
                }
                5742u16 => {
                    Self::SubgroupAvcMceGetInterMinorShapeINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        payload: Id(reader.next_word()?),
                    }
                }
                5743u16 => {
                    Self::SubgroupAvcMceGetInterDirectionsINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        payload: Id(reader.next_word()?),
                    }
                }
                5744u16 => {
                    Self::SubgroupAvcMceGetInterMotionVectorCountINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        payload: Id(reader.next_word()?),
                    }
                }
                5745u16 => {
                    Self::SubgroupAvcMceGetInterReferenceIdsINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        payload: Id(reader.next_word()?),
                    }
                }
                5746u16 => {
                    Self::SubgroupAvcMceGetInterReferenceInterlacedFieldPolaritiesINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        packed_reference_ids: Id(reader.next_word()?),
                        packed_reference_parameter_field_polarities: Id(
                            reader.next_word()?,
                        ),
                        payload: Id(reader.next_word()?),
                    }
                }
                5747u16 => {
                    Self::SubgroupAvcImeInitializeINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        src_coord: Id(reader.next_word()?),
                        partition_mask: Id(reader.next_word()?),
                        sad_adjustment: Id(reader.next_word()?),
                    }
                }
                5748u16 => {
                    Self::SubgroupAvcImeSetSingleReferenceINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        ref_offset: Id(reader.next_word()?),
                        search_window_config: Id(reader.next_word()?),
                        payload: Id(reader.next_word()?),
                    }
                }
                5749u16 => {
                    Self::SubgroupAvcImeSetDualReferenceINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        fwd_ref_offset: Id(reader.next_word()?),
                        bwd_ref_offset: Id(reader.next_word()?),
                        id_search_window_config: Id(reader.next_word()?),
                        payload: Id(reader.next_word()?),
                    }
                }
                5750u16 => {
                    Self::SubgroupAvcImeRefWindowSizeINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        search_window_config: Id(reader.next_word()?),
                        dual_ref: Id(reader.next_word()?),
                    }
                }
                5751u16 => {
                    Self::SubgroupAvcImeAdjustRefOffsetINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        ref_offset: Id(reader.next_word()?),
                        src_coord: Id(reader.next_word()?),
                        ref_window_size: Id(reader.next_word()?),
                        image_size: Id(reader.next_word()?),
                    }
                }
                5752u16 => {
                    Self::SubgroupAvcImeConvertToMcePayloadINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        payload: Id(reader.next_word()?),
                    }
                }
                5753u16 => {
                    Self::SubgroupAvcImeSetMaxMotionVectorCountINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        max_motion_vector_count: Id(reader.next_word()?),
                        payload: Id(reader.next_word()?),
                    }
                }
                5754u16 => {
                    Self::SubgroupAvcImeSetUnidirectionalMixDisableINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        payload: Id(reader.next_word()?),
                    }
                }
                5755u16 => {
                    Self::SubgroupAvcImeSetEarlySearchTerminationThresholdINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        threshold: Id(reader.next_word()?),
                        payload: Id(reader.next_word()?),
                    }
                }
                5756u16 => {
                    Self::SubgroupAvcImeSetWeightedSadINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        packed_sad_weights: Id(reader.next_word()?),
                        payload: Id(reader.next_word()?),
                    }
                }
                5757u16 => {
                    Self::SubgroupAvcImeEvaluateWithSingleReferenceINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        src_image: Id(reader.next_word()?),
                        ref_image: Id(reader.next_word()?),
                        payload: Id(reader.next_word()?),
                    }
                }
                5758u16 => {
                    Self::SubgroupAvcImeEvaluateWithDualReferenceINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        src_image: Id(reader.next_word()?),
                        fwd_ref_image: Id(reader.next_word()?),
                        bwd_ref_image: Id(reader.next_word()?),
                        payload: Id(reader.next_word()?),
                    }
                }
                5759u16 => {
                    Self::SubgroupAvcImeEvaluateWithSingleReferenceStreaminINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        src_image: Id(reader.next_word()?),
                        ref_image: Id(reader.next_word()?),
                        payload: Id(reader.next_word()?),
                        streamin_components: Id(reader.next_word()?),
                    }
                }
                5760u16 => {
                    Self::SubgroupAvcImeEvaluateWithDualReferenceStreaminINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        src_image: Id(reader.next_word()?),
                        fwd_ref_image: Id(reader.next_word()?),
                        bwd_ref_image: Id(reader.next_word()?),
                        payload: Id(reader.next_word()?),
                        streamin_components: Id(reader.next_word()?),
                    }
                }
                5761u16 => {
                    Self::SubgroupAvcImeEvaluateWithSingleReferenceStreamoutINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        src_image: Id(reader.next_word()?),
                        ref_image: Id(reader.next_word()?),
                        payload: Id(reader.next_word()?),
                    }
                }
                5762u16 => {
                    Self::SubgroupAvcImeEvaluateWithDualReferenceStreamoutINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        src_image: Id(reader.next_word()?),
                        fwd_ref_image: Id(reader.next_word()?),
                        bwd_ref_image: Id(reader.next_word()?),
                        payload: Id(reader.next_word()?),
                    }
                }
                5763u16 => {
                    Self::SubgroupAvcImeEvaluateWithSingleReferenceStreaminoutINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        src_image: Id(reader.next_word()?),
                        ref_image: Id(reader.next_word()?),
                        payload: Id(reader.next_word()?),
                        streamin_components: Id(reader.next_word()?),
                    }
                }
                5764u16 => {
                    Self::SubgroupAvcImeEvaluateWithDualReferenceStreaminoutINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        src_image: Id(reader.next_word()?),
                        fwd_ref_image: Id(reader.next_word()?),
                        bwd_ref_image: Id(reader.next_word()?),
                        payload: Id(reader.next_word()?),
                        streamin_components: Id(reader.next_word()?),
                    }
                }
                5765u16 => {
                    Self::SubgroupAvcImeConvertToMceResultINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        payload: Id(reader.next_word()?),
                    }
                }
                5766u16 => {
                    Self::SubgroupAvcImeGetSingleReferenceStreaminINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        payload: Id(reader.next_word()?),
                    }
                }
                5767u16 => {
                    Self::SubgroupAvcImeGetDualReferenceStreaminINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        payload: Id(reader.next_word()?),
                    }
                }
                5768u16 => {
                    Self::SubgroupAvcImeStripSingleReferenceStreamoutINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        payload: Id(reader.next_word()?),
                    }
                }
                5769u16 => {
                    Self::SubgroupAvcImeStripDualReferenceStreamoutINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        payload: Id(reader.next_word()?),
                    }
                }
                5770u16 => {
                    Self::SubgroupAvcImeGetStreamoutSingleReferenceMajorShapeMotionVectorsINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        payload: Id(reader.next_word()?),
                        major_shape: Id(reader.next_word()?),
                    }
                }
                5771u16 => {
                    Self::SubgroupAvcImeGetStreamoutSingleReferenceMajorShapeDistortionsINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        payload: Id(reader.next_word()?),
                        major_shape: Id(reader.next_word()?),
                    }
                }
                5772u16 => {
                    Self::SubgroupAvcImeGetStreamoutSingleReferenceMajorShapeReferenceIdsINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        payload: Id(reader.next_word()?),
                        major_shape: Id(reader.next_word()?),
                    }
                }
                5773u16 => {
                    Self::SubgroupAvcImeGetStreamoutDualReferenceMajorShapeMotionVectorsINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        payload: Id(reader.next_word()?),
                        major_shape: Id(reader.next_word()?),
                        direction: Id(reader.next_word()?),
                    }
                }
                5774u16 => {
                    Self::SubgroupAvcImeGetStreamoutDualReferenceMajorShapeDistortionsINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        payload: Id(reader.next_word()?),
                        major_shape: Id(reader.next_word()?),
                        direction: Id(reader.next_word()?),
                    }
                }
                5775u16 => {
                    Self::SubgroupAvcImeGetStreamoutDualReferenceMajorShapeReferenceIdsINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        payload: Id(reader.next_word()?),
                        major_shape: Id(reader.next_word()?),
                        direction: Id(reader.next_word()?),
                    }
                }
                5776u16 => {
                    Self::SubgroupAvcImeGetBorderReachedINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        image_select: Id(reader.next_word()?),
                        payload: Id(reader.next_word()?),
                    }
                }
                5777u16 => {
                    Self::SubgroupAvcImeGetTruncatedSearchIndicationINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        payload: Id(reader.next_word()?),
                    }
                }
                5778u16 => {
                    Self::SubgroupAvcImeGetUnidirectionalEarlySearchTerminationINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        payload: Id(reader.next_word()?),
                    }
                }
                5779u16 => {
                    Self::SubgroupAvcImeGetWeightingPatternMinimumMotionVectorINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        payload: Id(reader.next_word()?),
                    }
                }
                5780u16 => {
                    Self::SubgroupAvcImeGetWeightingPatternMinimumDistortionINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        payload: Id(reader.next_word()?),
                    }
                }
                5781u16 => {
                    Self::SubgroupAvcFmeInitializeINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        src_coord: Id(reader.next_word()?),
                        motion_vectors: Id(reader.next_word()?),
                        major_shapes: Id(reader.next_word()?),
                        minor_shapes: Id(reader.next_word()?),
                        direction: Id(reader.next_word()?),
                        pixel_resolution: Id(reader.next_word()?),
                        sad_adjustment: Id(reader.next_word()?),
                    }
                }
                5782u16 => {
                    Self::SubgroupAvcBmeInitializeINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        src_coord: Id(reader.next_word()?),
                        motion_vectors: Id(reader.next_word()?),
                        major_shapes: Id(reader.next_word()?),
                        minor_shapes: Id(reader.next_word()?),
                        direction: Id(reader.next_word()?),
                        pixel_resolution: Id(reader.next_word()?),
                        bidirectional_weight: Id(reader.next_word()?),
                        sad_adjustment: Id(reader.next_word()?),
                    }
                }
                5783u16 => {
                    Self::SubgroupAvcRefConvertToMcePayloadINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        payload: Id(reader.next_word()?),
                    }
                }
                5784u16 => {
                    Self::SubgroupAvcRefSetBidirectionalMixDisableINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        payload: Id(reader.next_word()?),
                    }
                }
                5785u16 => {
                    Self::SubgroupAvcRefSetBilinearFilterEnableINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        payload: Id(reader.next_word()?),
                    }
                }
                5786u16 => {
                    Self::SubgroupAvcRefEvaluateWithSingleReferenceINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        src_image: Id(reader.next_word()?),
                        ref_image: Id(reader.next_word()?),
                        payload: Id(reader.next_word()?),
                    }
                }
                5787u16 => {
                    Self::SubgroupAvcRefEvaluateWithDualReferenceINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        src_image: Id(reader.next_word()?),
                        fwd_ref_image: Id(reader.next_word()?),
                        bwd_ref_image: Id(reader.next_word()?),
                        payload: Id(reader.next_word()?),
                    }
                }
                5788u16 => {
                    Self::SubgroupAvcRefEvaluateWithMultiReferenceINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        src_image: Id(reader.next_word()?),
                        packed_reference_ids: Id(reader.next_word()?),
                        payload: Id(reader.next_word()?),
                    }
                }
                5789u16 => {
                    Self::SubgroupAvcRefEvaluateWithMultiReferenceInterlacedINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        src_image: Id(reader.next_word()?),
                        packed_reference_ids: Id(reader.next_word()?),
                        packed_reference_field_polarities: Id(reader.next_word()?),
                        payload: Id(reader.next_word()?),
                    }
                }
                5790u16 => {
                    Self::SubgroupAvcRefConvertToMceResultINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        payload: Id(reader.next_word()?),
                    }
                }
                5791u16 => {
                    Self::SubgroupAvcSicInitializeINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        src_coord: Id(reader.next_word()?),
                    }
                }
                5792u16 => {
                    Self::SubgroupAvcSicConfigureSkcINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        skip_block_partition_type: Id(reader.next_word()?),
                        skip_motion_vector_mask: Id(reader.next_word()?),
                        motion_vectors: Id(reader.next_word()?),
                        bidirectional_weight: Id(reader.next_word()?),
                        sad_adjustment: Id(reader.next_word()?),
                        payload: Id(reader.next_word()?),
                    }
                }
                5793u16 => {
                    Self::SubgroupAvcSicConfigureIpeLumaINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        luma_intra_partition_mask: Id(reader.next_word()?),
                        intra_neighbour_availabilty: Id(reader.next_word()?),
                        left_edge_luma_pixels: Id(reader.next_word()?),
                        upper_left_corner_luma_pixel: Id(reader.next_word()?),
                        upper_edge_luma_pixels: Id(reader.next_word()?),
                        upper_right_edge_luma_pixels: Id(reader.next_word()?),
                        sad_adjustment: Id(reader.next_word()?),
                        payload: Id(reader.next_word()?),
                    }
                }
                5794u16 => {
                    Self::SubgroupAvcSicConfigureIpeLumaChromaINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        luma_intra_partition_mask: Id(reader.next_word()?),
                        intra_neighbour_availabilty: Id(reader.next_word()?),
                        left_edge_luma_pixels: Id(reader.next_word()?),
                        upper_left_corner_luma_pixel: Id(reader.next_word()?),
                        upper_edge_luma_pixels: Id(reader.next_word()?),
                        upper_right_edge_luma_pixels: Id(reader.next_word()?),
                        left_edge_chroma_pixels: Id(reader.next_word()?),
                        upper_left_corner_chroma_pixel: Id(reader.next_word()?),
                        upper_edge_chroma_pixels: Id(reader.next_word()?),
                        sad_adjustment: Id(reader.next_word()?),
                        payload: Id(reader.next_word()?),
                    }
                }
                5795u16 => {
                    Self::SubgroupAvcSicGetMotionVectorMaskINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        skip_block_partition_type: Id(reader.next_word()?),
                        direction: Id(reader.next_word()?),
                    }
                }
                5796u16 => {
                    Self::SubgroupAvcSicConvertToMcePayloadINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        payload: Id(reader.next_word()?),
                    }
                }
                5797u16 => {
                    Self::SubgroupAvcSicSetIntraLumaShapePenaltyINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        packed_shape_penalty: Id(reader.next_word()?),
                        payload: Id(reader.next_word()?),
                    }
                }
                5798u16 => {
                    Self::SubgroupAvcSicSetIntraLumaModeCostFunctionINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        luma_mode_penalty: Id(reader.next_word()?),
                        luma_packed_neighbor_modes: Id(reader.next_word()?),
                        luma_packed_non_dc_penalty: Id(reader.next_word()?),
                        payload: Id(reader.next_word()?),
                    }
                }
                5799u16 => {
                    Self::SubgroupAvcSicSetIntraChromaModeCostFunctionINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        chroma_mode_base_penalty: Id(reader.next_word()?),
                        payload: Id(reader.next_word()?),
                    }
                }
                5800u16 => {
                    Self::SubgroupAvcSicSetBilinearFilterEnableINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        payload: Id(reader.next_word()?),
                    }
                }
                5801u16 => {
                    Self::SubgroupAvcSicSetSkcForwardTransformEnableINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        packed_sad_coefficients: Id(reader.next_word()?),
                        payload: Id(reader.next_word()?),
                    }
                }
                5802u16 => {
                    Self::SubgroupAvcSicSetBlockBasedRawSkipSadINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        block_based_skip_type: Id(reader.next_word()?),
                        payload: Id(reader.next_word()?),
                    }
                }
                5803u16 => {
                    Self::SubgroupAvcSicEvaluateIpeINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        src_image: Id(reader.next_word()?),
                        payload: Id(reader.next_word()?),
                    }
                }
                5804u16 => {
                    Self::SubgroupAvcSicEvaluateWithSingleReferenceINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        src_image: Id(reader.next_word()?),
                        ref_image: Id(reader.next_word()?),
                        payload: Id(reader.next_word()?),
                    }
                }
                5805u16 => {
                    Self::SubgroupAvcSicEvaluateWithDualReferenceINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        src_image: Id(reader.next_word()?),
                        fwd_ref_image: Id(reader.next_word()?),
                        bwd_ref_image: Id(reader.next_word()?),
                        payload: Id(reader.next_word()?),
                    }
                }
                5806u16 => {
                    Self::SubgroupAvcSicEvaluateWithMultiReferenceINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        src_image: Id(reader.next_word()?),
                        packed_reference_ids: Id(reader.next_word()?),
                        payload: Id(reader.next_word()?),
                    }
                }
                5807u16 => {
                    Self::SubgroupAvcSicEvaluateWithMultiReferenceInterlacedINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        src_image: Id(reader.next_word()?),
                        packed_reference_ids: Id(reader.next_word()?),
                        packed_reference_field_polarities: Id(reader.next_word()?),
                        payload: Id(reader.next_word()?),
                    }
                }
                5808u16 => {
                    Self::SubgroupAvcSicConvertToMceResultINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        payload: Id(reader.next_word()?),
                    }
                }
                5809u16 => {
                    Self::SubgroupAvcSicGetIpeLumaShapeINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        payload: Id(reader.next_word()?),
                    }
                }
                5810u16 => {
                    Self::SubgroupAvcSicGetBestIpeLumaDistortionINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        payload: Id(reader.next_word()?),
                    }
                }
                5811u16 => {
                    Self::SubgroupAvcSicGetBestIpeChromaDistortionINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        payload: Id(reader.next_word()?),
                    }
                }
                5812u16 => {
                    Self::SubgroupAvcSicGetPackedIpeLumaModesINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        payload: Id(reader.next_word()?),
                    }
                }
                5813u16 => {
                    Self::SubgroupAvcSicGetIpeChromaModeINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        payload: Id(reader.next_word()?),
                    }
                }
                5814u16 => {
                    Self::SubgroupAvcSicGetPackedSkcLumaCountThresholdINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        payload: Id(reader.next_word()?),
                    }
                }
                5815u16 => {
                    Self::SubgroupAvcSicGetPackedSkcLumaSumThresholdINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        payload: Id(reader.next_word()?),
                    }
                }
                5816u16 => {
                    Self::SubgroupAvcSicGetInterRawSadsINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        payload: Id(reader.next_word()?),
                    }
                }
                5818u16 => {
                    Self::VariableLengthArrayINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        lenght: Id(reader.next_word()?),
                    }
                }
                5819u16 => {
                    Self::SaveMemoryINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                    }
                }
                5820u16 => {
                    Self::RestoreMemoryINTEL {
                        ptr: Id(reader.next_word()?),
                    }
                }
                5840u16 => {
                    Self::ArbitraryFloatSinCosPiINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        a: Id(reader.next_word()?),
                        m1: reader.next_word()?,
                        mout: reader.next_word()?,
                        from_sign: reader.next_word()?,
                        enable_subnormals: reader.next_word()?,
                        rounding_mode: reader.next_word()?,
                        rounding_accuracy: reader.next_word()?,
                    }
                }
                5841u16 => {
                    Self::ArbitraryFloatCastINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        a: Id(reader.next_word()?),
                        m1: reader.next_word()?,
                        mout: reader.next_word()?,
                        enable_subnormals: reader.next_word()?,
                        rounding_mode: reader.next_word()?,
                        rounding_accuracy: reader.next_word()?,
                    }
                }
                5842u16 => {
                    Self::ArbitraryFloatCastFromIntINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        a: Id(reader.next_word()?),
                        mout: reader.next_word()?,
                        from_sign: reader.next_word()?,
                        enable_subnormals: reader.next_word()?,
                        rounding_mode: reader.next_word()?,
                        rounding_accuracy: reader.next_word()?,
                    }
                }
                5843u16 => {
                    Self::ArbitraryFloatCastToIntINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        a: Id(reader.next_word()?),
                        m1: reader.next_word()?,
                        enable_subnormals: reader.next_word()?,
                        rounding_mode: reader.next_word()?,
                        rounding_accuracy: reader.next_word()?,
                    }
                }
                5846u16 => {
                    Self::ArbitraryFloatAddINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        a: Id(reader.next_word()?),
                        m1: reader.next_word()?,
                        b: Id(reader.next_word()?),
                        m2: reader.next_word()?,
                        mout: reader.next_word()?,
                        enable_subnormals: reader.next_word()?,
                        rounding_mode: reader.next_word()?,
                        rounding_accuracy: reader.next_word()?,
                    }
                }
                5847u16 => {
                    Self::ArbitraryFloatSubINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        a: Id(reader.next_word()?),
                        m1: reader.next_word()?,
                        b: Id(reader.next_word()?),
                        m2: reader.next_word()?,
                        mout: reader.next_word()?,
                        enable_subnormals: reader.next_word()?,
                        rounding_mode: reader.next_word()?,
                        rounding_accuracy: reader.next_word()?,
                    }
                }
                5848u16 => {
                    Self::ArbitraryFloatMulINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        a: Id(reader.next_word()?),
                        m1: reader.next_word()?,
                        b: Id(reader.next_word()?),
                        m2: reader.next_word()?,
                        mout: reader.next_word()?,
                        enable_subnormals: reader.next_word()?,
                        rounding_mode: reader.next_word()?,
                        rounding_accuracy: reader.next_word()?,
                    }
                }
                5849u16 => {
                    Self::ArbitraryFloatDivINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        a: Id(reader.next_word()?),
                        m1: reader.next_word()?,
                        b: Id(reader.next_word()?),
                        m2: reader.next_word()?,
                        mout: reader.next_word()?,
                        enable_subnormals: reader.next_word()?,
                        rounding_mode: reader.next_word()?,
                        rounding_accuracy: reader.next_word()?,
                    }
                }
                5850u16 => {
                    Self::ArbitraryFloatGTINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        a: Id(reader.next_word()?),
                        m1: reader.next_word()?,
                        b: Id(reader.next_word()?),
                        m2: reader.next_word()?,
                    }
                }
                5851u16 => {
                    Self::ArbitraryFloatGEINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        a: Id(reader.next_word()?),
                        m1: reader.next_word()?,
                        b: Id(reader.next_word()?),
                        m2: reader.next_word()?,
                    }
                }
                5852u16 => {
                    Self::ArbitraryFloatLTINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        a: Id(reader.next_word()?),
                        m1: reader.next_word()?,
                        b: Id(reader.next_word()?),
                        m2: reader.next_word()?,
                    }
                }
                5853u16 => {
                    Self::ArbitraryFloatLEINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        a: Id(reader.next_word()?),
                        m1: reader.next_word()?,
                        b: Id(reader.next_word()?),
                        m2: reader.next_word()?,
                    }
                }
                5854u16 => {
                    Self::ArbitraryFloatEQINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        a: Id(reader.next_word()?),
                        m1: reader.next_word()?,
                        b: Id(reader.next_word()?),
                        m2: reader.next_word()?,
                    }
                }
                5855u16 => {
                    Self::ArbitraryFloatRecipINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        a: Id(reader.next_word()?),
                        m1: reader.next_word()?,
                        mout: reader.next_word()?,
                        enable_subnormals: reader.next_word()?,
                        rounding_mode: reader.next_word()?,
                        rounding_accuracy: reader.next_word()?,
                    }
                }
                5856u16 => {
                    Self::ArbitraryFloatRSqrtINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        a: Id(reader.next_word()?),
                        m1: reader.next_word()?,
                        mout: reader.next_word()?,
                        enable_subnormals: reader.next_word()?,
                        rounding_mode: reader.next_word()?,
                        rounding_accuracy: reader.next_word()?,
                    }
                }
                5857u16 => {
                    Self::ArbitraryFloatCbrtINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        a: Id(reader.next_word()?),
                        m1: reader.next_word()?,
                        mout: reader.next_word()?,
                        enable_subnormals: reader.next_word()?,
                        rounding_mode: reader.next_word()?,
                        rounding_accuracy: reader.next_word()?,
                    }
                }
                5858u16 => {
                    Self::ArbitraryFloatHypotINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        a: Id(reader.next_word()?),
                        m1: reader.next_word()?,
                        b: Id(reader.next_word()?),
                        m2: reader.next_word()?,
                        mout: reader.next_word()?,
                        enable_subnormals: reader.next_word()?,
                        rounding_mode: reader.next_word()?,
                        rounding_accuracy: reader.next_word()?,
                    }
                }
                5859u16 => {
                    Self::ArbitraryFloatSqrtINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        a: Id(reader.next_word()?),
                        m1: reader.next_word()?,
                        mout: reader.next_word()?,
                        enable_subnormals: reader.next_word()?,
                        rounding_mode: reader.next_word()?,
                        rounding_accuracy: reader.next_word()?,
                    }
                }
                5860u16 => {
                    Self::ArbitraryFloatLogINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        a: Id(reader.next_word()?),
                        m1: reader.next_word()?,
                        mout: reader.next_word()?,
                        enable_subnormals: reader.next_word()?,
                        rounding_mode: reader.next_word()?,
                        rounding_accuracy: reader.next_word()?,
                    }
                }
                5861u16 => {
                    Self::ArbitraryFloatLog2INTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        a: Id(reader.next_word()?),
                        m1: reader.next_word()?,
                        mout: reader.next_word()?,
                        enable_subnormals: reader.next_word()?,
                        rounding_mode: reader.next_word()?,
                        rounding_accuracy: reader.next_word()?,
                    }
                }
                5862u16 => {
                    Self::ArbitraryFloatLog10INTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        a: Id(reader.next_word()?),
                        m1: reader.next_word()?,
                        mout: reader.next_word()?,
                        enable_subnormals: reader.next_word()?,
                        rounding_mode: reader.next_word()?,
                        rounding_accuracy: reader.next_word()?,
                    }
                }
                5863u16 => {
                    Self::ArbitraryFloatLog1pINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        a: Id(reader.next_word()?),
                        m1: reader.next_word()?,
                        mout: reader.next_word()?,
                        enable_subnormals: reader.next_word()?,
                        rounding_mode: reader.next_word()?,
                        rounding_accuracy: reader.next_word()?,
                    }
                }
                5864u16 => {
                    Self::ArbitraryFloatExpINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        a: Id(reader.next_word()?),
                        m1: reader.next_word()?,
                        mout: reader.next_word()?,
                        enable_subnormals: reader.next_word()?,
                        rounding_mode: reader.next_word()?,
                        rounding_accuracy: reader.next_word()?,
                    }
                }
                5865u16 => {
                    Self::ArbitraryFloatExp2INTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        a: Id(reader.next_word()?),
                        m1: reader.next_word()?,
                        mout: reader.next_word()?,
                        enable_subnormals: reader.next_word()?,
                        rounding_mode: reader.next_word()?,
                        rounding_accuracy: reader.next_word()?,
                    }
                }
                5866u16 => {
                    Self::ArbitraryFloatExp10INTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        a: Id(reader.next_word()?),
                        m1: reader.next_word()?,
                        mout: reader.next_word()?,
                        enable_subnormals: reader.next_word()?,
                        rounding_mode: reader.next_word()?,
                        rounding_accuracy: reader.next_word()?,
                    }
                }
                5867u16 => {
                    Self::ArbitraryFloatExpm1INTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        a: Id(reader.next_word()?),
                        m1: reader.next_word()?,
                        mout: reader.next_word()?,
                        enable_subnormals: reader.next_word()?,
                        rounding_mode: reader.next_word()?,
                        rounding_accuracy: reader.next_word()?,
                    }
                }
                5868u16 => {
                    Self::ArbitraryFloatSinINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        a: Id(reader.next_word()?),
                        m1: reader.next_word()?,
                        mout: reader.next_word()?,
                        enable_subnormals: reader.next_word()?,
                        rounding_mode: reader.next_word()?,
                        rounding_accuracy: reader.next_word()?,
                    }
                }
                5869u16 => {
                    Self::ArbitraryFloatCosINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        a: Id(reader.next_word()?),
                        m1: reader.next_word()?,
                        mout: reader.next_word()?,
                        enable_subnormals: reader.next_word()?,
                        rounding_mode: reader.next_word()?,
                        rounding_accuracy: reader.next_word()?,
                    }
                }
                5870u16 => {
                    Self::ArbitraryFloatSinCosINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        a: Id(reader.next_word()?),
                        m1: reader.next_word()?,
                        mout: reader.next_word()?,
                        enable_subnormals: reader.next_word()?,
                        rounding_mode: reader.next_word()?,
                        rounding_accuracy: reader.next_word()?,
                    }
                }
                5871u16 => {
                    Self::ArbitraryFloatSinPiINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        a: Id(reader.next_word()?),
                        m1: reader.next_word()?,
                        mout: reader.next_word()?,
                        enable_subnormals: reader.next_word()?,
                        rounding_mode: reader.next_word()?,
                        rounding_accuracy: reader.next_word()?,
                    }
                }
                5872u16 => {
                    Self::ArbitraryFloatCosPiINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        a: Id(reader.next_word()?),
                        m1: reader.next_word()?,
                        mout: reader.next_word()?,
                        enable_subnormals: reader.next_word()?,
                        rounding_mode: reader.next_word()?,
                        rounding_accuracy: reader.next_word()?,
                    }
                }
                5873u16 => {
                    Self::ArbitraryFloatASinINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        a: Id(reader.next_word()?),
                        m1: reader.next_word()?,
                        mout: reader.next_word()?,
                        enable_subnormals: reader.next_word()?,
                        rounding_mode: reader.next_word()?,
                        rounding_accuracy: reader.next_word()?,
                    }
                }
                5874u16 => {
                    Self::ArbitraryFloatASinPiINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        a: Id(reader.next_word()?),
                        m1: reader.next_word()?,
                        mout: reader.next_word()?,
                        enable_subnormals: reader.next_word()?,
                        rounding_mode: reader.next_word()?,
                        rounding_accuracy: reader.next_word()?,
                    }
                }
                5875u16 => {
                    Self::ArbitraryFloatACosINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        a: Id(reader.next_word()?),
                        m1: reader.next_word()?,
                        mout: reader.next_word()?,
                        enable_subnormals: reader.next_word()?,
                        rounding_mode: reader.next_word()?,
                        rounding_accuracy: reader.next_word()?,
                    }
                }
                5876u16 => {
                    Self::ArbitraryFloatACosPiINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        a: Id(reader.next_word()?),
                        m1: reader.next_word()?,
                        mout: reader.next_word()?,
                        enable_subnormals: reader.next_word()?,
                        rounding_mode: reader.next_word()?,
                        rounding_accuracy: reader.next_word()?,
                    }
                }
                5877u16 => {
                    Self::ArbitraryFloatATanINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        a: Id(reader.next_word()?),
                        m1: reader.next_word()?,
                        mout: reader.next_word()?,
                        enable_subnormals: reader.next_word()?,
                        rounding_mode: reader.next_word()?,
                        rounding_accuracy: reader.next_word()?,
                    }
                }
                5878u16 => {
                    Self::ArbitraryFloatATanPiINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        a: Id(reader.next_word()?),
                        m1: reader.next_word()?,
                        mout: reader.next_word()?,
                        enable_subnormals: reader.next_word()?,
                        rounding_mode: reader.next_word()?,
                        rounding_accuracy: reader.next_word()?,
                    }
                }
                5879u16 => {
                    Self::ArbitraryFloatATan2INTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        a: Id(reader.next_word()?),
                        m1: reader.next_word()?,
                        b: Id(reader.next_word()?),
                        m2: reader.next_word()?,
                        mout: reader.next_word()?,
                        enable_subnormals: reader.next_word()?,
                        rounding_mode: reader.next_word()?,
                        rounding_accuracy: reader.next_word()?,
                    }
                }
                5880u16 => {
                    Self::ArbitraryFloatPowINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        a: Id(reader.next_word()?),
                        m1: reader.next_word()?,
                        b: Id(reader.next_word()?),
                        m2: reader.next_word()?,
                        mout: reader.next_word()?,
                        enable_subnormals: reader.next_word()?,
                        rounding_mode: reader.next_word()?,
                        rounding_accuracy: reader.next_word()?,
                    }
                }
                5881u16 => {
                    Self::ArbitraryFloatPowRINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        a: Id(reader.next_word()?),
                        m1: reader.next_word()?,
                        b: Id(reader.next_word()?),
                        m2: reader.next_word()?,
                        mout: reader.next_word()?,
                        enable_subnormals: reader.next_word()?,
                        rounding_mode: reader.next_word()?,
                        rounding_accuracy: reader.next_word()?,
                    }
                }
                5882u16 => {
                    Self::ArbitraryFloatPowNINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        a: Id(reader.next_word()?),
                        m1: reader.next_word()?,
                        b: Id(reader.next_word()?),
                        mout: reader.next_word()?,
                        enable_subnormals: reader.next_word()?,
                        rounding_mode: reader.next_word()?,
                        rounding_accuracy: reader.next_word()?,
                    }
                }
                5887u16 => {
                    Self::LoopControlINTEL {
                        loop_control_parameters: {
                            let mut vec = Vec::new();
                            while !reader.is_empty() {
                                vec.push(reader.next_word()?);
                            }
                            vec
                        },
                    }
                }
                5911u16 => {
                    Self::AliasDomainDeclINTEL {
                        result_id: Id(reader.next_word()?),
                        name: if !reader.is_empty() {
                            Some(Id(reader.next_word()?))
                        } else {
                            None
                        },
                    }
                }
                5912u16 => {
                    Self::AliasScopeDeclINTEL {
                        result_id: Id(reader.next_word()?),
                        alias_domain: Id(reader.next_word()?),
                        name: if !reader.is_empty() {
                            Some(Id(reader.next_word()?))
                        } else {
                            None
                        },
                    }
                }
                5913u16 => {
                    Self::AliasScopeListDeclINTEL {
                        result_id: Id(reader.next_word()?),
                        alias_scope1_alias_scope2: {
                            let mut vec = Vec::new();
                            while !reader.is_empty() {
                                vec.push(Id(reader.next_word()?));
                            }
                            vec
                        },
                    }
                }
                5923u16 => {
                    Self::FixedSqrtINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        input_type: Id(reader.next_word()?),
                        input: Id(reader.next_word()?),
                        s: reader.next_word()?,
                        i: reader.next_word()?,
                        r_i: reader.next_word()?,
                        q: reader.next_word()?,
                        o: reader.next_word()?,
                    }
                }
                5924u16 => {
                    Self::FixedRecipINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        input_type: Id(reader.next_word()?),
                        input: Id(reader.next_word()?),
                        s: reader.next_word()?,
                        i: reader.next_word()?,
                        r_i: reader.next_word()?,
                        q: reader.next_word()?,
                        o: reader.next_word()?,
                    }
                }
                5925u16 => {
                    Self::FixedRsqrtINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        input_type: Id(reader.next_word()?),
                        input: Id(reader.next_word()?),
                        s: reader.next_word()?,
                        i: reader.next_word()?,
                        r_i: reader.next_word()?,
                        q: reader.next_word()?,
                        o: reader.next_word()?,
                    }
                }
                5926u16 => {
                    Self::FixedSinINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        input_type: Id(reader.next_word()?),
                        input: Id(reader.next_word()?),
                        s: reader.next_word()?,
                        i: reader.next_word()?,
                        r_i: reader.next_word()?,
                        q: reader.next_word()?,
                        o: reader.next_word()?,
                    }
                }
                5927u16 => {
                    Self::FixedCosINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        input_type: Id(reader.next_word()?),
                        input: Id(reader.next_word()?),
                        s: reader.next_word()?,
                        i: reader.next_word()?,
                        r_i: reader.next_word()?,
                        q: reader.next_word()?,
                        o: reader.next_word()?,
                    }
                }
                5928u16 => {
                    Self::FixedSinCosINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        input_type: Id(reader.next_word()?),
                        input: Id(reader.next_word()?),
                        s: reader.next_word()?,
                        i: reader.next_word()?,
                        r_i: reader.next_word()?,
                        q: reader.next_word()?,
                        o: reader.next_word()?,
                    }
                }
                5929u16 => {
                    Self::FixedSinPiINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        input_type: Id(reader.next_word()?),
                        input: Id(reader.next_word()?),
                        s: reader.next_word()?,
                        i: reader.next_word()?,
                        r_i: reader.next_word()?,
                        q: reader.next_word()?,
                        o: reader.next_word()?,
                    }
                }
                5930u16 => {
                    Self::FixedCosPiINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        input_type: Id(reader.next_word()?),
                        input: Id(reader.next_word()?),
                        s: reader.next_word()?,
                        i: reader.next_word()?,
                        r_i: reader.next_word()?,
                        q: reader.next_word()?,
                        o: reader.next_word()?,
                    }
                }
                5931u16 => {
                    Self::FixedSinCosPiINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        input_type: Id(reader.next_word()?),
                        input: Id(reader.next_word()?),
                        s: reader.next_word()?,
                        i: reader.next_word()?,
                        r_i: reader.next_word()?,
                        q: reader.next_word()?,
                        o: reader.next_word()?,
                    }
                }
                5932u16 => {
                    Self::FixedLogINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        input_type: Id(reader.next_word()?),
                        input: Id(reader.next_word()?),
                        s: reader.next_word()?,
                        i: reader.next_word()?,
                        r_i: reader.next_word()?,
                        q: reader.next_word()?,
                        o: reader.next_word()?,
                    }
                }
                5933u16 => {
                    Self::FixedExpINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        input_type: Id(reader.next_word()?),
                        input: Id(reader.next_word()?),
                        s: reader.next_word()?,
                        i: reader.next_word()?,
                        r_i: reader.next_word()?,
                        q: reader.next_word()?,
                        o: reader.next_word()?,
                    }
                }
                5934u16 => {
                    Self::PtrCastToCrossWorkgroupINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        pointer: Id(reader.next_word()?),
                    }
                }
                5938u16 => {
                    Self::CrossWorkgroupCastToPtrINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        pointer: Id(reader.next_word()?),
                    }
                }
                5946u16 => {
                    Self::ReadPipeBlockingINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        packet_size: Id(reader.next_word()?),
                        packet_alignment: Id(reader.next_word()?),
                    }
                }
                5947u16 => {
                    Self::WritePipeBlockingINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        packet_size: Id(reader.next_word()?),
                        packet_alignment: Id(reader.next_word()?),
                    }
                }
                5949u16 => {
                    Self::FPGARegINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        result: Id(reader.next_word()?),
                        input: Id(reader.next_word()?),
                    }
                }
                6016u16 => {
                    Self::RayQueryGetRayTMinKHR {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        ray_query: Id(reader.next_word()?),
                    }
                }
                6017u16 => {
                    Self::RayQueryGetRayFlagsKHR {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        ray_query: Id(reader.next_word()?),
                    }
                }
                6018u16 => {
                    Self::RayQueryGetIntersectionTKHR {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        ray_query: Id(reader.next_word()?),
                        intersection: Id(reader.next_word()?),
                    }
                }
                6019u16 => {
                    Self::RayQueryGetIntersectionInstanceCustomIndexKHR {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        ray_query: Id(reader.next_word()?),
                        intersection: Id(reader.next_word()?),
                    }
                }
                6020u16 => {
                    Self::RayQueryGetIntersectionInstanceIdKHR {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        ray_query: Id(reader.next_word()?),
                        intersection: Id(reader.next_word()?),
                    }
                }
                6021u16 => {
                    Self::RayQueryGetIntersectionInstanceShaderBindingTableRecordOffsetKHR {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        ray_query: Id(reader.next_word()?),
                        intersection: Id(reader.next_word()?),
                    }
                }
                6022u16 => {
                    Self::RayQueryGetIntersectionGeometryIndexKHR {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        ray_query: Id(reader.next_word()?),
                        intersection: Id(reader.next_word()?),
                    }
                }
                6023u16 => {
                    Self::RayQueryGetIntersectionPrimitiveIndexKHR {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        ray_query: Id(reader.next_word()?),
                        intersection: Id(reader.next_word()?),
                    }
                }
                6024u16 => {
                    Self::RayQueryGetIntersectionBarycentricsKHR {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        ray_query: Id(reader.next_word()?),
                        intersection: Id(reader.next_word()?),
                    }
                }
                6025u16 => {
                    Self::RayQueryGetIntersectionFrontFaceKHR {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        ray_query: Id(reader.next_word()?),
                        intersection: Id(reader.next_word()?),
                    }
                }
                6026u16 => {
                    Self::RayQueryGetIntersectionCandidateAABBOpaqueKHR {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        ray_query: Id(reader.next_word()?),
                    }
                }
                6027u16 => {
                    Self::RayQueryGetIntersectionObjectRayDirectionKHR {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        ray_query: Id(reader.next_word()?),
                        intersection: Id(reader.next_word()?),
                    }
                }
                6028u16 => {
                    Self::RayQueryGetIntersectionObjectRayOriginKHR {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        ray_query: Id(reader.next_word()?),
                        intersection: Id(reader.next_word()?),
                    }
                }
                6029u16 => {
                    Self::RayQueryGetWorldRayDirectionKHR {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        ray_query: Id(reader.next_word()?),
                    }
                }
                6030u16 => {
                    Self::RayQueryGetWorldRayOriginKHR {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        ray_query: Id(reader.next_word()?),
                    }
                }
                6031u16 => {
                    Self::RayQueryGetIntersectionObjectToWorldKHR {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        ray_query: Id(reader.next_word()?),
                        intersection: Id(reader.next_word()?),
                    }
                }
                6032u16 => {
                    Self::RayQueryGetIntersectionWorldToObjectKHR {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        ray_query: Id(reader.next_word()?),
                        intersection: Id(reader.next_word()?),
                    }
                }
                6035u16 => {
                    Self::AtomicFAddEXT {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        pointer: Id(reader.next_word()?),
                        memory: Id(reader.next_word()?),
                        semantics: Id(reader.next_word()?),
                        value: Id(reader.next_word()?),
                    }
                }
                6086u16 => {
                    Self::TypeBufferSurfaceINTEL {
                        result_id: Id(reader.next_word()?),
                        access_qualifier: AccessQualifier::parse(reader)?,
                    }
                }
                6090u16 => {
                    Self::TypeStructContinuedINTEL {
                        member_types: {
                            let mut vec = Vec::new();
                            while !reader.is_empty() {
                                vec.push(Id(reader.next_word()?));
                            }
                            vec
                        },
                    }
                }
                6091u16 => {
                    Self::ConstantCompositeContinuedINTEL {
                        constituents: {
                            let mut vec = Vec::new();
                            while !reader.is_empty() {
                                vec.push(Id(reader.next_word()?));
                            }
                            vec
                        },
                    }
                }
                6092u16 => {
                    Self::SpecConstantCompositeContinuedINTEL {
                        constituents: {
                            let mut vec = Vec::new();
                            while !reader.is_empty() {
                                vec.push(Id(reader.next_word()?));
                            }
                            vec
                        },
                    }
                }
                6096u16 => {
                    Self::CompositeConstructContinuedINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        constituents: {
                            let mut vec = Vec::new();
                            while !reader.is_empty() {
                                vec.push(Id(reader.next_word()?));
                            }
                            vec
                        },
                    }
                }
                6116u16 => {
                    Self::ConvertFToBF16INTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        float_value: Id(reader.next_word()?),
                    }
                }
                6117u16 => {
                    Self::ConvertBF16ToFINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        b_float16_value: Id(reader.next_word()?),
                    }
                }
                6142u16 => {
                    Self::ControlBarrierArriveINTEL {
                        execution: Id(reader.next_word()?),
                        memory: Id(reader.next_word()?),
                        semantics: Id(reader.next_word()?),
                    }
                }
                6143u16 => {
                    Self::ControlBarrierWaitINTEL {
                        execution: Id(reader.next_word()?),
                        memory: Id(reader.next_word()?),
                        semantics: Id(reader.next_word()?),
                    }
                }
                6401u16 => {
                    Self::GroupIMulKHR {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        execution: Id(reader.next_word()?),
                        operation: GroupOperation::parse(reader)?,
                        x: Id(reader.next_word()?),
                    }
                }
                6402u16 => {
                    Self::GroupFMulKHR {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        execution: Id(reader.next_word()?),
                        operation: GroupOperation::parse(reader)?,
                        x: Id(reader.next_word()?),
                    }
                }
                6403u16 => {
                    Self::GroupBitwiseAndKHR {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        execution: Id(reader.next_word()?),
                        operation: GroupOperation::parse(reader)?,
                        x: Id(reader.next_word()?),
                    }
                }
                6404u16 => {
                    Self::GroupBitwiseOrKHR {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        execution: Id(reader.next_word()?),
                        operation: GroupOperation::parse(reader)?,
                        x: Id(reader.next_word()?),
                    }
                }
                6405u16 => {
                    Self::GroupBitwiseXorKHR {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        execution: Id(reader.next_word()?),
                        operation: GroupOperation::parse(reader)?,
                        x: Id(reader.next_word()?),
                    }
                }
                6406u16 => {
                    Self::GroupLogicalAndKHR {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        execution: Id(reader.next_word()?),
                        operation: GroupOperation::parse(reader)?,
                        x: Id(reader.next_word()?),
                    }
                }
                6407u16 => {
                    Self::GroupLogicalOrKHR {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        execution: Id(reader.next_word()?),
                        operation: GroupOperation::parse(reader)?,
                        x: Id(reader.next_word()?),
                    }
                }
                6408u16 => {
                    Self::GroupLogicalXorKHR {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        execution: Id(reader.next_word()?),
                        operation: GroupOperation::parse(reader)?,
                        x: Id(reader.next_word()?),
                    }
                }
                6428u16 => {
                    Self::MaskedGatherINTEL {
                        result_type_id: Id(reader.next_word()?),
                        result_id: Id(reader.next_word()?),
                        ptr_vector: Id(reader.next_word()?),
                        alignment: reader.next_word()?,
                        mask: Id(reader.next_word()?),
                        fill_empty: Id(reader.next_word()?),
                    }
                }
                6429u16 => {
                    Self::MaskedScatterINTEL {
                        input_vector: Id(reader.next_word()?),
                        ptr_vector: Id(reader.next_word()?),
                        alignment: reader.next_word()?,
                        mask: Id(reader.next_word()?),
                    }
                }
                opcode => return Err(reader.map_err(ParseErrors::UnknownOpcode(opcode))),
            },
        )
    }
    /// Returns the `Id` that is assigned by this instruction, if any.
    pub fn result_id(&self) -> Option<Id> {
        match self {
            Self::Undef { result_id, .. }
            | Self::String { result_id, .. }
            | Self::ExtInstImport { result_id, .. }
            | Self::ExtInst { result_id, .. }
            | Self::TypeVoid { result_id, .. }
            | Self::TypeBool { result_id, .. }
            | Self::TypeInt { result_id, .. }
            | Self::TypeFloat { result_id, .. }
            | Self::TypeVector { result_id, .. }
            | Self::TypeMatrix { result_id, .. }
            | Self::TypeImage { result_id, .. }
            | Self::TypeSampler { result_id, .. }
            | Self::TypeSampledImage { result_id, .. }
            | Self::TypeArray { result_id, .. }
            | Self::TypeRuntimeArray { result_id, .. }
            | Self::TypeStruct { result_id, .. }
            | Self::TypeOpaque { result_id, .. }
            | Self::TypePointer { result_id, .. }
            | Self::TypeFunction { result_id, .. }
            | Self::TypeEvent { result_id, .. }
            | Self::TypeDeviceEvent { result_id, .. }
            | Self::TypeReserveId { result_id, .. }
            | Self::TypeQueue { result_id, .. }
            | Self::TypePipe { result_id, .. }
            | Self::ConstantTrue { result_id, .. }
            | Self::ConstantFalse { result_id, .. }
            | Self::Constant { result_id, .. }
            | Self::ConstantComposite { result_id, .. }
            | Self::ConstantSampler { result_id, .. }
            | Self::ConstantNull { result_id, .. }
            | Self::SpecConstantTrue { result_id, .. }
            | Self::SpecConstantFalse { result_id, .. }
            | Self::SpecConstant { result_id, .. }
            | Self::SpecConstantComposite { result_id, .. }
            | Self::SpecConstantOp { result_id, .. }
            | Self::Function { result_id, .. }
            | Self::FunctionParameter { result_id, .. }
            | Self::FunctionCall { result_id, .. }
            | Self::Variable { result_id, .. }
            | Self::ImageTexelPointer { result_id, .. }
            | Self::Load { result_id, .. }
            | Self::AccessChain { result_id, .. }
            | Self::InBoundsAccessChain { result_id, .. }
            | Self::PtrAccessChain { result_id, .. }
            | Self::ArrayLength { result_id, .. }
            | Self::GenericPtrMemSemantics { result_id, .. }
            | Self::InBoundsPtrAccessChain { result_id, .. }
            | Self::DecorationGroup { result_id, .. }
            | Self::VectorExtractDynamic { result_id, .. }
            | Self::VectorInsertDynamic { result_id, .. }
            | Self::VectorShuffle { result_id, .. }
            | Self::CompositeConstruct { result_id, .. }
            | Self::CompositeExtract { result_id, .. }
            | Self::CompositeInsert { result_id, .. }
            | Self::CopyObject { result_id, .. }
            | Self::Transpose { result_id, .. }
            | Self::SampledImage { result_id, .. }
            | Self::ImageSampleImplicitLod { result_id, .. }
            | Self::ImageSampleExplicitLod { result_id, .. }
            | Self::ImageSampleDrefImplicitLod { result_id, .. }
            | Self::ImageSampleDrefExplicitLod { result_id, .. }
            | Self::ImageSampleProjImplicitLod { result_id, .. }
            | Self::ImageSampleProjExplicitLod { result_id, .. }
            | Self::ImageSampleProjDrefImplicitLod { result_id, .. }
            | Self::ImageSampleProjDrefExplicitLod { result_id, .. }
            | Self::ImageFetch { result_id, .. }
            | Self::ImageGather { result_id, .. }
            | Self::ImageDrefGather { result_id, .. }
            | Self::ImageRead { result_id, .. }
            | Self::Image { result_id, .. }
            | Self::ImageQueryFormat { result_id, .. }
            | Self::ImageQueryOrder { result_id, .. }
            | Self::ImageQuerySizeLod { result_id, .. }
            | Self::ImageQuerySize { result_id, .. }
            | Self::ImageQueryLod { result_id, .. }
            | Self::ImageQueryLevels { result_id, .. }
            | Self::ImageQuerySamples { result_id, .. }
            | Self::ConvertFToU { result_id, .. }
            | Self::ConvertFToS { result_id, .. }
            | Self::ConvertSToF { result_id, .. }
            | Self::ConvertUToF { result_id, .. }
            | Self::UConvert { result_id, .. }
            | Self::SConvert { result_id, .. }
            | Self::FConvert { result_id, .. }
            | Self::QuantizeToF16 { result_id, .. }
            | Self::ConvertPtrToU { result_id, .. }
            | Self::SatConvertSToU { result_id, .. }
            | Self::SatConvertUToS { result_id, .. }
            | Self::ConvertUToPtr { result_id, .. }
            | Self::PtrCastToGeneric { result_id, .. }
            | Self::GenericCastToPtr { result_id, .. }
            | Self::GenericCastToPtrExplicit { result_id, .. }
            | Self::Bitcast { result_id, .. }
            | Self::SNegate { result_id, .. }
            | Self::FNegate { result_id, .. }
            | Self::IAdd { result_id, .. }
            | Self::FAdd { result_id, .. }
            | Self::ISub { result_id, .. }
            | Self::FSub { result_id, .. }
            | Self::IMul { result_id, .. }
            | Self::FMul { result_id, .. }
            | Self::UDiv { result_id, .. }
            | Self::SDiv { result_id, .. }
            | Self::FDiv { result_id, .. }
            | Self::UMod { result_id, .. }
            | Self::SRem { result_id, .. }
            | Self::SMod { result_id, .. }
            | Self::FRem { result_id, .. }
            | Self::FMod { result_id, .. }
            | Self::VectorTimesScalar { result_id, .. }
            | Self::MatrixTimesScalar { result_id, .. }
            | Self::VectorTimesMatrix { result_id, .. }
            | Self::MatrixTimesVector { result_id, .. }
            | Self::MatrixTimesMatrix { result_id, .. }
            | Self::OuterProduct { result_id, .. }
            | Self::Dot { result_id, .. }
            | Self::IAddCarry { result_id, .. }
            | Self::ISubBorrow { result_id, .. }
            | Self::UMulExtended { result_id, .. }
            | Self::SMulExtended { result_id, .. }
            | Self::Any { result_id, .. }
            | Self::All { result_id, .. }
            | Self::IsNan { result_id, .. }
            | Self::IsInf { result_id, .. }
            | Self::IsFinite { result_id, .. }
            | Self::IsNormal { result_id, .. }
            | Self::SignBitSet { result_id, .. }
            | Self::LessOrGreater { result_id, .. }
            | Self::Ordered { result_id, .. }
            | Self::Unordered { result_id, .. }
            | Self::LogicalEqual { result_id, .. }
            | Self::LogicalNotEqual { result_id, .. }
            | Self::LogicalOr { result_id, .. }
            | Self::LogicalAnd { result_id, .. }
            | Self::LogicalNot { result_id, .. }
            | Self::Select { result_id, .. }
            | Self::IEqual { result_id, .. }
            | Self::INotEqual { result_id, .. }
            | Self::UGreaterThan { result_id, .. }
            | Self::SGreaterThan { result_id, .. }
            | Self::UGreaterThanEqual { result_id, .. }
            | Self::SGreaterThanEqual { result_id, .. }
            | Self::ULessThan { result_id, .. }
            | Self::SLessThan { result_id, .. }
            | Self::ULessThanEqual { result_id, .. }
            | Self::SLessThanEqual { result_id, .. }
            | Self::FOrdEqual { result_id, .. }
            | Self::FUnordEqual { result_id, .. }
            | Self::FOrdNotEqual { result_id, .. }
            | Self::FUnordNotEqual { result_id, .. }
            | Self::FOrdLessThan { result_id, .. }
            | Self::FUnordLessThan { result_id, .. }
            | Self::FOrdGreaterThan { result_id, .. }
            | Self::FUnordGreaterThan { result_id, .. }
            | Self::FOrdLessThanEqual { result_id, .. }
            | Self::FUnordLessThanEqual { result_id, .. }
            | Self::FOrdGreaterThanEqual { result_id, .. }
            | Self::FUnordGreaterThanEqual { result_id, .. }
            | Self::ShiftRightLogical { result_id, .. }
            | Self::ShiftRightArithmetic { result_id, .. }
            | Self::ShiftLeftLogical { result_id, .. }
            | Self::BitwiseOr { result_id, .. }
            | Self::BitwiseXor { result_id, .. }
            | Self::BitwiseAnd { result_id, .. }
            | Self::Not { result_id, .. }
            | Self::BitFieldInsert { result_id, .. }
            | Self::BitFieldSExtract { result_id, .. }
            | Self::BitFieldUExtract { result_id, .. }
            | Self::BitReverse { result_id, .. }
            | Self::BitCount { result_id, .. }
            | Self::DPdx { result_id, .. }
            | Self::DPdy { result_id, .. }
            | Self::Fwidth { result_id, .. }
            | Self::DPdxFine { result_id, .. }
            | Self::DPdyFine { result_id, .. }
            | Self::FwidthFine { result_id, .. }
            | Self::DPdxCoarse { result_id, .. }
            | Self::DPdyCoarse { result_id, .. }
            | Self::FwidthCoarse { result_id, .. }
            | Self::AtomicLoad { result_id, .. }
            | Self::AtomicExchange { result_id, .. }
            | Self::AtomicCompareExchange { result_id, .. }
            | Self::AtomicCompareExchangeWeak { result_id, .. }
            | Self::AtomicIIncrement { result_id, .. }
            | Self::AtomicIDecrement { result_id, .. }
            | Self::AtomicIAdd { result_id, .. }
            | Self::AtomicISub { result_id, .. }
            | Self::AtomicSMin { result_id, .. }
            | Self::AtomicUMin { result_id, .. }
            | Self::AtomicSMax { result_id, .. }
            | Self::AtomicUMax { result_id, .. }
            | Self::AtomicAnd { result_id, .. }
            | Self::AtomicOr { result_id, .. }
            | Self::AtomicXor { result_id, .. }
            | Self::Phi { result_id, .. }
            | Self::Label { result_id, .. }
            | Self::GroupAsyncCopy { result_id, .. }
            | Self::GroupAll { result_id, .. }
            | Self::GroupAny { result_id, .. }
            | Self::GroupBroadcast { result_id, .. }
            | Self::GroupIAdd { result_id, .. }
            | Self::GroupFAdd { result_id, .. }
            | Self::GroupFMin { result_id, .. }
            | Self::GroupUMin { result_id, .. }
            | Self::GroupSMin { result_id, .. }
            | Self::GroupFMax { result_id, .. }
            | Self::GroupUMax { result_id, .. }
            | Self::GroupSMax { result_id, .. }
            | Self::ReadPipe { result_id, .. }
            | Self::WritePipe { result_id, .. }
            | Self::ReservedReadPipe { result_id, .. }
            | Self::ReservedWritePipe { result_id, .. }
            | Self::ReserveReadPipePackets { result_id, .. }
            | Self::ReserveWritePipePackets { result_id, .. }
            | Self::IsValidReserveId { result_id, .. }
            | Self::GetNumPipePackets { result_id, .. }
            | Self::GetMaxPipePackets { result_id, .. }
            | Self::GroupReserveReadPipePackets { result_id, .. }
            | Self::GroupReserveWritePipePackets { result_id, .. }
            | Self::EnqueueMarker { result_id, .. }
            | Self::EnqueueKernel { result_id, .. }
            | Self::GetKernelNDrangeSubGroupCount { result_id, .. }
            | Self::GetKernelNDrangeMaxSubGroupSize { result_id, .. }
            | Self::GetKernelWorkGroupSize { result_id, .. }
            | Self::GetKernelPreferredWorkGroupSizeMultiple { result_id, .. }
            | Self::CreateUserEvent { result_id, .. }
            | Self::IsValidEvent { result_id, .. }
            | Self::GetDefaultQueue { result_id, .. }
            | Self::BuildNDRange { result_id, .. }
            | Self::ImageSparseSampleImplicitLod { result_id, .. }
            | Self::ImageSparseSampleExplicitLod { result_id, .. }
            | Self::ImageSparseSampleDrefImplicitLod { result_id, .. }
            | Self::ImageSparseSampleDrefExplicitLod { result_id, .. }
            | Self::ImageSparseSampleProjImplicitLod { result_id, .. }
            | Self::ImageSparseSampleProjExplicitLod { result_id, .. }
            | Self::ImageSparseSampleProjDrefImplicitLod { result_id, .. }
            | Self::ImageSparseSampleProjDrefExplicitLod { result_id, .. }
            | Self::ImageSparseFetch { result_id, .. }
            | Self::ImageSparseGather { result_id, .. }
            | Self::ImageSparseDrefGather { result_id, .. }
            | Self::ImageSparseTexelsResident { result_id, .. }
            | Self::AtomicFlagTestAndSet { result_id, .. }
            | Self::ImageSparseRead { result_id, .. }
            | Self::SizeOf { result_id, .. }
            | Self::TypePipeStorage { result_id, .. }
            | Self::ConstantPipeStorage { result_id, .. }
            | Self::CreatePipeFromPipeStorage { result_id, .. }
            | Self::GetKernelLocalSizeForSubgroupCount { result_id, .. }
            | Self::GetKernelMaxNumSubgroups { result_id, .. }
            | Self::TypeNamedBarrier { result_id, .. }
            | Self::NamedBarrierInitialize { result_id, .. }
            | Self::GroupNonUniformElect { result_id, .. }
            | Self::GroupNonUniformAll { result_id, .. }
            | Self::GroupNonUniformAny { result_id, .. }
            | Self::GroupNonUniformAllEqual { result_id, .. }
            | Self::GroupNonUniformBroadcast { result_id, .. }
            | Self::GroupNonUniformBroadcastFirst { result_id, .. }
            | Self::GroupNonUniformBallot { result_id, .. }
            | Self::GroupNonUniformInverseBallot { result_id, .. }
            | Self::GroupNonUniformBallotBitExtract { result_id, .. }
            | Self::GroupNonUniformBallotBitCount { result_id, .. }
            | Self::GroupNonUniformBallotFindLSB { result_id, .. }
            | Self::GroupNonUniformBallotFindMSB { result_id, .. }
            | Self::GroupNonUniformShuffle { result_id, .. }
            | Self::GroupNonUniformShuffleXor { result_id, .. }
            | Self::GroupNonUniformShuffleUp { result_id, .. }
            | Self::GroupNonUniformShuffleDown { result_id, .. }
            | Self::GroupNonUniformIAdd { result_id, .. }
            | Self::GroupNonUniformFAdd { result_id, .. }
            | Self::GroupNonUniformIMul { result_id, .. }
            | Self::GroupNonUniformFMul { result_id, .. }
            | Self::GroupNonUniformSMin { result_id, .. }
            | Self::GroupNonUniformUMin { result_id, .. }
            | Self::GroupNonUniformFMin { result_id, .. }
            | Self::GroupNonUniformSMax { result_id, .. }
            | Self::GroupNonUniformUMax { result_id, .. }
            | Self::GroupNonUniformFMax { result_id, .. }
            | Self::GroupNonUniformBitwiseAnd { result_id, .. }
            | Self::GroupNonUniformBitwiseOr { result_id, .. }
            | Self::GroupNonUniformBitwiseXor { result_id, .. }
            | Self::GroupNonUniformLogicalAnd { result_id, .. }
            | Self::GroupNonUniformLogicalOr { result_id, .. }
            | Self::GroupNonUniformLogicalXor { result_id, .. }
            | Self::GroupNonUniformQuadBroadcast { result_id, .. }
            | Self::GroupNonUniformQuadSwap { result_id, .. }
            | Self::CopyLogical { result_id, .. }
            | Self::PtrEqual { result_id, .. }
            | Self::PtrNotEqual { result_id, .. }
            | Self::PtrDiff { result_id, .. }
            | Self::ColorAttachmentReadEXT { result_id, .. }
            | Self::DepthAttachmentReadEXT { result_id, .. }
            | Self::StencilAttachmentReadEXT { result_id, .. }
            | Self::SubgroupBallotKHR { result_id, .. }
            | Self::SubgroupFirstInvocationKHR { result_id, .. }
            | Self::SubgroupAllKHR { result_id, .. }
            | Self::SubgroupAnyKHR { result_id, .. }
            | Self::SubgroupAllEqualKHR { result_id, .. }
            | Self::GroupNonUniformRotateKHR { result_id, .. }
            | Self::SubgroupReadInvocationKHR { result_id, .. }
            | Self::ConvertUToAccelerationStructureKHR { result_id, .. }
            | Self::SDot { result_id, .. }
            | Self::UDot { result_id, .. }
            | Self::SUDot { result_id, .. }
            | Self::SDotAccSat { result_id, .. }
            | Self::UDotAccSat { result_id, .. }
            | Self::SUDotAccSat { result_id, .. }
            | Self::TypeCooperativeMatrixKHR { result_id, .. }
            | Self::CooperativeMatrixLoadKHR { result_id, .. }
            | Self::CooperativeMatrixMulAddKHR { result_id, .. }
            | Self::CooperativeMatrixLengthKHR { result_id, .. }
            | Self::TypeRayQueryKHR { result_id, .. }
            | Self::RayQueryProceedKHR { result_id, .. }
            | Self::RayQueryGetIntersectionTypeKHR { result_id, .. }
            | Self::ImageSampleWeightedQCOM { result_id, .. }
            | Self::ImageBoxFilterQCOM { result_id, .. }
            | Self::ImageBlockMatchSSDQCOM { result_id, .. }
            | Self::ImageBlockMatchSADQCOM { result_id, .. }
            | Self::ImageBlockMatchWindowSSDQCOM { result_id, .. }
            | Self::ImageBlockMatchWindowSADQCOM { result_id, .. }
            | Self::ImageBlockMatchGatherSSDQCOM { result_id, .. }
            | Self::ImageBlockMatchGatherSADQCOM { result_id, .. }
            | Self::GroupIAddNonUniformAMD { result_id, .. }
            | Self::GroupFAddNonUniformAMD { result_id, .. }
            | Self::GroupFMinNonUniformAMD { result_id, .. }
            | Self::GroupUMinNonUniformAMD { result_id, .. }
            | Self::GroupSMinNonUniformAMD { result_id, .. }
            | Self::GroupFMaxNonUniformAMD { result_id, .. }
            | Self::GroupUMaxNonUniformAMD { result_id, .. }
            | Self::GroupSMaxNonUniformAMD { result_id, .. }
            | Self::FragmentMaskFetchAMD { result_id, .. }
            | Self::FragmentFetchAMD { result_id, .. }
            | Self::ReadClockKHR { result_id, .. }
            | Self::FinishWritingNodePayloadAMDX { result_id, .. }
            | Self::GroupNonUniformQuadAllKHR { result_id, .. }
            | Self::GroupNonUniformQuadAnyKHR { result_id, .. }
            | Self::HitObjectGetWorldToObjectNV { result_id, .. }
            | Self::HitObjectGetObjectToWorldNV { result_id, .. }
            | Self::HitObjectGetObjectRayDirectionNV { result_id, .. }
            | Self::HitObjectGetObjectRayOriginNV { result_id, .. }
            | Self::HitObjectGetShaderRecordBufferHandleNV { result_id, .. }
            | Self::HitObjectGetShaderBindingTableRecordIndexNV { result_id, .. }
            | Self::HitObjectGetCurrentTimeNV { result_id, .. }
            | Self::HitObjectGetHitKindNV { result_id, .. }
            | Self::HitObjectGetPrimitiveIndexNV { result_id, .. }
            | Self::HitObjectGetGeometryIndexNV { result_id, .. }
            | Self::HitObjectGetInstanceIdNV { result_id, .. }
            | Self::HitObjectGetInstanceCustomIndexNV { result_id, .. }
            | Self::HitObjectGetWorldRayDirectionNV { result_id, .. }
            | Self::HitObjectGetWorldRayOriginNV { result_id, .. }
            | Self::HitObjectGetRayTMaxNV { result_id, .. }
            | Self::HitObjectGetRayTMinNV { result_id, .. }
            | Self::HitObjectIsEmptyNV { result_id, .. }
            | Self::HitObjectIsHitNV { result_id, .. }
            | Self::HitObjectIsMissNV { result_id, .. }
            | Self::TypeHitObjectNV { result_id, .. }
            | Self::ImageSampleFootprintNV { result_id, .. }
            | Self::GroupNonUniformPartitionNV { result_id, .. }
            | Self::FetchMicroTriangleVertexPositionNV { result_id, .. }
            | Self::FetchMicroTriangleVertexBarycentricNV { result_id, .. }
            | Self::ReportIntersectionKHR { result_id, .. }
            | Self::RayQueryGetIntersectionTriangleVertexPositionsKHR { result_id, .. }
            | Self::TypeAccelerationStructureKHR { result_id, .. }
            | Self::TypeCooperativeMatrixNV { result_id, .. }
            | Self::CooperativeMatrixLoadNV { result_id, .. }
            | Self::CooperativeMatrixMulAddNV { result_id, .. }
            | Self::CooperativeMatrixLengthNV { result_id, .. }
            | Self::IsHelperInvocationEXT { result_id, .. }
            | Self::ConvertUToImageNV { result_id, .. }
            | Self::ConvertUToSamplerNV { result_id, .. }
            | Self::ConvertImageToUNV { result_id, .. }
            | Self::ConvertSamplerToUNV { result_id, .. }
            | Self::ConvertUToSampledImageNV { result_id, .. }
            | Self::ConvertSampledImageToUNV { result_id, .. }
            | Self::RawAccessChainNV { result_id, .. }
            | Self::SubgroupShuffleINTEL { result_id, .. }
            | Self::SubgroupShuffleDownINTEL { result_id, .. }
            | Self::SubgroupShuffleUpINTEL { result_id, .. }
            | Self::SubgroupShuffleXorINTEL { result_id, .. }
            | Self::SubgroupBlockReadINTEL { result_id, .. }
            | Self::SubgroupImageBlockReadINTEL { result_id, .. }
            | Self::SubgroupImageMediaBlockReadINTEL { result_id, .. }
            | Self::UCountLeadingZerosINTEL { result_id, .. }
            | Self::UCountTrailingZerosINTEL { result_id, .. }
            | Self::AbsISubINTEL { result_id, .. }
            | Self::AbsUSubINTEL { result_id, .. }
            | Self::IAddSatINTEL { result_id, .. }
            | Self::UAddSatINTEL { result_id, .. }
            | Self::IAverageINTEL { result_id, .. }
            | Self::UAverageINTEL { result_id, .. }
            | Self::IAverageRoundedINTEL { result_id, .. }
            | Self::UAverageRoundedINTEL { result_id, .. }
            | Self::ISubSatINTEL { result_id, .. }
            | Self::USubSatINTEL { result_id, .. }
            | Self::IMul32x16INTEL { result_id, .. }
            | Self::UMul32x16INTEL { result_id, .. }
            | Self::ConstantFunctionPointerINTEL { result_id, .. }
            | Self::FunctionPointerCallINTEL { result_id, .. }
            | Self::AsmTargetINTEL { result_id, .. }
            | Self::AsmINTEL { result_id, .. }
            | Self::AsmCallINTEL { result_id, .. }
            | Self::AtomicFMinEXT { result_id, .. }
            | Self::AtomicFMaxEXT { result_id, .. }
            | Self::ExpectKHR { result_id, .. }
            | Self::VmeImageINTEL { result_id, .. }
            | Self::TypeVmeImageINTEL { result_id, .. }
            | Self::TypeAvcImePayloadINTEL { result_id, .. }
            | Self::TypeAvcRefPayloadINTEL { result_id, .. }
            | Self::TypeAvcSicPayloadINTEL { result_id, .. }
            | Self::TypeAvcMcePayloadINTEL { result_id, .. }
            | Self::TypeAvcMceResultINTEL { result_id, .. }
            | Self::TypeAvcImeResultINTEL { result_id, .. }
            | Self::TypeAvcImeResultSingleReferenceStreamoutINTEL { result_id, .. }
            | Self::TypeAvcImeResultDualReferenceStreamoutINTEL { result_id, .. }
            | Self::TypeAvcImeSingleReferenceStreaminINTEL { result_id, .. }
            | Self::TypeAvcImeDualReferenceStreaminINTEL { result_id, .. }
            | Self::TypeAvcRefResultINTEL { result_id, .. }
            | Self::TypeAvcSicResultINTEL { result_id, .. }
            | Self::SubgroupAvcMceGetDefaultInterBaseMultiReferencePenaltyINTEL {
                result_id,
                ..
            }
            | Self::SubgroupAvcMceSetInterBaseMultiReferencePenaltyINTEL {
                result_id,
                ..
            }
            | Self::SubgroupAvcMceGetDefaultInterShapePenaltyINTEL { result_id, .. }
            | Self::SubgroupAvcMceSetInterShapePenaltyINTEL { result_id, .. }
            | Self::SubgroupAvcMceGetDefaultInterDirectionPenaltyINTEL { result_id, .. }
            | Self::SubgroupAvcMceSetInterDirectionPenaltyINTEL { result_id, .. }
            | Self::SubgroupAvcMceGetDefaultIntraLumaShapePenaltyINTEL { result_id, .. }
            | Self::SubgroupAvcMceGetDefaultInterMotionVectorCostTableINTEL {
                result_id,
                ..
            }
            | Self::SubgroupAvcMceGetDefaultHighPenaltyCostTableINTEL { result_id, .. }
            | Self::SubgroupAvcMceGetDefaultMediumPenaltyCostTableINTEL { result_id, .. }
            | Self::SubgroupAvcMceGetDefaultLowPenaltyCostTableINTEL { result_id, .. }
            | Self::SubgroupAvcMceSetMotionVectorCostFunctionINTEL { result_id, .. }
            | Self::SubgroupAvcMceGetDefaultIntraLumaModePenaltyINTEL { result_id, .. }
            | Self::SubgroupAvcMceGetDefaultNonDcLumaIntraPenaltyINTEL { result_id, .. }
            | Self::SubgroupAvcMceGetDefaultIntraChromaModeBasePenaltyINTEL {
                result_id,
                ..
            }
            | Self::SubgroupAvcMceSetAcOnlyHaarINTEL { result_id, .. }
            | Self::SubgroupAvcMceSetSourceInterlacedFieldPolarityINTEL { result_id, .. }
            | Self::SubgroupAvcMceSetSingleReferenceInterlacedFieldPolarityINTEL {
                result_id,
                ..
            }
            | Self::SubgroupAvcMceSetDualReferenceInterlacedFieldPolaritiesINTEL {
                result_id,
                ..
            }
            | Self::SubgroupAvcMceConvertToImePayloadINTEL { result_id, .. }
            | Self::SubgroupAvcMceConvertToImeResultINTEL { result_id, .. }
            | Self::SubgroupAvcMceConvertToRefPayloadINTEL { result_id, .. }
            | Self::SubgroupAvcMceConvertToRefResultINTEL { result_id, .. }
            | Self::SubgroupAvcMceConvertToSicPayloadINTEL { result_id, .. }
            | Self::SubgroupAvcMceConvertToSicResultINTEL { result_id, .. }
            | Self::SubgroupAvcMceGetMotionVectorsINTEL { result_id, .. }
            | Self::SubgroupAvcMceGetInterDistortionsINTEL { result_id, .. }
            | Self::SubgroupAvcMceGetBestInterDistortionsINTEL { result_id, .. }
            | Self::SubgroupAvcMceGetInterMajorShapeINTEL { result_id, .. }
            | Self::SubgroupAvcMceGetInterMinorShapeINTEL { result_id, .. }
            | Self::SubgroupAvcMceGetInterDirectionsINTEL { result_id, .. }
            | Self::SubgroupAvcMceGetInterMotionVectorCountINTEL { result_id, .. }
            | Self::SubgroupAvcMceGetInterReferenceIdsINTEL { result_id, .. }
            | Self::SubgroupAvcMceGetInterReferenceInterlacedFieldPolaritiesINTEL {
                result_id,
                ..
            }
            | Self::SubgroupAvcImeInitializeINTEL { result_id, .. }
            | Self::SubgroupAvcImeSetSingleReferenceINTEL { result_id, .. }
            | Self::SubgroupAvcImeSetDualReferenceINTEL { result_id, .. }
            | Self::SubgroupAvcImeRefWindowSizeINTEL { result_id, .. }
            | Self::SubgroupAvcImeAdjustRefOffsetINTEL { result_id, .. }
            | Self::SubgroupAvcImeConvertToMcePayloadINTEL { result_id, .. }
            | Self::SubgroupAvcImeSetMaxMotionVectorCountINTEL { result_id, .. }
            | Self::SubgroupAvcImeSetUnidirectionalMixDisableINTEL { result_id, .. }
            | Self::SubgroupAvcImeSetEarlySearchTerminationThresholdINTEL {
                result_id,
                ..
            }
            | Self::SubgroupAvcImeSetWeightedSadINTEL { result_id, .. }
            | Self::SubgroupAvcImeEvaluateWithSingleReferenceINTEL { result_id, .. }
            | Self::SubgroupAvcImeEvaluateWithDualReferenceINTEL { result_id, .. }
            | Self::SubgroupAvcImeEvaluateWithSingleReferenceStreaminINTEL {
                result_id,
                ..
            }
            | Self::SubgroupAvcImeEvaluateWithDualReferenceStreaminINTEL {
                result_id,
                ..
            }
            | Self::SubgroupAvcImeEvaluateWithSingleReferenceStreamoutINTEL {
                result_id,
                ..
            }
            | Self::SubgroupAvcImeEvaluateWithDualReferenceStreamoutINTEL {
                result_id,
                ..
            }
            | Self::SubgroupAvcImeEvaluateWithSingleReferenceStreaminoutINTEL {
                result_id,
                ..
            }
            | Self::SubgroupAvcImeEvaluateWithDualReferenceStreaminoutINTEL {
                result_id,
                ..
            }
            | Self::SubgroupAvcImeConvertToMceResultINTEL { result_id, .. }
            | Self::SubgroupAvcImeGetSingleReferenceStreaminINTEL { result_id, .. }
            | Self::SubgroupAvcImeGetDualReferenceStreaminINTEL { result_id, .. }
            | Self::SubgroupAvcImeStripSingleReferenceStreamoutINTEL { result_id, .. }
            | Self::SubgroupAvcImeStripDualReferenceStreamoutINTEL { result_id, .. }
            | Self::SubgroupAvcImeGetStreamoutSingleReferenceMajorShapeMotionVectorsINTEL {
                result_id,
                ..
            }
            | Self::SubgroupAvcImeGetStreamoutSingleReferenceMajorShapeDistortionsINTEL {
                result_id,
                ..
            }
            | Self::SubgroupAvcImeGetStreamoutSingleReferenceMajorShapeReferenceIdsINTEL {
                result_id,
                ..
            }
            | Self::SubgroupAvcImeGetStreamoutDualReferenceMajorShapeMotionVectorsINTEL {
                result_id,
                ..
            }
            | Self::SubgroupAvcImeGetStreamoutDualReferenceMajorShapeDistortionsINTEL {
                result_id,
                ..
            }
            | Self::SubgroupAvcImeGetStreamoutDualReferenceMajorShapeReferenceIdsINTEL {
                result_id,
                ..
            }
            | Self::SubgroupAvcImeGetBorderReachedINTEL { result_id, .. }
            | Self::SubgroupAvcImeGetTruncatedSearchIndicationINTEL { result_id, .. }
            | Self::SubgroupAvcImeGetUnidirectionalEarlySearchTerminationINTEL {
                result_id,
                ..
            }
            | Self::SubgroupAvcImeGetWeightingPatternMinimumMotionVectorINTEL {
                result_id,
                ..
            }
            | Self::SubgroupAvcImeGetWeightingPatternMinimumDistortionINTEL {
                result_id,
                ..
            }
            | Self::SubgroupAvcFmeInitializeINTEL { result_id, .. }
            | Self::SubgroupAvcBmeInitializeINTEL { result_id, .. }
            | Self::SubgroupAvcRefConvertToMcePayloadINTEL { result_id, .. }
            | Self::SubgroupAvcRefSetBidirectionalMixDisableINTEL { result_id, .. }
            | Self::SubgroupAvcRefSetBilinearFilterEnableINTEL { result_id, .. }
            | Self::SubgroupAvcRefEvaluateWithSingleReferenceINTEL { result_id, .. }
            | Self::SubgroupAvcRefEvaluateWithDualReferenceINTEL { result_id, .. }
            | Self::SubgroupAvcRefEvaluateWithMultiReferenceINTEL { result_id, .. }
            | Self::SubgroupAvcRefEvaluateWithMultiReferenceInterlacedINTEL {
                result_id,
                ..
            }
            | Self::SubgroupAvcRefConvertToMceResultINTEL { result_id, .. }
            | Self::SubgroupAvcSicInitializeINTEL { result_id, .. }
            | Self::SubgroupAvcSicConfigureSkcINTEL { result_id, .. }
            | Self::SubgroupAvcSicConfigureIpeLumaINTEL { result_id, .. }
            | Self::SubgroupAvcSicConfigureIpeLumaChromaINTEL { result_id, .. }
            | Self::SubgroupAvcSicGetMotionVectorMaskINTEL { result_id, .. }
            | Self::SubgroupAvcSicConvertToMcePayloadINTEL { result_id, .. }
            | Self::SubgroupAvcSicSetIntraLumaShapePenaltyINTEL { result_id, .. }
            | Self::SubgroupAvcSicSetIntraLumaModeCostFunctionINTEL { result_id, .. }
            | Self::SubgroupAvcSicSetIntraChromaModeCostFunctionINTEL { result_id, .. }
            | Self::SubgroupAvcSicSetBilinearFilterEnableINTEL { result_id, .. }
            | Self::SubgroupAvcSicSetSkcForwardTransformEnableINTEL { result_id, .. }
            | Self::SubgroupAvcSicSetBlockBasedRawSkipSadINTEL { result_id, .. }
            | Self::SubgroupAvcSicEvaluateIpeINTEL { result_id, .. }
            | Self::SubgroupAvcSicEvaluateWithSingleReferenceINTEL { result_id, .. }
            | Self::SubgroupAvcSicEvaluateWithDualReferenceINTEL { result_id, .. }
            | Self::SubgroupAvcSicEvaluateWithMultiReferenceINTEL { result_id, .. }
            | Self::SubgroupAvcSicEvaluateWithMultiReferenceInterlacedINTEL {
                result_id,
                ..
            }
            | Self::SubgroupAvcSicConvertToMceResultINTEL { result_id, .. }
            | Self::SubgroupAvcSicGetIpeLumaShapeINTEL { result_id, .. }
            | Self::SubgroupAvcSicGetBestIpeLumaDistortionINTEL { result_id, .. }
            | Self::SubgroupAvcSicGetBestIpeChromaDistortionINTEL { result_id, .. }
            | Self::SubgroupAvcSicGetPackedIpeLumaModesINTEL { result_id, .. }
            | Self::SubgroupAvcSicGetIpeChromaModeINTEL { result_id, .. }
            | Self::SubgroupAvcSicGetPackedSkcLumaCountThresholdINTEL { result_id, .. }
            | Self::SubgroupAvcSicGetPackedSkcLumaSumThresholdINTEL { result_id, .. }
            | Self::SubgroupAvcSicGetInterRawSadsINTEL { result_id, .. }
            | Self::VariableLengthArrayINTEL { result_id, .. }
            | Self::SaveMemoryINTEL { result_id, .. }
            | Self::ArbitraryFloatSinCosPiINTEL { result_id, .. }
            | Self::ArbitraryFloatCastINTEL { result_id, .. }
            | Self::ArbitraryFloatCastFromIntINTEL { result_id, .. }
            | Self::ArbitraryFloatCastToIntINTEL { result_id, .. }
            | Self::ArbitraryFloatAddINTEL { result_id, .. }
            | Self::ArbitraryFloatSubINTEL { result_id, .. }
            | Self::ArbitraryFloatMulINTEL { result_id, .. }
            | Self::ArbitraryFloatDivINTEL { result_id, .. }
            | Self::ArbitraryFloatGTINTEL { result_id, .. }
            | Self::ArbitraryFloatGEINTEL { result_id, .. }
            | Self::ArbitraryFloatLTINTEL { result_id, .. }
            | Self::ArbitraryFloatLEINTEL { result_id, .. }
            | Self::ArbitraryFloatEQINTEL { result_id, .. }
            | Self::ArbitraryFloatRecipINTEL { result_id, .. }
            | Self::ArbitraryFloatRSqrtINTEL { result_id, .. }
            | Self::ArbitraryFloatCbrtINTEL { result_id, .. }
            | Self::ArbitraryFloatHypotINTEL { result_id, .. }
            | Self::ArbitraryFloatSqrtINTEL { result_id, .. }
            | Self::ArbitraryFloatLogINTEL { result_id, .. }
            | Self::ArbitraryFloatLog2INTEL { result_id, .. }
            | Self::ArbitraryFloatLog10INTEL { result_id, .. }
            | Self::ArbitraryFloatLog1pINTEL { result_id, .. }
            | Self::ArbitraryFloatExpINTEL { result_id, .. }
            | Self::ArbitraryFloatExp2INTEL { result_id, .. }
            | Self::ArbitraryFloatExp10INTEL { result_id, .. }
            | Self::ArbitraryFloatExpm1INTEL { result_id, .. }
            | Self::ArbitraryFloatSinINTEL { result_id, .. }
            | Self::ArbitraryFloatCosINTEL { result_id, .. }
            | Self::ArbitraryFloatSinCosINTEL { result_id, .. }
            | Self::ArbitraryFloatSinPiINTEL { result_id, .. }
            | Self::ArbitraryFloatCosPiINTEL { result_id, .. }
            | Self::ArbitraryFloatASinINTEL { result_id, .. }
            | Self::ArbitraryFloatASinPiINTEL { result_id, .. }
            | Self::ArbitraryFloatACosINTEL { result_id, .. }
            | Self::ArbitraryFloatACosPiINTEL { result_id, .. }
            | Self::ArbitraryFloatATanINTEL { result_id, .. }
            | Self::ArbitraryFloatATanPiINTEL { result_id, .. }
            | Self::ArbitraryFloatATan2INTEL { result_id, .. }
            | Self::ArbitraryFloatPowINTEL { result_id, .. }
            | Self::ArbitraryFloatPowRINTEL { result_id, .. }
            | Self::ArbitraryFloatPowNINTEL { result_id, .. }
            | Self::AliasDomainDeclINTEL { result_id, .. }
            | Self::AliasScopeDeclINTEL { result_id, .. }
            | Self::AliasScopeListDeclINTEL { result_id, .. }
            | Self::FixedSqrtINTEL { result_id, .. }
            | Self::FixedRecipINTEL { result_id, .. }
            | Self::FixedRsqrtINTEL { result_id, .. }
            | Self::FixedSinINTEL { result_id, .. }
            | Self::FixedCosINTEL { result_id, .. }
            | Self::FixedSinCosINTEL { result_id, .. }
            | Self::FixedSinPiINTEL { result_id, .. }
            | Self::FixedCosPiINTEL { result_id, .. }
            | Self::FixedSinCosPiINTEL { result_id, .. }
            | Self::FixedLogINTEL { result_id, .. }
            | Self::FixedExpINTEL { result_id, .. }
            | Self::PtrCastToCrossWorkgroupINTEL { result_id, .. }
            | Self::CrossWorkgroupCastToPtrINTEL { result_id, .. }
            | Self::ReadPipeBlockingINTEL { result_id, .. }
            | Self::WritePipeBlockingINTEL { result_id, .. }
            | Self::FPGARegINTEL { result_id, .. }
            | Self::RayQueryGetRayTMinKHR { result_id, .. }
            | Self::RayQueryGetRayFlagsKHR { result_id, .. }
            | Self::RayQueryGetIntersectionTKHR { result_id, .. }
            | Self::RayQueryGetIntersectionInstanceCustomIndexKHR { result_id, .. }
            | Self::RayQueryGetIntersectionInstanceIdKHR { result_id, .. }
            | Self::RayQueryGetIntersectionInstanceShaderBindingTableRecordOffsetKHR {
                result_id,
                ..
            }
            | Self::RayQueryGetIntersectionGeometryIndexKHR { result_id, .. }
            | Self::RayQueryGetIntersectionPrimitiveIndexKHR { result_id, .. }
            | Self::RayQueryGetIntersectionBarycentricsKHR { result_id, .. }
            | Self::RayQueryGetIntersectionFrontFaceKHR { result_id, .. }
            | Self::RayQueryGetIntersectionCandidateAABBOpaqueKHR { result_id, .. }
            | Self::RayQueryGetIntersectionObjectRayDirectionKHR { result_id, .. }
            | Self::RayQueryGetIntersectionObjectRayOriginKHR { result_id, .. }
            | Self::RayQueryGetWorldRayDirectionKHR { result_id, .. }
            | Self::RayQueryGetWorldRayOriginKHR { result_id, .. }
            | Self::RayQueryGetIntersectionObjectToWorldKHR { result_id, .. }
            | Self::RayQueryGetIntersectionWorldToObjectKHR { result_id, .. }
            | Self::AtomicFAddEXT { result_id, .. }
            | Self::TypeBufferSurfaceINTEL { result_id, .. }
            | Self::CompositeConstructContinuedINTEL { result_id, .. }
            | Self::ConvertFToBF16INTEL { result_id, .. }
            | Self::ConvertBF16ToFINTEL { result_id, .. }
            | Self::GroupIMulKHR { result_id, .. }
            | Self::GroupFMulKHR { result_id, .. }
            | Self::GroupBitwiseAndKHR { result_id, .. }
            | Self::GroupBitwiseOrKHR { result_id, .. }
            | Self::GroupBitwiseXorKHR { result_id, .. }
            | Self::GroupLogicalAndKHR { result_id, .. }
            | Self::GroupLogicalOrKHR { result_id, .. }
            | Self::GroupLogicalXorKHR { result_id, .. }
            | Self::MaskedGatherINTEL { result_id, .. } => Some(*result_id),
            _ => None,
        }
    }
    /// Returns the `Id` of the type of `result_id`, if any.
    pub fn result_type_id(&self) -> Option<Id> {
        match self {
            Self::Undef { result_type_id, .. }
            | Self::ExtInst { result_type_id, .. }
            | Self::ConstantTrue { result_type_id, .. }
            | Self::ConstantFalse { result_type_id, .. }
            | Self::Constant { result_type_id, .. }
            | Self::ConstantComposite { result_type_id, .. }
            | Self::ConstantSampler { result_type_id, .. }
            | Self::ConstantNull { result_type_id, .. }
            | Self::SpecConstantTrue { result_type_id, .. }
            | Self::SpecConstantFalse { result_type_id, .. }
            | Self::SpecConstant { result_type_id, .. }
            | Self::SpecConstantComposite { result_type_id, .. }
            | Self::SpecConstantOp { result_type_id, .. }
            | Self::Function { result_type_id, .. }
            | Self::FunctionParameter { result_type_id, .. }
            | Self::FunctionCall { result_type_id, .. }
            | Self::Variable { result_type_id, .. }
            | Self::ImageTexelPointer { result_type_id, .. }
            | Self::Load { result_type_id, .. }
            | Self::AccessChain { result_type_id, .. }
            | Self::InBoundsAccessChain { result_type_id, .. }
            | Self::PtrAccessChain { result_type_id, .. }
            | Self::ArrayLength { result_type_id, .. }
            | Self::GenericPtrMemSemantics { result_type_id, .. }
            | Self::InBoundsPtrAccessChain { result_type_id, .. }
            | Self::VectorExtractDynamic { result_type_id, .. }
            | Self::VectorInsertDynamic { result_type_id, .. }
            | Self::VectorShuffle { result_type_id, .. }
            | Self::CompositeConstruct { result_type_id, .. }
            | Self::CompositeExtract { result_type_id, .. }
            | Self::CompositeInsert { result_type_id, .. }
            | Self::CopyObject { result_type_id, .. }
            | Self::Transpose { result_type_id, .. }
            | Self::SampledImage { result_type_id, .. }
            | Self::ImageSampleImplicitLod { result_type_id, .. }
            | Self::ImageSampleExplicitLod { result_type_id, .. }
            | Self::ImageSampleDrefImplicitLod { result_type_id, .. }
            | Self::ImageSampleDrefExplicitLod { result_type_id, .. }
            | Self::ImageSampleProjImplicitLod { result_type_id, .. }
            | Self::ImageSampleProjExplicitLod { result_type_id, .. }
            | Self::ImageSampleProjDrefImplicitLod { result_type_id, .. }
            | Self::ImageSampleProjDrefExplicitLod { result_type_id, .. }
            | Self::ImageFetch { result_type_id, .. }
            | Self::ImageGather { result_type_id, .. }
            | Self::ImageDrefGather { result_type_id, .. }
            | Self::ImageRead { result_type_id, .. }
            | Self::Image { result_type_id, .. }
            | Self::ImageQueryFormat { result_type_id, .. }
            | Self::ImageQueryOrder { result_type_id, .. }
            | Self::ImageQuerySizeLod { result_type_id, .. }
            | Self::ImageQuerySize { result_type_id, .. }
            | Self::ImageQueryLod { result_type_id, .. }
            | Self::ImageQueryLevels { result_type_id, .. }
            | Self::ImageQuerySamples { result_type_id, .. }
            | Self::ConvertFToU { result_type_id, .. }
            | Self::ConvertFToS { result_type_id, .. }
            | Self::ConvertSToF { result_type_id, .. }
            | Self::ConvertUToF { result_type_id, .. }
            | Self::UConvert { result_type_id, .. }
            | Self::SConvert { result_type_id, .. }
            | Self::FConvert { result_type_id, .. }
            | Self::QuantizeToF16 { result_type_id, .. }
            | Self::ConvertPtrToU { result_type_id, .. }
            | Self::SatConvertSToU { result_type_id, .. }
            | Self::SatConvertUToS { result_type_id, .. }
            | Self::ConvertUToPtr { result_type_id, .. }
            | Self::PtrCastToGeneric { result_type_id, .. }
            | Self::GenericCastToPtr { result_type_id, .. }
            | Self::GenericCastToPtrExplicit { result_type_id, .. }
            | Self::Bitcast { result_type_id, .. }
            | Self::SNegate { result_type_id, .. }
            | Self::FNegate { result_type_id, .. }
            | Self::IAdd { result_type_id, .. }
            | Self::FAdd { result_type_id, .. }
            | Self::ISub { result_type_id, .. }
            | Self::FSub { result_type_id, .. }
            | Self::IMul { result_type_id, .. }
            | Self::FMul { result_type_id, .. }
            | Self::UDiv { result_type_id, .. }
            | Self::SDiv { result_type_id, .. }
            | Self::FDiv { result_type_id, .. }
            | Self::UMod { result_type_id, .. }
            | Self::SRem { result_type_id, .. }
            | Self::SMod { result_type_id, .. }
            | Self::FRem { result_type_id, .. }
            | Self::FMod { result_type_id, .. }
            | Self::VectorTimesScalar { result_type_id, .. }
            | Self::MatrixTimesScalar { result_type_id, .. }
            | Self::VectorTimesMatrix { result_type_id, .. }
            | Self::MatrixTimesVector { result_type_id, .. }
            | Self::MatrixTimesMatrix { result_type_id, .. }
            | Self::OuterProduct { result_type_id, .. }
            | Self::Dot { result_type_id, .. }
            | Self::IAddCarry { result_type_id, .. }
            | Self::ISubBorrow { result_type_id, .. }
            | Self::UMulExtended { result_type_id, .. }
            | Self::SMulExtended { result_type_id, .. }
            | Self::Any { result_type_id, .. }
            | Self::All { result_type_id, .. }
            | Self::IsNan { result_type_id, .. }
            | Self::IsInf { result_type_id, .. }
            | Self::IsFinite { result_type_id, .. }
            | Self::IsNormal { result_type_id, .. }
            | Self::SignBitSet { result_type_id, .. }
            | Self::LessOrGreater { result_type_id, .. }
            | Self::Ordered { result_type_id, .. }
            | Self::Unordered { result_type_id, .. }
            | Self::LogicalEqual { result_type_id, .. }
            | Self::LogicalNotEqual { result_type_id, .. }
            | Self::LogicalOr { result_type_id, .. }
            | Self::LogicalAnd { result_type_id, .. }
            | Self::LogicalNot { result_type_id, .. }
            | Self::Select { result_type_id, .. }
            | Self::IEqual { result_type_id, .. }
            | Self::INotEqual { result_type_id, .. }
            | Self::UGreaterThan { result_type_id, .. }
            | Self::SGreaterThan { result_type_id, .. }
            | Self::UGreaterThanEqual { result_type_id, .. }
            | Self::SGreaterThanEqual { result_type_id, .. }
            | Self::ULessThan { result_type_id, .. }
            | Self::SLessThan { result_type_id, .. }
            | Self::ULessThanEqual { result_type_id, .. }
            | Self::SLessThanEqual { result_type_id, .. }
            | Self::FOrdEqual { result_type_id, .. }
            | Self::FUnordEqual { result_type_id, .. }
            | Self::FOrdNotEqual { result_type_id, .. }
            | Self::FUnordNotEqual { result_type_id, .. }
            | Self::FOrdLessThan { result_type_id, .. }
            | Self::FUnordLessThan { result_type_id, .. }
            | Self::FOrdGreaterThan { result_type_id, .. }
            | Self::FUnordGreaterThan { result_type_id, .. }
            | Self::FOrdLessThanEqual { result_type_id, .. }
            | Self::FUnordLessThanEqual { result_type_id, .. }
            | Self::FOrdGreaterThanEqual { result_type_id, .. }
            | Self::FUnordGreaterThanEqual { result_type_id, .. }
            | Self::ShiftRightLogical { result_type_id, .. }
            | Self::ShiftRightArithmetic { result_type_id, .. }
            | Self::ShiftLeftLogical { result_type_id, .. }
            | Self::BitwiseOr { result_type_id, .. }
            | Self::BitwiseXor { result_type_id, .. }
            | Self::BitwiseAnd { result_type_id, .. }
            | Self::Not { result_type_id, .. }
            | Self::BitFieldInsert { result_type_id, .. }
            | Self::BitFieldSExtract { result_type_id, .. }
            | Self::BitFieldUExtract { result_type_id, .. }
            | Self::BitReverse { result_type_id, .. }
            | Self::BitCount { result_type_id, .. }
            | Self::DPdx { result_type_id, .. }
            | Self::DPdy { result_type_id, .. }
            | Self::Fwidth { result_type_id, .. }
            | Self::DPdxFine { result_type_id, .. }
            | Self::DPdyFine { result_type_id, .. }
            | Self::FwidthFine { result_type_id, .. }
            | Self::DPdxCoarse { result_type_id, .. }
            | Self::DPdyCoarse { result_type_id, .. }
            | Self::FwidthCoarse { result_type_id, .. }
            | Self::AtomicLoad { result_type_id, .. }
            | Self::AtomicExchange { result_type_id, .. }
            | Self::AtomicCompareExchange { result_type_id, .. }
            | Self::AtomicCompareExchangeWeak { result_type_id, .. }
            | Self::AtomicIIncrement { result_type_id, .. }
            | Self::AtomicIDecrement { result_type_id, .. }
            | Self::AtomicIAdd { result_type_id, .. }
            | Self::AtomicISub { result_type_id, .. }
            | Self::AtomicSMin { result_type_id, .. }
            | Self::AtomicUMin { result_type_id, .. }
            | Self::AtomicSMax { result_type_id, .. }
            | Self::AtomicUMax { result_type_id, .. }
            | Self::AtomicAnd { result_type_id, .. }
            | Self::AtomicOr { result_type_id, .. }
            | Self::AtomicXor { result_type_id, .. }
            | Self::Phi { result_type_id, .. }
            | Self::GroupAsyncCopy { result_type_id, .. }
            | Self::GroupAll { result_type_id, .. }
            | Self::GroupAny { result_type_id, .. }
            | Self::GroupBroadcast { result_type_id, .. }
            | Self::GroupIAdd { result_type_id, .. }
            | Self::GroupFAdd { result_type_id, .. }
            | Self::GroupFMin { result_type_id, .. }
            | Self::GroupUMin { result_type_id, .. }
            | Self::GroupSMin { result_type_id, .. }
            | Self::GroupFMax { result_type_id, .. }
            | Self::GroupUMax { result_type_id, .. }
            | Self::GroupSMax { result_type_id, .. }
            | Self::ReadPipe { result_type_id, .. }
            | Self::WritePipe { result_type_id, .. }
            | Self::ReservedReadPipe { result_type_id, .. }
            | Self::ReservedWritePipe { result_type_id, .. }
            | Self::ReserveReadPipePackets { result_type_id, .. }
            | Self::ReserveWritePipePackets { result_type_id, .. }
            | Self::IsValidReserveId { result_type_id, .. }
            | Self::GetNumPipePackets { result_type_id, .. }
            | Self::GetMaxPipePackets { result_type_id, .. }
            | Self::GroupReserveReadPipePackets { result_type_id, .. }
            | Self::GroupReserveWritePipePackets { result_type_id, .. }
            | Self::EnqueueMarker { result_type_id, .. }
            | Self::EnqueueKernel { result_type_id, .. }
            | Self::GetKernelNDrangeSubGroupCount { result_type_id, .. }
            | Self::GetKernelNDrangeMaxSubGroupSize { result_type_id, .. }
            | Self::GetKernelWorkGroupSize { result_type_id, .. }
            | Self::GetKernelPreferredWorkGroupSizeMultiple { result_type_id, .. }
            | Self::CreateUserEvent { result_type_id, .. }
            | Self::IsValidEvent { result_type_id, .. }
            | Self::GetDefaultQueue { result_type_id, .. }
            | Self::BuildNDRange { result_type_id, .. }
            | Self::ImageSparseSampleImplicitLod { result_type_id, .. }
            | Self::ImageSparseSampleExplicitLod { result_type_id, .. }
            | Self::ImageSparseSampleDrefImplicitLod { result_type_id, .. }
            | Self::ImageSparseSampleDrefExplicitLod { result_type_id, .. }
            | Self::ImageSparseSampleProjImplicitLod { result_type_id, .. }
            | Self::ImageSparseSampleProjExplicitLod { result_type_id, .. }
            | Self::ImageSparseSampleProjDrefImplicitLod { result_type_id, .. }
            | Self::ImageSparseSampleProjDrefExplicitLod { result_type_id, .. }
            | Self::ImageSparseFetch { result_type_id, .. }
            | Self::ImageSparseGather { result_type_id, .. }
            | Self::ImageSparseDrefGather { result_type_id, .. }
            | Self::ImageSparseTexelsResident { result_type_id, .. }
            | Self::AtomicFlagTestAndSet { result_type_id, .. }
            | Self::ImageSparseRead { result_type_id, .. }
            | Self::SizeOf { result_type_id, .. }
            | Self::ConstantPipeStorage { result_type_id, .. }
            | Self::CreatePipeFromPipeStorage { result_type_id, .. }
            | Self::GetKernelLocalSizeForSubgroupCount { result_type_id, .. }
            | Self::GetKernelMaxNumSubgroups { result_type_id, .. }
            | Self::NamedBarrierInitialize { result_type_id, .. }
            | Self::GroupNonUniformElect { result_type_id, .. }
            | Self::GroupNonUniformAll { result_type_id, .. }
            | Self::GroupNonUniformAny { result_type_id, .. }
            | Self::GroupNonUniformAllEqual { result_type_id, .. }
            | Self::GroupNonUniformBroadcast { result_type_id, .. }
            | Self::GroupNonUniformBroadcastFirst { result_type_id, .. }
            | Self::GroupNonUniformBallot { result_type_id, .. }
            | Self::GroupNonUniformInverseBallot { result_type_id, .. }
            | Self::GroupNonUniformBallotBitExtract { result_type_id, .. }
            | Self::GroupNonUniformBallotBitCount { result_type_id, .. }
            | Self::GroupNonUniformBallotFindLSB { result_type_id, .. }
            | Self::GroupNonUniformBallotFindMSB { result_type_id, .. }
            | Self::GroupNonUniformShuffle { result_type_id, .. }
            | Self::GroupNonUniformShuffleXor { result_type_id, .. }
            | Self::GroupNonUniformShuffleUp { result_type_id, .. }
            | Self::GroupNonUniformShuffleDown { result_type_id, .. }
            | Self::GroupNonUniformIAdd { result_type_id, .. }
            | Self::GroupNonUniformFAdd { result_type_id, .. }
            | Self::GroupNonUniformIMul { result_type_id, .. }
            | Self::GroupNonUniformFMul { result_type_id, .. }
            | Self::GroupNonUniformSMin { result_type_id, .. }
            | Self::GroupNonUniformUMin { result_type_id, .. }
            | Self::GroupNonUniformFMin { result_type_id, .. }
            | Self::GroupNonUniformSMax { result_type_id, .. }
            | Self::GroupNonUniformUMax { result_type_id, .. }
            | Self::GroupNonUniformFMax { result_type_id, .. }
            | Self::GroupNonUniformBitwiseAnd { result_type_id, .. }
            | Self::GroupNonUniformBitwiseOr { result_type_id, .. }
            | Self::GroupNonUniformBitwiseXor { result_type_id, .. }
            | Self::GroupNonUniformLogicalAnd { result_type_id, .. }
            | Self::GroupNonUniformLogicalOr { result_type_id, .. }
            | Self::GroupNonUniformLogicalXor { result_type_id, .. }
            | Self::GroupNonUniformQuadBroadcast { result_type_id, .. }
            | Self::GroupNonUniformQuadSwap { result_type_id, .. }
            | Self::CopyLogical { result_type_id, .. }
            | Self::PtrEqual { result_type_id, .. }
            | Self::PtrNotEqual { result_type_id, .. }
            | Self::PtrDiff { result_type_id, .. }
            | Self::ColorAttachmentReadEXT { result_type_id, .. }
            | Self::DepthAttachmentReadEXT { result_type_id, .. }
            | Self::StencilAttachmentReadEXT { result_type_id, .. }
            | Self::SubgroupBallotKHR { result_type_id, .. }
            | Self::SubgroupFirstInvocationKHR { result_type_id, .. }
            | Self::SubgroupAllKHR { result_type_id, .. }
            | Self::SubgroupAnyKHR { result_type_id, .. }
            | Self::SubgroupAllEqualKHR { result_type_id, .. }
            | Self::GroupNonUniformRotateKHR { result_type_id, .. }
            | Self::SubgroupReadInvocationKHR { result_type_id, .. }
            | Self::ConvertUToAccelerationStructureKHR { result_type_id, .. }
            | Self::SDot { result_type_id, .. }
            | Self::UDot { result_type_id, .. }
            | Self::SUDot { result_type_id, .. }
            | Self::SDotAccSat { result_type_id, .. }
            | Self::UDotAccSat { result_type_id, .. }
            | Self::SUDotAccSat { result_type_id, .. }
            | Self::CooperativeMatrixLoadKHR { result_type_id, .. }
            | Self::CooperativeMatrixMulAddKHR { result_type_id, .. }
            | Self::CooperativeMatrixLengthKHR { result_type_id, .. }
            | Self::RayQueryProceedKHR { result_type_id, .. }
            | Self::RayQueryGetIntersectionTypeKHR { result_type_id, .. }
            | Self::ImageSampleWeightedQCOM { result_type_id, .. }
            | Self::ImageBoxFilterQCOM { result_type_id, .. }
            | Self::ImageBlockMatchSSDQCOM { result_type_id, .. }
            | Self::ImageBlockMatchSADQCOM { result_type_id, .. }
            | Self::ImageBlockMatchWindowSSDQCOM { result_type_id, .. }
            | Self::ImageBlockMatchWindowSADQCOM { result_type_id, .. }
            | Self::ImageBlockMatchGatherSSDQCOM { result_type_id, .. }
            | Self::ImageBlockMatchGatherSADQCOM { result_type_id, .. }
            | Self::GroupIAddNonUniformAMD { result_type_id, .. }
            | Self::GroupFAddNonUniformAMD { result_type_id, .. }
            | Self::GroupFMinNonUniformAMD { result_type_id, .. }
            | Self::GroupUMinNonUniformAMD { result_type_id, .. }
            | Self::GroupSMinNonUniformAMD { result_type_id, .. }
            | Self::GroupFMaxNonUniformAMD { result_type_id, .. }
            | Self::GroupUMaxNonUniformAMD { result_type_id, .. }
            | Self::GroupSMaxNonUniformAMD { result_type_id, .. }
            | Self::FragmentMaskFetchAMD { result_type_id, .. }
            | Self::FragmentFetchAMD { result_type_id, .. }
            | Self::ReadClockKHR { result_type_id, .. }
            | Self::FinishWritingNodePayloadAMDX { result_type_id, .. }
            | Self::GroupNonUniformQuadAllKHR { result_type_id, .. }
            | Self::GroupNonUniformQuadAnyKHR { result_type_id, .. }
            | Self::HitObjectGetWorldToObjectNV { result_type_id, .. }
            | Self::HitObjectGetObjectToWorldNV { result_type_id, .. }
            | Self::HitObjectGetObjectRayDirectionNV { result_type_id, .. }
            | Self::HitObjectGetObjectRayOriginNV { result_type_id, .. }
            | Self::HitObjectGetShaderRecordBufferHandleNV { result_type_id, .. }
            | Self::HitObjectGetShaderBindingTableRecordIndexNV { result_type_id, .. }
            | Self::HitObjectGetCurrentTimeNV { result_type_id, .. }
            | Self::HitObjectGetHitKindNV { result_type_id, .. }
            | Self::HitObjectGetPrimitiveIndexNV { result_type_id, .. }
            | Self::HitObjectGetGeometryIndexNV { result_type_id, .. }
            | Self::HitObjectGetInstanceIdNV { result_type_id, .. }
            | Self::HitObjectGetInstanceCustomIndexNV { result_type_id, .. }
            | Self::HitObjectGetWorldRayDirectionNV { result_type_id, .. }
            | Self::HitObjectGetWorldRayOriginNV { result_type_id, .. }
            | Self::HitObjectGetRayTMaxNV { result_type_id, .. }
            | Self::HitObjectGetRayTMinNV { result_type_id, .. }
            | Self::HitObjectIsEmptyNV { result_type_id, .. }
            | Self::HitObjectIsHitNV { result_type_id, .. }
            | Self::HitObjectIsMissNV { result_type_id, .. }
            | Self::ImageSampleFootprintNV { result_type_id, .. }
            | Self::GroupNonUniformPartitionNV { result_type_id, .. }
            | Self::FetchMicroTriangleVertexPositionNV { result_type_id, .. }
            | Self::FetchMicroTriangleVertexBarycentricNV { result_type_id, .. }
            | Self::ReportIntersectionKHR { result_type_id, .. }
            | Self::RayQueryGetIntersectionTriangleVertexPositionsKHR {
                result_type_id,
                ..
            }
            | Self::CooperativeMatrixLoadNV { result_type_id, .. }
            | Self::CooperativeMatrixMulAddNV { result_type_id, .. }
            | Self::CooperativeMatrixLengthNV { result_type_id, .. }
            | Self::IsHelperInvocationEXT { result_type_id, .. }
            | Self::ConvertUToImageNV { result_type_id, .. }
            | Self::ConvertUToSamplerNV { result_type_id, .. }
            | Self::ConvertImageToUNV { result_type_id, .. }
            | Self::ConvertSamplerToUNV { result_type_id, .. }
            | Self::ConvertUToSampledImageNV { result_type_id, .. }
            | Self::ConvertSampledImageToUNV { result_type_id, .. }
            | Self::RawAccessChainNV { result_type_id, .. }
            | Self::SubgroupShuffleINTEL { result_type_id, .. }
            | Self::SubgroupShuffleDownINTEL { result_type_id, .. }
            | Self::SubgroupShuffleUpINTEL { result_type_id, .. }
            | Self::SubgroupShuffleXorINTEL { result_type_id, .. }
            | Self::SubgroupBlockReadINTEL { result_type_id, .. }
            | Self::SubgroupImageBlockReadINTEL { result_type_id, .. }
            | Self::SubgroupImageMediaBlockReadINTEL { result_type_id, .. }
            | Self::UCountLeadingZerosINTEL { result_type_id, .. }
            | Self::UCountTrailingZerosINTEL { result_type_id, .. }
            | Self::AbsISubINTEL { result_type_id, .. }
            | Self::AbsUSubINTEL { result_type_id, .. }
            | Self::IAddSatINTEL { result_type_id, .. }
            | Self::UAddSatINTEL { result_type_id, .. }
            | Self::IAverageINTEL { result_type_id, .. }
            | Self::UAverageINTEL { result_type_id, .. }
            | Self::IAverageRoundedINTEL { result_type_id, .. }
            | Self::UAverageRoundedINTEL { result_type_id, .. }
            | Self::ISubSatINTEL { result_type_id, .. }
            | Self::USubSatINTEL { result_type_id, .. }
            | Self::IMul32x16INTEL { result_type_id, .. }
            | Self::UMul32x16INTEL { result_type_id, .. }
            | Self::ConstantFunctionPointerINTEL { result_type_id, .. }
            | Self::FunctionPointerCallINTEL { result_type_id, .. }
            | Self::AsmTargetINTEL { result_type_id, .. }
            | Self::AsmINTEL { result_type_id, .. }
            | Self::AsmCallINTEL { result_type_id, .. }
            | Self::AtomicFMinEXT { result_type_id, .. }
            | Self::AtomicFMaxEXT { result_type_id, .. }
            | Self::ExpectKHR { result_type_id, .. }
            | Self::VmeImageINTEL { result_type_id, .. }
            | Self::SubgroupAvcMceGetDefaultInterBaseMultiReferencePenaltyINTEL {
                result_type_id,
                ..
            }
            | Self::SubgroupAvcMceSetInterBaseMultiReferencePenaltyINTEL {
                result_type_id,
                ..
            }
            | Self::SubgroupAvcMceGetDefaultInterShapePenaltyINTEL { result_type_id, .. }
            | Self::SubgroupAvcMceSetInterShapePenaltyINTEL { result_type_id, .. }
            | Self::SubgroupAvcMceGetDefaultInterDirectionPenaltyINTEL {
                result_type_id,
                ..
            }
            | Self::SubgroupAvcMceSetInterDirectionPenaltyINTEL { result_type_id, .. }
            | Self::SubgroupAvcMceGetDefaultIntraLumaShapePenaltyINTEL {
                result_type_id,
                ..
            }
            | Self::SubgroupAvcMceGetDefaultInterMotionVectorCostTableINTEL {
                result_type_id,
                ..
            }
            | Self::SubgroupAvcMceGetDefaultHighPenaltyCostTableINTEL {
                result_type_id,
                ..
            }
            | Self::SubgroupAvcMceGetDefaultMediumPenaltyCostTableINTEL {
                result_type_id,
                ..
            }
            | Self::SubgroupAvcMceGetDefaultLowPenaltyCostTableINTEL {
                result_type_id,
                ..
            }
            | Self::SubgroupAvcMceSetMotionVectorCostFunctionINTEL { result_type_id, .. }
            | Self::SubgroupAvcMceGetDefaultIntraLumaModePenaltyINTEL {
                result_type_id,
                ..
            }
            | Self::SubgroupAvcMceGetDefaultNonDcLumaIntraPenaltyINTEL {
                result_type_id,
                ..
            }
            | Self::SubgroupAvcMceGetDefaultIntraChromaModeBasePenaltyINTEL {
                result_type_id,
                ..
            }
            | Self::SubgroupAvcMceSetAcOnlyHaarINTEL { result_type_id, .. }
            | Self::SubgroupAvcMceSetSourceInterlacedFieldPolarityINTEL {
                result_type_id,
                ..
            }
            | Self::SubgroupAvcMceSetSingleReferenceInterlacedFieldPolarityINTEL {
                result_type_id,
                ..
            }
            | Self::SubgroupAvcMceSetDualReferenceInterlacedFieldPolaritiesINTEL {
                result_type_id,
                ..
            }
            | Self::SubgroupAvcMceConvertToImePayloadINTEL { result_type_id, .. }
            | Self::SubgroupAvcMceConvertToImeResultINTEL { result_type_id, .. }
            | Self::SubgroupAvcMceConvertToRefPayloadINTEL { result_type_id, .. }
            | Self::SubgroupAvcMceConvertToRefResultINTEL { result_type_id, .. }
            | Self::SubgroupAvcMceConvertToSicPayloadINTEL { result_type_id, .. }
            | Self::SubgroupAvcMceConvertToSicResultINTEL { result_type_id, .. }
            | Self::SubgroupAvcMceGetMotionVectorsINTEL { result_type_id, .. }
            | Self::SubgroupAvcMceGetInterDistortionsINTEL { result_type_id, .. }
            | Self::SubgroupAvcMceGetBestInterDistortionsINTEL { result_type_id, .. }
            | Self::SubgroupAvcMceGetInterMajorShapeINTEL { result_type_id, .. }
            | Self::SubgroupAvcMceGetInterMinorShapeINTEL { result_type_id, .. }
            | Self::SubgroupAvcMceGetInterDirectionsINTEL { result_type_id, .. }
            | Self::SubgroupAvcMceGetInterMotionVectorCountINTEL { result_type_id, .. }
            | Self::SubgroupAvcMceGetInterReferenceIdsINTEL { result_type_id, .. }
            | Self::SubgroupAvcMceGetInterReferenceInterlacedFieldPolaritiesINTEL {
                result_type_id,
                ..
            }
            | Self::SubgroupAvcImeInitializeINTEL { result_type_id, .. }
            | Self::SubgroupAvcImeSetSingleReferenceINTEL { result_type_id, .. }
            | Self::SubgroupAvcImeSetDualReferenceINTEL { result_type_id, .. }
            | Self::SubgroupAvcImeRefWindowSizeINTEL { result_type_id, .. }
            | Self::SubgroupAvcImeAdjustRefOffsetINTEL { result_type_id, .. }
            | Self::SubgroupAvcImeConvertToMcePayloadINTEL { result_type_id, .. }
            | Self::SubgroupAvcImeSetMaxMotionVectorCountINTEL { result_type_id, .. }
            | Self::SubgroupAvcImeSetUnidirectionalMixDisableINTEL { result_type_id, .. }
            | Self::SubgroupAvcImeSetEarlySearchTerminationThresholdINTEL {
                result_type_id,
                ..
            }
            | Self::SubgroupAvcImeSetWeightedSadINTEL { result_type_id, .. }
            | Self::SubgroupAvcImeEvaluateWithSingleReferenceINTEL { result_type_id, .. }
            | Self::SubgroupAvcImeEvaluateWithDualReferenceINTEL { result_type_id, .. }
            | Self::SubgroupAvcImeEvaluateWithSingleReferenceStreaminINTEL {
                result_type_id,
                ..
            }
            | Self::SubgroupAvcImeEvaluateWithDualReferenceStreaminINTEL {
                result_type_id,
                ..
            }
            | Self::SubgroupAvcImeEvaluateWithSingleReferenceStreamoutINTEL {
                result_type_id,
                ..
            }
            | Self::SubgroupAvcImeEvaluateWithDualReferenceStreamoutINTEL {
                result_type_id,
                ..
            }
            | Self::SubgroupAvcImeEvaluateWithSingleReferenceStreaminoutINTEL {
                result_type_id,
                ..
            }
            | Self::SubgroupAvcImeEvaluateWithDualReferenceStreaminoutINTEL {
                result_type_id,
                ..
            }
            | Self::SubgroupAvcImeConvertToMceResultINTEL { result_type_id, .. }
            | Self::SubgroupAvcImeGetSingleReferenceStreaminINTEL { result_type_id, .. }
            | Self::SubgroupAvcImeGetDualReferenceStreaminINTEL { result_type_id, .. }
            | Self::SubgroupAvcImeStripSingleReferenceStreamoutINTEL {
                result_type_id,
                ..
            }
            | Self::SubgroupAvcImeStripDualReferenceStreamoutINTEL { result_type_id, .. }
            | Self::SubgroupAvcImeGetStreamoutSingleReferenceMajorShapeMotionVectorsINTEL {
                result_type_id,
                ..
            }
            | Self::SubgroupAvcImeGetStreamoutSingleReferenceMajorShapeDistortionsINTEL {
                result_type_id,
                ..
            }
            | Self::SubgroupAvcImeGetStreamoutSingleReferenceMajorShapeReferenceIdsINTEL {
                result_type_id,
                ..
            }
            | Self::SubgroupAvcImeGetStreamoutDualReferenceMajorShapeMotionVectorsINTEL {
                result_type_id,
                ..
            }
            | Self::SubgroupAvcImeGetStreamoutDualReferenceMajorShapeDistortionsINTEL {
                result_type_id,
                ..
            }
            | Self::SubgroupAvcImeGetStreamoutDualReferenceMajorShapeReferenceIdsINTEL {
                result_type_id,
                ..
            }
            | Self::SubgroupAvcImeGetBorderReachedINTEL { result_type_id, .. }
            | Self::SubgroupAvcImeGetTruncatedSearchIndicationINTEL {
                result_type_id,
                ..
            }
            | Self::SubgroupAvcImeGetUnidirectionalEarlySearchTerminationINTEL {
                result_type_id,
                ..
            }
            | Self::SubgroupAvcImeGetWeightingPatternMinimumMotionVectorINTEL {
                result_type_id,
                ..
            }
            | Self::SubgroupAvcImeGetWeightingPatternMinimumDistortionINTEL {
                result_type_id,
                ..
            }
            | Self::SubgroupAvcFmeInitializeINTEL { result_type_id, .. }
            | Self::SubgroupAvcBmeInitializeINTEL { result_type_id, .. }
            | Self::SubgroupAvcRefConvertToMcePayloadINTEL { result_type_id, .. }
            | Self::SubgroupAvcRefSetBidirectionalMixDisableINTEL { result_type_id, .. }
            | Self::SubgroupAvcRefSetBilinearFilterEnableINTEL { result_type_id, .. }
            | Self::SubgroupAvcRefEvaluateWithSingleReferenceINTEL { result_type_id, .. }
            | Self::SubgroupAvcRefEvaluateWithDualReferenceINTEL { result_type_id, .. }
            | Self::SubgroupAvcRefEvaluateWithMultiReferenceINTEL { result_type_id, .. }
            | Self::SubgroupAvcRefEvaluateWithMultiReferenceInterlacedINTEL {
                result_type_id,
                ..
            }
            | Self::SubgroupAvcRefConvertToMceResultINTEL { result_type_id, .. }
            | Self::SubgroupAvcSicInitializeINTEL { result_type_id, .. }
            | Self::SubgroupAvcSicConfigureSkcINTEL { result_type_id, .. }
            | Self::SubgroupAvcSicConfigureIpeLumaINTEL { result_type_id, .. }
            | Self::SubgroupAvcSicConfigureIpeLumaChromaINTEL { result_type_id, .. }
            | Self::SubgroupAvcSicGetMotionVectorMaskINTEL { result_type_id, .. }
            | Self::SubgroupAvcSicConvertToMcePayloadINTEL { result_type_id, .. }
            | Self::SubgroupAvcSicSetIntraLumaShapePenaltyINTEL { result_type_id, .. }
            | Self::SubgroupAvcSicSetIntraLumaModeCostFunctionINTEL {
                result_type_id,
                ..
            }
            | Self::SubgroupAvcSicSetIntraChromaModeCostFunctionINTEL {
                result_type_id,
                ..
            }
            | Self::SubgroupAvcSicSetBilinearFilterEnableINTEL { result_type_id, .. }
            | Self::SubgroupAvcSicSetSkcForwardTransformEnableINTEL {
                result_type_id,
                ..
            }
            | Self::SubgroupAvcSicSetBlockBasedRawSkipSadINTEL { result_type_id, .. }
            | Self::SubgroupAvcSicEvaluateIpeINTEL { result_type_id, .. }
            | Self::SubgroupAvcSicEvaluateWithSingleReferenceINTEL { result_type_id, .. }
            | Self::SubgroupAvcSicEvaluateWithDualReferenceINTEL { result_type_id, .. }
            | Self::SubgroupAvcSicEvaluateWithMultiReferenceINTEL { result_type_id, .. }
            | Self::SubgroupAvcSicEvaluateWithMultiReferenceInterlacedINTEL {
                result_type_id,
                ..
            }
            | Self::SubgroupAvcSicConvertToMceResultINTEL { result_type_id, .. }
            | Self::SubgroupAvcSicGetIpeLumaShapeINTEL { result_type_id, .. }
            | Self::SubgroupAvcSicGetBestIpeLumaDistortionINTEL { result_type_id, .. }
            | Self::SubgroupAvcSicGetBestIpeChromaDistortionINTEL { result_type_id, .. }
            | Self::SubgroupAvcSicGetPackedIpeLumaModesINTEL { result_type_id, .. }
            | Self::SubgroupAvcSicGetIpeChromaModeINTEL { result_type_id, .. }
            | Self::SubgroupAvcSicGetPackedSkcLumaCountThresholdINTEL {
                result_type_id,
                ..
            }
            | Self::SubgroupAvcSicGetPackedSkcLumaSumThresholdINTEL {
                result_type_id,
                ..
            }
            | Self::SubgroupAvcSicGetInterRawSadsINTEL { result_type_id, .. }
            | Self::VariableLengthArrayINTEL { result_type_id, .. }
            | Self::SaveMemoryINTEL { result_type_id, .. }
            | Self::ArbitraryFloatSinCosPiINTEL { result_type_id, .. }
            | Self::ArbitraryFloatCastINTEL { result_type_id, .. }
            | Self::ArbitraryFloatCastFromIntINTEL { result_type_id, .. }
            | Self::ArbitraryFloatCastToIntINTEL { result_type_id, .. }
            | Self::ArbitraryFloatAddINTEL { result_type_id, .. }
            | Self::ArbitraryFloatSubINTEL { result_type_id, .. }
            | Self::ArbitraryFloatMulINTEL { result_type_id, .. }
            | Self::ArbitraryFloatDivINTEL { result_type_id, .. }
            | Self::ArbitraryFloatGTINTEL { result_type_id, .. }
            | Self::ArbitraryFloatGEINTEL { result_type_id, .. }
            | Self::ArbitraryFloatLTINTEL { result_type_id, .. }
            | Self::ArbitraryFloatLEINTEL { result_type_id, .. }
            | Self::ArbitraryFloatEQINTEL { result_type_id, .. }
            | Self::ArbitraryFloatRecipINTEL { result_type_id, .. }
            | Self::ArbitraryFloatRSqrtINTEL { result_type_id, .. }
            | Self::ArbitraryFloatCbrtINTEL { result_type_id, .. }
            | Self::ArbitraryFloatHypotINTEL { result_type_id, .. }
            | Self::ArbitraryFloatSqrtINTEL { result_type_id, .. }
            | Self::ArbitraryFloatLogINTEL { result_type_id, .. }
            | Self::ArbitraryFloatLog2INTEL { result_type_id, .. }
            | Self::ArbitraryFloatLog10INTEL { result_type_id, .. }
            | Self::ArbitraryFloatLog1pINTEL { result_type_id, .. }
            | Self::ArbitraryFloatExpINTEL { result_type_id, .. }
            | Self::ArbitraryFloatExp2INTEL { result_type_id, .. }
            | Self::ArbitraryFloatExp10INTEL { result_type_id, .. }
            | Self::ArbitraryFloatExpm1INTEL { result_type_id, .. }
            | Self::ArbitraryFloatSinINTEL { result_type_id, .. }
            | Self::ArbitraryFloatCosINTEL { result_type_id, .. }
            | Self::ArbitraryFloatSinCosINTEL { result_type_id, .. }
            | Self::ArbitraryFloatSinPiINTEL { result_type_id, .. }
            | Self::ArbitraryFloatCosPiINTEL { result_type_id, .. }
            | Self::ArbitraryFloatASinINTEL { result_type_id, .. }
            | Self::ArbitraryFloatASinPiINTEL { result_type_id, .. }
            | Self::ArbitraryFloatACosINTEL { result_type_id, .. }
            | Self::ArbitraryFloatACosPiINTEL { result_type_id, .. }
            | Self::ArbitraryFloatATanINTEL { result_type_id, .. }
            | Self::ArbitraryFloatATanPiINTEL { result_type_id, .. }
            | Self::ArbitraryFloatATan2INTEL { result_type_id, .. }
            | Self::ArbitraryFloatPowINTEL { result_type_id, .. }
            | Self::ArbitraryFloatPowRINTEL { result_type_id, .. }
            | Self::ArbitraryFloatPowNINTEL { result_type_id, .. }
            | Self::FixedSqrtINTEL { result_type_id, .. }
            | Self::FixedRecipINTEL { result_type_id, .. }
            | Self::FixedRsqrtINTEL { result_type_id, .. }
            | Self::FixedSinINTEL { result_type_id, .. }
            | Self::FixedCosINTEL { result_type_id, .. }
            | Self::FixedSinCosINTEL { result_type_id, .. }
            | Self::FixedSinPiINTEL { result_type_id, .. }
            | Self::FixedCosPiINTEL { result_type_id, .. }
            | Self::FixedSinCosPiINTEL { result_type_id, .. }
            | Self::FixedLogINTEL { result_type_id, .. }
            | Self::FixedExpINTEL { result_type_id, .. }
            | Self::PtrCastToCrossWorkgroupINTEL { result_type_id, .. }
            | Self::CrossWorkgroupCastToPtrINTEL { result_type_id, .. }
            | Self::ReadPipeBlockingINTEL { result_type_id, .. }
            | Self::WritePipeBlockingINTEL { result_type_id, .. }
            | Self::FPGARegINTEL { result_type_id, .. }
            | Self::RayQueryGetRayTMinKHR { result_type_id, .. }
            | Self::RayQueryGetRayFlagsKHR { result_type_id, .. }
            | Self::RayQueryGetIntersectionTKHR { result_type_id, .. }
            | Self::RayQueryGetIntersectionInstanceCustomIndexKHR { result_type_id, .. }
            | Self::RayQueryGetIntersectionInstanceIdKHR { result_type_id, .. }
            | Self::RayQueryGetIntersectionInstanceShaderBindingTableRecordOffsetKHR {
                result_type_id,
                ..
            }
            | Self::RayQueryGetIntersectionGeometryIndexKHR { result_type_id, .. }
            | Self::RayQueryGetIntersectionPrimitiveIndexKHR { result_type_id, .. }
            | Self::RayQueryGetIntersectionBarycentricsKHR { result_type_id, .. }
            | Self::RayQueryGetIntersectionFrontFaceKHR { result_type_id, .. }
            | Self::RayQueryGetIntersectionCandidateAABBOpaqueKHR { result_type_id, .. }
            | Self::RayQueryGetIntersectionObjectRayDirectionKHR { result_type_id, .. }
            | Self::RayQueryGetIntersectionObjectRayOriginKHR { result_type_id, .. }
            | Self::RayQueryGetWorldRayDirectionKHR { result_type_id, .. }
            | Self::RayQueryGetWorldRayOriginKHR { result_type_id, .. }
            | Self::RayQueryGetIntersectionObjectToWorldKHR { result_type_id, .. }
            | Self::RayQueryGetIntersectionWorldToObjectKHR { result_type_id, .. }
            | Self::AtomicFAddEXT { result_type_id, .. }
            | Self::CompositeConstructContinuedINTEL { result_type_id, .. }
            | Self::ConvertFToBF16INTEL { result_type_id, .. }
            | Self::ConvertBF16ToFINTEL { result_type_id, .. }
            | Self::GroupIMulKHR { result_type_id, .. }
            | Self::GroupFMulKHR { result_type_id, .. }
            | Self::GroupBitwiseAndKHR { result_type_id, .. }
            | Self::GroupBitwiseOrKHR { result_type_id, .. }
            | Self::GroupBitwiseXorKHR { result_type_id, .. }
            | Self::GroupLogicalAndKHR { result_type_id, .. }
            | Self::GroupLogicalOrKHR { result_type_id, .. }
            | Self::GroupLogicalXorKHR { result_type_id, .. }
            | Self::MaskedGatherINTEL { result_type_id, .. } => Some(*result_type_id),
            _ => None,
        }
    }
    /// Returns the `Id` of the pointer in an atomic operation, if any.
    pub fn atomic_pointer_id(&self) -> Option<Id> {
        match self {
            Self::AtomicLoad { pointer, .. }
            | Self::AtomicStore { pointer, .. }
            | Self::AtomicExchange { pointer, .. }
            | Self::AtomicCompareExchange { pointer, .. }
            | Self::AtomicCompareExchangeWeak { pointer, .. }
            | Self::AtomicIIncrement { pointer, .. }
            | Self::AtomicIDecrement { pointer, .. }
            | Self::AtomicIAdd { pointer, .. }
            | Self::AtomicISub { pointer, .. }
            | Self::AtomicSMin { pointer, .. }
            | Self::AtomicUMin { pointer, .. }
            | Self::AtomicSMax { pointer, .. }
            | Self::AtomicUMax { pointer, .. }
            | Self::AtomicAnd { pointer, .. }
            | Self::AtomicOr { pointer, .. }
            | Self::AtomicXor { pointer, .. }
            | Self::AtomicFlagTestAndSet { pointer, .. }
            | Self::AtomicFlagClear { pointer, .. }
            | Self::AtomicFMinEXT { pointer, .. }
            | Self::AtomicFMaxEXT { pointer, .. }
            | Self::AtomicFAddEXT { pointer, .. } => Some(*pointer),
            _ => None,
        }
    }
    /// Returns whether the instruction is a cooperative matrix instruction.
    pub fn is_cooperative_matrix(&self) -> bool {
        matches!(
            self, Self::CooperativeMatrixLoadKHR { .. } | Self::CooperativeMatrixStoreKHR
            { .. } | Self::CooperativeMatrixMulAddKHR { .. } |
            Self::CooperativeMatrixLengthKHR { .. }
        )
    }
    /// Returns whether the instruction is an NV cooperative matrix instruction.
    pub fn is_cooperative_matrix_nv(&self) -> bool {
        matches!(
            self, Self::CooperativeMatrixLoadNV { .. } | Self::CooperativeMatrixStoreNV {
            .. } | Self::CooperativeMatrixMulAddNV { .. } |
            Self::CooperativeMatrixLengthNV { .. }
        )
    }
    /// Returns whether the instruction is a group operation instruction.
    pub fn is_group_operation(&self) -> bool {
        matches!(
            self, Self::GroupAsyncCopy { .. } | Self::GroupWaitEvents { .. } |
            Self::GroupAll { .. } | Self::GroupAny { .. } | Self::GroupBroadcast { .. } |
            Self::GroupIAdd { .. } | Self::GroupFAdd { .. } | Self::GroupFMin { .. } |
            Self::GroupUMin { .. } | Self::GroupSMin { .. } | Self::GroupFMax { .. } |
            Self::GroupUMax { .. } | Self::GroupSMax { .. } | Self::GroupNonUniformElect
            { .. } | Self::GroupNonUniformAll { .. } | Self::GroupNonUniformAny { .. } |
            Self::GroupNonUniformAllEqual { .. } | Self::GroupNonUniformBroadcast { .. }
            | Self::GroupNonUniformBroadcastFirst { .. } | Self::GroupNonUniformBallot {
            .. } | Self::GroupNonUniformInverseBallot { .. } |
            Self::GroupNonUniformBallotBitExtract { .. } |
            Self::GroupNonUniformBallotBitCount { .. } |
            Self::GroupNonUniformBallotFindLSB { .. } |
            Self::GroupNonUniformBallotFindMSB { .. } | Self::GroupNonUniformShuffle { ..
            } | Self::GroupNonUniformShuffleXor { .. } | Self::GroupNonUniformShuffleUp {
            .. } | Self::GroupNonUniformShuffleDown { .. } | Self::GroupNonUniformIAdd {
            .. } | Self::GroupNonUniformFAdd { .. } | Self::GroupNonUniformIMul { .. } |
            Self::GroupNonUniformFMul { .. } | Self::GroupNonUniformSMin { .. } |
            Self::GroupNonUniformUMin { .. } | Self::GroupNonUniformFMin { .. } |
            Self::GroupNonUniformSMax { .. } | Self::GroupNonUniformUMax { .. } |
            Self::GroupNonUniformFMax { .. } | Self::GroupNonUniformBitwiseAnd { .. } |
            Self::GroupNonUniformBitwiseOr { .. } | Self::GroupNonUniformBitwiseXor { ..
            } | Self::GroupNonUniformLogicalAnd { .. } | Self::GroupNonUniformLogicalOr {
            .. } | Self::GroupNonUniformLogicalXor { .. } |
            Self::GroupNonUniformQuadBroadcast { .. } | Self::GroupNonUniformQuadSwap {
            .. } | Self::SubgroupBallotKHR { .. } | Self::SubgroupFirstInvocationKHR { ..
            } | Self::SubgroupAllKHR { .. } | Self::SubgroupAnyKHR { .. } |
            Self::SubgroupAllEqualKHR { .. } | Self::GroupNonUniformRotateKHR { .. } |
            Self::SubgroupReadInvocationKHR { .. } | Self::GroupIAddNonUniformAMD { .. }
            | Self::GroupFAddNonUniformAMD { .. } | Self::GroupFMinNonUniformAMD { .. } |
            Self::GroupUMinNonUniformAMD { .. } | Self::GroupSMinNonUniformAMD { .. } |
            Self::GroupFMaxNonUniformAMD { .. } | Self::GroupUMaxNonUniformAMD { .. } |
            Self::GroupSMaxNonUniformAMD { .. } | Self::GroupNonUniformQuadAllKHR { .. }
            | Self::GroupNonUniformQuadAnyKHR { .. } | Self::GroupNonUniformPartitionNV {
            .. } | Self::SubgroupShuffleINTEL { .. } | Self::SubgroupShuffleDownINTEL {
            .. } | Self::SubgroupShuffleUpINTEL { .. } | Self::SubgroupShuffleXorINTEL {
            .. } | Self::SubgroupBlockReadINTEL { .. } | Self::SubgroupBlockWriteINTEL {
            .. } | Self::SubgroupImageBlockReadINTEL { .. } |
            Self::SubgroupImageBlockWriteINTEL { .. } |
            Self::SubgroupImageMediaBlockReadINTEL { .. } |
            Self::SubgroupImageMediaBlockWriteINTEL { .. } | Self::GroupIMulKHR { .. } |
            Self::GroupFMulKHR { .. } | Self::GroupBitwiseAndKHR { .. } |
            Self::GroupBitwiseOrKHR { .. } | Self::GroupBitwiseXorKHR { .. } |
            Self::GroupLogicalAndKHR { .. } | Self::GroupLogicalOrKHR { .. } |
            Self::GroupLogicalXorKHR { .. }
        )
    }
    /// Returns whether the instruction is a quad group operation instruction.
    pub fn is_quad_group_operation(&self) -> bool {
        matches!(
            self, Self::GroupNonUniformQuadBroadcast { .. } |
            Self::GroupNonUniformQuadSwap { .. } | Self::GroupNonUniformQuadAllKHR { .. }
            | Self::GroupNonUniformQuadAnyKHR { .. }
        )
    }
    /// Returns whether the instruction is an `ImageFetch*` instruction.
    pub fn is_image_fetch(&self) -> bool {
        matches!(self, Self::ImageFetch { .. })
    }
    /// Returns whether the instruction is an `Image*Gather` instruction.
    pub fn is_image_gather(&self) -> bool {
        matches!(
            self, Self::ImageGather { .. } | Self::ImageDrefGather { .. } |
            Self::ImageSparseGather { .. } | Self::ImageSparseDrefGather { .. }
        )
    }
    /// Returns whether the instruction is an `ImageSample*` instruction.
    pub fn is_image_sample(&self) -> bool {
        matches!(
            self, Self::ImageSampleImplicitLod { .. } | Self::ImageSampleExplicitLod { ..
            } | Self::ImageSampleDrefImplicitLod { .. } |
            Self::ImageSampleDrefExplicitLod { .. } | Self::ImageSampleProjImplicitLod {
            .. } | Self::ImageSampleProjExplicitLod { .. } |
            Self::ImageSampleProjDrefImplicitLod { .. } |
            Self::ImageSampleProjDrefExplicitLod { .. } | Self::ImageSampleWeightedQCOM {
            .. } | Self::ImageSampleFootprintNV { .. }
        )
    }
    /// Returns the `Id` of the execution scope ID operand, if any.
    pub fn execution_scope_id(&self) -> Option<Id> {
        match self {
            Self::ControlBarrier { execution, .. }
            | Self::GroupAsyncCopy { execution, .. }
            | Self::GroupWaitEvents { execution, .. }
            | Self::GroupAll { execution, .. }
            | Self::GroupAny { execution, .. }
            | Self::GroupBroadcast { execution, .. }
            | Self::GroupIAdd { execution, .. }
            | Self::GroupFAdd { execution, .. }
            | Self::GroupFMin { execution, .. }
            | Self::GroupUMin { execution, .. }
            | Self::GroupSMin { execution, .. }
            | Self::GroupFMax { execution, .. }
            | Self::GroupUMax { execution, .. }
            | Self::GroupSMax { execution, .. }
            | Self::GroupReserveReadPipePackets { execution, .. }
            | Self::GroupReserveWritePipePackets { execution, .. }
            | Self::GroupCommitReadPipe { execution, .. }
            | Self::GroupCommitWritePipe { execution, .. }
            | Self::GroupNonUniformElect { execution, .. }
            | Self::GroupNonUniformAll { execution, .. }
            | Self::GroupNonUniformAny { execution, .. }
            | Self::GroupNonUniformAllEqual { execution, .. }
            | Self::GroupNonUniformBroadcast { execution, .. }
            | Self::GroupNonUniformBroadcastFirst { execution, .. }
            | Self::GroupNonUniformBallot { execution, .. }
            | Self::GroupNonUniformInverseBallot { execution, .. }
            | Self::GroupNonUniformBallotBitExtract { execution, .. }
            | Self::GroupNonUniformBallotBitCount { execution, .. }
            | Self::GroupNonUniformBallotFindLSB { execution, .. }
            | Self::GroupNonUniformBallotFindMSB { execution, .. }
            | Self::GroupNonUniformShuffle { execution, .. }
            | Self::GroupNonUniformShuffleXor { execution, .. }
            | Self::GroupNonUniformShuffleUp { execution, .. }
            | Self::GroupNonUniformShuffleDown { execution, .. }
            | Self::GroupNonUniformIAdd { execution, .. }
            | Self::GroupNonUniformFAdd { execution, .. }
            | Self::GroupNonUniformIMul { execution, .. }
            | Self::GroupNonUniformFMul { execution, .. }
            | Self::GroupNonUniformSMin { execution, .. }
            | Self::GroupNonUniformUMin { execution, .. }
            | Self::GroupNonUniformFMin { execution, .. }
            | Self::GroupNonUniformSMax { execution, .. }
            | Self::GroupNonUniformUMax { execution, .. }
            | Self::GroupNonUniformFMax { execution, .. }
            | Self::GroupNonUniformBitwiseAnd { execution, .. }
            | Self::GroupNonUniformBitwiseOr { execution, .. }
            | Self::GroupNonUniformBitwiseXor { execution, .. }
            | Self::GroupNonUniformLogicalAnd { execution, .. }
            | Self::GroupNonUniformLogicalOr { execution, .. }
            | Self::GroupNonUniformLogicalXor { execution, .. }
            | Self::GroupNonUniformQuadBroadcast { execution, .. }
            | Self::GroupNonUniformQuadSwap { execution, .. }
            | Self::GroupNonUniformRotateKHR { execution, .. }
            | Self::GroupIAddNonUniformAMD { execution, .. }
            | Self::GroupFAddNonUniformAMD { execution, .. }
            | Self::GroupFMinNonUniformAMD { execution, .. }
            | Self::GroupUMinNonUniformAMD { execution, .. }
            | Self::GroupSMinNonUniformAMD { execution, .. }
            | Self::GroupFMaxNonUniformAMD { execution, .. }
            | Self::GroupUMaxNonUniformAMD { execution, .. }
            | Self::GroupSMaxNonUniformAMD { execution, .. }
            | Self::TypeCooperativeMatrixNV { execution, .. }
            | Self::ControlBarrierArriveINTEL { execution, .. }
            | Self::ControlBarrierWaitINTEL { execution, .. }
            | Self::GroupIMulKHR { execution, .. }
            | Self::GroupFMulKHR { execution, .. }
            | Self::GroupBitwiseAndKHR { execution, .. }
            | Self::GroupBitwiseOrKHR { execution, .. }
            | Self::GroupBitwiseXorKHR { execution, .. }
            | Self::GroupLogicalAndKHR { execution, .. }
            | Self::GroupLogicalOrKHR { execution, .. }
            | Self::GroupLogicalXorKHR { execution, .. } => Some(*execution),
            _ => None,
        }
    }
    /// Returns the `Id` of the memory scope ID operand, if any.
    pub fn memory_scope_id(&self) -> Option<Id> {
        match self {
            Self::ControlBarrier { memory, .. }
            | Self::MemoryBarrier { memory, .. }
            | Self::AtomicLoad { memory, .. }
            | Self::AtomicStore { memory, .. }
            | Self::AtomicExchange { memory, .. }
            | Self::AtomicCompareExchange { memory, .. }
            | Self::AtomicCompareExchangeWeak { memory, .. }
            | Self::AtomicIIncrement { memory, .. }
            | Self::AtomicIDecrement { memory, .. }
            | Self::AtomicIAdd { memory, .. }
            | Self::AtomicISub { memory, .. }
            | Self::AtomicSMin { memory, .. }
            | Self::AtomicUMin { memory, .. }
            | Self::AtomicSMax { memory, .. }
            | Self::AtomicUMax { memory, .. }
            | Self::AtomicAnd { memory, .. }
            | Self::AtomicOr { memory, .. }
            | Self::AtomicXor { memory, .. }
            | Self::AtomicFlagTestAndSet { memory, .. }
            | Self::AtomicFlagClear { memory, .. }
            | Self::MemoryNamedBarrier { memory, .. }
            | Self::AtomicFMinEXT { memory, .. }
            | Self::AtomicFMaxEXT { memory, .. }
            | Self::AtomicFAddEXT { memory, .. }
            | Self::ControlBarrierArriveINTEL { memory, .. }
            | Self::ControlBarrierWaitINTEL { memory, .. } => Some(*memory),
            _ => None,
        }
    }
    /// Returns the image operands, if any.
    pub fn image_operands(&self) -> Option<&ImageOperands> {
        match self {
            Self::ImageSampleImplicitLod { image_operands: Some(image_operands), .. }
            | Self::ImageSampleExplicitLod { image_operands, .. }
            | Self::ImageSampleDrefImplicitLod {
                image_operands: Some(image_operands),
                ..
            }
            | Self::ImageSampleDrefExplicitLod { image_operands, .. }
            | Self::ImageSampleProjImplicitLod {
                image_operands: Some(image_operands),
                ..
            }
            | Self::ImageSampleProjExplicitLod { image_operands, .. }
            | Self::ImageSampleProjDrefImplicitLod {
                image_operands: Some(image_operands),
                ..
            }
            | Self::ImageSampleProjDrefExplicitLod { image_operands, .. }
            | Self::ImageFetch { image_operands: Some(image_operands), .. }
            | Self::ImageGather { image_operands: Some(image_operands), .. }
            | Self::ImageDrefGather { image_operands: Some(image_operands), .. }
            | Self::ImageRead { image_operands: Some(image_operands), .. }
            | Self::ImageWrite { image_operands: Some(image_operands), .. }
            | Self::ImageSparseSampleImplicitLod {
                image_operands: Some(image_operands),
                ..
            }
            | Self::ImageSparseSampleExplicitLod { image_operands, .. }
            | Self::ImageSparseSampleDrefImplicitLod {
                image_operands: Some(image_operands),
                ..
            }
            | Self::ImageSparseSampleDrefExplicitLod { image_operands, .. }
            | Self::ImageSparseSampleProjImplicitLod {
                image_operands: Some(image_operands),
                ..
            }
            | Self::ImageSparseSampleProjExplicitLod { image_operands, .. }
            | Self::ImageSparseSampleProjDrefImplicitLod {
                image_operands: Some(image_operands),
                ..
            }
            | Self::ImageSparseSampleProjDrefExplicitLod { image_operands, .. }
            | Self::ImageSparseFetch { image_operands: Some(image_operands), .. }
            | Self::ImageSparseGather { image_operands: Some(image_operands), .. }
            | Self::ImageSparseDrefGather { image_operands: Some(image_operands), .. }
            | Self::ImageSparseRead { image_operands: Some(image_operands), .. }
            | Self::ImageSampleFootprintNV {
                image_operands: Some(image_operands),
                ..
            } => Some(image_operands),
            _ => None,
        }
    }
}
#[derive(Clone, Debug, PartialEq)]
///An instruction that is used as the operand of the `SpecConstantOp` instruction.
pub enum SpecConstantInstruction {
    VectorShuffle { vector_1: Id, vector_2: Id, components: Vec<u32> },
    CompositeExtract { composite: Id, indexes: Vec<u32> },
    CompositeInsert { object: Id, composite: Id, indexes: Vec<u32> },
    UConvert { unsigned_value: Id },
    SConvert { signed_value: Id },
    FConvert { float_value: Id },
    QuantizeToF16 { value: Id },
    SNegate { operand: Id },
    IAdd { operand1: Id, operand2: Id },
    ISub { operand1: Id, operand2: Id },
    IMul { operand1: Id, operand2: Id },
    UDiv { operand1: Id, operand2: Id },
    SDiv { operand1: Id, operand2: Id },
    UMod { operand1: Id, operand2: Id },
    SRem { operand1: Id, operand2: Id },
    SMod { operand1: Id, operand2: Id },
    LogicalEqual { operand1: Id, operand2: Id },
    LogicalNotEqual { operand1: Id, operand2: Id },
    LogicalOr { operand1: Id, operand2: Id },
    LogicalAnd { operand1: Id, operand2: Id },
    LogicalNot { operand: Id },
    Select { condition: Id, object_1: Id, object_2: Id },
    IEqual { operand1: Id, operand2: Id },
    INotEqual { operand1: Id, operand2: Id },
    UGreaterThan { operand1: Id, operand2: Id },
    SGreaterThan { operand1: Id, operand2: Id },
    UGreaterThanEqual { operand1: Id, operand2: Id },
    SGreaterThanEqual { operand1: Id, operand2: Id },
    ULessThan { operand1: Id, operand2: Id },
    SLessThan { operand1: Id, operand2: Id },
    ULessThanEqual { operand1: Id, operand2: Id },
    SLessThanEqual { operand1: Id, operand2: Id },
    ShiftRightLogical { base: Id, shift: Id },
    ShiftRightArithmetic { base: Id, shift: Id },
    ShiftLeftLogical { base: Id, shift: Id },
    BitwiseOr { operand1: Id, operand2: Id },
    BitwiseXor { operand1: Id, operand2: Id },
    BitwiseAnd { operand1: Id, operand2: Id },
    Not { operand: Id },
}
impl SpecConstantInstruction {
    #[allow(dead_code)]
    fn parse(reader: &mut InstructionReader<'_>) -> Result<Self, ParseError> {
        let opcode = (reader.next_word()? & 0xffff) as u16;
        Ok(
            match opcode {
                79u16 => {
                    Self::VectorShuffle {
                        vector_1: Id(reader.next_word()?),
                        vector_2: Id(reader.next_word()?),
                        components: {
                            let mut vec = Vec::new();
                            while !reader.is_empty() {
                                vec.push(reader.next_word()?);
                            }
                            vec
                        },
                    }
                }
                81u16 => {
                    Self::CompositeExtract {
                        composite: Id(reader.next_word()?),
                        indexes: {
                            let mut vec = Vec::new();
                            while !reader.is_empty() {
                                vec.push(reader.next_word()?);
                            }
                            vec
                        },
                    }
                }
                82u16 => {
                    Self::CompositeInsert {
                        object: Id(reader.next_word()?),
                        composite: Id(reader.next_word()?),
                        indexes: {
                            let mut vec = Vec::new();
                            while !reader.is_empty() {
                                vec.push(reader.next_word()?);
                            }
                            vec
                        },
                    }
                }
                113u16 => {
                    Self::UConvert {
                        unsigned_value: Id(reader.next_word()?),
                    }
                }
                114u16 => {
                    Self::SConvert {
                        signed_value: Id(reader.next_word()?),
                    }
                }
                115u16 => {
                    Self::FConvert {
                        float_value: Id(reader.next_word()?),
                    }
                }
                116u16 => {
                    Self::QuantizeToF16 {
                        value: Id(reader.next_word()?),
                    }
                }
                126u16 => {
                    Self::SNegate {
                        operand: Id(reader.next_word()?),
                    }
                }
                128u16 => {
                    Self::IAdd {
                        operand1: Id(reader.next_word()?),
                        operand2: Id(reader.next_word()?),
                    }
                }
                130u16 => {
                    Self::ISub {
                        operand1: Id(reader.next_word()?),
                        operand2: Id(reader.next_word()?),
                    }
                }
                132u16 => {
                    Self::IMul {
                        operand1: Id(reader.next_word()?),
                        operand2: Id(reader.next_word()?),
                    }
                }
                134u16 => {
                    Self::UDiv {
                        operand1: Id(reader.next_word()?),
                        operand2: Id(reader.next_word()?),
                    }
                }
                135u16 => {
                    Self::SDiv {
                        operand1: Id(reader.next_word()?),
                        operand2: Id(reader.next_word()?),
                    }
                }
                137u16 => {
                    Self::UMod {
                        operand1: Id(reader.next_word()?),
                        operand2: Id(reader.next_word()?),
                    }
                }
                138u16 => {
                    Self::SRem {
                        operand1: Id(reader.next_word()?),
                        operand2: Id(reader.next_word()?),
                    }
                }
                139u16 => {
                    Self::SMod {
                        operand1: Id(reader.next_word()?),
                        operand2: Id(reader.next_word()?),
                    }
                }
                164u16 => {
                    Self::LogicalEqual {
                        operand1: Id(reader.next_word()?),
                        operand2: Id(reader.next_word()?),
                    }
                }
                165u16 => {
                    Self::LogicalNotEqual {
                        operand1: Id(reader.next_word()?),
                        operand2: Id(reader.next_word()?),
                    }
                }
                166u16 => {
                    Self::LogicalOr {
                        operand1: Id(reader.next_word()?),
                        operand2: Id(reader.next_word()?),
                    }
                }
                167u16 => {
                    Self::LogicalAnd {
                        operand1: Id(reader.next_word()?),
                        operand2: Id(reader.next_word()?),
                    }
                }
                168u16 => {
                    Self::LogicalNot {
                        operand: Id(reader.next_word()?),
                    }
                }
                169u16 => {
                    Self::Select {
                        condition: Id(reader.next_word()?),
                        object_1: Id(reader.next_word()?),
                        object_2: Id(reader.next_word()?),
                    }
                }
                170u16 => {
                    Self::IEqual {
                        operand1: Id(reader.next_word()?),
                        operand2: Id(reader.next_word()?),
                    }
                }
                171u16 => {
                    Self::INotEqual {
                        operand1: Id(reader.next_word()?),
                        operand2: Id(reader.next_word()?),
                    }
                }
                172u16 => {
                    Self::UGreaterThan {
                        operand1: Id(reader.next_word()?),
                        operand2: Id(reader.next_word()?),
                    }
                }
                173u16 => {
                    Self::SGreaterThan {
                        operand1: Id(reader.next_word()?),
                        operand2: Id(reader.next_word()?),
                    }
                }
                174u16 => {
                    Self::UGreaterThanEqual {
                        operand1: Id(reader.next_word()?),
                        operand2: Id(reader.next_word()?),
                    }
                }
                175u16 => {
                    Self::SGreaterThanEqual {
                        operand1: Id(reader.next_word()?),
                        operand2: Id(reader.next_word()?),
                    }
                }
                176u16 => {
                    Self::ULessThan {
                        operand1: Id(reader.next_word()?),
                        operand2: Id(reader.next_word()?),
                    }
                }
                177u16 => {
                    Self::SLessThan {
                        operand1: Id(reader.next_word()?),
                        operand2: Id(reader.next_word()?),
                    }
                }
                178u16 => {
                    Self::ULessThanEqual {
                        operand1: Id(reader.next_word()?),
                        operand2: Id(reader.next_word()?),
                    }
                }
                179u16 => {
                    Self::SLessThanEqual {
                        operand1: Id(reader.next_word()?),
                        operand2: Id(reader.next_word()?),
                    }
                }
                194u16 => {
                    Self::ShiftRightLogical {
                        base: Id(reader.next_word()?),
                        shift: Id(reader.next_word()?),
                    }
                }
                195u16 => {
                    Self::ShiftRightArithmetic {
                        base: Id(reader.next_word()?),
                        shift: Id(reader.next_word()?),
                    }
                }
                196u16 => {
                    Self::ShiftLeftLogical {
                        base: Id(reader.next_word()?),
                        shift: Id(reader.next_word()?),
                    }
                }
                197u16 => {
                    Self::BitwiseOr {
                        operand1: Id(reader.next_word()?),
                        operand2: Id(reader.next_word()?),
                    }
                }
                198u16 => {
                    Self::BitwiseXor {
                        operand1: Id(reader.next_word()?),
                        operand2: Id(reader.next_word()?),
                    }
                }
                199u16 => {
                    Self::BitwiseAnd {
                        operand1: Id(reader.next_word()?),
                        operand2: Id(reader.next_word()?),
                    }
                }
                200u16 => {
                    Self::Not {
                        operand: Id(reader.next_word()?),
                    }
                }
                opcode => {
                    return Err(
                        reader.map_err(ParseErrors::UnknownSpecConstantOpcode(opcode)),
                    );
                }
            },
        )
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct ImageOperands {
    pub bias: Option<Id>,
    pub lod: Option<Id>,
    pub grad: Option<(Id, Id)>,
    pub const_offset: Option<Id>,
    pub offset: Option<Id>,
    pub const_offsets: Option<Id>,
    pub sample: Option<Id>,
    pub min_lod: Option<Id>,
    pub make_texel_available: Option<Id>,
    pub make_texel_visible: Option<Id>,
    pub non_private_texel: bool,
    pub volatile_texel: bool,
    pub sign_extend: bool,
    pub zero_extend: bool,
    pub nontemporal: bool,
    pub offsets: Option<Id>,
}
impl ImageOperands {
    #[allow(dead_code)]
    fn parse(reader: &mut InstructionReader<'_>) -> Result<ImageOperands, ParseError> {
        let value = reader.next_word()?;
        Ok(Self {
            bias: if value & 1u32 != 0 { Some(Id(reader.next_word()?)) } else { None },
            lod: if value & 2u32 != 0 { Some(Id(reader.next_word()?)) } else { None },
            grad: if value & 4u32 != 0 {
                Some((Id(reader.next_word()?), Id(reader.next_word()?)))
            } else {
                None
            },
            const_offset: if value & 8u32 != 0 {
                Some(Id(reader.next_word()?))
            } else {
                None
            },
            offset: if value & 16u32 != 0 {
                Some(Id(reader.next_word()?))
            } else {
                None
            },
            const_offsets: if value & 32u32 != 0 {
                Some(Id(reader.next_word()?))
            } else {
                None
            },
            sample: if value & 64u32 != 0 {
                Some(Id(reader.next_word()?))
            } else {
                None
            },
            min_lod: if value & 128u32 != 0 {
                Some(Id(reader.next_word()?))
            } else {
                None
            },
            make_texel_available: if value & 256u32 != 0 {
                Some(Id(reader.next_word()?))
            } else {
                None
            },
            make_texel_visible: if value & 512u32 != 0 {
                Some(Id(reader.next_word()?))
            } else {
                None
            },
            non_private_texel: value & 1024u32 != 0,
            volatile_texel: value & 2048u32 != 0,
            sign_extend: value & 4096u32 != 0,
            zero_extend: value & 8192u32 != 0,
            nontemporal: value & 16384u32 != 0,
            offsets: if value & 65536u32 != 0 {
                Some(Id(reader.next_word()?))
            } else {
                None
            },
        })
    }
}
impl From<u32> for ImageOperands {
    fn from(value: u32) -> Self {
        Self {
            bias: None,
            lod: None,
            grad: None,
            const_offset: None,
            offset: None,
            const_offsets: None,
            sample: None,
            min_lod: None,
            make_texel_available: None,
            make_texel_visible: None,
            non_private_texel: value & 1024u32 != 0,
            volatile_texel: value & 2048u32 != 0,
            sign_extend: value & 4096u32 != 0,
            zero_extend: value & 8192u32 != 0,
            nontemporal: value & 16384u32 != 0,
            offsets: None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct FPFastMathMode {
    pub not_nan: bool,
    pub not_inf: bool,
    pub nsz: bool,
    pub allow_recip: bool,
    pub fast: bool,
    pub allow_contract: bool,
    pub allow_reassoc: bool,
    pub allow_transform: bool,
}
impl FPFastMathMode {
    #[allow(dead_code)]
    fn parse(reader: &mut InstructionReader<'_>) -> Result<FPFastMathMode, ParseError> {
        let value = reader.next_word()?;
        Ok(Self {
            not_nan: value & 1u32 != 0,
            not_inf: value & 2u32 != 0,
            nsz: value & 4u32 != 0,
            allow_recip: value & 8u32 != 0,
            fast: value & 16u32 != 0,
            allow_contract: value & 65536u32 != 0,
            allow_reassoc: value & 131072u32 != 0,
            allow_transform: value & 262144u32 != 0,
        })
    }
}
impl From<u32> for FPFastMathMode {
    fn from(value: u32) -> Self {
        Self {
            not_nan: value & 1u32 != 0,
            not_inf: value & 2u32 != 0,
            nsz: value & 4u32 != 0,
            allow_recip: value & 8u32 != 0,
            fast: value & 16u32 != 0,
            allow_contract: value & 65536u32 != 0,
            allow_reassoc: value & 131072u32 != 0,
            allow_transform: value & 262144u32 != 0,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct SelectionControl {
    pub flatten: bool,
    pub dont_flatten: bool,
}
impl SelectionControl {
    #[allow(dead_code)]
    fn parse(
        reader: &mut InstructionReader<'_>,
    ) -> Result<SelectionControl, ParseError> {
        let value = reader.next_word()?;
        Ok(Self {
            flatten: value & 1u32 != 0,
            dont_flatten: value & 2u32 != 0,
        })
    }
}
impl From<u32> for SelectionControl {
    fn from(value: u32) -> Self {
        Self {
            flatten: value & 1u32 != 0,
            dont_flatten: value & 2u32 != 0,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct LoopControl {
    pub unroll: bool,
    pub dont_unroll: bool,
    pub dependency_infinite: bool,
    pub dependency_length: Option<u32>,
    pub min_iterations: Option<u32>,
    pub max_iterations: Option<u32>,
    pub iteration_multiple: Option<u32>,
    pub peel_count: Option<u32>,
    pub partial_count: Option<u32>,
    pub initiation_interval_intel: Option<u32>,
    pub max_concurrency_intel: Option<u32>,
    pub dependency_array_intel: Option<u32>,
    pub pipeline_enable_intel: Option<u32>,
    pub loop_coalesce_intel: Option<u32>,
    pub max_interleaving_intel: Option<u32>,
    pub speculated_iterations_intel: Option<u32>,
    pub no_fusion_intel: bool,
    pub loop_count_intel: Option<u32>,
    pub max_reinvocation_delay_intel: Option<u32>,
}
impl LoopControl {
    #[allow(dead_code)]
    fn parse(reader: &mut InstructionReader<'_>) -> Result<LoopControl, ParseError> {
        let value = reader.next_word()?;
        Ok(Self {
            unroll: value & 1u32 != 0,
            dont_unroll: value & 2u32 != 0,
            dependency_infinite: value & 4u32 != 0,
            dependency_length: if value & 8u32 != 0 {
                Some(reader.next_word()?)
            } else {
                None
            },
            min_iterations: if value & 16u32 != 0 {
                Some(reader.next_word()?)
            } else {
                None
            },
            max_iterations: if value & 32u32 != 0 {
                Some(reader.next_word()?)
            } else {
                None
            },
            iteration_multiple: if value & 64u32 != 0 {
                Some(reader.next_word()?)
            } else {
                None
            },
            peel_count: if value & 128u32 != 0 {
                Some(reader.next_word()?)
            } else {
                None
            },
            partial_count: if value & 256u32 != 0 {
                Some(reader.next_word()?)
            } else {
                None
            },
            initiation_interval_intel: if value & 65536u32 != 0 {
                Some(reader.next_word()?)
            } else {
                None
            },
            max_concurrency_intel: if value & 131072u32 != 0 {
                Some(reader.next_word()?)
            } else {
                None
            },
            dependency_array_intel: if value & 262144u32 != 0 {
                Some(reader.next_word()?)
            } else {
                None
            },
            pipeline_enable_intel: if value & 524288u32 != 0 {
                Some(reader.next_word()?)
            } else {
                None
            },
            loop_coalesce_intel: if value & 1048576u32 != 0 {
                Some(reader.next_word()?)
            } else {
                None
            },
            max_interleaving_intel: if value & 2097152u32 != 0 {
                Some(reader.next_word()?)
            } else {
                None
            },
            speculated_iterations_intel: if value & 4194304u32 != 0 {
                Some(reader.next_word()?)
            } else {
                None
            },
            no_fusion_intel: value & 8388608u32 != 0,
            loop_count_intel: if value & 16777216u32 != 0 {
                Some(reader.next_word()?)
            } else {
                None
            },
            max_reinvocation_delay_intel: if value & 33554432u32 != 0 {
                Some(reader.next_word()?)
            } else {
                None
            },
        })
    }
}
impl From<u32> for LoopControl {
    fn from(value: u32) -> Self {
        Self {
            unroll: value & 1u32 != 0,
            dont_unroll: value & 2u32 != 0,
            dependency_infinite: value & 4u32 != 0,
            dependency_length: None,
            min_iterations: None,
            max_iterations: None,
            iteration_multiple: None,
            peel_count: None,
            partial_count: None,
            initiation_interval_intel: None,
            max_concurrency_intel: None,
            dependency_array_intel: None,
            pipeline_enable_intel: None,
            loop_coalesce_intel: None,
            max_interleaving_intel: None,
            speculated_iterations_intel: None,
            no_fusion_intel: value & 8388608u32 != 0,
            loop_count_intel: None,
            max_reinvocation_delay_intel: None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct FunctionControl {
    pub inline: bool,
    pub dont_inline: bool,
    pub pure: bool,
    pub constant: bool,
    pub opt_none_intel: bool,
}
impl FunctionControl {
    #[allow(dead_code)]
    fn parse(reader: &mut InstructionReader<'_>) -> Result<FunctionControl, ParseError> {
        let value = reader.next_word()?;
        Ok(Self {
            inline: value & 1u32 != 0,
            dont_inline: value & 2u32 != 0,
            pure: value & 4u32 != 0,
            constant: value & 8u32 != 0,
            opt_none_intel: value & 65536u32 != 0,
        })
    }
}
impl From<u32> for FunctionControl {
    fn from(value: u32) -> Self {
        Self {
            inline: value & 1u32 != 0,
            dont_inline: value & 2u32 != 0,
            pure: value & 4u32 != 0,
            constant: value & 8u32 != 0,
            opt_none_intel: value & 65536u32 != 0,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct MemorySemantics {
    pub acquire: bool,
    pub release: bool,
    pub acquire_release: bool,
    pub sequentially_consistent: bool,
    pub uniform_memory: bool,
    pub subgroup_memory: bool,
    pub workgroup_memory: bool,
    pub cross_workgroup_memory: bool,
    pub atomic_counter_memory: bool,
    pub image_memory: bool,
    pub output_memory: bool,
    pub make_available: bool,
    pub make_visible: bool,
    pub volatile: bool,
}
impl MemorySemantics {
    #[allow(dead_code)]
    fn parse(reader: &mut InstructionReader<'_>) -> Result<MemorySemantics, ParseError> {
        let value = reader.next_word()?;
        Ok(Self {
            acquire: value & 2u32 != 0,
            release: value & 4u32 != 0,
            acquire_release: value & 8u32 != 0,
            sequentially_consistent: value & 16u32 != 0,
            uniform_memory: value & 64u32 != 0,
            subgroup_memory: value & 128u32 != 0,
            workgroup_memory: value & 256u32 != 0,
            cross_workgroup_memory: value & 512u32 != 0,
            atomic_counter_memory: value & 1024u32 != 0,
            image_memory: value & 2048u32 != 0,
            output_memory: value & 4096u32 != 0,
            make_available: value & 8192u32 != 0,
            make_visible: value & 16384u32 != 0,
            volatile: value & 32768u32 != 0,
        })
    }
}
impl From<u32> for MemorySemantics {
    fn from(value: u32) -> Self {
        Self {
            acquire: value & 2u32 != 0,
            release: value & 4u32 != 0,
            acquire_release: value & 8u32 != 0,
            sequentially_consistent: value & 16u32 != 0,
            uniform_memory: value & 64u32 != 0,
            subgroup_memory: value & 128u32 != 0,
            workgroup_memory: value & 256u32 != 0,
            cross_workgroup_memory: value & 512u32 != 0,
            atomic_counter_memory: value & 1024u32 != 0,
            image_memory: value & 2048u32 != 0,
            output_memory: value & 4096u32 != 0,
            make_available: value & 8192u32 != 0,
            make_visible: value & 16384u32 != 0,
            volatile: value & 32768u32 != 0,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct MemoryAccess {
    pub volatile: bool,
    pub aligned: Option<u32>,
    pub nontemporal: bool,
    pub make_pointer_available: Option<Id>,
    pub make_pointer_visible: Option<Id>,
    pub non_private_pointer: bool,
    pub alias_scope_intel_mask: Option<Id>,
    pub no_alias_intel_mask: Option<Id>,
}
impl MemoryAccess {
    #[allow(dead_code)]
    fn parse(reader: &mut InstructionReader<'_>) -> Result<MemoryAccess, ParseError> {
        let value = reader.next_word()?;
        Ok(Self {
            volatile: value & 1u32 != 0,
            aligned: if value & 2u32 != 0 { Some(reader.next_word()?) } else { None },
            nontemporal: value & 4u32 != 0,
            make_pointer_available: if value & 8u32 != 0 {
                Some(Id(reader.next_word()?))
            } else {
                None
            },
            make_pointer_visible: if value & 16u32 != 0 {
                Some(Id(reader.next_word()?))
            } else {
                None
            },
            non_private_pointer: value & 32u32 != 0,
            alias_scope_intel_mask: if value & 65536u32 != 0 {
                Some(Id(reader.next_word()?))
            } else {
                None
            },
            no_alias_intel_mask: if value & 131072u32 != 0 {
                Some(Id(reader.next_word()?))
            } else {
                None
            },
        })
    }
}
impl From<u32> for MemoryAccess {
    fn from(value: u32) -> Self {
        Self {
            volatile: value & 1u32 != 0,
            aligned: None,
            nontemporal: value & 4u32 != 0,
            make_pointer_available: None,
            make_pointer_visible: None,
            non_private_pointer: value & 32u32 != 0,
            alias_scope_intel_mask: None,
            no_alias_intel_mask: None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct KernelProfilingInfo {
    pub cmd_exec_time: bool,
}
impl KernelProfilingInfo {
    #[allow(dead_code)]
    fn parse(
        reader: &mut InstructionReader<'_>,
    ) -> Result<KernelProfilingInfo, ParseError> {
        let value = reader.next_word()?;
        Ok(Self {
            cmd_exec_time: value & 1u32 != 0,
        })
    }
}
impl From<u32> for KernelProfilingInfo {
    fn from(value: u32) -> Self {
        Self {
            cmd_exec_time: value & 1u32 != 0,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct RayFlags {
    pub opaque_khr: bool,
    pub no_opaque_khr: bool,
    pub terminate_on_first_hit_khr: bool,
    pub skip_closest_hit_shader_khr: bool,
    pub cull_back_facing_triangles_khr: bool,
    pub cull_front_facing_triangles_khr: bool,
    pub cull_opaque_khr: bool,
    pub cull_no_opaque_khr: bool,
    pub skip_triangles_khr: bool,
    pub skip_aab_bs_khr: bool,
    pub force_opacity_micromap2_state_ext: bool,
}
impl RayFlags {
    #[allow(dead_code)]
    fn parse(reader: &mut InstructionReader<'_>) -> Result<RayFlags, ParseError> {
        let value = reader.next_word()?;
        Ok(Self {
            opaque_khr: value & 1u32 != 0,
            no_opaque_khr: value & 2u32 != 0,
            terminate_on_first_hit_khr: value & 4u32 != 0,
            skip_closest_hit_shader_khr: value & 8u32 != 0,
            cull_back_facing_triangles_khr: value & 16u32 != 0,
            cull_front_facing_triangles_khr: value & 32u32 != 0,
            cull_opaque_khr: value & 64u32 != 0,
            cull_no_opaque_khr: value & 128u32 != 0,
            skip_triangles_khr: value & 256u32 != 0,
            skip_aab_bs_khr: value & 512u32 != 0,
            force_opacity_micromap2_state_ext: value & 1024u32 != 0,
        })
    }
}
impl From<u32> for RayFlags {
    fn from(value: u32) -> Self {
        Self {
            opaque_khr: value & 1u32 != 0,
            no_opaque_khr: value & 2u32 != 0,
            terminate_on_first_hit_khr: value & 4u32 != 0,
            skip_closest_hit_shader_khr: value & 8u32 != 0,
            cull_back_facing_triangles_khr: value & 16u32 != 0,
            cull_front_facing_triangles_khr: value & 32u32 != 0,
            cull_opaque_khr: value & 64u32 != 0,
            cull_no_opaque_khr: value & 128u32 != 0,
            skip_triangles_khr: value & 256u32 != 0,
            skip_aab_bs_khr: value & 512u32 != 0,
            force_opacity_micromap2_state_ext: value & 1024u32 != 0,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct FragmentShadingRate {
    pub vertical2_pixels: bool,
    pub vertical4_pixels: bool,
    pub horizontal2_pixels: bool,
    pub horizontal4_pixels: bool,
}
impl FragmentShadingRate {
    #[allow(dead_code)]
    fn parse(
        reader: &mut InstructionReader<'_>,
    ) -> Result<FragmentShadingRate, ParseError> {
        let value = reader.next_word()?;
        Ok(Self {
            vertical2_pixels: value & 1u32 != 0,
            vertical4_pixels: value & 2u32 != 0,
            horizontal2_pixels: value & 4u32 != 0,
            horizontal4_pixels: value & 8u32 != 0,
        })
    }
}
impl From<u32> for FragmentShadingRate {
    fn from(value: u32) -> Self {
        Self {
            vertical2_pixels: value & 1u32 != 0,
            vertical4_pixels: value & 2u32 != 0,
            horizontal2_pixels: value & 4u32 != 0,
            horizontal4_pixels: value & 8u32 != 0,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct RawAccessChainOperands {
    pub robustness_per_component_nv: bool,
    pub robustness_per_element_nv: bool,
}
impl RawAccessChainOperands {
    #[allow(dead_code)]
    fn parse(
        reader: &mut InstructionReader<'_>,
    ) -> Result<RawAccessChainOperands, ParseError> {
        let value = reader.next_word()?;
        Ok(Self {
            robustness_per_component_nv: value & 1u32 != 0,
            robustness_per_element_nv: value & 2u32 != 0,
        })
    }
}
impl From<u32> for RawAccessChainOperands {
    fn from(value: u32) -> Self {
        Self {
            robustness_per_component_nv: value & 1u32 != 0,
            robustness_per_element_nv: value & 2u32 != 0,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub struct CooperativeMatrixOperands {
    pub matrix_a_signed_components_khr: bool,
    pub matrix_b_signed_components_khr: bool,
    pub matrix_c_signed_components_khr: bool,
    pub matrix_result_signed_components_khr: bool,
    pub saturating_accumulation_khr: bool,
}
impl CooperativeMatrixOperands {
    #[allow(dead_code)]
    fn parse(
        reader: &mut InstructionReader<'_>,
    ) -> Result<CooperativeMatrixOperands, ParseError> {
        let value = reader.next_word()?;
        Ok(Self {
            matrix_a_signed_components_khr: value & 1u32 != 0,
            matrix_b_signed_components_khr: value & 2u32 != 0,
            matrix_c_signed_components_khr: value & 4u32 != 0,
            matrix_result_signed_components_khr: value & 8u32 != 0,
            saturating_accumulation_khr: value & 16u32 != 0,
        })
    }
}
impl From<u32> for CooperativeMatrixOperands {
    fn from(value: u32) -> Self {
        Self {
            matrix_a_signed_components_khr: value & 1u32 != 0,
            matrix_b_signed_components_khr: value & 2u32 != 0,
            matrix_c_signed_components_khr: value & 4u32 != 0,
            matrix_result_signed_components_khr: value & 8u32 != 0,
            saturating_accumulation_khr: value & 16u32 != 0,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum SourceLanguage {
    Unknown = 0u32,
    ESSL = 1u32,
    GLSL = 2u32,
    OpenCL_C = 3u32,
    OpenCL_CPP = 4u32,
    HLSL = 5u32,
    CPP_for_OpenCL = 6u32,
    SYCL = 7u32,
    HERO_C = 8u32,
    NZSL = 9u32,
    WGSL = 10u32,
    Slang = 11u32,
    Zig = 12u32,
}
impl SourceLanguage {
    #[allow(dead_code)]
    fn parse(reader: &mut InstructionReader<'_>) -> Result<SourceLanguage, ParseError> {
        Ok(
            match reader.next_word()? {
                0u32 => Self::Unknown,
                1u32 => Self::ESSL,
                2u32 => Self::GLSL,
                3u32 => Self::OpenCL_C,
                4u32 => Self::OpenCL_CPP,
                5u32 => Self::HLSL,
                6u32 => Self::CPP_for_OpenCL,
                7u32 => Self::SYCL,
                8u32 => Self::HERO_C,
                9u32 => Self::NZSL,
                10u32 => Self::WGSL,
                11u32 => Self::Slang,
                12u32 => Self::Zig,
                value => {
                    return Err(
                        reader
                            .map_err(
                                ParseErrors::UnknownEnumerant("SourceLanguage", value),
                            ),
                    );
                }
            },
        )
    }
}
impl TryFrom<u32> for SourceLanguage {
    type Error = ();
    fn try_from(val: u32) -> Result<Self, Self::Error> {
        match val {
            0u32 => Ok(Self::Unknown),
            1u32 => Ok(Self::ESSL),
            2u32 => Ok(Self::GLSL),
            3u32 => Ok(Self::OpenCL_C),
            4u32 => Ok(Self::OpenCL_CPP),
            5u32 => Ok(Self::HLSL),
            6u32 => Ok(Self::CPP_for_OpenCL),
            7u32 => Ok(Self::SYCL),
            8u32 => Ok(Self::HERO_C),
            9u32 => Ok(Self::NZSL),
            10u32 => Ok(Self::WGSL),
            11u32 => Ok(Self::Slang),
            12u32 => Ok(Self::Zig),
            _ => Err(()),
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum ExecutionModel {
    Vertex = 0u32,
    TessellationControl = 1u32,
    TessellationEvaluation = 2u32,
    Geometry = 3u32,
    Fragment = 4u32,
    GLCompute = 5u32,
    Kernel = 6u32,
    TaskNV = 5267u32,
    MeshNV = 5268u32,
    RayGenerationKHR = 5313u32,
    IntersectionKHR = 5314u32,
    AnyHitKHR = 5315u32,
    ClosestHitKHR = 5316u32,
    MissKHR = 5317u32,
    CallableKHR = 5318u32,
    TaskEXT = 5364u32,
    MeshEXT = 5365u32,
}
impl ExecutionModel {
    #[allow(dead_code)]
    fn parse(reader: &mut InstructionReader<'_>) -> Result<ExecutionModel, ParseError> {
        Ok(
            match reader.next_word()? {
                0u32 => Self::Vertex,
                1u32 => Self::TessellationControl,
                2u32 => Self::TessellationEvaluation,
                3u32 => Self::Geometry,
                4u32 => Self::Fragment,
                5u32 => Self::GLCompute,
                6u32 => Self::Kernel,
                5267u32 => Self::TaskNV,
                5268u32 => Self::MeshNV,
                5313u32 => Self::RayGenerationKHR,
                5314u32 => Self::IntersectionKHR,
                5315u32 => Self::AnyHitKHR,
                5316u32 => Self::ClosestHitKHR,
                5317u32 => Self::MissKHR,
                5318u32 => Self::CallableKHR,
                5364u32 => Self::TaskEXT,
                5365u32 => Self::MeshEXT,
                value => {
                    return Err(
                        reader
                            .map_err(
                                ParseErrors::UnknownEnumerant("ExecutionModel", value),
                            ),
                    );
                }
            },
        )
    }
}
impl TryFrom<u32> for ExecutionModel {
    type Error = ();
    fn try_from(val: u32) -> Result<Self, Self::Error> {
        match val {
            0u32 => Ok(Self::Vertex),
            1u32 => Ok(Self::TessellationControl),
            2u32 => Ok(Self::TessellationEvaluation),
            3u32 => Ok(Self::Geometry),
            4u32 => Ok(Self::Fragment),
            5u32 => Ok(Self::GLCompute),
            6u32 => Ok(Self::Kernel),
            5267u32 => Ok(Self::TaskNV),
            5268u32 => Ok(Self::MeshNV),
            5313u32 => Ok(Self::RayGenerationKHR),
            5314u32 => Ok(Self::IntersectionKHR),
            5315u32 => Ok(Self::AnyHitKHR),
            5316u32 => Ok(Self::ClosestHitKHR),
            5317u32 => Ok(Self::MissKHR),
            5318u32 => Ok(Self::CallableKHR),
            5364u32 => Ok(Self::TaskEXT),
            5365u32 => Ok(Self::MeshEXT),
            _ => Err(()),
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum AddressingModel {
    Logical = 0u32,
    Physical32 = 1u32,
    Physical64 = 2u32,
    PhysicalStorageBuffer64 = 5348u32,
}
impl AddressingModel {
    #[allow(dead_code)]
    fn parse(reader: &mut InstructionReader<'_>) -> Result<AddressingModel, ParseError> {
        Ok(
            match reader.next_word()? {
                0u32 => Self::Logical,
                1u32 => Self::Physical32,
                2u32 => Self::Physical64,
                5348u32 => Self::PhysicalStorageBuffer64,
                value => {
                    return Err(
                        reader
                            .map_err(
                                ParseErrors::UnknownEnumerant("AddressingModel", value),
                            ),
                    );
                }
            },
        )
    }
}
impl TryFrom<u32> for AddressingModel {
    type Error = ();
    fn try_from(val: u32) -> Result<Self, Self::Error> {
        match val {
            0u32 => Ok(Self::Logical),
            1u32 => Ok(Self::Physical32),
            2u32 => Ok(Self::Physical64),
            5348u32 => Ok(Self::PhysicalStorageBuffer64),
            _ => Err(()),
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum MemoryModel {
    Simple = 0u32,
    GLSL450 = 1u32,
    OpenCL = 2u32,
    Vulkan = 3u32,
}
impl MemoryModel {
    #[allow(dead_code)]
    fn parse(reader: &mut InstructionReader<'_>) -> Result<MemoryModel, ParseError> {
        Ok(
            match reader.next_word()? {
                0u32 => Self::Simple,
                1u32 => Self::GLSL450,
                2u32 => Self::OpenCL,
                3u32 => Self::Vulkan,
                value => {
                    return Err(
                        reader
                            .map_err(ParseErrors::UnknownEnumerant("MemoryModel", value)),
                    );
                }
            },
        )
    }
}
impl TryFrom<u32> for MemoryModel {
    type Error = ();
    fn try_from(val: u32) -> Result<Self, Self::Error> {
        match val {
            0u32 => Ok(Self::Simple),
            1u32 => Ok(Self::GLSL450),
            2u32 => Ok(Self::OpenCL),
            3u32 => Ok(Self::Vulkan),
            _ => Err(()),
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum ExecutionMode {
    Invocations { number_of_invocation_invocations: u32 } = 0u32,
    SpacingEqual = 1u32,
    SpacingFractionalEven = 2u32,
    SpacingFractionalOdd = 3u32,
    VertexOrderCw = 4u32,
    VertexOrderCcw = 5u32,
    PixelCenterInteger = 6u32,
    OriginUpperLeft = 7u32,
    OriginLowerLeft = 8u32,
    EarlyFragmentTests = 9u32,
    PointMode = 10u32,
    Xfb = 11u32,
    DepthReplacing = 12u32,
    DepthGreater = 14u32,
    DepthLess = 15u32,
    DepthUnchanged = 16u32,
    LocalSize { x_size: u32, y_size: u32, z_size: u32 } = 17u32,
    LocalSizeHint { x_size: u32, y_size: u32, z_size: u32 } = 18u32,
    InputPoints = 19u32,
    InputLines = 20u32,
    InputLinesAdjacency = 21u32,
    Triangles = 22u32,
    InputTrianglesAdjacency = 23u32,
    Quads = 24u32,
    Isolines = 25u32,
    OutputVertices { vertex_count: u32 } = 26u32,
    OutputPoints = 27u32,
    OutputLineStrip = 28u32,
    OutputTriangleStrip = 29u32,
    VecTypeHint { vector_type: u32 } = 30u32,
    ContractionOff = 31u32,
    Initializer = 33u32,
    Finalizer = 34u32,
    SubgroupSize { subgroup_size: u32 } = 35u32,
    SubgroupsPerWorkgroup { subgroups_per_workgroup: u32 } = 36u32,
    SubgroupsPerWorkgroupId { subgroups_per_workgroup: Id } = 37u32,
    LocalSizeId { x_size: Id, y_size: Id, z_size: Id } = 38u32,
    LocalSizeHintId { x_size_hint: Id, y_size_hint: Id, z_size_hint: Id } = 39u32,
    NonCoherentColorAttachmentReadEXT = 4169u32,
    NonCoherentDepthAttachmentReadEXT = 4170u32,
    NonCoherentStencilAttachmentReadEXT = 4171u32,
    SubgroupUniformControlFlowKHR = 4421u32,
    PostDepthCoverage = 4446u32,
    DenormPreserve { target_width: u32 } = 4459u32,
    DenormFlushToZero { target_width: u32 } = 4460u32,
    SignedZeroInfNanPreserve { target_width: u32 } = 4461u32,
    RoundingModeRTE { target_width: u32 } = 4462u32,
    RoundingModeRTZ { target_width: u32 } = 4463u32,
    EarlyAndLateFragmentTestsAMD = 5017u32,
    StencilRefReplacingEXT = 5027u32,
    CoalescingAMDX = 5069u32,
    MaxNodeRecursionAMDX { number_of_recursions: Id } = 5071u32,
    StaticNumWorkgroupsAMDX { x_size: Id, y_size: Id, z_size: Id } = 5072u32,
    ShaderIndexAMDX { shader_index: Id } = 5073u32,
    MaxNumWorkgroupsAMDX { x_size: Id, y_size: Id, z_size: Id } = 5077u32,
    StencilRefUnchangedFrontAMD = 5079u32,
    StencilRefGreaterFrontAMD = 5080u32,
    StencilRefLessFrontAMD = 5081u32,
    StencilRefUnchangedBackAMD = 5082u32,
    StencilRefGreaterBackAMD = 5083u32,
    StencilRefLessBackAMD = 5084u32,
    QuadDerivativesKHR = 5088u32,
    RequireFullQuadsKHR = 5089u32,
    OutputLinesEXT = 5269u32,
    OutputPrimitivesEXT { primitive_count: u32 } = 5270u32,
    DerivativeGroupQuadsNV = 5289u32,
    DerivativeGroupLinearNV = 5290u32,
    OutputTrianglesEXT = 5298u32,
    PixelInterlockOrderedEXT = 5366u32,
    PixelInterlockUnorderedEXT = 5367u32,
    SampleInterlockOrderedEXT = 5368u32,
    SampleInterlockUnorderedEXT = 5369u32,
    ShadingRateInterlockOrderedEXT = 5370u32,
    ShadingRateInterlockUnorderedEXT = 5371u32,
    SharedLocalMemorySizeINTEL { size: u32 } = 5618u32,
    RoundingModeRTPINTEL { target_width: u32 } = 5620u32,
    RoundingModeRTNINTEL { target_width: u32 } = 5621u32,
    FloatingPointModeALTINTEL { target_width: u32 } = 5622u32,
    FloatingPointModeIEEEINTEL { target_width: u32 } = 5623u32,
    MaxWorkgroupSizeINTEL {
        max_x_size: u32,
        max_y_size: u32,
        max_z_size: u32,
    } = 5893u32,
    MaxWorkDimINTEL { max_dimensions: u32 } = 5894u32,
    NoGlobalOffsetINTEL = 5895u32,
    NumSIMDWorkitemsINTEL { vector_width: u32 } = 5896u32,
    SchedulerTargetFmaxMhzINTEL { target_fmax: u32 } = 5903u32,
    MaximallyReconvergesKHR = 6023u32,
    FPFastMathDefault { target_type: Id, fast_math_mode: Id } = 6028u32,
    StreamingInterfaceINTEL { stall_free_return: u32 } = 6154u32,
    RegisterMapInterfaceINTEL { wait_for_done_write: u32 } = 6160u32,
    NamedBarrierCountINTEL { barrier_count: u32 } = 6417u32,
    MaximumRegistersINTEL { number_of_registers: u32 } = 6461u32,
    MaximumRegistersIdINTEL { number_of_registers: Id } = 6462u32,
    NamedMaximumRegistersINTEL {
        named_maximum_number_of_registers: NamedMaximumNumberOfRegisters,
    } = 6463u32,
}
impl ExecutionMode {
    #[allow(dead_code)]
    fn parse(reader: &mut InstructionReader<'_>) -> Result<ExecutionMode, ParseError> {
        Ok(
            match reader.next_word()? {
                0u32 => {
                    Self::Invocations {
                        number_of_invocation_invocations: reader.next_word()?,
                    }
                }
                1u32 => Self::SpacingEqual,
                2u32 => Self::SpacingFractionalEven,
                3u32 => Self::SpacingFractionalOdd,
                4u32 => Self::VertexOrderCw,
                5u32 => Self::VertexOrderCcw,
                6u32 => Self::PixelCenterInteger,
                7u32 => Self::OriginUpperLeft,
                8u32 => Self::OriginLowerLeft,
                9u32 => Self::EarlyFragmentTests,
                10u32 => Self::PointMode,
                11u32 => Self::Xfb,
                12u32 => Self::DepthReplacing,
                14u32 => Self::DepthGreater,
                15u32 => Self::DepthLess,
                16u32 => Self::DepthUnchanged,
                17u32 => {
                    Self::LocalSize {
                        x_size: reader.next_word()?,
                        y_size: reader.next_word()?,
                        z_size: reader.next_word()?,
                    }
                }
                18u32 => {
                    Self::LocalSizeHint {
                        x_size: reader.next_word()?,
                        y_size: reader.next_word()?,
                        z_size: reader.next_word()?,
                    }
                }
                19u32 => Self::InputPoints,
                20u32 => Self::InputLines,
                21u32 => Self::InputLinesAdjacency,
                22u32 => Self::Triangles,
                23u32 => Self::InputTrianglesAdjacency,
                24u32 => Self::Quads,
                25u32 => Self::Isolines,
                26u32 => {
                    Self::OutputVertices {
                        vertex_count: reader.next_word()?,
                    }
                }
                27u32 => Self::OutputPoints,
                28u32 => Self::OutputLineStrip,
                29u32 => Self::OutputTriangleStrip,
                30u32 => {
                    Self::VecTypeHint {
                        vector_type: reader.next_word()?,
                    }
                }
                31u32 => Self::ContractionOff,
                33u32 => Self::Initializer,
                34u32 => Self::Finalizer,
                35u32 => {
                    Self::SubgroupSize {
                        subgroup_size: reader.next_word()?,
                    }
                }
                36u32 => {
                    Self::SubgroupsPerWorkgroup {
                        subgroups_per_workgroup: reader.next_word()?,
                    }
                }
                37u32 => {
                    Self::SubgroupsPerWorkgroupId {
                        subgroups_per_workgroup: Id(reader.next_word()?),
                    }
                }
                38u32 => {
                    Self::LocalSizeId {
                        x_size: Id(reader.next_word()?),
                        y_size: Id(reader.next_word()?),
                        z_size: Id(reader.next_word()?),
                    }
                }
                39u32 => {
                    Self::LocalSizeHintId {
                        x_size_hint: Id(reader.next_word()?),
                        y_size_hint: Id(reader.next_word()?),
                        z_size_hint: Id(reader.next_word()?),
                    }
                }
                4169u32 => Self::NonCoherentColorAttachmentReadEXT,
                4170u32 => Self::NonCoherentDepthAttachmentReadEXT,
                4171u32 => Self::NonCoherentStencilAttachmentReadEXT,
                4421u32 => Self::SubgroupUniformControlFlowKHR,
                4446u32 => Self::PostDepthCoverage,
                4459u32 => {
                    Self::DenormPreserve {
                        target_width: reader.next_word()?,
                    }
                }
                4460u32 => {
                    Self::DenormFlushToZero {
                        target_width: reader.next_word()?,
                    }
                }
                4461u32 => {
                    Self::SignedZeroInfNanPreserve {
                        target_width: reader.next_word()?,
                    }
                }
                4462u32 => {
                    Self::RoundingModeRTE {
                        target_width: reader.next_word()?,
                    }
                }
                4463u32 => {
                    Self::RoundingModeRTZ {
                        target_width: reader.next_word()?,
                    }
                }
                5017u32 => Self::EarlyAndLateFragmentTestsAMD,
                5027u32 => Self::StencilRefReplacingEXT,
                5069u32 => Self::CoalescingAMDX,
                5071u32 => {
                    Self::MaxNodeRecursionAMDX {
                        number_of_recursions: Id(reader.next_word()?),
                    }
                }
                5072u32 => {
                    Self::StaticNumWorkgroupsAMDX {
                        x_size: Id(reader.next_word()?),
                        y_size: Id(reader.next_word()?),
                        z_size: Id(reader.next_word()?),
                    }
                }
                5073u32 => {
                    Self::ShaderIndexAMDX {
                        shader_index: Id(reader.next_word()?),
                    }
                }
                5077u32 => {
                    Self::MaxNumWorkgroupsAMDX {
                        x_size: Id(reader.next_word()?),
                        y_size: Id(reader.next_word()?),
                        z_size: Id(reader.next_word()?),
                    }
                }
                5079u32 => Self::StencilRefUnchangedFrontAMD,
                5080u32 => Self::StencilRefGreaterFrontAMD,
                5081u32 => Self::StencilRefLessFrontAMD,
                5082u32 => Self::StencilRefUnchangedBackAMD,
                5083u32 => Self::StencilRefGreaterBackAMD,
                5084u32 => Self::StencilRefLessBackAMD,
                5088u32 => Self::QuadDerivativesKHR,
                5089u32 => Self::RequireFullQuadsKHR,
                5269u32 => Self::OutputLinesEXT,
                5270u32 => {
                    Self::OutputPrimitivesEXT {
                        primitive_count: reader.next_word()?,
                    }
                }
                5289u32 => Self::DerivativeGroupQuadsNV,
                5290u32 => Self::DerivativeGroupLinearNV,
                5298u32 => Self::OutputTrianglesEXT,
                5366u32 => Self::PixelInterlockOrderedEXT,
                5367u32 => Self::PixelInterlockUnorderedEXT,
                5368u32 => Self::SampleInterlockOrderedEXT,
                5369u32 => Self::SampleInterlockUnorderedEXT,
                5370u32 => Self::ShadingRateInterlockOrderedEXT,
                5371u32 => Self::ShadingRateInterlockUnorderedEXT,
                5618u32 => {
                    Self::SharedLocalMemorySizeINTEL {
                        size: reader.next_word()?,
                    }
                }
                5620u32 => {
                    Self::RoundingModeRTPINTEL {
                        target_width: reader.next_word()?,
                    }
                }
                5621u32 => {
                    Self::RoundingModeRTNINTEL {
                        target_width: reader.next_word()?,
                    }
                }
                5622u32 => {
                    Self::FloatingPointModeALTINTEL {
                        target_width: reader.next_word()?,
                    }
                }
                5623u32 => {
                    Self::FloatingPointModeIEEEINTEL {
                        target_width: reader.next_word()?,
                    }
                }
                5893u32 => {
                    Self::MaxWorkgroupSizeINTEL {
                        max_x_size: reader.next_word()?,
                        max_y_size: reader.next_word()?,
                        max_z_size: reader.next_word()?,
                    }
                }
                5894u32 => {
                    Self::MaxWorkDimINTEL {
                        max_dimensions: reader.next_word()?,
                    }
                }
                5895u32 => Self::NoGlobalOffsetINTEL,
                5896u32 => {
                    Self::NumSIMDWorkitemsINTEL {
                        vector_width: reader.next_word()?,
                    }
                }
                5903u32 => {
                    Self::SchedulerTargetFmaxMhzINTEL {
                        target_fmax: reader.next_word()?,
                    }
                }
                6023u32 => Self::MaximallyReconvergesKHR,
                6028u32 => {
                    Self::FPFastMathDefault {
                        target_type: Id(reader.next_word()?),
                        fast_math_mode: Id(reader.next_word()?),
                    }
                }
                6154u32 => {
                    Self::StreamingInterfaceINTEL {
                        stall_free_return: reader.next_word()?,
                    }
                }
                6160u32 => {
                    Self::RegisterMapInterfaceINTEL {
                        wait_for_done_write: reader.next_word()?,
                    }
                }
                6417u32 => {
                    Self::NamedBarrierCountINTEL {
                        barrier_count: reader.next_word()?,
                    }
                }
                6461u32 => {
                    Self::MaximumRegistersINTEL {
                        number_of_registers: reader.next_word()?,
                    }
                }
                6462u32 => {
                    Self::MaximumRegistersIdINTEL {
                        number_of_registers: Id(reader.next_word()?),
                    }
                }
                6463u32 => {
                    Self::NamedMaximumRegistersINTEL {
                        named_maximum_number_of_registers: NamedMaximumNumberOfRegisters::parse(
                            reader,
                        )?,
                    }
                }
                value => {
                    return Err(
                        reader
                            .map_err(
                                ParseErrors::UnknownEnumerant("ExecutionMode", value),
                            ),
                    );
                }
            },
        )
    }
}
impl TryFrom<u32> for ExecutionMode {
    type Error = ();
    fn try_from(val: u32) -> Result<Self, Self::Error> {
        match val {
            1u32 => Ok(Self::SpacingEqual),
            2u32 => Ok(Self::SpacingFractionalEven),
            3u32 => Ok(Self::SpacingFractionalOdd),
            4u32 => Ok(Self::VertexOrderCw),
            5u32 => Ok(Self::VertexOrderCcw),
            6u32 => Ok(Self::PixelCenterInteger),
            7u32 => Ok(Self::OriginUpperLeft),
            8u32 => Ok(Self::OriginLowerLeft),
            9u32 => Ok(Self::EarlyFragmentTests),
            10u32 => Ok(Self::PointMode),
            11u32 => Ok(Self::Xfb),
            12u32 => Ok(Self::DepthReplacing),
            14u32 => Ok(Self::DepthGreater),
            15u32 => Ok(Self::DepthLess),
            16u32 => Ok(Self::DepthUnchanged),
            19u32 => Ok(Self::InputPoints),
            20u32 => Ok(Self::InputLines),
            21u32 => Ok(Self::InputLinesAdjacency),
            22u32 => Ok(Self::Triangles),
            23u32 => Ok(Self::InputTrianglesAdjacency),
            24u32 => Ok(Self::Quads),
            25u32 => Ok(Self::Isolines),
            27u32 => Ok(Self::OutputPoints),
            28u32 => Ok(Self::OutputLineStrip),
            29u32 => Ok(Self::OutputTriangleStrip),
            31u32 => Ok(Self::ContractionOff),
            33u32 => Ok(Self::Initializer),
            34u32 => Ok(Self::Finalizer),
            4169u32 => Ok(Self::NonCoherentColorAttachmentReadEXT),
            4170u32 => Ok(Self::NonCoherentDepthAttachmentReadEXT),
            4171u32 => Ok(Self::NonCoherentStencilAttachmentReadEXT),
            4421u32 => Ok(Self::SubgroupUniformControlFlowKHR),
            4446u32 => Ok(Self::PostDepthCoverage),
            5017u32 => Ok(Self::EarlyAndLateFragmentTestsAMD),
            5027u32 => Ok(Self::StencilRefReplacingEXT),
            5069u32 => Ok(Self::CoalescingAMDX),
            5079u32 => Ok(Self::StencilRefUnchangedFrontAMD),
            5080u32 => Ok(Self::StencilRefGreaterFrontAMD),
            5081u32 => Ok(Self::StencilRefLessFrontAMD),
            5082u32 => Ok(Self::StencilRefUnchangedBackAMD),
            5083u32 => Ok(Self::StencilRefGreaterBackAMD),
            5084u32 => Ok(Self::StencilRefLessBackAMD),
            5088u32 => Ok(Self::QuadDerivativesKHR),
            5089u32 => Ok(Self::RequireFullQuadsKHR),
            5269u32 => Ok(Self::OutputLinesEXT),
            5289u32 => Ok(Self::DerivativeGroupQuadsNV),
            5290u32 => Ok(Self::DerivativeGroupLinearNV),
            5298u32 => Ok(Self::OutputTrianglesEXT),
            5366u32 => Ok(Self::PixelInterlockOrderedEXT),
            5367u32 => Ok(Self::PixelInterlockUnorderedEXT),
            5368u32 => Ok(Self::SampleInterlockOrderedEXT),
            5369u32 => Ok(Self::SampleInterlockUnorderedEXT),
            5370u32 => Ok(Self::ShadingRateInterlockOrderedEXT),
            5371u32 => Ok(Self::ShadingRateInterlockUnorderedEXT),
            5895u32 => Ok(Self::NoGlobalOffsetINTEL),
            6023u32 => Ok(Self::MaximallyReconvergesKHR),
            _ => Err(()),
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum StorageClass {
    UniformConstant = 0u32,
    Input = 1u32,
    Uniform = 2u32,
    Output = 3u32,
    Workgroup = 4u32,
    CrossWorkgroup = 5u32,
    Private = 6u32,
    Function = 7u32,
    Generic = 8u32,
    PushConstant = 9u32,
    AtomicCounter = 10u32,
    Image = 11u32,
    StorageBuffer = 12u32,
    TileImageEXT = 4172u32,
    NodePayloadAMDX = 5068u32,
    NodeOutputPayloadAMDX = 5076u32,
    CallableDataKHR = 5328u32,
    IncomingCallableDataKHR = 5329u32,
    RayPayloadKHR = 5338u32,
    HitAttributeKHR = 5339u32,
    IncomingRayPayloadKHR = 5342u32,
    ShaderRecordBufferKHR = 5343u32,
    PhysicalStorageBuffer = 5349u32,
    HitObjectAttributeNV = 5385u32,
    TaskPayloadWorkgroupEXT = 5402u32,
    CodeSectionINTEL = 5605u32,
    DeviceOnlyINTEL = 5936u32,
    HostOnlyINTEL = 5937u32,
}
impl StorageClass {
    #[allow(dead_code)]
    fn parse(reader: &mut InstructionReader<'_>) -> Result<StorageClass, ParseError> {
        Ok(
            match reader.next_word()? {
                0u32 => Self::UniformConstant,
                1u32 => Self::Input,
                2u32 => Self::Uniform,
                3u32 => Self::Output,
                4u32 => Self::Workgroup,
                5u32 => Self::CrossWorkgroup,
                6u32 => Self::Private,
                7u32 => Self::Function,
                8u32 => Self::Generic,
                9u32 => Self::PushConstant,
                10u32 => Self::AtomicCounter,
                11u32 => Self::Image,
                12u32 => Self::StorageBuffer,
                4172u32 => Self::TileImageEXT,
                5068u32 => Self::NodePayloadAMDX,
                5076u32 => Self::NodeOutputPayloadAMDX,
                5328u32 => Self::CallableDataKHR,
                5329u32 => Self::IncomingCallableDataKHR,
                5338u32 => Self::RayPayloadKHR,
                5339u32 => Self::HitAttributeKHR,
                5342u32 => Self::IncomingRayPayloadKHR,
                5343u32 => Self::ShaderRecordBufferKHR,
                5349u32 => Self::PhysicalStorageBuffer,
                5385u32 => Self::HitObjectAttributeNV,
                5402u32 => Self::TaskPayloadWorkgroupEXT,
                5605u32 => Self::CodeSectionINTEL,
                5936u32 => Self::DeviceOnlyINTEL,
                5937u32 => Self::HostOnlyINTEL,
                value => {
                    return Err(
                        reader
                            .map_err(
                                ParseErrors::UnknownEnumerant("StorageClass", value),
                            ),
                    );
                }
            },
        )
    }
}
impl TryFrom<u32> for StorageClass {
    type Error = ();
    fn try_from(val: u32) -> Result<Self, Self::Error> {
        match val {
            0u32 => Ok(Self::UniformConstant),
            1u32 => Ok(Self::Input),
            2u32 => Ok(Self::Uniform),
            3u32 => Ok(Self::Output),
            4u32 => Ok(Self::Workgroup),
            5u32 => Ok(Self::CrossWorkgroup),
            6u32 => Ok(Self::Private),
            7u32 => Ok(Self::Function),
            8u32 => Ok(Self::Generic),
            9u32 => Ok(Self::PushConstant),
            10u32 => Ok(Self::AtomicCounter),
            11u32 => Ok(Self::Image),
            12u32 => Ok(Self::StorageBuffer),
            4172u32 => Ok(Self::TileImageEXT),
            5068u32 => Ok(Self::NodePayloadAMDX),
            5076u32 => Ok(Self::NodeOutputPayloadAMDX),
            5328u32 => Ok(Self::CallableDataKHR),
            5329u32 => Ok(Self::IncomingCallableDataKHR),
            5338u32 => Ok(Self::RayPayloadKHR),
            5339u32 => Ok(Self::HitAttributeKHR),
            5342u32 => Ok(Self::IncomingRayPayloadKHR),
            5343u32 => Ok(Self::ShaderRecordBufferKHR),
            5349u32 => Ok(Self::PhysicalStorageBuffer),
            5385u32 => Ok(Self::HitObjectAttributeNV),
            5402u32 => Ok(Self::TaskPayloadWorkgroupEXT),
            5605u32 => Ok(Self::CodeSectionINTEL),
            5936u32 => Ok(Self::DeviceOnlyINTEL),
            5937u32 => Ok(Self::HostOnlyINTEL),
            _ => Err(()),
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum Dim {
    Dim1D = 0u32,
    Dim2D = 1u32,
    Dim3D = 2u32,
    Cube = 3u32,
    Rect = 4u32,
    Buffer = 5u32,
    SubpassData = 6u32,
    TileImageDataEXT = 4173u32,
}
impl Dim {
    #[allow(dead_code)]
    fn parse(reader: &mut InstructionReader<'_>) -> Result<Dim, ParseError> {
        Ok(
            match reader.next_word()? {
                0u32 => Self::Dim1D,
                1u32 => Self::Dim2D,
                2u32 => Self::Dim3D,
                3u32 => Self::Cube,
                4u32 => Self::Rect,
                5u32 => Self::Buffer,
                6u32 => Self::SubpassData,
                4173u32 => Self::TileImageDataEXT,
                value => {
                    return Err(
                        reader.map_err(ParseErrors::UnknownEnumerant("Dim", value)),
                    );
                }
            },
        )
    }
}
impl TryFrom<u32> for Dim {
    type Error = ();
    fn try_from(val: u32) -> Result<Self, Self::Error> {
        match val {
            0u32 => Ok(Self::Dim1D),
            1u32 => Ok(Self::Dim2D),
            2u32 => Ok(Self::Dim3D),
            3u32 => Ok(Self::Cube),
            4u32 => Ok(Self::Rect),
            5u32 => Ok(Self::Buffer),
            6u32 => Ok(Self::SubpassData),
            4173u32 => Ok(Self::TileImageDataEXT),
            _ => Err(()),
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum SamplerAddressingMode {
    None = 0u32,
    ClampToEdge = 1u32,
    Clamp = 2u32,
    Repeat = 3u32,
    RepeatMirrored = 4u32,
}
impl SamplerAddressingMode {
    #[allow(dead_code)]
    fn parse(
        reader: &mut InstructionReader<'_>,
    ) -> Result<SamplerAddressingMode, ParseError> {
        Ok(
            match reader.next_word()? {
                0u32 => Self::None,
                1u32 => Self::ClampToEdge,
                2u32 => Self::Clamp,
                3u32 => Self::Repeat,
                4u32 => Self::RepeatMirrored,
                value => {
                    return Err(
                        reader
                            .map_err(
                                ParseErrors::UnknownEnumerant(
                                    "SamplerAddressingMode",
                                    value,
                                ),
                            ),
                    );
                }
            },
        )
    }
}
impl TryFrom<u32> for SamplerAddressingMode {
    type Error = ();
    fn try_from(val: u32) -> Result<Self, Self::Error> {
        match val {
            0u32 => Ok(Self::None),
            1u32 => Ok(Self::ClampToEdge),
            2u32 => Ok(Self::Clamp),
            3u32 => Ok(Self::Repeat),
            4u32 => Ok(Self::RepeatMirrored),
            _ => Err(()),
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum SamplerFilterMode {
    Nearest = 0u32,
    Linear = 1u32,
}
impl SamplerFilterMode {
    #[allow(dead_code)]
    fn parse(
        reader: &mut InstructionReader<'_>,
    ) -> Result<SamplerFilterMode, ParseError> {
        Ok(
            match reader.next_word()? {
                0u32 => Self::Nearest,
                1u32 => Self::Linear,
                value => {
                    return Err(
                        reader
                            .map_err(
                                ParseErrors::UnknownEnumerant("SamplerFilterMode", value),
                            ),
                    );
                }
            },
        )
    }
}
impl TryFrom<u32> for SamplerFilterMode {
    type Error = ();
    fn try_from(val: u32) -> Result<Self, Self::Error> {
        match val {
            0u32 => Ok(Self::Nearest),
            1u32 => Ok(Self::Linear),
            _ => Err(()),
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum ImageFormat {
    Unknown = 0u32,
    Rgba32f = 1u32,
    Rgba16f = 2u32,
    R32f = 3u32,
    Rgba8 = 4u32,
    Rgba8Snorm = 5u32,
    Rg32f = 6u32,
    Rg16f = 7u32,
    R11fG11fB10f = 8u32,
    R16f = 9u32,
    Rgba16 = 10u32,
    Rgb10A2 = 11u32,
    Rg16 = 12u32,
    Rg8 = 13u32,
    R16 = 14u32,
    R8 = 15u32,
    Rgba16Snorm = 16u32,
    Rg16Snorm = 17u32,
    Rg8Snorm = 18u32,
    R16Snorm = 19u32,
    R8Snorm = 20u32,
    Rgba32i = 21u32,
    Rgba16i = 22u32,
    Rgba8i = 23u32,
    R32i = 24u32,
    Rg32i = 25u32,
    Rg16i = 26u32,
    Rg8i = 27u32,
    R16i = 28u32,
    R8i = 29u32,
    Rgba32ui = 30u32,
    Rgba16ui = 31u32,
    Rgba8ui = 32u32,
    R32ui = 33u32,
    Rgb10a2ui = 34u32,
    Rg32ui = 35u32,
    Rg16ui = 36u32,
    Rg8ui = 37u32,
    R16ui = 38u32,
    R8ui = 39u32,
    R64ui = 40u32,
    R64i = 41u32,
}
impl ImageFormat {
    #[allow(dead_code)]
    fn parse(reader: &mut InstructionReader<'_>) -> Result<ImageFormat, ParseError> {
        Ok(
            match reader.next_word()? {
                0u32 => Self::Unknown,
                1u32 => Self::Rgba32f,
                2u32 => Self::Rgba16f,
                3u32 => Self::R32f,
                4u32 => Self::Rgba8,
                5u32 => Self::Rgba8Snorm,
                6u32 => Self::Rg32f,
                7u32 => Self::Rg16f,
                8u32 => Self::R11fG11fB10f,
                9u32 => Self::R16f,
                10u32 => Self::Rgba16,
                11u32 => Self::Rgb10A2,
                12u32 => Self::Rg16,
                13u32 => Self::Rg8,
                14u32 => Self::R16,
                15u32 => Self::R8,
                16u32 => Self::Rgba16Snorm,
                17u32 => Self::Rg16Snorm,
                18u32 => Self::Rg8Snorm,
                19u32 => Self::R16Snorm,
                20u32 => Self::R8Snorm,
                21u32 => Self::Rgba32i,
                22u32 => Self::Rgba16i,
                23u32 => Self::Rgba8i,
                24u32 => Self::R32i,
                25u32 => Self::Rg32i,
                26u32 => Self::Rg16i,
                27u32 => Self::Rg8i,
                28u32 => Self::R16i,
                29u32 => Self::R8i,
                30u32 => Self::Rgba32ui,
                31u32 => Self::Rgba16ui,
                32u32 => Self::Rgba8ui,
                33u32 => Self::R32ui,
                34u32 => Self::Rgb10a2ui,
                35u32 => Self::Rg32ui,
                36u32 => Self::Rg16ui,
                37u32 => Self::Rg8ui,
                38u32 => Self::R16ui,
                39u32 => Self::R8ui,
                40u32 => Self::R64ui,
                41u32 => Self::R64i,
                value => {
                    return Err(
                        reader
                            .map_err(ParseErrors::UnknownEnumerant("ImageFormat", value)),
                    );
                }
            },
        )
    }
}
impl TryFrom<u32> for ImageFormat {
    type Error = ();
    fn try_from(val: u32) -> Result<Self, Self::Error> {
        match val {
            0u32 => Ok(Self::Unknown),
            1u32 => Ok(Self::Rgba32f),
            2u32 => Ok(Self::Rgba16f),
            3u32 => Ok(Self::R32f),
            4u32 => Ok(Self::Rgba8),
            5u32 => Ok(Self::Rgba8Snorm),
            6u32 => Ok(Self::Rg32f),
            7u32 => Ok(Self::Rg16f),
            8u32 => Ok(Self::R11fG11fB10f),
            9u32 => Ok(Self::R16f),
            10u32 => Ok(Self::Rgba16),
            11u32 => Ok(Self::Rgb10A2),
            12u32 => Ok(Self::Rg16),
            13u32 => Ok(Self::Rg8),
            14u32 => Ok(Self::R16),
            15u32 => Ok(Self::R8),
            16u32 => Ok(Self::Rgba16Snorm),
            17u32 => Ok(Self::Rg16Snorm),
            18u32 => Ok(Self::Rg8Snorm),
            19u32 => Ok(Self::R16Snorm),
            20u32 => Ok(Self::R8Snorm),
            21u32 => Ok(Self::Rgba32i),
            22u32 => Ok(Self::Rgba16i),
            23u32 => Ok(Self::Rgba8i),
            24u32 => Ok(Self::R32i),
            25u32 => Ok(Self::Rg32i),
            26u32 => Ok(Self::Rg16i),
            27u32 => Ok(Self::Rg8i),
            28u32 => Ok(Self::R16i),
            29u32 => Ok(Self::R8i),
            30u32 => Ok(Self::Rgba32ui),
            31u32 => Ok(Self::Rgba16ui),
            32u32 => Ok(Self::Rgba8ui),
            33u32 => Ok(Self::R32ui),
            34u32 => Ok(Self::Rgb10a2ui),
            35u32 => Ok(Self::Rg32ui),
            36u32 => Ok(Self::Rg16ui),
            37u32 => Ok(Self::Rg8ui),
            38u32 => Ok(Self::R16ui),
            39u32 => Ok(Self::R8ui),
            40u32 => Ok(Self::R64ui),
            41u32 => Ok(Self::R64i),
            _ => Err(()),
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum ImageChannelOrder {
    R = 0u32,
    A = 1u32,
    RG = 2u32,
    RA = 3u32,
    RGB = 4u32,
    RGBA = 5u32,
    BGRA = 6u32,
    ARGB = 7u32,
    Intensity = 8u32,
    Luminance = 9u32,
    Rx = 10u32,
    RGx = 11u32,
    RGBx = 12u32,
    Depth = 13u32,
    DepthStencil = 14u32,
    sRGB = 15u32,
    sRGBx = 16u32,
    sRGBA = 17u32,
    sBGRA = 18u32,
    ABGR = 19u32,
}
impl ImageChannelOrder {
    #[allow(dead_code)]
    fn parse(
        reader: &mut InstructionReader<'_>,
    ) -> Result<ImageChannelOrder, ParseError> {
        Ok(
            match reader.next_word()? {
                0u32 => Self::R,
                1u32 => Self::A,
                2u32 => Self::RG,
                3u32 => Self::RA,
                4u32 => Self::RGB,
                5u32 => Self::RGBA,
                6u32 => Self::BGRA,
                7u32 => Self::ARGB,
                8u32 => Self::Intensity,
                9u32 => Self::Luminance,
                10u32 => Self::Rx,
                11u32 => Self::RGx,
                12u32 => Self::RGBx,
                13u32 => Self::Depth,
                14u32 => Self::DepthStencil,
                15u32 => Self::sRGB,
                16u32 => Self::sRGBx,
                17u32 => Self::sRGBA,
                18u32 => Self::sBGRA,
                19u32 => Self::ABGR,
                value => {
                    return Err(
                        reader
                            .map_err(
                                ParseErrors::UnknownEnumerant("ImageChannelOrder", value),
                            ),
                    );
                }
            },
        )
    }
}
impl TryFrom<u32> for ImageChannelOrder {
    type Error = ();
    fn try_from(val: u32) -> Result<Self, Self::Error> {
        match val {
            0u32 => Ok(Self::R),
            1u32 => Ok(Self::A),
            2u32 => Ok(Self::RG),
            3u32 => Ok(Self::RA),
            4u32 => Ok(Self::RGB),
            5u32 => Ok(Self::RGBA),
            6u32 => Ok(Self::BGRA),
            7u32 => Ok(Self::ARGB),
            8u32 => Ok(Self::Intensity),
            9u32 => Ok(Self::Luminance),
            10u32 => Ok(Self::Rx),
            11u32 => Ok(Self::RGx),
            12u32 => Ok(Self::RGBx),
            13u32 => Ok(Self::Depth),
            14u32 => Ok(Self::DepthStencil),
            15u32 => Ok(Self::sRGB),
            16u32 => Ok(Self::sRGBx),
            17u32 => Ok(Self::sRGBA),
            18u32 => Ok(Self::sBGRA),
            19u32 => Ok(Self::ABGR),
            _ => Err(()),
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum ImageChannelDataType {
    SnormInt8 = 0u32,
    SnormInt16 = 1u32,
    UnormInt8 = 2u32,
    UnormInt16 = 3u32,
    UnormShort565 = 4u32,
    UnormShort555 = 5u32,
    UnormInt101010 = 6u32,
    SignedInt8 = 7u32,
    SignedInt16 = 8u32,
    SignedInt32 = 9u32,
    UnsignedInt8 = 10u32,
    UnsignedInt16 = 11u32,
    UnsignedInt32 = 12u32,
    HalfFloat = 13u32,
    Float = 14u32,
    UnormInt24 = 15u32,
    UnormInt101010_2 = 16u32,
    UnsignedIntRaw10EXT = 19u32,
    UnsignedIntRaw12EXT = 20u32,
}
impl ImageChannelDataType {
    #[allow(dead_code)]
    fn parse(
        reader: &mut InstructionReader<'_>,
    ) -> Result<ImageChannelDataType, ParseError> {
        Ok(
            match reader.next_word()? {
                0u32 => Self::SnormInt8,
                1u32 => Self::SnormInt16,
                2u32 => Self::UnormInt8,
                3u32 => Self::UnormInt16,
                4u32 => Self::UnormShort565,
                5u32 => Self::UnormShort555,
                6u32 => Self::UnormInt101010,
                7u32 => Self::SignedInt8,
                8u32 => Self::SignedInt16,
                9u32 => Self::SignedInt32,
                10u32 => Self::UnsignedInt8,
                11u32 => Self::UnsignedInt16,
                12u32 => Self::UnsignedInt32,
                13u32 => Self::HalfFloat,
                14u32 => Self::Float,
                15u32 => Self::UnormInt24,
                16u32 => Self::UnormInt101010_2,
                19u32 => Self::UnsignedIntRaw10EXT,
                20u32 => Self::UnsignedIntRaw12EXT,
                value => {
                    return Err(
                        reader
                            .map_err(
                                ParseErrors::UnknownEnumerant("ImageChannelDataType", value),
                            ),
                    );
                }
            },
        )
    }
}
impl TryFrom<u32> for ImageChannelDataType {
    type Error = ();
    fn try_from(val: u32) -> Result<Self, Self::Error> {
        match val {
            0u32 => Ok(Self::SnormInt8),
            1u32 => Ok(Self::SnormInt16),
            2u32 => Ok(Self::UnormInt8),
            3u32 => Ok(Self::UnormInt16),
            4u32 => Ok(Self::UnormShort565),
            5u32 => Ok(Self::UnormShort555),
            6u32 => Ok(Self::UnormInt101010),
            7u32 => Ok(Self::SignedInt8),
            8u32 => Ok(Self::SignedInt16),
            9u32 => Ok(Self::SignedInt32),
            10u32 => Ok(Self::UnsignedInt8),
            11u32 => Ok(Self::UnsignedInt16),
            12u32 => Ok(Self::UnsignedInt32),
            13u32 => Ok(Self::HalfFloat),
            14u32 => Ok(Self::Float),
            15u32 => Ok(Self::UnormInt24),
            16u32 => Ok(Self::UnormInt101010_2),
            19u32 => Ok(Self::UnsignedIntRaw10EXT),
            20u32 => Ok(Self::UnsignedIntRaw12EXT),
            _ => Err(()),
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum FPRoundingMode {
    RTE = 0u32,
    RTZ = 1u32,
    RTP = 2u32,
    RTN = 3u32,
}
impl FPRoundingMode {
    #[allow(dead_code)]
    fn parse(reader: &mut InstructionReader<'_>) -> Result<FPRoundingMode, ParseError> {
        Ok(
            match reader.next_word()? {
                0u32 => Self::RTE,
                1u32 => Self::RTZ,
                2u32 => Self::RTP,
                3u32 => Self::RTN,
                value => {
                    return Err(
                        reader
                            .map_err(
                                ParseErrors::UnknownEnumerant("FPRoundingMode", value),
                            ),
                    );
                }
            },
        )
    }
}
impl TryFrom<u32> for FPRoundingMode {
    type Error = ();
    fn try_from(val: u32) -> Result<Self, Self::Error> {
        match val {
            0u32 => Ok(Self::RTE),
            1u32 => Ok(Self::RTZ),
            2u32 => Ok(Self::RTP),
            3u32 => Ok(Self::RTN),
            _ => Err(()),
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum FPDenormMode {
    Preserve = 0u32,
    FlushToZero = 1u32,
}
impl FPDenormMode {
    #[allow(dead_code)]
    fn parse(reader: &mut InstructionReader<'_>) -> Result<FPDenormMode, ParseError> {
        Ok(
            match reader.next_word()? {
                0u32 => Self::Preserve,
                1u32 => Self::FlushToZero,
                value => {
                    return Err(
                        reader
                            .map_err(
                                ParseErrors::UnknownEnumerant("FPDenormMode", value),
                            ),
                    );
                }
            },
        )
    }
}
impl TryFrom<u32> for FPDenormMode {
    type Error = ();
    fn try_from(val: u32) -> Result<Self, Self::Error> {
        match val {
            0u32 => Ok(Self::Preserve),
            1u32 => Ok(Self::FlushToZero),
            _ => Err(()),
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum QuantizationModes {
    TRN = 0u32,
    TRN_ZERO = 1u32,
    RND = 2u32,
    RND_ZERO = 3u32,
    RND_INF = 4u32,
    RND_MIN_INF = 5u32,
    RND_CONV = 6u32,
    RND_CONV_ODD = 7u32,
}
impl QuantizationModes {
    #[allow(dead_code)]
    fn parse(
        reader: &mut InstructionReader<'_>,
    ) -> Result<QuantizationModes, ParseError> {
        Ok(
            match reader.next_word()? {
                0u32 => Self::TRN,
                1u32 => Self::TRN_ZERO,
                2u32 => Self::RND,
                3u32 => Self::RND_ZERO,
                4u32 => Self::RND_INF,
                5u32 => Self::RND_MIN_INF,
                6u32 => Self::RND_CONV,
                7u32 => Self::RND_CONV_ODD,
                value => {
                    return Err(
                        reader
                            .map_err(
                                ParseErrors::UnknownEnumerant("QuantizationModes", value),
                            ),
                    );
                }
            },
        )
    }
}
impl TryFrom<u32> for QuantizationModes {
    type Error = ();
    fn try_from(val: u32) -> Result<Self, Self::Error> {
        match val {
            0u32 => Ok(Self::TRN),
            1u32 => Ok(Self::TRN_ZERO),
            2u32 => Ok(Self::RND),
            3u32 => Ok(Self::RND_ZERO),
            4u32 => Ok(Self::RND_INF),
            5u32 => Ok(Self::RND_MIN_INF),
            6u32 => Ok(Self::RND_CONV),
            7u32 => Ok(Self::RND_CONV_ODD),
            _ => Err(()),
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum FPOperationMode {
    IEEE = 0u32,
    ALT = 1u32,
}
impl FPOperationMode {
    #[allow(dead_code)]
    fn parse(reader: &mut InstructionReader<'_>) -> Result<FPOperationMode, ParseError> {
        Ok(
            match reader.next_word()? {
                0u32 => Self::IEEE,
                1u32 => Self::ALT,
                value => {
                    return Err(
                        reader
                            .map_err(
                                ParseErrors::UnknownEnumerant("FPOperationMode", value),
                            ),
                    );
                }
            },
        )
    }
}
impl TryFrom<u32> for FPOperationMode {
    type Error = ();
    fn try_from(val: u32) -> Result<Self, Self::Error> {
        match val {
            0u32 => Ok(Self::IEEE),
            1u32 => Ok(Self::ALT),
            _ => Err(()),
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum OverflowModes {
    WRAP = 0u32,
    SAT = 1u32,
    SAT_ZERO = 2u32,
    SAT_SYM = 3u32,
}
impl OverflowModes {
    #[allow(dead_code)]
    fn parse(reader: &mut InstructionReader<'_>) -> Result<OverflowModes, ParseError> {
        Ok(
            match reader.next_word()? {
                0u32 => Self::WRAP,
                1u32 => Self::SAT,
                2u32 => Self::SAT_ZERO,
                3u32 => Self::SAT_SYM,
                value => {
                    return Err(
                        reader
                            .map_err(
                                ParseErrors::UnknownEnumerant("OverflowModes", value),
                            ),
                    );
                }
            },
        )
    }
}
impl TryFrom<u32> for OverflowModes {
    type Error = ();
    fn try_from(val: u32) -> Result<Self, Self::Error> {
        match val {
            0u32 => Ok(Self::WRAP),
            1u32 => Ok(Self::SAT),
            2u32 => Ok(Self::SAT_ZERO),
            3u32 => Ok(Self::SAT_SYM),
            _ => Err(()),
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum LinkageType {
    Export = 0u32,
    Import = 1u32,
    LinkOnceODR = 2u32,
}
impl LinkageType {
    #[allow(dead_code)]
    fn parse(reader: &mut InstructionReader<'_>) -> Result<LinkageType, ParseError> {
        Ok(
            match reader.next_word()? {
                0u32 => Self::Export,
                1u32 => Self::Import,
                2u32 => Self::LinkOnceODR,
                value => {
                    return Err(
                        reader
                            .map_err(ParseErrors::UnknownEnumerant("LinkageType", value)),
                    );
                }
            },
        )
    }
}
impl TryFrom<u32> for LinkageType {
    type Error = ();
    fn try_from(val: u32) -> Result<Self, Self::Error> {
        match val {
            0u32 => Ok(Self::Export),
            1u32 => Ok(Self::Import),
            2u32 => Ok(Self::LinkOnceODR),
            _ => Err(()),
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum AccessQualifier {
    ReadOnly = 0u32,
    WriteOnly = 1u32,
    ReadWrite = 2u32,
}
impl AccessQualifier {
    #[allow(dead_code)]
    fn parse(reader: &mut InstructionReader<'_>) -> Result<AccessQualifier, ParseError> {
        Ok(
            match reader.next_word()? {
                0u32 => Self::ReadOnly,
                1u32 => Self::WriteOnly,
                2u32 => Self::ReadWrite,
                value => {
                    return Err(
                        reader
                            .map_err(
                                ParseErrors::UnknownEnumerant("AccessQualifier", value),
                            ),
                    );
                }
            },
        )
    }
}
impl TryFrom<u32> for AccessQualifier {
    type Error = ();
    fn try_from(val: u32) -> Result<Self, Self::Error> {
        match val {
            0u32 => Ok(Self::ReadOnly),
            1u32 => Ok(Self::WriteOnly),
            2u32 => Ok(Self::ReadWrite),
            _ => Err(()),
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum HostAccessQualifier {
    NoneINTEL = 0u32,
    ReadINTEL = 1u32,
    WriteINTEL = 2u32,
    ReadWriteINTEL = 3u32,
}
impl HostAccessQualifier {
    #[allow(dead_code)]
    fn parse(
        reader: &mut InstructionReader<'_>,
    ) -> Result<HostAccessQualifier, ParseError> {
        Ok(
            match reader.next_word()? {
                0u32 => Self::NoneINTEL,
                1u32 => Self::ReadINTEL,
                2u32 => Self::WriteINTEL,
                3u32 => Self::ReadWriteINTEL,
                value => {
                    return Err(
                        reader
                            .map_err(
                                ParseErrors::UnknownEnumerant("HostAccessQualifier", value),
                            ),
                    );
                }
            },
        )
    }
}
impl TryFrom<u32> for HostAccessQualifier {
    type Error = ();
    fn try_from(val: u32) -> Result<Self, Self::Error> {
        match val {
            0u32 => Ok(Self::NoneINTEL),
            1u32 => Ok(Self::ReadINTEL),
            2u32 => Ok(Self::WriteINTEL),
            3u32 => Ok(Self::ReadWriteINTEL),
            _ => Err(()),
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum FunctionParameterAttribute {
    Zext = 0u32,
    Sext = 1u32,
    ByVal = 2u32,
    Sret = 3u32,
    NoAlias = 4u32,
    NoCapture = 5u32,
    NoWrite = 6u32,
    NoReadWrite = 7u32,
    RuntimeAlignedINTEL = 5940u32,
}
impl FunctionParameterAttribute {
    #[allow(dead_code)]
    fn parse(
        reader: &mut InstructionReader<'_>,
    ) -> Result<FunctionParameterAttribute, ParseError> {
        Ok(
            match reader.next_word()? {
                0u32 => Self::Zext,
                1u32 => Self::Sext,
                2u32 => Self::ByVal,
                3u32 => Self::Sret,
                4u32 => Self::NoAlias,
                5u32 => Self::NoCapture,
                6u32 => Self::NoWrite,
                7u32 => Self::NoReadWrite,
                5940u32 => Self::RuntimeAlignedINTEL,
                value => {
                    return Err(
                        reader
                            .map_err(
                                ParseErrors::UnknownEnumerant(
                                    "FunctionParameterAttribute",
                                    value,
                                ),
                            ),
                    );
                }
            },
        )
    }
}
impl TryFrom<u32> for FunctionParameterAttribute {
    type Error = ();
    fn try_from(val: u32) -> Result<Self, Self::Error> {
        match val {
            0u32 => Ok(Self::Zext),
            1u32 => Ok(Self::Sext),
            2u32 => Ok(Self::ByVal),
            3u32 => Ok(Self::Sret),
            4u32 => Ok(Self::NoAlias),
            5u32 => Ok(Self::NoCapture),
            6u32 => Ok(Self::NoWrite),
            7u32 => Ok(Self::NoReadWrite),
            5940u32 => Ok(Self::RuntimeAlignedINTEL),
            _ => Err(()),
        }
    }
}
#[derive(Clone, Debug, PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum Decoration {
    RelaxedPrecision = 0u32,
    SpecId { specialization_constant_id: u32 } = 1u32,
    Block = 2u32,
    BufferBlock = 3u32,
    RowMajor = 4u32,
    ColMajor = 5u32,
    ArrayStride { array_stride: u32 } = 6u32,
    MatrixStride { matrix_stride: u32 } = 7u32,
    GLSLShared = 8u32,
    GLSLPacked = 9u32,
    CPacked = 10u32,
    BuiltIn { built_in: BuiltIn } = 11u32,
    NoPerspective = 13u32,
    Flat = 14u32,
    Patch = 15u32,
    Centroid = 16u32,
    Sample = 17u32,
    Invariant = 18u32,
    Restrict = 19u32,
    Aliased = 20u32,
    Volatile = 21u32,
    Constant = 22u32,
    Coherent = 23u32,
    NonWritable = 24u32,
    NonReadable = 25u32,
    Uniform = 26u32,
    UniformId { execution: Id } = 27u32,
    SaturatedConversion = 28u32,
    Stream { stream_number: u32 } = 29u32,
    Location { location: u32 } = 30u32,
    Component { component: u32 } = 31u32,
    Index { index: u32 } = 32u32,
    Binding { binding_point: u32 } = 33u32,
    DescriptorSet { descriptor_set: u32 } = 34u32,
    Offset { byte_offset: u32 } = 35u32,
    XfbBuffer { xfb_buffer_number: u32 } = 36u32,
    XfbStride { xfb_stride: u32 } = 37u32,
    FuncParamAttr { function_parameter_attribute: FunctionParameterAttribute } = 38u32,
    FPRoundingMode { floating_point_rounding_mode: FPRoundingMode } = 39u32,
    FPFastMathMode { fast_math_mode: FPFastMathMode } = 40u32,
    LinkageAttributes { name: String, linkage_type: LinkageType } = 41u32,
    NoContraction = 42u32,
    InputAttachmentIndex { attachment_index: u32 } = 43u32,
    Alignment { alignment: u32 } = 44u32,
    MaxByteOffset { max_byte_offset: u32 } = 45u32,
    AlignmentId { alignment: Id } = 46u32,
    MaxByteOffsetId { max_byte_offset: Id } = 47u32,
    NoSignedWrap = 4469u32,
    NoUnsignedWrap = 4470u32,
    WeightTextureQCOM = 4487u32,
    BlockMatchTextureQCOM = 4488u32,
    BlockMatchSamplerQCOM = 4499u32,
    ExplicitInterpAMD = 4999u32,
    NodeSharesPayloadLimitsWithAMDX { payload_array: Id } = 5019u32,
    NodeMaxPayloadsAMDX { max_number_of_payloads: Id } = 5020u32,
    TrackFinishWritingAMDX = 5078u32,
    PayloadNodeNameAMDX { node_name: String } = 5091u32,
    OverrideCoverageNV = 5248u32,
    PassthroughNV = 5250u32,
    ViewportRelativeNV = 5252u32,
    SecondaryViewportRelativeNV { offset: u32 } = 5256u32,
    PerPrimitiveEXT = 5271u32,
    PerViewNV = 5272u32,
    PerTaskNV = 5273u32,
    PerVertexKHR = 5285u32,
    NonUniform = 5300u32,
    RestrictPointer = 5355u32,
    AliasedPointer = 5356u32,
    HitObjectShaderRecordBufferNV = 5386u32,
    BindlessSamplerNV = 5398u32,
    BindlessImageNV = 5399u32,
    BoundSamplerNV = 5400u32,
    BoundImageNV = 5401u32,
    SIMTCallINTEL { n: u32 } = 5599u32,
    ReferencedIndirectlyINTEL = 5602u32,
    ClobberINTEL { register: String } = 5607u32,
    SideEffectsINTEL = 5608u32,
    VectorComputeVariableINTEL = 5624u32,
    FuncParamIOKindINTEL { kind: u32 } = 5625u32,
    VectorComputeFunctionINTEL = 5626u32,
    StackCallINTEL = 5627u32,
    GlobalVariableOffsetINTEL { offset: u32 } = 5628u32,
    CounterBuffer { counter_buffer: Id } = 5634u32,
    UserSemantic { semantic: String } = 5635u32,
    UserTypeGOOGLE { user_type: String } = 5636u32,
    FunctionRoundingModeINTEL {
        target_width: u32,
        fp_rounding_mode: FPRoundingMode,
    } = 5822u32,
    FunctionDenormModeINTEL {
        target_width: u32,
        fp_denorm_mode: FPDenormMode,
    } = 5823u32,
    RegisterINTEL = 5825u32,
    MemoryINTEL { memory_type: String } = 5826u32,
    NumbanksINTEL { banks: u32 } = 5827u32,
    BankwidthINTEL { bank_width: u32 } = 5828u32,
    MaxPrivateCopiesINTEL { maximum_copies: u32 } = 5829u32,
    SinglepumpINTEL = 5830u32,
    DoublepumpINTEL = 5831u32,
    MaxReplicatesINTEL { maximum_replicates: u32 } = 5832u32,
    SimpleDualPortINTEL = 5833u32,
    MergeINTEL { merge_key: String, merge_type: String } = 5834u32,
    BankBitsINTEL { bank_bits: u32 } = 5835u32,
    ForcePow2DepthINTEL { force_key: u32 } = 5836u32,
    StridesizeINTEL { stride_size: u32 } = 5883u32,
    WordsizeINTEL { word_size: u32 } = 5884u32,
    TrueDualPortINTEL = 5885u32,
    BurstCoalesceINTEL = 5899u32,
    CacheSizeINTEL { cache_size_in_bytes: u32 } = 5900u32,
    DontStaticallyCoalesceINTEL = 5901u32,
    PrefetchINTEL { prefetcher_size_in_bytes: u32 } = 5902u32,
    StallEnableINTEL = 5905u32,
    FuseLoopsInFunctionINTEL = 5907u32,
    MathOpDSPModeINTEL { mode: u32, propagate: u32 } = 5909u32,
    AliasScopeINTEL { aliasing_scopes_list: Id } = 5914u32,
    NoAliasINTEL { aliasing_scopes_list: Id } = 5915u32,
    InitiationIntervalINTEL { cycles: u32 } = 5917u32,
    MaxConcurrencyINTEL { invocations: u32 } = 5918u32,
    PipelineEnableINTEL { enable: u32 } = 5919u32,
    BufferLocationINTEL { buffer_location_id: u32 } = 5921u32,
    IOPipeStorageINTEL { io_pipe_id: u32 } = 5944u32,
    FunctionFloatingPointModeINTEL {
        target_width: u32,
        fp_operation_mode: FPOperationMode,
    } = 6080u32,
    SingleElementVectorINTEL = 6085u32,
    VectorComputeCallableFunctionINTEL = 6087u32,
    MediaBlockIOINTEL = 6140u32,
    StallFreeINTEL = 6151u32,
    FPMaxErrorDecorationINTEL { max_error: f32 } = 6170u32,
    LatencyControlLabelINTEL { latency_label: u32 } = 6172u32,
    LatencyControlConstraintINTEL {
        relative_to: u32,
        control_type: u32,
        relative_cycle: u32,
    } = 6173u32,
    ConduitKernelArgumentINTEL = 6175u32,
    RegisterMapKernelArgumentINTEL = 6176u32,
    MMHostInterfaceAddressWidthINTEL { address_width: u32 } = 6177u32,
    MMHostInterfaceDataWidthINTEL { data_width: u32 } = 6178u32,
    MMHostInterfaceLatencyINTEL { latency: u32 } = 6179u32,
    MMHostInterfaceReadWriteModeINTEL { read_write_mode: AccessQualifier } = 6180u32,
    MMHostInterfaceMaxBurstINTEL { max_burst_count: u32 } = 6181u32,
    MMHostInterfaceWaitRequestINTEL { waitrequest: u32 } = 6182u32,
    StableKernelArgumentINTEL = 6183u32,
    HostAccessINTEL { access: HostAccessQualifier, name: String } = 6188u32,
    InitModeINTEL { trigger: InitializationModeQualifier } = 6190u32,
    ImplementInRegisterMapINTEL { value: u32 } = 6191u32,
    CacheControlLoadINTEL {
        cache_level: u32,
        cache_control: LoadCacheControl,
    } = 6442u32,
    CacheControlStoreINTEL {
        cache_level: u32,
        cache_control: StoreCacheControl,
    } = 6443u32,
}
impl Decoration {
    #[allow(dead_code)]
    fn parse(reader: &mut InstructionReader<'_>) -> Result<Decoration, ParseError> {
        Ok(
            match reader.next_word()? {
                0u32 => Self::RelaxedPrecision,
                1u32 => {
                    Self::SpecId {
                        specialization_constant_id: reader.next_word()?,
                    }
                }
                2u32 => Self::Block,
                3u32 => Self::BufferBlock,
                4u32 => Self::RowMajor,
                5u32 => Self::ColMajor,
                6u32 => {
                    Self::ArrayStride {
                        array_stride: reader.next_word()?,
                    }
                }
                7u32 => {
                    Self::MatrixStride {
                        matrix_stride: reader.next_word()?,
                    }
                }
                8u32 => Self::GLSLShared,
                9u32 => Self::GLSLPacked,
                10u32 => Self::CPacked,
                11u32 => {
                    Self::BuiltIn {
                        built_in: BuiltIn::parse(reader)?,
                    }
                }
                13u32 => Self::NoPerspective,
                14u32 => Self::Flat,
                15u32 => Self::Patch,
                16u32 => Self::Centroid,
                17u32 => Self::Sample,
                18u32 => Self::Invariant,
                19u32 => Self::Restrict,
                20u32 => Self::Aliased,
                21u32 => Self::Volatile,
                22u32 => Self::Constant,
                23u32 => Self::Coherent,
                24u32 => Self::NonWritable,
                25u32 => Self::NonReadable,
                26u32 => Self::Uniform,
                27u32 => {
                    Self::UniformId {
                        execution: Id(reader.next_word()?),
                    }
                }
                28u32 => Self::SaturatedConversion,
                29u32 => {
                    Self::Stream {
                        stream_number: reader.next_word()?,
                    }
                }
                30u32 => {
                    Self::Location {
                        location: reader.next_word()?,
                    }
                }
                31u32 => {
                    Self::Component {
                        component: reader.next_word()?,
                    }
                }
                32u32 => {
                    Self::Index {
                        index: reader.next_word()?,
                    }
                }
                33u32 => {
                    Self::Binding {
                        binding_point: reader.next_word()?,
                    }
                }
                34u32 => {
                    Self::DescriptorSet {
                        descriptor_set: reader.next_word()?,
                    }
                }
                35u32 => {
                    Self::Offset {
                        byte_offset: reader.next_word()?,
                    }
                }
                36u32 => {
                    Self::XfbBuffer {
                        xfb_buffer_number: reader.next_word()?,
                    }
                }
                37u32 => {
                    Self::XfbStride {
                        xfb_stride: reader.next_word()?,
                    }
                }
                38u32 => {
                    Self::FuncParamAttr {
                        function_parameter_attribute: FunctionParameterAttribute::parse(
                            reader,
                        )?,
                    }
                }
                39u32 => {
                    Self::FPRoundingMode {
                        floating_point_rounding_mode: FPRoundingMode::parse(reader)?,
                    }
                }
                40u32 => {
                    Self::FPFastMathMode {
                        fast_math_mode: FPFastMathMode::parse(reader)?,
                    }
                }
                41u32 => {
                    Self::LinkageAttributes {
                        name: reader.next_string()?,
                        linkage_type: LinkageType::parse(reader)?,
                    }
                }
                42u32 => Self::NoContraction,
                43u32 => {
                    Self::InputAttachmentIndex {
                        attachment_index: reader.next_word()?,
                    }
                }
                44u32 => {
                    Self::Alignment {
                        alignment: reader.next_word()?,
                    }
                }
                45u32 => {
                    Self::MaxByteOffset {
                        max_byte_offset: reader.next_word()?,
                    }
                }
                46u32 => {
                    Self::AlignmentId {
                        alignment: Id(reader.next_word()?),
                    }
                }
                47u32 => {
                    Self::MaxByteOffsetId {
                        max_byte_offset: Id(reader.next_word()?),
                    }
                }
                4469u32 => Self::NoSignedWrap,
                4470u32 => Self::NoUnsignedWrap,
                4487u32 => Self::WeightTextureQCOM,
                4488u32 => Self::BlockMatchTextureQCOM,
                4499u32 => Self::BlockMatchSamplerQCOM,
                4999u32 => Self::ExplicitInterpAMD,
                5019u32 => {
                    Self::NodeSharesPayloadLimitsWithAMDX {
                        payload_array: Id(reader.next_word()?),
                    }
                }
                5020u32 => {
                    Self::NodeMaxPayloadsAMDX {
                        max_number_of_payloads: Id(reader.next_word()?),
                    }
                }
                5078u32 => Self::TrackFinishWritingAMDX,
                5091u32 => {
                    Self::PayloadNodeNameAMDX {
                        node_name: reader.next_string()?,
                    }
                }
                5248u32 => Self::OverrideCoverageNV,
                5250u32 => Self::PassthroughNV,
                5252u32 => Self::ViewportRelativeNV,
                5256u32 => {
                    Self::SecondaryViewportRelativeNV {
                        offset: reader.next_word()?,
                    }
                }
                5271u32 => Self::PerPrimitiveEXT,
                5272u32 => Self::PerViewNV,
                5273u32 => Self::PerTaskNV,
                5285u32 => Self::PerVertexKHR,
                5300u32 => Self::NonUniform,
                5355u32 => Self::RestrictPointer,
                5356u32 => Self::AliasedPointer,
                5386u32 => Self::HitObjectShaderRecordBufferNV,
                5398u32 => Self::BindlessSamplerNV,
                5399u32 => Self::BindlessImageNV,
                5400u32 => Self::BoundSamplerNV,
                5401u32 => Self::BoundImageNV,
                5599u32 => {
                    Self::SIMTCallINTEL {
                        n: reader.next_word()?,
                    }
                }
                5602u32 => Self::ReferencedIndirectlyINTEL,
                5607u32 => {
                    Self::ClobberINTEL {
                        register: reader.next_string()?,
                    }
                }
                5608u32 => Self::SideEffectsINTEL,
                5624u32 => Self::VectorComputeVariableINTEL,
                5625u32 => {
                    Self::FuncParamIOKindINTEL {
                        kind: reader.next_word()?,
                    }
                }
                5626u32 => Self::VectorComputeFunctionINTEL,
                5627u32 => Self::StackCallINTEL,
                5628u32 => {
                    Self::GlobalVariableOffsetINTEL {
                        offset: reader.next_word()?,
                    }
                }
                5634u32 => {
                    Self::CounterBuffer {
                        counter_buffer: Id(reader.next_word()?),
                    }
                }
                5635u32 => {
                    Self::UserSemantic {
                        semantic: reader.next_string()?,
                    }
                }
                5636u32 => {
                    Self::UserTypeGOOGLE {
                        user_type: reader.next_string()?,
                    }
                }
                5822u32 => {
                    Self::FunctionRoundingModeINTEL {
                        target_width: reader.next_word()?,
                        fp_rounding_mode: FPRoundingMode::parse(reader)?,
                    }
                }
                5823u32 => {
                    Self::FunctionDenormModeINTEL {
                        target_width: reader.next_word()?,
                        fp_denorm_mode: FPDenormMode::parse(reader)?,
                    }
                }
                5825u32 => Self::RegisterINTEL,
                5826u32 => {
                    Self::MemoryINTEL {
                        memory_type: reader.next_string()?,
                    }
                }
                5827u32 => {
                    Self::NumbanksINTEL {
                        banks: reader.next_word()?,
                    }
                }
                5828u32 => {
                    Self::BankwidthINTEL {
                        bank_width: reader.next_word()?,
                    }
                }
                5829u32 => {
                    Self::MaxPrivateCopiesINTEL {
                        maximum_copies: reader.next_word()?,
                    }
                }
                5830u32 => Self::SinglepumpINTEL,
                5831u32 => Self::DoublepumpINTEL,
                5832u32 => {
                    Self::MaxReplicatesINTEL {
                        maximum_replicates: reader.next_word()?,
                    }
                }
                5833u32 => Self::SimpleDualPortINTEL,
                5834u32 => {
                    Self::MergeINTEL {
                        merge_key: reader.next_string()?,
                        merge_type: reader.next_string()?,
                    }
                }
                5835u32 => {
                    Self::BankBitsINTEL {
                        bank_bits: reader.next_word()?,
                    }
                }
                5836u32 => {
                    Self::ForcePow2DepthINTEL {
                        force_key: reader.next_word()?,
                    }
                }
                5883u32 => {
                    Self::StridesizeINTEL {
                        stride_size: reader.next_word()?,
                    }
                }
                5884u32 => {
                    Self::WordsizeINTEL {
                        word_size: reader.next_word()?,
                    }
                }
                5885u32 => Self::TrueDualPortINTEL,
                5899u32 => Self::BurstCoalesceINTEL,
                5900u32 => {
                    Self::CacheSizeINTEL {
                        cache_size_in_bytes: reader.next_word()?,
                    }
                }
                5901u32 => Self::DontStaticallyCoalesceINTEL,
                5902u32 => {
                    Self::PrefetchINTEL {
                        prefetcher_size_in_bytes: reader.next_word()?,
                    }
                }
                5905u32 => Self::StallEnableINTEL,
                5907u32 => Self::FuseLoopsInFunctionINTEL,
                5909u32 => {
                    Self::MathOpDSPModeINTEL {
                        mode: reader.next_word()?,
                        propagate: reader.next_word()?,
                    }
                }
                5914u32 => {
                    Self::AliasScopeINTEL {
                        aliasing_scopes_list: Id(reader.next_word()?),
                    }
                }
                5915u32 => {
                    Self::NoAliasINTEL {
                        aliasing_scopes_list: Id(reader.next_word()?),
                    }
                }
                5917u32 => {
                    Self::InitiationIntervalINTEL {
                        cycles: reader.next_word()?,
                    }
                }
                5918u32 => {
                    Self::MaxConcurrencyINTEL {
                        invocations: reader.next_word()?,
                    }
                }
                5919u32 => {
                    Self::PipelineEnableINTEL {
                        enable: reader.next_word()?,
                    }
                }
                5921u32 => {
                    Self::BufferLocationINTEL {
                        buffer_location_id: reader.next_word()?,
                    }
                }
                5944u32 => {
                    Self::IOPipeStorageINTEL {
                        io_pipe_id: reader.next_word()?,
                    }
                }
                6080u32 => {
                    Self::FunctionFloatingPointModeINTEL {
                        target_width: reader.next_word()?,
                        fp_operation_mode: FPOperationMode::parse(reader)?,
                    }
                }
                6085u32 => Self::SingleElementVectorINTEL,
                6087u32 => Self::VectorComputeCallableFunctionINTEL,
                6140u32 => Self::MediaBlockIOINTEL,
                6151u32 => Self::StallFreeINTEL,
                6170u32 => {
                    Self::FPMaxErrorDecorationINTEL {
                        max_error: f32::from_bits(reader.next_word()?),
                    }
                }
                6172u32 => {
                    Self::LatencyControlLabelINTEL {
                        latency_label: reader.next_word()?,
                    }
                }
                6173u32 => {
                    Self::LatencyControlConstraintINTEL {
                        relative_to: reader.next_word()?,
                        control_type: reader.next_word()?,
                        relative_cycle: reader.next_word()?,
                    }
                }
                6175u32 => Self::ConduitKernelArgumentINTEL,
                6176u32 => Self::RegisterMapKernelArgumentINTEL,
                6177u32 => {
                    Self::MMHostInterfaceAddressWidthINTEL {
                        address_width: reader.next_word()?,
                    }
                }
                6178u32 => {
                    Self::MMHostInterfaceDataWidthINTEL {
                        data_width: reader.next_word()?,
                    }
                }
                6179u32 => {
                    Self::MMHostInterfaceLatencyINTEL {
                        latency: reader.next_word()?,
                    }
                }
                6180u32 => {
                    Self::MMHostInterfaceReadWriteModeINTEL {
                        read_write_mode: AccessQualifier::parse(reader)?,
                    }
                }
                6181u32 => {
                    Self::MMHostInterfaceMaxBurstINTEL {
                        max_burst_count: reader.next_word()?,
                    }
                }
                6182u32 => {
                    Self::MMHostInterfaceWaitRequestINTEL {
                        waitrequest: reader.next_word()?,
                    }
                }
                6183u32 => Self::StableKernelArgumentINTEL,
                6188u32 => {
                    Self::HostAccessINTEL {
                        access: HostAccessQualifier::parse(reader)?,
                        name: reader.next_string()?,
                    }
                }
                6190u32 => {
                    Self::InitModeINTEL {
                        trigger: InitializationModeQualifier::parse(reader)?,
                    }
                }
                6191u32 => {
                    Self::ImplementInRegisterMapINTEL {
                        value: reader.next_word()?,
                    }
                }
                6442u32 => {
                    Self::CacheControlLoadINTEL {
                        cache_level: reader.next_word()?,
                        cache_control: LoadCacheControl::parse(reader)?,
                    }
                }
                6443u32 => {
                    Self::CacheControlStoreINTEL {
                        cache_level: reader.next_word()?,
                        cache_control: StoreCacheControl::parse(reader)?,
                    }
                }
                value => {
                    return Err(
                        reader
                            .map_err(ParseErrors::UnknownEnumerant("Decoration", value)),
                    );
                }
            },
        )
    }
}
impl TryFrom<u32> for Decoration {
    type Error = ();
    fn try_from(val: u32) -> Result<Self, Self::Error> {
        match val {
            0u32 => Ok(Self::RelaxedPrecision),
            2u32 => Ok(Self::Block),
            3u32 => Ok(Self::BufferBlock),
            4u32 => Ok(Self::RowMajor),
            5u32 => Ok(Self::ColMajor),
            8u32 => Ok(Self::GLSLShared),
            9u32 => Ok(Self::GLSLPacked),
            10u32 => Ok(Self::CPacked),
            13u32 => Ok(Self::NoPerspective),
            14u32 => Ok(Self::Flat),
            15u32 => Ok(Self::Patch),
            16u32 => Ok(Self::Centroid),
            17u32 => Ok(Self::Sample),
            18u32 => Ok(Self::Invariant),
            19u32 => Ok(Self::Restrict),
            20u32 => Ok(Self::Aliased),
            21u32 => Ok(Self::Volatile),
            22u32 => Ok(Self::Constant),
            23u32 => Ok(Self::Coherent),
            24u32 => Ok(Self::NonWritable),
            25u32 => Ok(Self::NonReadable),
            26u32 => Ok(Self::Uniform),
            28u32 => Ok(Self::SaturatedConversion),
            42u32 => Ok(Self::NoContraction),
            4469u32 => Ok(Self::NoSignedWrap),
            4470u32 => Ok(Self::NoUnsignedWrap),
            4487u32 => Ok(Self::WeightTextureQCOM),
            4488u32 => Ok(Self::BlockMatchTextureQCOM),
            4499u32 => Ok(Self::BlockMatchSamplerQCOM),
            4999u32 => Ok(Self::ExplicitInterpAMD),
            5078u32 => Ok(Self::TrackFinishWritingAMDX),
            5248u32 => Ok(Self::OverrideCoverageNV),
            5250u32 => Ok(Self::PassthroughNV),
            5252u32 => Ok(Self::ViewportRelativeNV),
            5271u32 => Ok(Self::PerPrimitiveEXT),
            5272u32 => Ok(Self::PerViewNV),
            5273u32 => Ok(Self::PerTaskNV),
            5285u32 => Ok(Self::PerVertexKHR),
            5300u32 => Ok(Self::NonUniform),
            5355u32 => Ok(Self::RestrictPointer),
            5356u32 => Ok(Self::AliasedPointer),
            5386u32 => Ok(Self::HitObjectShaderRecordBufferNV),
            5398u32 => Ok(Self::BindlessSamplerNV),
            5399u32 => Ok(Self::BindlessImageNV),
            5400u32 => Ok(Self::BoundSamplerNV),
            5401u32 => Ok(Self::BoundImageNV),
            5602u32 => Ok(Self::ReferencedIndirectlyINTEL),
            5608u32 => Ok(Self::SideEffectsINTEL),
            5624u32 => Ok(Self::VectorComputeVariableINTEL),
            5626u32 => Ok(Self::VectorComputeFunctionINTEL),
            5627u32 => Ok(Self::StackCallINTEL),
            5825u32 => Ok(Self::RegisterINTEL),
            5830u32 => Ok(Self::SinglepumpINTEL),
            5831u32 => Ok(Self::DoublepumpINTEL),
            5833u32 => Ok(Self::SimpleDualPortINTEL),
            5885u32 => Ok(Self::TrueDualPortINTEL),
            5899u32 => Ok(Self::BurstCoalesceINTEL),
            5901u32 => Ok(Self::DontStaticallyCoalesceINTEL),
            5905u32 => Ok(Self::StallEnableINTEL),
            5907u32 => Ok(Self::FuseLoopsInFunctionINTEL),
            6085u32 => Ok(Self::SingleElementVectorINTEL),
            6087u32 => Ok(Self::VectorComputeCallableFunctionINTEL),
            6140u32 => Ok(Self::MediaBlockIOINTEL),
            6151u32 => Ok(Self::StallFreeINTEL),
            6175u32 => Ok(Self::ConduitKernelArgumentINTEL),
            6176u32 => Ok(Self::RegisterMapKernelArgumentINTEL),
            6183u32 => Ok(Self::StableKernelArgumentINTEL),
            _ => Err(()),
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum BuiltIn {
    Position = 0u32,
    PointSize = 1u32,
    ClipDistance = 3u32,
    CullDistance = 4u32,
    VertexId = 5u32,
    InstanceId = 6u32,
    PrimitiveId = 7u32,
    InvocationId = 8u32,
    Layer = 9u32,
    ViewportIndex = 10u32,
    TessLevelOuter = 11u32,
    TessLevelInner = 12u32,
    TessCoord = 13u32,
    PatchVertices = 14u32,
    FragCoord = 15u32,
    PointCoord = 16u32,
    FrontFacing = 17u32,
    SampleId = 18u32,
    SamplePosition = 19u32,
    SampleMask = 20u32,
    FragDepth = 22u32,
    HelperInvocation = 23u32,
    NumWorkgroups = 24u32,
    WorkgroupSize = 25u32,
    WorkgroupId = 26u32,
    LocalInvocationId = 27u32,
    GlobalInvocationId = 28u32,
    LocalInvocationIndex = 29u32,
    WorkDim = 30u32,
    GlobalSize = 31u32,
    EnqueuedWorkgroupSize = 32u32,
    GlobalOffset = 33u32,
    GlobalLinearId = 34u32,
    SubgroupSize = 36u32,
    SubgroupMaxSize = 37u32,
    NumSubgroups = 38u32,
    NumEnqueuedSubgroups = 39u32,
    SubgroupId = 40u32,
    SubgroupLocalInvocationId = 41u32,
    VertexIndex = 42u32,
    InstanceIndex = 43u32,
    CoreIDARM = 4160u32,
    CoreCountARM = 4161u32,
    CoreMaxIDARM = 4162u32,
    WarpIDARM = 4163u32,
    WarpMaxIDARM = 4164u32,
    SubgroupEqMask = 4416u32,
    SubgroupGeMask = 4417u32,
    SubgroupGtMask = 4418u32,
    SubgroupLeMask = 4419u32,
    SubgroupLtMask = 4420u32,
    BaseVertex = 4424u32,
    BaseInstance = 4425u32,
    DrawIndex = 4426u32,
    PrimitiveShadingRateKHR = 4432u32,
    DeviceIndex = 4438u32,
    ViewIndex = 4440u32,
    ShadingRateKHR = 4444u32,
    BaryCoordNoPerspAMD = 4992u32,
    BaryCoordNoPerspCentroidAMD = 4993u32,
    BaryCoordNoPerspSampleAMD = 4994u32,
    BaryCoordSmoothAMD = 4995u32,
    BaryCoordSmoothCentroidAMD = 4996u32,
    BaryCoordSmoothSampleAMD = 4997u32,
    BaryCoordPullModelAMD = 4998u32,
    FragStencilRefEXT = 5014u32,
    CoalescedInputCountAMDX = 5021u32,
    ShaderIndexAMDX = 5073u32,
    ViewportMaskNV = 5253u32,
    SecondaryPositionNV = 5257u32,
    SecondaryViewportMaskNV = 5258u32,
    PositionPerViewNV = 5261u32,
    ViewportMaskPerViewNV = 5262u32,
    FullyCoveredEXT = 5264u32,
    TaskCountNV = 5274u32,
    PrimitiveCountNV = 5275u32,
    PrimitiveIndicesNV = 5276u32,
    ClipDistancePerViewNV = 5277u32,
    CullDistancePerViewNV = 5278u32,
    LayerPerViewNV = 5279u32,
    MeshViewCountNV = 5280u32,
    MeshViewIndicesNV = 5281u32,
    BaryCoordKHR = 5286u32,
    BaryCoordNoPerspKHR = 5287u32,
    FragSizeEXT = 5292u32,
    FragInvocationCountEXT = 5293u32,
    PrimitivePointIndicesEXT = 5294u32,
    PrimitiveLineIndicesEXT = 5295u32,
    PrimitiveTriangleIndicesEXT = 5296u32,
    CullPrimitiveEXT = 5299u32,
    LaunchIdKHR = 5319u32,
    LaunchSizeKHR = 5320u32,
    WorldRayOriginKHR = 5321u32,
    WorldRayDirectionKHR = 5322u32,
    ObjectRayOriginKHR = 5323u32,
    ObjectRayDirectionKHR = 5324u32,
    RayTminKHR = 5325u32,
    RayTmaxKHR = 5326u32,
    InstanceCustomIndexKHR = 5327u32,
    ObjectToWorldKHR = 5330u32,
    WorldToObjectKHR = 5331u32,
    HitTNV = 5332u32,
    HitKindKHR = 5333u32,
    CurrentRayTimeNV = 5334u32,
    HitTriangleVertexPositionsKHR = 5335u32,
    HitMicroTriangleVertexPositionsNV = 5337u32,
    HitMicroTriangleVertexBarycentricsNV = 5344u32,
    IncomingRayFlagsKHR = 5351u32,
    RayGeometryIndexKHR = 5352u32,
    WarpsPerSMNV = 5374u32,
    SMCountNV = 5375u32,
    WarpIDNV = 5376u32,
    SMIDNV = 5377u32,
    HitKindFrontFacingMicroTriangleNV = 5405u32,
    HitKindBackFacingMicroTriangleNV = 5406u32,
    CullMaskKHR = 6021u32,
}
impl BuiltIn {
    #[allow(dead_code)]
    fn parse(reader: &mut InstructionReader<'_>) -> Result<BuiltIn, ParseError> {
        Ok(
            match reader.next_word()? {
                0u32 => Self::Position,
                1u32 => Self::PointSize,
                3u32 => Self::ClipDistance,
                4u32 => Self::CullDistance,
                5u32 => Self::VertexId,
                6u32 => Self::InstanceId,
                7u32 => Self::PrimitiveId,
                8u32 => Self::InvocationId,
                9u32 => Self::Layer,
                10u32 => Self::ViewportIndex,
                11u32 => Self::TessLevelOuter,
                12u32 => Self::TessLevelInner,
                13u32 => Self::TessCoord,
                14u32 => Self::PatchVertices,
                15u32 => Self::FragCoord,
                16u32 => Self::PointCoord,
                17u32 => Self::FrontFacing,
                18u32 => Self::SampleId,
                19u32 => Self::SamplePosition,
                20u32 => Self::SampleMask,
                22u32 => Self::FragDepth,
                23u32 => Self::HelperInvocation,
                24u32 => Self::NumWorkgroups,
                25u32 => Self::WorkgroupSize,
                26u32 => Self::WorkgroupId,
                27u32 => Self::LocalInvocationId,
                28u32 => Self::GlobalInvocationId,
                29u32 => Self::LocalInvocationIndex,
                30u32 => Self::WorkDim,
                31u32 => Self::GlobalSize,
                32u32 => Self::EnqueuedWorkgroupSize,
                33u32 => Self::GlobalOffset,
                34u32 => Self::GlobalLinearId,
                36u32 => Self::SubgroupSize,
                37u32 => Self::SubgroupMaxSize,
                38u32 => Self::NumSubgroups,
                39u32 => Self::NumEnqueuedSubgroups,
                40u32 => Self::SubgroupId,
                41u32 => Self::SubgroupLocalInvocationId,
                42u32 => Self::VertexIndex,
                43u32 => Self::InstanceIndex,
                4160u32 => Self::CoreIDARM,
                4161u32 => Self::CoreCountARM,
                4162u32 => Self::CoreMaxIDARM,
                4163u32 => Self::WarpIDARM,
                4164u32 => Self::WarpMaxIDARM,
                4416u32 => Self::SubgroupEqMask,
                4417u32 => Self::SubgroupGeMask,
                4418u32 => Self::SubgroupGtMask,
                4419u32 => Self::SubgroupLeMask,
                4420u32 => Self::SubgroupLtMask,
                4424u32 => Self::BaseVertex,
                4425u32 => Self::BaseInstance,
                4426u32 => Self::DrawIndex,
                4432u32 => Self::PrimitiveShadingRateKHR,
                4438u32 => Self::DeviceIndex,
                4440u32 => Self::ViewIndex,
                4444u32 => Self::ShadingRateKHR,
                4992u32 => Self::BaryCoordNoPerspAMD,
                4993u32 => Self::BaryCoordNoPerspCentroidAMD,
                4994u32 => Self::BaryCoordNoPerspSampleAMD,
                4995u32 => Self::BaryCoordSmoothAMD,
                4996u32 => Self::BaryCoordSmoothCentroidAMD,
                4997u32 => Self::BaryCoordSmoothSampleAMD,
                4998u32 => Self::BaryCoordPullModelAMD,
                5014u32 => Self::FragStencilRefEXT,
                5021u32 => Self::CoalescedInputCountAMDX,
                5073u32 => Self::ShaderIndexAMDX,
                5253u32 => Self::ViewportMaskNV,
                5257u32 => Self::SecondaryPositionNV,
                5258u32 => Self::SecondaryViewportMaskNV,
                5261u32 => Self::PositionPerViewNV,
                5262u32 => Self::ViewportMaskPerViewNV,
                5264u32 => Self::FullyCoveredEXT,
                5274u32 => Self::TaskCountNV,
                5275u32 => Self::PrimitiveCountNV,
                5276u32 => Self::PrimitiveIndicesNV,
                5277u32 => Self::ClipDistancePerViewNV,
                5278u32 => Self::CullDistancePerViewNV,
                5279u32 => Self::LayerPerViewNV,
                5280u32 => Self::MeshViewCountNV,
                5281u32 => Self::MeshViewIndicesNV,
                5286u32 => Self::BaryCoordKHR,
                5287u32 => Self::BaryCoordNoPerspKHR,
                5292u32 => Self::FragSizeEXT,
                5293u32 => Self::FragInvocationCountEXT,
                5294u32 => Self::PrimitivePointIndicesEXT,
                5295u32 => Self::PrimitiveLineIndicesEXT,
                5296u32 => Self::PrimitiveTriangleIndicesEXT,
                5299u32 => Self::CullPrimitiveEXT,
                5319u32 => Self::LaunchIdKHR,
                5320u32 => Self::LaunchSizeKHR,
                5321u32 => Self::WorldRayOriginKHR,
                5322u32 => Self::WorldRayDirectionKHR,
                5323u32 => Self::ObjectRayOriginKHR,
                5324u32 => Self::ObjectRayDirectionKHR,
                5325u32 => Self::RayTminKHR,
                5326u32 => Self::RayTmaxKHR,
                5327u32 => Self::InstanceCustomIndexKHR,
                5330u32 => Self::ObjectToWorldKHR,
                5331u32 => Self::WorldToObjectKHR,
                5332u32 => Self::HitTNV,
                5333u32 => Self::HitKindKHR,
                5334u32 => Self::CurrentRayTimeNV,
                5335u32 => Self::HitTriangleVertexPositionsKHR,
                5337u32 => Self::HitMicroTriangleVertexPositionsNV,
                5344u32 => Self::HitMicroTriangleVertexBarycentricsNV,
                5351u32 => Self::IncomingRayFlagsKHR,
                5352u32 => Self::RayGeometryIndexKHR,
                5374u32 => Self::WarpsPerSMNV,
                5375u32 => Self::SMCountNV,
                5376u32 => Self::WarpIDNV,
                5377u32 => Self::SMIDNV,
                5405u32 => Self::HitKindFrontFacingMicroTriangleNV,
                5406u32 => Self::HitKindBackFacingMicroTriangleNV,
                6021u32 => Self::CullMaskKHR,
                value => {
                    return Err(
                        reader.map_err(ParseErrors::UnknownEnumerant("BuiltIn", value)),
                    );
                }
            },
        )
    }
}
impl TryFrom<u32> for BuiltIn {
    type Error = ();
    fn try_from(val: u32) -> Result<Self, Self::Error> {
        match val {
            0u32 => Ok(Self::Position),
            1u32 => Ok(Self::PointSize),
            3u32 => Ok(Self::ClipDistance),
            4u32 => Ok(Self::CullDistance),
            5u32 => Ok(Self::VertexId),
            6u32 => Ok(Self::InstanceId),
            7u32 => Ok(Self::PrimitiveId),
            8u32 => Ok(Self::InvocationId),
            9u32 => Ok(Self::Layer),
            10u32 => Ok(Self::ViewportIndex),
            11u32 => Ok(Self::TessLevelOuter),
            12u32 => Ok(Self::TessLevelInner),
            13u32 => Ok(Self::TessCoord),
            14u32 => Ok(Self::PatchVertices),
            15u32 => Ok(Self::FragCoord),
            16u32 => Ok(Self::PointCoord),
            17u32 => Ok(Self::FrontFacing),
            18u32 => Ok(Self::SampleId),
            19u32 => Ok(Self::SamplePosition),
            20u32 => Ok(Self::SampleMask),
            22u32 => Ok(Self::FragDepth),
            23u32 => Ok(Self::HelperInvocation),
            24u32 => Ok(Self::NumWorkgroups),
            25u32 => Ok(Self::WorkgroupSize),
            26u32 => Ok(Self::WorkgroupId),
            27u32 => Ok(Self::LocalInvocationId),
            28u32 => Ok(Self::GlobalInvocationId),
            29u32 => Ok(Self::LocalInvocationIndex),
            30u32 => Ok(Self::WorkDim),
            31u32 => Ok(Self::GlobalSize),
            32u32 => Ok(Self::EnqueuedWorkgroupSize),
            33u32 => Ok(Self::GlobalOffset),
            34u32 => Ok(Self::GlobalLinearId),
            36u32 => Ok(Self::SubgroupSize),
            37u32 => Ok(Self::SubgroupMaxSize),
            38u32 => Ok(Self::NumSubgroups),
            39u32 => Ok(Self::NumEnqueuedSubgroups),
            40u32 => Ok(Self::SubgroupId),
            41u32 => Ok(Self::SubgroupLocalInvocationId),
            42u32 => Ok(Self::VertexIndex),
            43u32 => Ok(Self::InstanceIndex),
            4160u32 => Ok(Self::CoreIDARM),
            4161u32 => Ok(Self::CoreCountARM),
            4162u32 => Ok(Self::CoreMaxIDARM),
            4163u32 => Ok(Self::WarpIDARM),
            4164u32 => Ok(Self::WarpMaxIDARM),
            4416u32 => Ok(Self::SubgroupEqMask),
            4417u32 => Ok(Self::SubgroupGeMask),
            4418u32 => Ok(Self::SubgroupGtMask),
            4419u32 => Ok(Self::SubgroupLeMask),
            4420u32 => Ok(Self::SubgroupLtMask),
            4424u32 => Ok(Self::BaseVertex),
            4425u32 => Ok(Self::BaseInstance),
            4426u32 => Ok(Self::DrawIndex),
            4432u32 => Ok(Self::PrimitiveShadingRateKHR),
            4438u32 => Ok(Self::DeviceIndex),
            4440u32 => Ok(Self::ViewIndex),
            4444u32 => Ok(Self::ShadingRateKHR),
            4992u32 => Ok(Self::BaryCoordNoPerspAMD),
            4993u32 => Ok(Self::BaryCoordNoPerspCentroidAMD),
            4994u32 => Ok(Self::BaryCoordNoPerspSampleAMD),
            4995u32 => Ok(Self::BaryCoordSmoothAMD),
            4996u32 => Ok(Self::BaryCoordSmoothCentroidAMD),
            4997u32 => Ok(Self::BaryCoordSmoothSampleAMD),
            4998u32 => Ok(Self::BaryCoordPullModelAMD),
            5014u32 => Ok(Self::FragStencilRefEXT),
            5021u32 => Ok(Self::CoalescedInputCountAMDX),
            5073u32 => Ok(Self::ShaderIndexAMDX),
            5253u32 => Ok(Self::ViewportMaskNV),
            5257u32 => Ok(Self::SecondaryPositionNV),
            5258u32 => Ok(Self::SecondaryViewportMaskNV),
            5261u32 => Ok(Self::PositionPerViewNV),
            5262u32 => Ok(Self::ViewportMaskPerViewNV),
            5264u32 => Ok(Self::FullyCoveredEXT),
            5274u32 => Ok(Self::TaskCountNV),
            5275u32 => Ok(Self::PrimitiveCountNV),
            5276u32 => Ok(Self::PrimitiveIndicesNV),
            5277u32 => Ok(Self::ClipDistancePerViewNV),
            5278u32 => Ok(Self::CullDistancePerViewNV),
            5279u32 => Ok(Self::LayerPerViewNV),
            5280u32 => Ok(Self::MeshViewCountNV),
            5281u32 => Ok(Self::MeshViewIndicesNV),
            5286u32 => Ok(Self::BaryCoordKHR),
            5287u32 => Ok(Self::BaryCoordNoPerspKHR),
            5292u32 => Ok(Self::FragSizeEXT),
            5293u32 => Ok(Self::FragInvocationCountEXT),
            5294u32 => Ok(Self::PrimitivePointIndicesEXT),
            5295u32 => Ok(Self::PrimitiveLineIndicesEXT),
            5296u32 => Ok(Self::PrimitiveTriangleIndicesEXT),
            5299u32 => Ok(Self::CullPrimitiveEXT),
            5319u32 => Ok(Self::LaunchIdKHR),
            5320u32 => Ok(Self::LaunchSizeKHR),
            5321u32 => Ok(Self::WorldRayOriginKHR),
            5322u32 => Ok(Self::WorldRayDirectionKHR),
            5323u32 => Ok(Self::ObjectRayOriginKHR),
            5324u32 => Ok(Self::ObjectRayDirectionKHR),
            5325u32 => Ok(Self::RayTminKHR),
            5326u32 => Ok(Self::RayTmaxKHR),
            5327u32 => Ok(Self::InstanceCustomIndexKHR),
            5330u32 => Ok(Self::ObjectToWorldKHR),
            5331u32 => Ok(Self::WorldToObjectKHR),
            5332u32 => Ok(Self::HitTNV),
            5333u32 => Ok(Self::HitKindKHR),
            5334u32 => Ok(Self::CurrentRayTimeNV),
            5335u32 => Ok(Self::HitTriangleVertexPositionsKHR),
            5337u32 => Ok(Self::HitMicroTriangleVertexPositionsNV),
            5344u32 => Ok(Self::HitMicroTriangleVertexBarycentricsNV),
            5351u32 => Ok(Self::IncomingRayFlagsKHR),
            5352u32 => Ok(Self::RayGeometryIndexKHR),
            5374u32 => Ok(Self::WarpsPerSMNV),
            5375u32 => Ok(Self::SMCountNV),
            5376u32 => Ok(Self::WarpIDNV),
            5377u32 => Ok(Self::SMIDNV),
            5405u32 => Ok(Self::HitKindFrontFacingMicroTriangleNV),
            5406u32 => Ok(Self::HitKindBackFacingMicroTriangleNV),
            6021u32 => Ok(Self::CullMaskKHR),
            _ => Err(()),
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum Scope {
    CrossDevice = 0u32,
    Device = 1u32,
    Workgroup = 2u32,
    Subgroup = 3u32,
    Invocation = 4u32,
    QueueFamily = 5u32,
    ShaderCallKHR = 6u32,
}
impl Scope {
    #[allow(dead_code)]
    fn parse(reader: &mut InstructionReader<'_>) -> Result<Scope, ParseError> {
        Ok(
            match reader.next_word()? {
                0u32 => Self::CrossDevice,
                1u32 => Self::Device,
                2u32 => Self::Workgroup,
                3u32 => Self::Subgroup,
                4u32 => Self::Invocation,
                5u32 => Self::QueueFamily,
                6u32 => Self::ShaderCallKHR,
                value => {
                    return Err(
                        reader.map_err(ParseErrors::UnknownEnumerant("Scope", value)),
                    );
                }
            },
        )
    }
}
impl TryFrom<u32> for Scope {
    type Error = ();
    fn try_from(val: u32) -> Result<Self, Self::Error> {
        match val {
            0u32 => Ok(Self::CrossDevice),
            1u32 => Ok(Self::Device),
            2u32 => Ok(Self::Workgroup),
            3u32 => Ok(Self::Subgroup),
            4u32 => Ok(Self::Invocation),
            5u32 => Ok(Self::QueueFamily),
            6u32 => Ok(Self::ShaderCallKHR),
            _ => Err(()),
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum GroupOperation {
    Reduce = 0u32,
    InclusiveScan = 1u32,
    ExclusiveScan = 2u32,
    ClusteredReduce = 3u32,
    PartitionedReduceNV = 6u32,
    PartitionedInclusiveScanNV = 7u32,
    PartitionedExclusiveScanNV = 8u32,
}
impl GroupOperation {
    #[allow(dead_code)]
    fn parse(reader: &mut InstructionReader<'_>) -> Result<GroupOperation, ParseError> {
        Ok(
            match reader.next_word()? {
                0u32 => Self::Reduce,
                1u32 => Self::InclusiveScan,
                2u32 => Self::ExclusiveScan,
                3u32 => Self::ClusteredReduce,
                6u32 => Self::PartitionedReduceNV,
                7u32 => Self::PartitionedInclusiveScanNV,
                8u32 => Self::PartitionedExclusiveScanNV,
                value => {
                    return Err(
                        reader
                            .map_err(
                                ParseErrors::UnknownEnumerant("GroupOperation", value),
                            ),
                    );
                }
            },
        )
    }
}
impl TryFrom<u32> for GroupOperation {
    type Error = ();
    fn try_from(val: u32) -> Result<Self, Self::Error> {
        match val {
            0u32 => Ok(Self::Reduce),
            1u32 => Ok(Self::InclusiveScan),
            2u32 => Ok(Self::ExclusiveScan),
            3u32 => Ok(Self::ClusteredReduce),
            6u32 => Ok(Self::PartitionedReduceNV),
            7u32 => Ok(Self::PartitionedInclusiveScanNV),
            8u32 => Ok(Self::PartitionedExclusiveScanNV),
            _ => Err(()),
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum KernelEnqueueFlags {
    NoWait = 0u32,
    WaitKernel = 1u32,
    WaitWorkGroup = 2u32,
}
impl KernelEnqueueFlags {
    #[allow(dead_code)]
    fn parse(
        reader: &mut InstructionReader<'_>,
    ) -> Result<KernelEnqueueFlags, ParseError> {
        Ok(
            match reader.next_word()? {
                0u32 => Self::NoWait,
                1u32 => Self::WaitKernel,
                2u32 => Self::WaitWorkGroup,
                value => {
                    return Err(
                        reader
                            .map_err(
                                ParseErrors::UnknownEnumerant("KernelEnqueueFlags", value),
                            ),
                    );
                }
            },
        )
    }
}
impl TryFrom<u32> for KernelEnqueueFlags {
    type Error = ();
    fn try_from(val: u32) -> Result<Self, Self::Error> {
        match val {
            0u32 => Ok(Self::NoWait),
            1u32 => Ok(Self::WaitKernel),
            2u32 => Ok(Self::WaitWorkGroup),
            _ => Err(()),
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum Capability {
    Matrix = 0u32,
    Shader = 1u32,
    Geometry = 2u32,
    Tessellation = 3u32,
    Addresses = 4u32,
    Linkage = 5u32,
    Kernel = 6u32,
    Vector16 = 7u32,
    Float16Buffer = 8u32,
    Float16 = 9u32,
    Float64 = 10u32,
    Int64 = 11u32,
    Int64Atomics = 12u32,
    ImageBasic = 13u32,
    ImageReadWrite = 14u32,
    ImageMipmap = 15u32,
    Pipes = 17u32,
    Groups = 18u32,
    DeviceEnqueue = 19u32,
    LiteralSampler = 20u32,
    AtomicStorage = 21u32,
    Int16 = 22u32,
    TessellationPointSize = 23u32,
    GeometryPointSize = 24u32,
    ImageGatherExtended = 25u32,
    StorageImageMultisample = 27u32,
    UniformBufferArrayDynamicIndexing = 28u32,
    SampledImageArrayDynamicIndexing = 29u32,
    StorageBufferArrayDynamicIndexing = 30u32,
    StorageImageArrayDynamicIndexing = 31u32,
    ClipDistance = 32u32,
    CullDistance = 33u32,
    ImageCubeArray = 34u32,
    SampleRateShading = 35u32,
    ImageRect = 36u32,
    SampledRect = 37u32,
    GenericPointer = 38u32,
    Int8 = 39u32,
    InputAttachment = 40u32,
    SparseResidency = 41u32,
    MinLod = 42u32,
    Sampled1D = 43u32,
    Image1D = 44u32,
    SampledCubeArray = 45u32,
    SampledBuffer = 46u32,
    ImageBuffer = 47u32,
    ImageMSArray = 48u32,
    StorageImageExtendedFormats = 49u32,
    ImageQuery = 50u32,
    DerivativeControl = 51u32,
    InterpolationFunction = 52u32,
    TransformFeedback = 53u32,
    GeometryStreams = 54u32,
    StorageImageReadWithoutFormat = 55u32,
    StorageImageWriteWithoutFormat = 56u32,
    MultiViewport = 57u32,
    SubgroupDispatch = 58u32,
    NamedBarrier = 59u32,
    PipeStorage = 60u32,
    GroupNonUniform = 61u32,
    GroupNonUniformVote = 62u32,
    GroupNonUniformArithmetic = 63u32,
    GroupNonUniformBallot = 64u32,
    GroupNonUniformShuffle = 65u32,
    GroupNonUniformShuffleRelative = 66u32,
    GroupNonUniformClustered = 67u32,
    GroupNonUniformQuad = 68u32,
    ShaderLayer = 69u32,
    ShaderViewportIndex = 70u32,
    UniformDecoration = 71u32,
    CoreBuiltinsARM = 4165u32,
    TileImageColorReadAccessEXT = 4166u32,
    TileImageDepthReadAccessEXT = 4167u32,
    TileImageStencilReadAccessEXT = 4168u32,
    FragmentShadingRateKHR = 4422u32,
    SubgroupBallotKHR = 4423u32,
    DrawParameters = 4427u32,
    WorkgroupMemoryExplicitLayoutKHR = 4428u32,
    WorkgroupMemoryExplicitLayout8BitAccessKHR = 4429u32,
    WorkgroupMemoryExplicitLayout16BitAccessKHR = 4430u32,
    SubgroupVoteKHR = 4431u32,
    StorageBuffer16BitAccess = 4433u32,
    UniformAndStorageBuffer16BitAccess = 4434u32,
    StoragePushConstant16 = 4435u32,
    StorageInputOutput16 = 4436u32,
    DeviceGroup = 4437u32,
    MultiView = 4439u32,
    VariablePointersStorageBuffer = 4441u32,
    VariablePointers = 4442u32,
    AtomicStorageOps = 4445u32,
    SampleMaskPostDepthCoverage = 4447u32,
    StorageBuffer8BitAccess = 4448u32,
    UniformAndStorageBuffer8BitAccess = 4449u32,
    StoragePushConstant8 = 4450u32,
    DenormPreserve = 4464u32,
    DenormFlushToZero = 4465u32,
    SignedZeroInfNanPreserve = 4466u32,
    RoundingModeRTE = 4467u32,
    RoundingModeRTZ = 4468u32,
    RayQueryProvisionalKHR = 4471u32,
    RayQueryKHR = 4472u32,
    RayTraversalPrimitiveCullingKHR = 4478u32,
    RayTracingKHR = 4479u32,
    TextureSampleWeightedQCOM = 4484u32,
    TextureBoxFilterQCOM = 4485u32,
    TextureBlockMatchQCOM = 4486u32,
    TextureBlockMatch2QCOM = 4498u32,
    Float16ImageAMD = 5008u32,
    ImageGatherBiasLodAMD = 5009u32,
    FragmentMaskAMD = 5010u32,
    StencilExportEXT = 5013u32,
    ImageReadWriteLodAMD = 5015u32,
    Int64ImageEXT = 5016u32,
    ShaderClockKHR = 5055u32,
    ShaderEnqueueAMDX = 5067u32,
    QuadControlKHR = 5087u32,
    SampleMaskOverrideCoverageNV = 5249u32,
    GeometryShaderPassthroughNV = 5251u32,
    ShaderViewportIndexLayerEXT = 5254u32,
    ShaderViewportMaskNV = 5255u32,
    ShaderStereoViewNV = 5259u32,
    PerViewAttributesNV = 5260u32,
    FragmentFullyCoveredEXT = 5265u32,
    MeshShadingNV = 5266u32,
    ImageFootprintNV = 5282u32,
    MeshShadingEXT = 5283u32,
    FragmentBarycentricKHR = 5284u32,
    ComputeDerivativeGroupQuadsNV = 5288u32,
    FragmentDensityEXT = 5291u32,
    GroupNonUniformPartitionedNV = 5297u32,
    ShaderNonUniform = 5301u32,
    RuntimeDescriptorArray = 5302u32,
    InputAttachmentArrayDynamicIndexing = 5303u32,
    UniformTexelBufferArrayDynamicIndexing = 5304u32,
    StorageTexelBufferArrayDynamicIndexing = 5305u32,
    UniformBufferArrayNonUniformIndexing = 5306u32,
    SampledImageArrayNonUniformIndexing = 5307u32,
    StorageBufferArrayNonUniformIndexing = 5308u32,
    StorageImageArrayNonUniformIndexing = 5309u32,
    InputAttachmentArrayNonUniformIndexing = 5310u32,
    UniformTexelBufferArrayNonUniformIndexing = 5311u32,
    StorageTexelBufferArrayNonUniformIndexing = 5312u32,
    RayTracingPositionFetchKHR = 5336u32,
    RayTracingNV = 5340u32,
    RayTracingMotionBlurNV = 5341u32,
    VulkanMemoryModel = 5345u32,
    VulkanMemoryModelDeviceScope = 5346u32,
    PhysicalStorageBufferAddresses = 5347u32,
    ComputeDerivativeGroupLinearNV = 5350u32,
    RayTracingProvisionalKHR = 5353u32,
    CooperativeMatrixNV = 5357u32,
    FragmentShaderSampleInterlockEXT = 5363u32,
    FragmentShaderShadingRateInterlockEXT = 5372u32,
    ShaderSMBuiltinsNV = 5373u32,
    FragmentShaderPixelInterlockEXT = 5378u32,
    DemoteToHelperInvocation = 5379u32,
    DisplacementMicromapNV = 5380u32,
    RayTracingOpacityMicromapEXT = 5381u32,
    ShaderInvocationReorderNV = 5383u32,
    BindlessTextureNV = 5390u32,
    RayQueryPositionFetchKHR = 5391u32,
    AtomicFloat16VectorNV = 5404u32,
    RayTracingDisplacementMicromapNV = 5409u32,
    RawAccessChainsNV = 5414u32,
    SubgroupShuffleINTEL = 5568u32,
    SubgroupBufferBlockIOINTEL = 5569u32,
    SubgroupImageBlockIOINTEL = 5570u32,
    SubgroupImageMediaBlockIOINTEL = 5579u32,
    RoundToInfinityINTEL = 5582u32,
    FloatingPointModeINTEL = 5583u32,
    IntegerFunctions2INTEL = 5584u32,
    FunctionPointersINTEL = 5603u32,
    IndirectReferencesINTEL = 5604u32,
    AsmINTEL = 5606u32,
    AtomicFloat32MinMaxEXT = 5612u32,
    AtomicFloat64MinMaxEXT = 5613u32,
    AtomicFloat16MinMaxEXT = 5616u32,
    VectorComputeINTEL = 5617u32,
    VectorAnyINTEL = 5619u32,
    ExpectAssumeKHR = 5629u32,
    SubgroupAvcMotionEstimationINTEL = 5696u32,
    SubgroupAvcMotionEstimationIntraINTEL = 5697u32,
    SubgroupAvcMotionEstimationChromaINTEL = 5698u32,
    VariableLengthArrayINTEL = 5817u32,
    FunctionFloatControlINTEL = 5821u32,
    FPGAMemoryAttributesINTEL = 5824u32,
    FPFastMathModeINTEL = 5837u32,
    ArbitraryPrecisionIntegersINTEL = 5844u32,
    ArbitraryPrecisionFloatingPointINTEL = 5845u32,
    UnstructuredLoopControlsINTEL = 5886u32,
    FPGALoopControlsINTEL = 5888u32,
    KernelAttributesINTEL = 5892u32,
    FPGAKernelAttributesINTEL = 5897u32,
    FPGAMemoryAccessesINTEL = 5898u32,
    FPGAClusterAttributesINTEL = 5904u32,
    LoopFuseINTEL = 5906u32,
    FPGADSPControlINTEL = 5908u32,
    MemoryAccessAliasingINTEL = 5910u32,
    FPGAInvocationPipeliningAttributesINTEL = 5916u32,
    FPGABufferLocationINTEL = 5920u32,
    ArbitraryPrecisionFixedPointINTEL = 5922u32,
    USMStorageClassesINTEL = 5935u32,
    RuntimeAlignedAttributeINTEL = 5939u32,
    IOPipesINTEL = 5943u32,
    BlockingPipesINTEL = 5945u32,
    FPGARegINTEL = 5948u32,
    DotProductInputAll = 6016u32,
    DotProductInput4x8Bit = 6017u32,
    DotProductInput4x8BitPacked = 6018u32,
    DotProduct = 6019u32,
    RayCullMaskKHR = 6020u32,
    CooperativeMatrixKHR = 6022u32,
    BitInstructions = 6025u32,
    GroupNonUniformRotateKHR = 6026u32,
    FloatControls2 = 6029u32,
    AtomicFloat32AddEXT = 6033u32,
    AtomicFloat64AddEXT = 6034u32,
    LongCompositesINTEL = 6089u32,
    OptNoneINTEL = 6094u32,
    AtomicFloat16AddEXT = 6095u32,
    DebugInfoModuleINTEL = 6114u32,
    BFloat16ConversionINTEL = 6115u32,
    SplitBarrierINTEL = 6141u32,
    FPGAClusterAttributesV2INTEL = 6150u32,
    FPGAKernelAttributesv2INTEL = 6161u32,
    FPMaxErrorINTEL = 6169u32,
    FPGALatencyControlINTEL = 6171u32,
    FPGAArgumentInterfacesINTEL = 6174u32,
    GlobalVariableHostAccessINTEL = 6187u32,
    GlobalVariableFPGADecorationsINTEL = 6189u32,
    GroupUniformArithmeticKHR = 6400u32,
    MaskedGatherScatterINTEL = 6427u32,
    CacheControlsINTEL = 6441u32,
    RegisterLimitsINTEL = 6460u32,
}
impl Capability {
    #[allow(dead_code)]
    fn parse(reader: &mut InstructionReader<'_>) -> Result<Capability, ParseError> {
        Ok(
            match reader.next_word()? {
                0u32 => Self::Matrix,
                1u32 => Self::Shader,
                2u32 => Self::Geometry,
                3u32 => Self::Tessellation,
                4u32 => Self::Addresses,
                5u32 => Self::Linkage,
                6u32 => Self::Kernel,
                7u32 => Self::Vector16,
                8u32 => Self::Float16Buffer,
                9u32 => Self::Float16,
                10u32 => Self::Float64,
                11u32 => Self::Int64,
                12u32 => Self::Int64Atomics,
                13u32 => Self::ImageBasic,
                14u32 => Self::ImageReadWrite,
                15u32 => Self::ImageMipmap,
                17u32 => Self::Pipes,
                18u32 => Self::Groups,
                19u32 => Self::DeviceEnqueue,
                20u32 => Self::LiteralSampler,
                21u32 => Self::AtomicStorage,
                22u32 => Self::Int16,
                23u32 => Self::TessellationPointSize,
                24u32 => Self::GeometryPointSize,
                25u32 => Self::ImageGatherExtended,
                27u32 => Self::StorageImageMultisample,
                28u32 => Self::UniformBufferArrayDynamicIndexing,
                29u32 => Self::SampledImageArrayDynamicIndexing,
                30u32 => Self::StorageBufferArrayDynamicIndexing,
                31u32 => Self::StorageImageArrayDynamicIndexing,
                32u32 => Self::ClipDistance,
                33u32 => Self::CullDistance,
                34u32 => Self::ImageCubeArray,
                35u32 => Self::SampleRateShading,
                36u32 => Self::ImageRect,
                37u32 => Self::SampledRect,
                38u32 => Self::GenericPointer,
                39u32 => Self::Int8,
                40u32 => Self::InputAttachment,
                41u32 => Self::SparseResidency,
                42u32 => Self::MinLod,
                43u32 => Self::Sampled1D,
                44u32 => Self::Image1D,
                45u32 => Self::SampledCubeArray,
                46u32 => Self::SampledBuffer,
                47u32 => Self::ImageBuffer,
                48u32 => Self::ImageMSArray,
                49u32 => Self::StorageImageExtendedFormats,
                50u32 => Self::ImageQuery,
                51u32 => Self::DerivativeControl,
                52u32 => Self::InterpolationFunction,
                53u32 => Self::TransformFeedback,
                54u32 => Self::GeometryStreams,
                55u32 => Self::StorageImageReadWithoutFormat,
                56u32 => Self::StorageImageWriteWithoutFormat,
                57u32 => Self::MultiViewport,
                58u32 => Self::SubgroupDispatch,
                59u32 => Self::NamedBarrier,
                60u32 => Self::PipeStorage,
                61u32 => Self::GroupNonUniform,
                62u32 => Self::GroupNonUniformVote,
                63u32 => Self::GroupNonUniformArithmetic,
                64u32 => Self::GroupNonUniformBallot,
                65u32 => Self::GroupNonUniformShuffle,
                66u32 => Self::GroupNonUniformShuffleRelative,
                67u32 => Self::GroupNonUniformClustered,
                68u32 => Self::GroupNonUniformQuad,
                69u32 => Self::ShaderLayer,
                70u32 => Self::ShaderViewportIndex,
                71u32 => Self::UniformDecoration,
                4165u32 => Self::CoreBuiltinsARM,
                4166u32 => Self::TileImageColorReadAccessEXT,
                4167u32 => Self::TileImageDepthReadAccessEXT,
                4168u32 => Self::TileImageStencilReadAccessEXT,
                4422u32 => Self::FragmentShadingRateKHR,
                4423u32 => Self::SubgroupBallotKHR,
                4427u32 => Self::DrawParameters,
                4428u32 => Self::WorkgroupMemoryExplicitLayoutKHR,
                4429u32 => Self::WorkgroupMemoryExplicitLayout8BitAccessKHR,
                4430u32 => Self::WorkgroupMemoryExplicitLayout16BitAccessKHR,
                4431u32 => Self::SubgroupVoteKHR,
                4433u32 => Self::StorageBuffer16BitAccess,
                4434u32 => Self::UniformAndStorageBuffer16BitAccess,
                4435u32 => Self::StoragePushConstant16,
                4436u32 => Self::StorageInputOutput16,
                4437u32 => Self::DeviceGroup,
                4439u32 => Self::MultiView,
                4441u32 => Self::VariablePointersStorageBuffer,
                4442u32 => Self::VariablePointers,
                4445u32 => Self::AtomicStorageOps,
                4447u32 => Self::SampleMaskPostDepthCoverage,
                4448u32 => Self::StorageBuffer8BitAccess,
                4449u32 => Self::UniformAndStorageBuffer8BitAccess,
                4450u32 => Self::StoragePushConstant8,
                4464u32 => Self::DenormPreserve,
                4465u32 => Self::DenormFlushToZero,
                4466u32 => Self::SignedZeroInfNanPreserve,
                4467u32 => Self::RoundingModeRTE,
                4468u32 => Self::RoundingModeRTZ,
                4471u32 => Self::RayQueryProvisionalKHR,
                4472u32 => Self::RayQueryKHR,
                4478u32 => Self::RayTraversalPrimitiveCullingKHR,
                4479u32 => Self::RayTracingKHR,
                4484u32 => Self::TextureSampleWeightedQCOM,
                4485u32 => Self::TextureBoxFilterQCOM,
                4486u32 => Self::TextureBlockMatchQCOM,
                4498u32 => Self::TextureBlockMatch2QCOM,
                5008u32 => Self::Float16ImageAMD,
                5009u32 => Self::ImageGatherBiasLodAMD,
                5010u32 => Self::FragmentMaskAMD,
                5013u32 => Self::StencilExportEXT,
                5015u32 => Self::ImageReadWriteLodAMD,
                5016u32 => Self::Int64ImageEXT,
                5055u32 => Self::ShaderClockKHR,
                5067u32 => Self::ShaderEnqueueAMDX,
                5087u32 => Self::QuadControlKHR,
                5249u32 => Self::SampleMaskOverrideCoverageNV,
                5251u32 => Self::GeometryShaderPassthroughNV,
                5254u32 => Self::ShaderViewportIndexLayerEXT,
                5255u32 => Self::ShaderViewportMaskNV,
                5259u32 => Self::ShaderStereoViewNV,
                5260u32 => Self::PerViewAttributesNV,
                5265u32 => Self::FragmentFullyCoveredEXT,
                5266u32 => Self::MeshShadingNV,
                5282u32 => Self::ImageFootprintNV,
                5283u32 => Self::MeshShadingEXT,
                5284u32 => Self::FragmentBarycentricKHR,
                5288u32 => Self::ComputeDerivativeGroupQuadsNV,
                5291u32 => Self::FragmentDensityEXT,
                5297u32 => Self::GroupNonUniformPartitionedNV,
                5301u32 => Self::ShaderNonUniform,
                5302u32 => Self::RuntimeDescriptorArray,
                5303u32 => Self::InputAttachmentArrayDynamicIndexing,
                5304u32 => Self::UniformTexelBufferArrayDynamicIndexing,
                5305u32 => Self::StorageTexelBufferArrayDynamicIndexing,
                5306u32 => Self::UniformBufferArrayNonUniformIndexing,
                5307u32 => Self::SampledImageArrayNonUniformIndexing,
                5308u32 => Self::StorageBufferArrayNonUniformIndexing,
                5309u32 => Self::StorageImageArrayNonUniformIndexing,
                5310u32 => Self::InputAttachmentArrayNonUniformIndexing,
                5311u32 => Self::UniformTexelBufferArrayNonUniformIndexing,
                5312u32 => Self::StorageTexelBufferArrayNonUniformIndexing,
                5336u32 => Self::RayTracingPositionFetchKHR,
                5340u32 => Self::RayTracingNV,
                5341u32 => Self::RayTracingMotionBlurNV,
                5345u32 => Self::VulkanMemoryModel,
                5346u32 => Self::VulkanMemoryModelDeviceScope,
                5347u32 => Self::PhysicalStorageBufferAddresses,
                5350u32 => Self::ComputeDerivativeGroupLinearNV,
                5353u32 => Self::RayTracingProvisionalKHR,
                5357u32 => Self::CooperativeMatrixNV,
                5363u32 => Self::FragmentShaderSampleInterlockEXT,
                5372u32 => Self::FragmentShaderShadingRateInterlockEXT,
                5373u32 => Self::ShaderSMBuiltinsNV,
                5378u32 => Self::FragmentShaderPixelInterlockEXT,
                5379u32 => Self::DemoteToHelperInvocation,
                5380u32 => Self::DisplacementMicromapNV,
                5381u32 => Self::RayTracingOpacityMicromapEXT,
                5383u32 => Self::ShaderInvocationReorderNV,
                5390u32 => Self::BindlessTextureNV,
                5391u32 => Self::RayQueryPositionFetchKHR,
                5404u32 => Self::AtomicFloat16VectorNV,
                5409u32 => Self::RayTracingDisplacementMicromapNV,
                5414u32 => Self::RawAccessChainsNV,
                5568u32 => Self::SubgroupShuffleINTEL,
                5569u32 => Self::SubgroupBufferBlockIOINTEL,
                5570u32 => Self::SubgroupImageBlockIOINTEL,
                5579u32 => Self::SubgroupImageMediaBlockIOINTEL,
                5582u32 => Self::RoundToInfinityINTEL,
                5583u32 => Self::FloatingPointModeINTEL,
                5584u32 => Self::IntegerFunctions2INTEL,
                5603u32 => Self::FunctionPointersINTEL,
                5604u32 => Self::IndirectReferencesINTEL,
                5606u32 => Self::AsmINTEL,
                5612u32 => Self::AtomicFloat32MinMaxEXT,
                5613u32 => Self::AtomicFloat64MinMaxEXT,
                5616u32 => Self::AtomicFloat16MinMaxEXT,
                5617u32 => Self::VectorComputeINTEL,
                5619u32 => Self::VectorAnyINTEL,
                5629u32 => Self::ExpectAssumeKHR,
                5696u32 => Self::SubgroupAvcMotionEstimationINTEL,
                5697u32 => Self::SubgroupAvcMotionEstimationIntraINTEL,
                5698u32 => Self::SubgroupAvcMotionEstimationChromaINTEL,
                5817u32 => Self::VariableLengthArrayINTEL,
                5821u32 => Self::FunctionFloatControlINTEL,
                5824u32 => Self::FPGAMemoryAttributesINTEL,
                5837u32 => Self::FPFastMathModeINTEL,
                5844u32 => Self::ArbitraryPrecisionIntegersINTEL,
                5845u32 => Self::ArbitraryPrecisionFloatingPointINTEL,
                5886u32 => Self::UnstructuredLoopControlsINTEL,
                5888u32 => Self::FPGALoopControlsINTEL,
                5892u32 => Self::KernelAttributesINTEL,
                5897u32 => Self::FPGAKernelAttributesINTEL,
                5898u32 => Self::FPGAMemoryAccessesINTEL,
                5904u32 => Self::FPGAClusterAttributesINTEL,
                5906u32 => Self::LoopFuseINTEL,
                5908u32 => Self::FPGADSPControlINTEL,
                5910u32 => Self::MemoryAccessAliasingINTEL,
                5916u32 => Self::FPGAInvocationPipeliningAttributesINTEL,
                5920u32 => Self::FPGABufferLocationINTEL,
                5922u32 => Self::ArbitraryPrecisionFixedPointINTEL,
                5935u32 => Self::USMStorageClassesINTEL,
                5939u32 => Self::RuntimeAlignedAttributeINTEL,
                5943u32 => Self::IOPipesINTEL,
                5945u32 => Self::BlockingPipesINTEL,
                5948u32 => Self::FPGARegINTEL,
                6016u32 => Self::DotProductInputAll,
                6017u32 => Self::DotProductInput4x8Bit,
                6018u32 => Self::DotProductInput4x8BitPacked,
                6019u32 => Self::DotProduct,
                6020u32 => Self::RayCullMaskKHR,
                6022u32 => Self::CooperativeMatrixKHR,
                6025u32 => Self::BitInstructions,
                6026u32 => Self::GroupNonUniformRotateKHR,
                6029u32 => Self::FloatControls2,
                6033u32 => Self::AtomicFloat32AddEXT,
                6034u32 => Self::AtomicFloat64AddEXT,
                6089u32 => Self::LongCompositesINTEL,
                6094u32 => Self::OptNoneINTEL,
                6095u32 => Self::AtomicFloat16AddEXT,
                6114u32 => Self::DebugInfoModuleINTEL,
                6115u32 => Self::BFloat16ConversionINTEL,
                6141u32 => Self::SplitBarrierINTEL,
                6150u32 => Self::FPGAClusterAttributesV2INTEL,
                6161u32 => Self::FPGAKernelAttributesv2INTEL,
                6169u32 => Self::FPMaxErrorINTEL,
                6171u32 => Self::FPGALatencyControlINTEL,
                6174u32 => Self::FPGAArgumentInterfacesINTEL,
                6187u32 => Self::GlobalVariableHostAccessINTEL,
                6189u32 => Self::GlobalVariableFPGADecorationsINTEL,
                6400u32 => Self::GroupUniformArithmeticKHR,
                6427u32 => Self::MaskedGatherScatterINTEL,
                6441u32 => Self::CacheControlsINTEL,
                6460u32 => Self::RegisterLimitsINTEL,
                value => {
                    return Err(
                        reader
                            .map_err(ParseErrors::UnknownEnumerant("Capability", value)),
                    );
                }
            },
        )
    }
}
impl TryFrom<u32> for Capability {
    type Error = ();
    fn try_from(val: u32) -> Result<Self, Self::Error> {
        match val {
            0u32 => Ok(Self::Matrix),
            1u32 => Ok(Self::Shader),
            2u32 => Ok(Self::Geometry),
            3u32 => Ok(Self::Tessellation),
            4u32 => Ok(Self::Addresses),
            5u32 => Ok(Self::Linkage),
            6u32 => Ok(Self::Kernel),
            7u32 => Ok(Self::Vector16),
            8u32 => Ok(Self::Float16Buffer),
            9u32 => Ok(Self::Float16),
            10u32 => Ok(Self::Float64),
            11u32 => Ok(Self::Int64),
            12u32 => Ok(Self::Int64Atomics),
            13u32 => Ok(Self::ImageBasic),
            14u32 => Ok(Self::ImageReadWrite),
            15u32 => Ok(Self::ImageMipmap),
            17u32 => Ok(Self::Pipes),
            18u32 => Ok(Self::Groups),
            19u32 => Ok(Self::DeviceEnqueue),
            20u32 => Ok(Self::LiteralSampler),
            21u32 => Ok(Self::AtomicStorage),
            22u32 => Ok(Self::Int16),
            23u32 => Ok(Self::TessellationPointSize),
            24u32 => Ok(Self::GeometryPointSize),
            25u32 => Ok(Self::ImageGatherExtended),
            27u32 => Ok(Self::StorageImageMultisample),
            28u32 => Ok(Self::UniformBufferArrayDynamicIndexing),
            29u32 => Ok(Self::SampledImageArrayDynamicIndexing),
            30u32 => Ok(Self::StorageBufferArrayDynamicIndexing),
            31u32 => Ok(Self::StorageImageArrayDynamicIndexing),
            32u32 => Ok(Self::ClipDistance),
            33u32 => Ok(Self::CullDistance),
            34u32 => Ok(Self::ImageCubeArray),
            35u32 => Ok(Self::SampleRateShading),
            36u32 => Ok(Self::ImageRect),
            37u32 => Ok(Self::SampledRect),
            38u32 => Ok(Self::GenericPointer),
            39u32 => Ok(Self::Int8),
            40u32 => Ok(Self::InputAttachment),
            41u32 => Ok(Self::SparseResidency),
            42u32 => Ok(Self::MinLod),
            43u32 => Ok(Self::Sampled1D),
            44u32 => Ok(Self::Image1D),
            45u32 => Ok(Self::SampledCubeArray),
            46u32 => Ok(Self::SampledBuffer),
            47u32 => Ok(Self::ImageBuffer),
            48u32 => Ok(Self::ImageMSArray),
            49u32 => Ok(Self::StorageImageExtendedFormats),
            50u32 => Ok(Self::ImageQuery),
            51u32 => Ok(Self::DerivativeControl),
            52u32 => Ok(Self::InterpolationFunction),
            53u32 => Ok(Self::TransformFeedback),
            54u32 => Ok(Self::GeometryStreams),
            55u32 => Ok(Self::StorageImageReadWithoutFormat),
            56u32 => Ok(Self::StorageImageWriteWithoutFormat),
            57u32 => Ok(Self::MultiViewport),
            58u32 => Ok(Self::SubgroupDispatch),
            59u32 => Ok(Self::NamedBarrier),
            60u32 => Ok(Self::PipeStorage),
            61u32 => Ok(Self::GroupNonUniform),
            62u32 => Ok(Self::GroupNonUniformVote),
            63u32 => Ok(Self::GroupNonUniformArithmetic),
            64u32 => Ok(Self::GroupNonUniformBallot),
            65u32 => Ok(Self::GroupNonUniformShuffle),
            66u32 => Ok(Self::GroupNonUniformShuffleRelative),
            67u32 => Ok(Self::GroupNonUniformClustered),
            68u32 => Ok(Self::GroupNonUniformQuad),
            69u32 => Ok(Self::ShaderLayer),
            70u32 => Ok(Self::ShaderViewportIndex),
            71u32 => Ok(Self::UniformDecoration),
            4165u32 => Ok(Self::CoreBuiltinsARM),
            4166u32 => Ok(Self::TileImageColorReadAccessEXT),
            4167u32 => Ok(Self::TileImageDepthReadAccessEXT),
            4168u32 => Ok(Self::TileImageStencilReadAccessEXT),
            4422u32 => Ok(Self::FragmentShadingRateKHR),
            4423u32 => Ok(Self::SubgroupBallotKHR),
            4427u32 => Ok(Self::DrawParameters),
            4428u32 => Ok(Self::WorkgroupMemoryExplicitLayoutKHR),
            4429u32 => Ok(Self::WorkgroupMemoryExplicitLayout8BitAccessKHR),
            4430u32 => Ok(Self::WorkgroupMemoryExplicitLayout16BitAccessKHR),
            4431u32 => Ok(Self::SubgroupVoteKHR),
            4433u32 => Ok(Self::StorageBuffer16BitAccess),
            4434u32 => Ok(Self::UniformAndStorageBuffer16BitAccess),
            4435u32 => Ok(Self::StoragePushConstant16),
            4436u32 => Ok(Self::StorageInputOutput16),
            4437u32 => Ok(Self::DeviceGroup),
            4439u32 => Ok(Self::MultiView),
            4441u32 => Ok(Self::VariablePointersStorageBuffer),
            4442u32 => Ok(Self::VariablePointers),
            4445u32 => Ok(Self::AtomicStorageOps),
            4447u32 => Ok(Self::SampleMaskPostDepthCoverage),
            4448u32 => Ok(Self::StorageBuffer8BitAccess),
            4449u32 => Ok(Self::UniformAndStorageBuffer8BitAccess),
            4450u32 => Ok(Self::StoragePushConstant8),
            4464u32 => Ok(Self::DenormPreserve),
            4465u32 => Ok(Self::DenormFlushToZero),
            4466u32 => Ok(Self::SignedZeroInfNanPreserve),
            4467u32 => Ok(Self::RoundingModeRTE),
            4468u32 => Ok(Self::RoundingModeRTZ),
            4471u32 => Ok(Self::RayQueryProvisionalKHR),
            4472u32 => Ok(Self::RayQueryKHR),
            4478u32 => Ok(Self::RayTraversalPrimitiveCullingKHR),
            4479u32 => Ok(Self::RayTracingKHR),
            4484u32 => Ok(Self::TextureSampleWeightedQCOM),
            4485u32 => Ok(Self::TextureBoxFilterQCOM),
            4486u32 => Ok(Self::TextureBlockMatchQCOM),
            4498u32 => Ok(Self::TextureBlockMatch2QCOM),
            5008u32 => Ok(Self::Float16ImageAMD),
            5009u32 => Ok(Self::ImageGatherBiasLodAMD),
            5010u32 => Ok(Self::FragmentMaskAMD),
            5013u32 => Ok(Self::StencilExportEXT),
            5015u32 => Ok(Self::ImageReadWriteLodAMD),
            5016u32 => Ok(Self::Int64ImageEXT),
            5055u32 => Ok(Self::ShaderClockKHR),
            5067u32 => Ok(Self::ShaderEnqueueAMDX),
            5087u32 => Ok(Self::QuadControlKHR),
            5249u32 => Ok(Self::SampleMaskOverrideCoverageNV),
            5251u32 => Ok(Self::GeometryShaderPassthroughNV),
            5254u32 => Ok(Self::ShaderViewportIndexLayerEXT),
            5255u32 => Ok(Self::ShaderViewportMaskNV),
            5259u32 => Ok(Self::ShaderStereoViewNV),
            5260u32 => Ok(Self::PerViewAttributesNV),
            5265u32 => Ok(Self::FragmentFullyCoveredEXT),
            5266u32 => Ok(Self::MeshShadingNV),
            5282u32 => Ok(Self::ImageFootprintNV),
            5283u32 => Ok(Self::MeshShadingEXT),
            5284u32 => Ok(Self::FragmentBarycentricKHR),
            5288u32 => Ok(Self::ComputeDerivativeGroupQuadsNV),
            5291u32 => Ok(Self::FragmentDensityEXT),
            5297u32 => Ok(Self::GroupNonUniformPartitionedNV),
            5301u32 => Ok(Self::ShaderNonUniform),
            5302u32 => Ok(Self::RuntimeDescriptorArray),
            5303u32 => Ok(Self::InputAttachmentArrayDynamicIndexing),
            5304u32 => Ok(Self::UniformTexelBufferArrayDynamicIndexing),
            5305u32 => Ok(Self::StorageTexelBufferArrayDynamicIndexing),
            5306u32 => Ok(Self::UniformBufferArrayNonUniformIndexing),
            5307u32 => Ok(Self::SampledImageArrayNonUniformIndexing),
            5308u32 => Ok(Self::StorageBufferArrayNonUniformIndexing),
            5309u32 => Ok(Self::StorageImageArrayNonUniformIndexing),
            5310u32 => Ok(Self::InputAttachmentArrayNonUniformIndexing),
            5311u32 => Ok(Self::UniformTexelBufferArrayNonUniformIndexing),
            5312u32 => Ok(Self::StorageTexelBufferArrayNonUniformIndexing),
            5336u32 => Ok(Self::RayTracingPositionFetchKHR),
            5340u32 => Ok(Self::RayTracingNV),
            5341u32 => Ok(Self::RayTracingMotionBlurNV),
            5345u32 => Ok(Self::VulkanMemoryModel),
            5346u32 => Ok(Self::VulkanMemoryModelDeviceScope),
            5347u32 => Ok(Self::PhysicalStorageBufferAddresses),
            5350u32 => Ok(Self::ComputeDerivativeGroupLinearNV),
            5353u32 => Ok(Self::RayTracingProvisionalKHR),
            5357u32 => Ok(Self::CooperativeMatrixNV),
            5363u32 => Ok(Self::FragmentShaderSampleInterlockEXT),
            5372u32 => Ok(Self::FragmentShaderShadingRateInterlockEXT),
            5373u32 => Ok(Self::ShaderSMBuiltinsNV),
            5378u32 => Ok(Self::FragmentShaderPixelInterlockEXT),
            5379u32 => Ok(Self::DemoteToHelperInvocation),
            5380u32 => Ok(Self::DisplacementMicromapNV),
            5381u32 => Ok(Self::RayTracingOpacityMicromapEXT),
            5383u32 => Ok(Self::ShaderInvocationReorderNV),
            5390u32 => Ok(Self::BindlessTextureNV),
            5391u32 => Ok(Self::RayQueryPositionFetchKHR),
            5404u32 => Ok(Self::AtomicFloat16VectorNV),
            5409u32 => Ok(Self::RayTracingDisplacementMicromapNV),
            5414u32 => Ok(Self::RawAccessChainsNV),
            5568u32 => Ok(Self::SubgroupShuffleINTEL),
            5569u32 => Ok(Self::SubgroupBufferBlockIOINTEL),
            5570u32 => Ok(Self::SubgroupImageBlockIOINTEL),
            5579u32 => Ok(Self::SubgroupImageMediaBlockIOINTEL),
            5582u32 => Ok(Self::RoundToInfinityINTEL),
            5583u32 => Ok(Self::FloatingPointModeINTEL),
            5584u32 => Ok(Self::IntegerFunctions2INTEL),
            5603u32 => Ok(Self::FunctionPointersINTEL),
            5604u32 => Ok(Self::IndirectReferencesINTEL),
            5606u32 => Ok(Self::AsmINTEL),
            5612u32 => Ok(Self::AtomicFloat32MinMaxEXT),
            5613u32 => Ok(Self::AtomicFloat64MinMaxEXT),
            5616u32 => Ok(Self::AtomicFloat16MinMaxEXT),
            5617u32 => Ok(Self::VectorComputeINTEL),
            5619u32 => Ok(Self::VectorAnyINTEL),
            5629u32 => Ok(Self::ExpectAssumeKHR),
            5696u32 => Ok(Self::SubgroupAvcMotionEstimationINTEL),
            5697u32 => Ok(Self::SubgroupAvcMotionEstimationIntraINTEL),
            5698u32 => Ok(Self::SubgroupAvcMotionEstimationChromaINTEL),
            5817u32 => Ok(Self::VariableLengthArrayINTEL),
            5821u32 => Ok(Self::FunctionFloatControlINTEL),
            5824u32 => Ok(Self::FPGAMemoryAttributesINTEL),
            5837u32 => Ok(Self::FPFastMathModeINTEL),
            5844u32 => Ok(Self::ArbitraryPrecisionIntegersINTEL),
            5845u32 => Ok(Self::ArbitraryPrecisionFloatingPointINTEL),
            5886u32 => Ok(Self::UnstructuredLoopControlsINTEL),
            5888u32 => Ok(Self::FPGALoopControlsINTEL),
            5892u32 => Ok(Self::KernelAttributesINTEL),
            5897u32 => Ok(Self::FPGAKernelAttributesINTEL),
            5898u32 => Ok(Self::FPGAMemoryAccessesINTEL),
            5904u32 => Ok(Self::FPGAClusterAttributesINTEL),
            5906u32 => Ok(Self::LoopFuseINTEL),
            5908u32 => Ok(Self::FPGADSPControlINTEL),
            5910u32 => Ok(Self::MemoryAccessAliasingINTEL),
            5916u32 => Ok(Self::FPGAInvocationPipeliningAttributesINTEL),
            5920u32 => Ok(Self::FPGABufferLocationINTEL),
            5922u32 => Ok(Self::ArbitraryPrecisionFixedPointINTEL),
            5935u32 => Ok(Self::USMStorageClassesINTEL),
            5939u32 => Ok(Self::RuntimeAlignedAttributeINTEL),
            5943u32 => Ok(Self::IOPipesINTEL),
            5945u32 => Ok(Self::BlockingPipesINTEL),
            5948u32 => Ok(Self::FPGARegINTEL),
            6016u32 => Ok(Self::DotProductInputAll),
            6017u32 => Ok(Self::DotProductInput4x8Bit),
            6018u32 => Ok(Self::DotProductInput4x8BitPacked),
            6019u32 => Ok(Self::DotProduct),
            6020u32 => Ok(Self::RayCullMaskKHR),
            6022u32 => Ok(Self::CooperativeMatrixKHR),
            6025u32 => Ok(Self::BitInstructions),
            6026u32 => Ok(Self::GroupNonUniformRotateKHR),
            6029u32 => Ok(Self::FloatControls2),
            6033u32 => Ok(Self::AtomicFloat32AddEXT),
            6034u32 => Ok(Self::AtomicFloat64AddEXT),
            6089u32 => Ok(Self::LongCompositesINTEL),
            6094u32 => Ok(Self::OptNoneINTEL),
            6095u32 => Ok(Self::AtomicFloat16AddEXT),
            6114u32 => Ok(Self::DebugInfoModuleINTEL),
            6115u32 => Ok(Self::BFloat16ConversionINTEL),
            6141u32 => Ok(Self::SplitBarrierINTEL),
            6150u32 => Ok(Self::FPGAClusterAttributesV2INTEL),
            6161u32 => Ok(Self::FPGAKernelAttributesv2INTEL),
            6169u32 => Ok(Self::FPMaxErrorINTEL),
            6171u32 => Ok(Self::FPGALatencyControlINTEL),
            6174u32 => Ok(Self::FPGAArgumentInterfacesINTEL),
            6187u32 => Ok(Self::GlobalVariableHostAccessINTEL),
            6189u32 => Ok(Self::GlobalVariableFPGADecorationsINTEL),
            6400u32 => Ok(Self::GroupUniformArithmeticKHR),
            6427u32 => Ok(Self::MaskedGatherScatterINTEL),
            6441u32 => Ok(Self::CacheControlsINTEL),
            6460u32 => Ok(Self::RegisterLimitsINTEL),
            _ => Err(()),
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum RayQueryIntersection {
    RayQueryCandidateIntersectionKHR = 0u32,
    RayQueryCommittedIntersectionKHR = 1u32,
}
impl RayQueryIntersection {
    #[allow(dead_code)]
    fn parse(
        reader: &mut InstructionReader<'_>,
    ) -> Result<RayQueryIntersection, ParseError> {
        Ok(
            match reader.next_word()? {
                0u32 => Self::RayQueryCandidateIntersectionKHR,
                1u32 => Self::RayQueryCommittedIntersectionKHR,
                value => {
                    return Err(
                        reader
                            .map_err(
                                ParseErrors::UnknownEnumerant("RayQueryIntersection", value),
                            ),
                    );
                }
            },
        )
    }
}
impl TryFrom<u32> for RayQueryIntersection {
    type Error = ();
    fn try_from(val: u32) -> Result<Self, Self::Error> {
        match val {
            0u32 => Ok(Self::RayQueryCandidateIntersectionKHR),
            1u32 => Ok(Self::RayQueryCommittedIntersectionKHR),
            _ => Err(()),
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum RayQueryCommittedIntersectionType {
    RayQueryCommittedIntersectionNoneKHR = 0u32,
    RayQueryCommittedIntersectionTriangleKHR = 1u32,
    RayQueryCommittedIntersectionGeneratedKHR = 2u32,
}
impl RayQueryCommittedIntersectionType {
    #[allow(dead_code)]
    fn parse(
        reader: &mut InstructionReader<'_>,
    ) -> Result<RayQueryCommittedIntersectionType, ParseError> {
        Ok(
            match reader.next_word()? {
                0u32 => Self::RayQueryCommittedIntersectionNoneKHR,
                1u32 => Self::RayQueryCommittedIntersectionTriangleKHR,
                2u32 => Self::RayQueryCommittedIntersectionGeneratedKHR,
                value => {
                    return Err(
                        reader
                            .map_err(
                                ParseErrors::UnknownEnumerant(
                                    "RayQueryCommittedIntersectionType",
                                    value,
                                ),
                            ),
                    );
                }
            },
        )
    }
}
impl TryFrom<u32> for RayQueryCommittedIntersectionType {
    type Error = ();
    fn try_from(val: u32) -> Result<Self, Self::Error> {
        match val {
            0u32 => Ok(Self::RayQueryCommittedIntersectionNoneKHR),
            1u32 => Ok(Self::RayQueryCommittedIntersectionTriangleKHR),
            2u32 => Ok(Self::RayQueryCommittedIntersectionGeneratedKHR),
            _ => Err(()),
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum RayQueryCandidateIntersectionType {
    RayQueryCandidateIntersectionTriangleKHR = 0u32,
    RayQueryCandidateIntersectionAABBKHR = 1u32,
}
impl RayQueryCandidateIntersectionType {
    #[allow(dead_code)]
    fn parse(
        reader: &mut InstructionReader<'_>,
    ) -> Result<RayQueryCandidateIntersectionType, ParseError> {
        Ok(
            match reader.next_word()? {
                0u32 => Self::RayQueryCandidateIntersectionTriangleKHR,
                1u32 => Self::RayQueryCandidateIntersectionAABBKHR,
                value => {
                    return Err(
                        reader
                            .map_err(
                                ParseErrors::UnknownEnumerant(
                                    "RayQueryCandidateIntersectionType",
                                    value,
                                ),
                            ),
                    );
                }
            },
        )
    }
}
impl TryFrom<u32> for RayQueryCandidateIntersectionType {
    type Error = ();
    fn try_from(val: u32) -> Result<Self, Self::Error> {
        match val {
            0u32 => Ok(Self::RayQueryCandidateIntersectionTriangleKHR),
            1u32 => Ok(Self::RayQueryCandidateIntersectionAABBKHR),
            _ => Err(()),
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum PackedVectorFormat {
    PackedVectorFormat4x8Bit = 0u32,
}
impl PackedVectorFormat {
    #[allow(dead_code)]
    fn parse(
        reader: &mut InstructionReader<'_>,
    ) -> Result<PackedVectorFormat, ParseError> {
        Ok(
            match reader.next_word()? {
                0u32 => Self::PackedVectorFormat4x8Bit,
                value => {
                    return Err(
                        reader
                            .map_err(
                                ParseErrors::UnknownEnumerant("PackedVectorFormat", value),
                            ),
                    );
                }
            },
        )
    }
}
impl TryFrom<u32> for PackedVectorFormat {
    type Error = ();
    fn try_from(val: u32) -> Result<Self, Self::Error> {
        match val {
            0u32 => Ok(Self::PackedVectorFormat4x8Bit),
            _ => Err(()),
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum CooperativeMatrixLayout {
    RowMajorKHR = 0u32,
    ColumnMajorKHR = 1u32,
}
impl CooperativeMatrixLayout {
    #[allow(dead_code)]
    fn parse(
        reader: &mut InstructionReader<'_>,
    ) -> Result<CooperativeMatrixLayout, ParseError> {
        Ok(
            match reader.next_word()? {
                0u32 => Self::RowMajorKHR,
                1u32 => Self::ColumnMajorKHR,
                value => {
                    return Err(
                        reader
                            .map_err(
                                ParseErrors::UnknownEnumerant(
                                    "CooperativeMatrixLayout",
                                    value,
                                ),
                            ),
                    );
                }
            },
        )
    }
}
impl TryFrom<u32> for CooperativeMatrixLayout {
    type Error = ();
    fn try_from(val: u32) -> Result<Self, Self::Error> {
        match val {
            0u32 => Ok(Self::RowMajorKHR),
            1u32 => Ok(Self::ColumnMajorKHR),
            _ => Err(()),
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum CooperativeMatrixUse {
    MatrixAKHR = 0u32,
    MatrixBKHR = 1u32,
    MatrixAccumulatorKHR = 2u32,
}
impl CooperativeMatrixUse {
    #[allow(dead_code)]
    fn parse(
        reader: &mut InstructionReader<'_>,
    ) -> Result<CooperativeMatrixUse, ParseError> {
        Ok(
            match reader.next_word()? {
                0u32 => Self::MatrixAKHR,
                1u32 => Self::MatrixBKHR,
                2u32 => Self::MatrixAccumulatorKHR,
                value => {
                    return Err(
                        reader
                            .map_err(
                                ParseErrors::UnknownEnumerant("CooperativeMatrixUse", value),
                            ),
                    );
                }
            },
        )
    }
}
impl TryFrom<u32> for CooperativeMatrixUse {
    type Error = ();
    fn try_from(val: u32) -> Result<Self, Self::Error> {
        match val {
            0u32 => Ok(Self::MatrixAKHR),
            1u32 => Ok(Self::MatrixBKHR),
            2u32 => Ok(Self::MatrixAccumulatorKHR),
            _ => Err(()),
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum InitializationModeQualifier {
    InitOnDeviceReprogramINTEL = 0u32,
    InitOnDeviceResetINTEL = 1u32,
}
impl InitializationModeQualifier {
    #[allow(dead_code)]
    fn parse(
        reader: &mut InstructionReader<'_>,
    ) -> Result<InitializationModeQualifier, ParseError> {
        Ok(
            match reader.next_word()? {
                0u32 => Self::InitOnDeviceReprogramINTEL,
                1u32 => Self::InitOnDeviceResetINTEL,
                value => {
                    return Err(
                        reader
                            .map_err(
                                ParseErrors::UnknownEnumerant(
                                    "InitializationModeQualifier",
                                    value,
                                ),
                            ),
                    );
                }
            },
        )
    }
}
impl TryFrom<u32> for InitializationModeQualifier {
    type Error = ();
    fn try_from(val: u32) -> Result<Self, Self::Error> {
        match val {
            0u32 => Ok(Self::InitOnDeviceReprogramINTEL),
            1u32 => Ok(Self::InitOnDeviceResetINTEL),
            _ => Err(()),
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum LoadCacheControl {
    UncachedINTEL = 0u32,
    CachedINTEL = 1u32,
    StreamingINTEL = 2u32,
    InvalidateAfterReadINTEL = 3u32,
    ConstCachedINTEL = 4u32,
}
impl LoadCacheControl {
    #[allow(dead_code)]
    fn parse(
        reader: &mut InstructionReader<'_>,
    ) -> Result<LoadCacheControl, ParseError> {
        Ok(
            match reader.next_word()? {
                0u32 => Self::UncachedINTEL,
                1u32 => Self::CachedINTEL,
                2u32 => Self::StreamingINTEL,
                3u32 => Self::InvalidateAfterReadINTEL,
                4u32 => Self::ConstCachedINTEL,
                value => {
                    return Err(
                        reader
                            .map_err(
                                ParseErrors::UnknownEnumerant("LoadCacheControl", value),
                            ),
                    );
                }
            },
        )
    }
}
impl TryFrom<u32> for LoadCacheControl {
    type Error = ();
    fn try_from(val: u32) -> Result<Self, Self::Error> {
        match val {
            0u32 => Ok(Self::UncachedINTEL),
            1u32 => Ok(Self::CachedINTEL),
            2u32 => Ok(Self::StreamingINTEL),
            3u32 => Ok(Self::InvalidateAfterReadINTEL),
            4u32 => Ok(Self::ConstCachedINTEL),
            _ => Err(()),
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum StoreCacheControl {
    UncachedINTEL = 0u32,
    WriteThroughINTEL = 1u32,
    WriteBackINTEL = 2u32,
    StreamingINTEL = 3u32,
}
impl StoreCacheControl {
    #[allow(dead_code)]
    fn parse(
        reader: &mut InstructionReader<'_>,
    ) -> Result<StoreCacheControl, ParseError> {
        Ok(
            match reader.next_word()? {
                0u32 => Self::UncachedINTEL,
                1u32 => Self::WriteThroughINTEL,
                2u32 => Self::WriteBackINTEL,
                3u32 => Self::StreamingINTEL,
                value => {
                    return Err(
                        reader
                            .map_err(
                                ParseErrors::UnknownEnumerant("StoreCacheControl", value),
                            ),
                    );
                }
            },
        )
    }
}
impl TryFrom<u32> for StoreCacheControl {
    type Error = ();
    fn try_from(val: u32) -> Result<Self, Self::Error> {
        match val {
            0u32 => Ok(Self::UncachedINTEL),
            1u32 => Ok(Self::WriteThroughINTEL),
            2u32 => Ok(Self::WriteBackINTEL),
            3u32 => Ok(Self::StreamingINTEL),
            _ => Err(()),
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum NamedMaximumNumberOfRegisters {
    AutoINTEL = 0u32,
}
impl NamedMaximumNumberOfRegisters {
    #[allow(dead_code)]
    fn parse(
        reader: &mut InstructionReader<'_>,
    ) -> Result<NamedMaximumNumberOfRegisters, ParseError> {
        Ok(
            match reader.next_word()? {
                0u32 => Self::AutoINTEL,
                value => {
                    return Err(
                        reader
                            .map_err(
                                ParseErrors::UnknownEnumerant(
                                    "NamedMaximumNumberOfRegisters",
                                    value,
                                ),
                            ),
                    );
                }
            },
        )
    }
}
impl TryFrom<u32> for NamedMaximumNumberOfRegisters {
    type Error = ();
    fn try_from(val: u32) -> Result<Self, Self::Error> {
        match val {
            0u32 => Ok(Self::AutoINTEL),
            _ => Err(()),
        }
    }
}
