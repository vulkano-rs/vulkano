// This file is auto-generated by vulkano autogen from vk.xml header version 1.3.281.
// It should not be edited manually. Changes should be made by editing autogen.


/// List of extensions that are enabled or available.
#[derive(Copy, Clone, PartialEq, Eq)]
pub struct DeviceExtensions {
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_16bit_storage.html)
- Promoted to Vulkan 1.1
- Requires all of:
  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](crate::instance::InstanceExtensions::khr_get_physical_device_properties2)
  - Vulkan API version 1.1 or device extension [`khr_storage_buffer_storage_class`](crate::device::DeviceExtensions::khr_storage_buffer_storage_class)*/
    pub khr_16bit_storage: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_8bit_storage.html)
- Promoted to Vulkan 1.2
- Requires all of:
  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](crate::instance::InstanceExtensions::khr_get_physical_device_properties2)
  - Vulkan API version 1.1 or device extension [`khr_storage_buffer_storage_class`](crate::device::DeviceExtensions::khr_storage_buffer_storage_class)*/
    pub khr_8bit_storage: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_acceleration_structure.html)
- Requires all of:
  - Vulkan API version 1.1
  - Vulkan API version 1.2 or device extension [`ext_descriptor_indexing`](crate::device::DeviceExtensions::ext_descriptor_indexing)
  - Vulkan API version 1.2 or device extension [`khr_buffer_device_address`](crate::device::DeviceExtensions::khr_buffer_device_address)
  - device extension [`khr_deferred_host_operations`](crate::device::DeviceExtensions::khr_deferred_host_operations)*/
    pub khr_acceleration_structure: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_bind_memory2.html)
- Promoted to Vulkan 1.1*/
    pub khr_bind_memory2: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_buffer_device_address.html)
- Promoted to Vulkan 1.2
- Requires all of:
  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](crate::instance::InstanceExtensions::khr_get_physical_device_properties2)
  - Vulkan API version 1.1 or device extension [`khr_device_group`](crate::device::DeviceExtensions::khr_device_group)
- Conflicts with device extension: [`ext_buffer_device_address`](crate::device::DeviceExtensions::ext_buffer_device_address)*/
    pub khr_buffer_device_address: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_calibrated_timestamps.html)
- Requires all of:
  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](crate::instance::InstanceExtensions::khr_get_physical_device_properties2)*/
    pub khr_calibrated_timestamps: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_cooperative_matrix.html)
- Requires all of:
  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](crate::instance::InstanceExtensions::khr_get_physical_device_properties2)*/
    pub khr_cooperative_matrix: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_copy_commands2.html)
- Promoted to Vulkan 1.3
- Requires all of:
  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](crate::instance::InstanceExtensions::khr_get_physical_device_properties2)*/
    pub khr_copy_commands2: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_create_renderpass2.html)
- Promoted to Vulkan 1.2
- Requires all of:
  - Vulkan API version 1.1 or device extension [`khr_multiview`](crate::device::DeviceExtensions::khr_multiview)
  - Vulkan API version 1.1 or device extension [`khr_maintenance2`](crate::device::DeviceExtensions::khr_maintenance2)*/
    pub khr_create_renderpass2: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_dedicated_allocation.html)
- Promoted to Vulkan 1.1
- Requires all of:
  - Vulkan API version 1.1 or device extension [`khr_get_memory_requirements2`](crate::device::DeviceExtensions::khr_get_memory_requirements2)*/
    pub khr_dedicated_allocation: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_deferred_host_operations.html)
    pub khr_deferred_host_operations: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_depth_stencil_resolve.html)
- Promoted to Vulkan 1.2
- Requires all of:
  - Vulkan API version 1.2 or device extension [`khr_create_renderpass2`](crate::device::DeviceExtensions::khr_create_renderpass2)*/
    pub khr_depth_stencil_resolve: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_descriptor_update_template.html)
- Promoted to Vulkan 1.1*/
    pub khr_descriptor_update_template: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_device_group.html)
- Promoted to Vulkan 1.1
- Requires all of:
  - Vulkan API version 1.1 or instance extension [`khr_device_group_creation`](crate::instance::InstanceExtensions::khr_device_group_creation)*/
    pub khr_device_group: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_display_swapchain.html)
- Requires all of:
  - device extension [`khr_swapchain`](crate::device::DeviceExtensions::khr_swapchain)
  - instance extension [`khr_display`](crate::instance::InstanceExtensions::khr_display)*/
    pub khr_display_swapchain: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_draw_indirect_count.html)
- Promoted to Vulkan 1.2*/
    pub khr_draw_indirect_count: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_driver_properties.html)
- Promoted to Vulkan 1.2
- Requires all of:
  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](crate::instance::InstanceExtensions::khr_get_physical_device_properties2)*/
    pub khr_driver_properties: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_dynamic_rendering.html)
- Promoted to Vulkan 1.3
- Requires all of:
  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](crate::instance::InstanceExtensions::khr_get_physical_device_properties2)
  - Vulkan API version 1.2 or device extension [`khr_depth_stencil_resolve`](crate::device::DeviceExtensions::khr_depth_stencil_resolve)*/
    pub khr_dynamic_rendering: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_dynamic_rendering_local_read.html)
- Requires all of:
  - Vulkan API version 1.3 or device extension [`khr_dynamic_rendering`](crate::device::DeviceExtensions::khr_dynamic_rendering)*/
    pub khr_dynamic_rendering_local_read: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_external_fence.html)
- Promoted to Vulkan 1.1
- Requires all of:
  - Vulkan API version 1.1 or instance extension [`khr_external_fence_capabilities`](crate::instance::InstanceExtensions::khr_external_fence_capabilities)*/
    pub khr_external_fence: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_external_fence_fd.html)
- Requires all of:
  - Vulkan API version 1.1 or device extension [`khr_external_fence`](crate::device::DeviceExtensions::khr_external_fence)*/
    pub khr_external_fence_fd: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_external_fence_win32.html)
- Requires all of:
  - Vulkan API version 1.1 or device extension [`khr_external_fence`](crate::device::DeviceExtensions::khr_external_fence)*/
    pub khr_external_fence_win32: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_external_memory.html)
- Promoted to Vulkan 1.1
- Requires all of:
  - Vulkan API version 1.1 or instance extension [`khr_external_memory_capabilities`](crate::instance::InstanceExtensions::khr_external_memory_capabilities)*/
    pub khr_external_memory: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_external_memory_fd.html)
- Requires all of:
  - Vulkan API version 1.1 or device extension [`khr_external_memory`](crate::device::DeviceExtensions::khr_external_memory)*/
    pub khr_external_memory_fd: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_external_memory_win32.html)
- Requires all of:
  - Vulkan API version 1.1 or device extension [`khr_external_memory`](crate::device::DeviceExtensions::khr_external_memory)*/
    pub khr_external_memory_win32: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_external_semaphore.html)
- Promoted to Vulkan 1.1
- Requires all of:
  - Vulkan API version 1.1 or instance extension [`khr_external_semaphore_capabilities`](crate::instance::InstanceExtensions::khr_external_semaphore_capabilities)*/
    pub khr_external_semaphore: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_external_semaphore_fd.html)
- Requires all of:
  - Vulkan API version 1.1 or device extension [`khr_external_semaphore`](crate::device::DeviceExtensions::khr_external_semaphore)*/
    pub khr_external_semaphore_fd: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_external_semaphore_win32.html)
- Requires all of:
  - Vulkan API version 1.1 or device extension [`khr_external_semaphore`](crate::device::DeviceExtensions::khr_external_semaphore)*/
    pub khr_external_semaphore_win32: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_format_feature_flags2.html)
- Promoted to Vulkan 1.3
- Requires all of:
  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](crate::instance::InstanceExtensions::khr_get_physical_device_properties2)*/
    pub khr_format_feature_flags2: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_fragment_shader_barycentric.html)
- Requires all of:
  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](crate::instance::InstanceExtensions::khr_get_physical_device_properties2)*/
    pub khr_fragment_shader_barycentric: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_fragment_shading_rate.html)
- Requires all of:
  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](crate::instance::InstanceExtensions::khr_get_physical_device_properties2)
  - Vulkan API version 1.2 or device extension [`khr_create_renderpass2`](crate::device::DeviceExtensions::khr_create_renderpass2)*/
    pub khr_fragment_shading_rate: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_get_memory_requirements2.html)
- Promoted to Vulkan 1.1*/
    pub khr_get_memory_requirements2: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_global_priority.html)
- Requires all of:
  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](crate::instance::InstanceExtensions::khr_get_physical_device_properties2)*/
    pub khr_global_priority: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_image_format_list.html)
- Promoted to Vulkan 1.2*/
    pub khr_image_format_list: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_imageless_framebuffer.html)
- Promoted to Vulkan 1.2
- Requires all of:
  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](crate::instance::InstanceExtensions::khr_get_physical_device_properties2)
  - Vulkan API version 1.1 or device extension [`khr_maintenance2`](crate::device::DeviceExtensions::khr_maintenance2)
  - Vulkan API version 1.2 or device extension [`khr_image_format_list`](crate::device::DeviceExtensions::khr_image_format_list)*/
    pub khr_imageless_framebuffer: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_incremental_present.html)
- Requires all of:
  - device extension [`khr_swapchain`](crate::device::DeviceExtensions::khr_swapchain)*/
    pub khr_incremental_present: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_index_type_uint8.html)
- Requires all of:
  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](crate::instance::InstanceExtensions::khr_get_physical_device_properties2)*/
    pub khr_index_type_uint8: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_line_rasterization.html)
- Requires all of:
  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](crate::instance::InstanceExtensions::khr_get_physical_device_properties2)*/
    pub khr_line_rasterization: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_load_store_op_none.html)
    pub khr_load_store_op_none: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_maintenance1.html)
- Promoted to Vulkan 1.1*/
    pub khr_maintenance1: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_maintenance2.html)
- Promoted to Vulkan 1.1*/
    pub khr_maintenance2: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_maintenance3.html)
- Promoted to Vulkan 1.1
- Requires all of:
  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](crate::instance::InstanceExtensions::khr_get_physical_device_properties2)*/
    pub khr_maintenance3: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_maintenance4.html)
- Promoted to Vulkan 1.3
- Requires all of:
  - Vulkan API version 1.1*/
    pub khr_maintenance4: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_maintenance5.html)
- Requires all of:
  - Vulkan API version 1.1
  - Vulkan API version 1.3 or device extension [`khr_dynamic_rendering`](crate::device::DeviceExtensions::khr_dynamic_rendering)*/
    pub khr_maintenance5: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_maintenance6.html)
- Requires all of:
  - Vulkan API version 1.1*/
    pub khr_maintenance6: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_map_memory2.html)
    pub khr_map_memory2: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_multiview.html)
- Promoted to Vulkan 1.1
- Requires all of:
  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](crate::instance::InstanceExtensions::khr_get_physical_device_properties2)*/
    pub khr_multiview: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_performance_query.html)
- Requires all of:
  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](crate::instance::InstanceExtensions::khr_get_physical_device_properties2)*/
    pub khr_performance_query: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_pipeline_executable_properties.html)
- Requires all of:
  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](crate::instance::InstanceExtensions::khr_get_physical_device_properties2)*/
    pub khr_pipeline_executable_properties: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_pipeline_library.html)
    pub khr_pipeline_library: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_portability_subset.html)
- Must be enabled if it is supported by the physical device
- Requires all of:
  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](crate::instance::InstanceExtensions::khr_get_physical_device_properties2)*/
    pub khr_portability_subset: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_present_id.html)
- Requires all of:
  - Vulkan API version 1.1 or device extension [`khr_swapchain`](crate::device::DeviceExtensions::khr_swapchain)
  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](crate::instance::InstanceExtensions::khr_get_physical_device_properties2)*/
    pub khr_present_id: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_present_wait.html)
- Requires all of:
  - device extension [`khr_swapchain`](crate::device::DeviceExtensions::khr_swapchain)
  - device extension [`khr_present_id`](crate::device::DeviceExtensions::khr_present_id)*/
    pub khr_present_wait: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_push_descriptor.html)
- Requires all of:
  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](crate::instance::InstanceExtensions::khr_get_physical_device_properties2)*/
    pub khr_push_descriptor: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_ray_query.html)
- Requires all of:
  - Vulkan API version 1.2 or device extension [`khr_spirv_1_4`](crate::device::DeviceExtensions::khr_spirv_1_4)
  - device extension [`khr_acceleration_structure`](crate::device::DeviceExtensions::khr_acceleration_structure)*/
    pub khr_ray_query: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_ray_tracing_maintenance1.html)
- Requires all of:
  - device extension [`khr_acceleration_structure`](crate::device::DeviceExtensions::khr_acceleration_structure)*/
    pub khr_ray_tracing_maintenance1: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_ray_tracing_pipeline.html)
- Requires all of:
  - Vulkan API version 1.2 or device extension [`khr_spirv_1_4`](crate::device::DeviceExtensions::khr_spirv_1_4)
  - device extension [`khr_acceleration_structure`](crate::device::DeviceExtensions::khr_acceleration_structure)*/
    pub khr_ray_tracing_pipeline: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_ray_tracing_position_fetch.html)
- Requires all of:
  - device extension [`khr_acceleration_structure`](crate::device::DeviceExtensions::khr_acceleration_structure)*/
    pub khr_ray_tracing_position_fetch: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_relaxed_block_layout.html)
- Promoted to Vulkan 1.1*/
    pub khr_relaxed_block_layout: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_sampler_mirror_clamp_to_edge.html)
- Promoted to Vulkan 1.2*/
    pub khr_sampler_mirror_clamp_to_edge: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_sampler_ycbcr_conversion.html)
- Promoted to Vulkan 1.1
- Requires all of:
  - Vulkan API version 1.1 or device extension [`khr_maintenance1`](crate::device::DeviceExtensions::khr_maintenance1)
  - Vulkan API version 1.1 or device extension [`khr_bind_memory2`](crate::device::DeviceExtensions::khr_bind_memory2)
  - Vulkan API version 1.1 or device extension [`khr_get_memory_requirements2`](crate::device::DeviceExtensions::khr_get_memory_requirements2)
  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](crate::instance::InstanceExtensions::khr_get_physical_device_properties2)*/
    pub khr_sampler_ycbcr_conversion: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_separate_depth_stencil_layouts.html)
- Promoted to Vulkan 1.2
- Requires all of:
  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](crate::instance::InstanceExtensions::khr_get_physical_device_properties2)
  - Vulkan API version 1.2 or device extension [`khr_create_renderpass2`](crate::device::DeviceExtensions::khr_create_renderpass2)*/
    pub khr_separate_depth_stencil_layouts: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_shader_atomic_int64.html)
- Promoted to Vulkan 1.2
- Requires all of:
  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](crate::instance::InstanceExtensions::khr_get_physical_device_properties2)*/
    pub khr_shader_atomic_int64: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_shader_clock.html)
- Requires all of:
  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](crate::instance::InstanceExtensions::khr_get_physical_device_properties2)*/
    pub khr_shader_clock: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_shader_draw_parameters.html)
- Promoted to Vulkan 1.1*/
    pub khr_shader_draw_parameters: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_shader_expect_assume.html)
- Requires all of:
  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](crate::instance::InstanceExtensions::khr_get_physical_device_properties2)*/
    pub khr_shader_expect_assume: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_shader_float16_int8.html)
- Promoted to Vulkan 1.2
- Requires all of:
  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](crate::instance::InstanceExtensions::khr_get_physical_device_properties2)*/
    pub khr_shader_float16_int8: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_shader_float_controls.html)
- Promoted to Vulkan 1.2
- Requires all of:
  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](crate::instance::InstanceExtensions::khr_get_physical_device_properties2)*/
    pub khr_shader_float_controls: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_shader_float_controls2.html)
- Requires all of:
  - Vulkan API version 1.1
  - Vulkan API version 1.2 or device extension [`khr_shader_float_controls`](crate::device::DeviceExtensions::khr_shader_float_controls)*/
    pub khr_shader_float_controls2: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_shader_integer_dot_product.html)
- Promoted to Vulkan 1.3
- Requires all of:
  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](crate::instance::InstanceExtensions::khr_get_physical_device_properties2)*/
    pub khr_shader_integer_dot_product: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_shader_maximal_reconvergence.html)
- Requires all of:
  - Vulkan API version 1.1*/
    pub khr_shader_maximal_reconvergence: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_shader_non_semantic_info.html)
- Promoted to Vulkan 1.3*/
    pub khr_shader_non_semantic_info: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_shader_quad_control.html)
- Requires all of:
  - Vulkan API version 1.1
  - Vulkan API version 1.2 or device extension [`khr_vulkan_memory_model`](crate::device::DeviceExtensions::khr_vulkan_memory_model)
  - device extension [`khr_shader_maximal_reconvergence`](crate::device::DeviceExtensions::khr_shader_maximal_reconvergence)*/
    pub khr_shader_quad_control: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_shader_subgroup_extended_types.html)
- Promoted to Vulkan 1.2
- Requires all of:
  - Vulkan API version 1.1*/
    pub khr_shader_subgroup_extended_types: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_shader_subgroup_rotate.html)
    pub khr_shader_subgroup_rotate: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_shader_subgroup_uniform_control_flow.html)
- Requires all of:
  - Vulkan API version 1.1*/
    pub khr_shader_subgroup_uniform_control_flow: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_shader_terminate_invocation.html)
- Promoted to Vulkan 1.3
- Requires all of:
  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](crate::instance::InstanceExtensions::khr_get_physical_device_properties2)*/
    pub khr_shader_terminate_invocation: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_shared_presentable_image.html)
- Requires all of:
  - device extension [`khr_swapchain`](crate::device::DeviceExtensions::khr_swapchain)
  - instance extension [`khr_get_surface_capabilities2`](crate::instance::InstanceExtensions::khr_get_surface_capabilities2)
  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](crate::instance::InstanceExtensions::khr_get_physical_device_properties2)*/
    pub khr_shared_presentable_image: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_spirv_1_4.html)
- Promoted to Vulkan 1.2
- Requires all of:
  - Vulkan API version 1.1
  - Vulkan API version 1.2 or device extension [`khr_shader_float_controls`](crate::device::DeviceExtensions::khr_shader_float_controls)*/
    pub khr_spirv_1_4: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_storage_buffer_storage_class.html)
- Promoted to Vulkan 1.1*/
    pub khr_storage_buffer_storage_class: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_swapchain.html)
- Requires all of:
  - instance extension [`khr_surface`](crate::instance::InstanceExtensions::khr_surface)*/
    pub khr_swapchain: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_swapchain_mutable_format.html)
- Requires all of:
  - device extension [`khr_swapchain`](crate::device::DeviceExtensions::khr_swapchain)
  - Vulkan API version 1.1 or device extension [`khr_maintenance2`](crate::device::DeviceExtensions::khr_maintenance2)
  - Vulkan API version 1.2 or device extension [`khr_image_format_list`](crate::device::DeviceExtensions::khr_image_format_list)*/
    pub khr_swapchain_mutable_format: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_synchronization2.html)
- Promoted to Vulkan 1.3
- Requires all of:
  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](crate::instance::InstanceExtensions::khr_get_physical_device_properties2)*/
    pub khr_synchronization2: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_timeline_semaphore.html)
- Promoted to Vulkan 1.2
- Requires all of:
  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](crate::instance::InstanceExtensions::khr_get_physical_device_properties2)*/
    pub khr_timeline_semaphore: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_uniform_buffer_standard_layout.html)
- Promoted to Vulkan 1.2
- Requires all of:
  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](crate::instance::InstanceExtensions::khr_get_physical_device_properties2)*/
    pub khr_uniform_buffer_standard_layout: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_variable_pointers.html)
- Promoted to Vulkan 1.1
- Requires all of:
  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](crate::instance::InstanceExtensions::khr_get_physical_device_properties2)
  - Vulkan API version 1.1 or device extension [`khr_storage_buffer_storage_class`](crate::device::DeviceExtensions::khr_storage_buffer_storage_class)*/
    pub khr_variable_pointers: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_vertex_attribute_divisor.html)
- Requires all of:
  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](crate::instance::InstanceExtensions::khr_get_physical_device_properties2)*/
    pub khr_vertex_attribute_divisor: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_video_decode_av1.html)
- Requires all of:
  - device extension [`khr_video_decode_queue`](crate::device::DeviceExtensions::khr_video_decode_queue)*/
    pub khr_video_decode_av1: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_video_decode_h264.html)
- Requires all of:
  - device extension [`khr_video_decode_queue`](crate::device::DeviceExtensions::khr_video_decode_queue)*/
    pub khr_video_decode_h264: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_video_decode_h265.html)
- Requires all of:
  - device extension [`khr_video_decode_queue`](crate::device::DeviceExtensions::khr_video_decode_queue)*/
    pub khr_video_decode_h265: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_video_decode_queue.html)
- Requires all of:
  - device extension [`khr_video_queue`](crate::device::DeviceExtensions::khr_video_queue)
  - Vulkan API version 1.3 or device extension [`khr_synchronization2`](crate::device::DeviceExtensions::khr_synchronization2)*/
    pub khr_video_decode_queue: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_video_encode_h264.html)
- Requires all of:
  - device extension [`khr_video_encode_queue`](crate::device::DeviceExtensions::khr_video_encode_queue)*/
    pub khr_video_encode_h264: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_video_encode_h265.html)
- Requires all of:
  - device extension [`khr_video_encode_queue`](crate::device::DeviceExtensions::khr_video_encode_queue)*/
    pub khr_video_encode_h265: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_video_encode_queue.html)
- Requires all of:
  - device extension [`khr_video_queue`](crate::device::DeviceExtensions::khr_video_queue)
  - Vulkan API version 1.3 or device extension [`khr_synchronization2`](crate::device::DeviceExtensions::khr_synchronization2)*/
    pub khr_video_encode_queue: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_video_maintenance1.html)
- Requires all of:
  - device extension [`khr_video_queue`](crate::device::DeviceExtensions::khr_video_queue)*/
    pub khr_video_maintenance1: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_video_queue.html)
- Requires all of:
  - Vulkan API version 1.1
  - Vulkan API version 1.3 or device extension [`khr_synchronization2`](crate::device::DeviceExtensions::khr_synchronization2)*/
    pub khr_video_queue: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_vulkan_memory_model.html)
- Promoted to Vulkan 1.2
- Requires all of:
  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](crate::instance::InstanceExtensions::khr_get_physical_device_properties2)*/
    pub khr_vulkan_memory_model: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_win32_keyed_mutex.html)
- Requires all of:
  - device extension [`khr_external_memory_win32`](crate::device::DeviceExtensions::khr_external_memory_win32)*/
    pub khr_win32_keyed_mutex: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_workgroup_memory_explicit_layout.html)
- Requires all of:
  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](crate::instance::InstanceExtensions::khr_get_physical_device_properties2)*/
    pub khr_workgroup_memory_explicit_layout: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_zero_initialize_workgroup_memory.html)
- Promoted to Vulkan 1.3
- Requires all of:
  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](crate::instance::InstanceExtensions::khr_get_physical_device_properties2)*/
    pub khr_zero_initialize_workgroup_memory: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_4444_formats.html)
- Promoted to Vulkan 1.3
- Requires all of:
  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](crate::instance::InstanceExtensions::khr_get_physical_device_properties2)*/
    pub ext_4444_formats: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_astc_decode_mode.html)
- Requires all of:
  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](crate::instance::InstanceExtensions::khr_get_physical_device_properties2)*/
    pub ext_astc_decode_mode: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_attachment_feedback_loop_dynamic_state.html)
- Requires all of:
  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](crate::instance::InstanceExtensions::khr_get_physical_device_properties2)
  - device extension [`ext_attachment_feedback_loop_layout`](crate::device::DeviceExtensions::ext_attachment_feedback_loop_layout)*/
    pub ext_attachment_feedback_loop_dynamic_state: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_attachment_feedback_loop_layout.html)
- Requires all of:
  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](crate::instance::InstanceExtensions::khr_get_physical_device_properties2)*/
    pub ext_attachment_feedback_loop_layout: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_blend_operation_advanced.html)
- Requires all of:
  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](crate::instance::InstanceExtensions::khr_get_physical_device_properties2)*/
    pub ext_blend_operation_advanced: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_border_color_swizzle.html)
- Requires all of:
  - device extension [`ext_custom_border_color`](crate::device::DeviceExtensions::ext_custom_border_color)*/
    pub ext_border_color_swizzle: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_buffer_device_address.html)
- Deprecated by [`khr_buffer_device_address`](crate::device::DeviceExtensions::khr_buffer_device_address)
- Requires all of:
  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](crate::instance::InstanceExtensions::khr_get_physical_device_properties2)
- Conflicts with device extension: [`khr_buffer_device_address`](crate::device::DeviceExtensions::khr_buffer_device_address)*/
    pub ext_buffer_device_address: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_calibrated_timestamps.html)
- Promoted to [`khr_calibrated_timestamps`](crate::device::DeviceExtensions::khr_calibrated_timestamps)
- Requires all of:
  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](crate::instance::InstanceExtensions::khr_get_physical_device_properties2)*/
    pub ext_calibrated_timestamps: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_color_write_enable.html)
- Requires all of:
  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](crate::instance::InstanceExtensions::khr_get_physical_device_properties2)*/
    pub ext_color_write_enable: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_conditional_rendering.html)
- Requires all of:
  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](crate::instance::InstanceExtensions::khr_get_physical_device_properties2)*/
    pub ext_conditional_rendering: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_conservative_rasterization.html)
- Requires all of:
  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](crate::instance::InstanceExtensions::khr_get_physical_device_properties2)*/
    pub ext_conservative_rasterization: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_custom_border_color.html)
- Requires all of:
  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](crate::instance::InstanceExtensions::khr_get_physical_device_properties2)*/
    pub ext_custom_border_color: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_debug_marker.html)
- Promoted to [`ext_debug_utils`](crate::instance::InstanceExtensions::ext_debug_utils)
- Requires all of:
  - instance extension [`ext_debug_report`](crate::instance::InstanceExtensions::ext_debug_report)*/
    pub ext_debug_marker: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_depth_bias_control.html)
- Requires all of:
  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](crate::instance::InstanceExtensions::khr_get_physical_device_properties2)*/
    pub ext_depth_bias_control: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_depth_clamp_zero_one.html)
- Requires all of:
  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](crate::instance::InstanceExtensions::khr_get_physical_device_properties2)*/
    pub ext_depth_clamp_zero_one: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_depth_clip_control.html)
- Requires all of:
  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](crate::instance::InstanceExtensions::khr_get_physical_device_properties2)*/
    pub ext_depth_clip_control: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_depth_clip_enable.html)
- Requires all of:
  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](crate::instance::InstanceExtensions::khr_get_physical_device_properties2)*/
    pub ext_depth_clip_enable: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_depth_range_unrestricted.html)
    pub ext_depth_range_unrestricted: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_descriptor_buffer.html)
- Requires all of:
  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](crate::instance::InstanceExtensions::khr_get_physical_device_properties2)
  - Vulkan API version 1.2 or device extension [`khr_buffer_device_address`](crate::device::DeviceExtensions::khr_buffer_device_address)
  - Vulkan API version 1.2 or device extension [`ext_descriptor_indexing`](crate::device::DeviceExtensions::ext_descriptor_indexing)
  - Vulkan API version 1.3 or device extension [`khr_synchronization2`](crate::device::DeviceExtensions::khr_synchronization2)*/
    pub ext_descriptor_buffer: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_descriptor_indexing.html)
- Promoted to Vulkan 1.2
- Requires all of:
  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](crate::instance::InstanceExtensions::khr_get_physical_device_properties2)
  - Vulkan API version 1.1 or device extension [`khr_maintenance3`](crate::device::DeviceExtensions::khr_maintenance3)*/
    pub ext_descriptor_indexing: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_device_address_binding_report.html)
- Requires all of:
  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](crate::instance::InstanceExtensions::khr_get_physical_device_properties2)
  - instance extension [`ext_debug_utils`](crate::instance::InstanceExtensions::ext_debug_utils)*/
    pub ext_device_address_binding_report: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_device_fault.html)
- Requires all of:
  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](crate::instance::InstanceExtensions::khr_get_physical_device_properties2)*/
    pub ext_device_fault: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_device_memory_report.html)
- Requires all of:
  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](crate::instance::InstanceExtensions::khr_get_physical_device_properties2)*/
    pub ext_device_memory_report: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_discard_rectangles.html)
- Requires all of:
  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](crate::instance::InstanceExtensions::khr_get_physical_device_properties2)*/
    pub ext_discard_rectangles: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_display_control.html)
- Requires all of:
  - instance extension [`ext_display_surface_counter`](crate::instance::InstanceExtensions::ext_display_surface_counter)
  - device extension [`khr_swapchain`](crate::device::DeviceExtensions::khr_swapchain)*/
    pub ext_display_control: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_dynamic_rendering_unused_attachments.html)
- Requires all of:
  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](crate::instance::InstanceExtensions::khr_get_physical_device_properties2)
  - Vulkan API version 1.3 or device extension [`khr_dynamic_rendering`](crate::device::DeviceExtensions::khr_dynamic_rendering)*/
    pub ext_dynamic_rendering_unused_attachments: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_extended_dynamic_state.html)
- Promoted to Vulkan 1.3
- Requires all of:
  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](crate::instance::InstanceExtensions::khr_get_physical_device_properties2)*/
    pub ext_extended_dynamic_state: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_extended_dynamic_state2.html)
- Promoted to Vulkan 1.3
- Requires all of:
  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](crate::instance::InstanceExtensions::khr_get_physical_device_properties2)*/
    pub ext_extended_dynamic_state2: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_extended_dynamic_state3.html)
- Requires all of:
  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](crate::instance::InstanceExtensions::khr_get_physical_device_properties2)*/
    pub ext_extended_dynamic_state3: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_external_memory_acquire_unmodified.html)
- Requires all of:
  - Vulkan API version 1.1 or device extension [`khr_external_memory`](crate::device::DeviceExtensions::khr_external_memory)*/
    pub ext_external_memory_acquire_unmodified: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_external_memory_dma_buf.html)
- Requires all of:
  - device extension [`khr_external_memory_fd`](crate::device::DeviceExtensions::khr_external_memory_fd)*/
    pub ext_external_memory_dma_buf: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_external_memory_host.html)
- Requires all of:
  - Vulkan API version 1.1 or device extension [`khr_external_memory`](crate::device::DeviceExtensions::khr_external_memory)*/
    pub ext_external_memory_host: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_filter_cubic.html)
    pub ext_filter_cubic: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_fragment_density_map.html)
- Requires all of:
  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](crate::instance::InstanceExtensions::khr_get_physical_device_properties2)*/
    pub ext_fragment_density_map: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_fragment_density_map2.html)
- Requires all of:
  - device extension [`ext_fragment_density_map`](crate::device::DeviceExtensions::ext_fragment_density_map)*/
    pub ext_fragment_density_map2: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_fragment_shader_interlock.html)
- Requires all of:
  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](crate::instance::InstanceExtensions::khr_get_physical_device_properties2)*/
    pub ext_fragment_shader_interlock: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_frame_boundary.html)
    pub ext_frame_boundary: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_full_screen_exclusive.html)
- Requires all of:
  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](crate::instance::InstanceExtensions::khr_get_physical_device_properties2)
  - instance extension [`khr_surface`](crate::instance::InstanceExtensions::khr_surface)
  - instance extension [`khr_get_surface_capabilities2`](crate::instance::InstanceExtensions::khr_get_surface_capabilities2)
  - device extension [`khr_swapchain`](crate::device::DeviceExtensions::khr_swapchain)*/
    pub ext_full_screen_exclusive: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_global_priority.html)
- Promoted to [`khr_global_priority`](crate::device::DeviceExtensions::khr_global_priority)*/
    pub ext_global_priority: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_global_priority_query.html)
- Promoted to [`khr_global_priority`](crate::device::DeviceExtensions::khr_global_priority)
- Requires all of:
  - device extension [`khr_global_priority`](crate::device::DeviceExtensions::khr_global_priority) or device extension [`ext_global_priority`](crate::device::DeviceExtensions::ext_global_priority)
  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](crate::instance::InstanceExtensions::khr_get_physical_device_properties2)*/
    pub ext_global_priority_query: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_graphics_pipeline_library.html)
- Requires all of:
  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](crate::instance::InstanceExtensions::khr_get_physical_device_properties2)
  - device extension [`khr_pipeline_library`](crate::device::DeviceExtensions::khr_pipeline_library)*/
    pub ext_graphics_pipeline_library: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_hdr_metadata.html)
- Requires all of:
  - device extension [`khr_swapchain`](crate::device::DeviceExtensions::khr_swapchain)*/
    pub ext_hdr_metadata: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_host_image_copy.html)
- Requires all of:
  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](crate::instance::InstanceExtensions::khr_get_physical_device_properties2)
  - Vulkan API version 1.3 or device extension [`khr_copy_commands2`](crate::device::DeviceExtensions::khr_copy_commands2)
  - Vulkan API version 1.3 or device extension [`khr_format_feature_flags2`](crate::device::DeviceExtensions::khr_format_feature_flags2)*/
    pub ext_host_image_copy: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_host_query_reset.html)
- Promoted to Vulkan 1.2
- Requires all of:
  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](crate::instance::InstanceExtensions::khr_get_physical_device_properties2)*/
    pub ext_host_query_reset: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_image_2d_view_of_3d.html)
- Requires all of:
  - Vulkan API version 1.1 or device extension [`khr_maintenance1`](crate::device::DeviceExtensions::khr_maintenance1)
  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](crate::instance::InstanceExtensions::khr_get_physical_device_properties2)*/
    pub ext_image_2d_view_of_3d: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_image_compression_control.html)
- Requires all of:
  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](crate::instance::InstanceExtensions::khr_get_physical_device_properties2)*/
    pub ext_image_compression_control: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_image_compression_control_swapchain.html)
- Requires all of:
  - device extension [`ext_image_compression_control`](crate::device::DeviceExtensions::ext_image_compression_control)*/
    pub ext_image_compression_control_swapchain: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_image_drm_format_modifier.html)
- Requires all of:
  - Vulkan API version 1.1 or device extension [`khr_bind_memory2`](crate::device::DeviceExtensions::khr_bind_memory2)
  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](crate::instance::InstanceExtensions::khr_get_physical_device_properties2)
  - Vulkan API version 1.1 or device extension [`khr_sampler_ycbcr_conversion`](crate::device::DeviceExtensions::khr_sampler_ycbcr_conversion)
  - Vulkan API version 1.2 or device extension [`khr_image_format_list`](crate::device::DeviceExtensions::khr_image_format_list)*/
    pub ext_image_drm_format_modifier: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_image_robustness.html)
- Promoted to Vulkan 1.3
- Requires all of:
  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](crate::instance::InstanceExtensions::khr_get_physical_device_properties2)*/
    pub ext_image_robustness: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_image_sliced_view_of_3d.html)
- Requires all of:
  - Vulkan API version 1.1 or device extension [`khr_maintenance1`](crate::device::DeviceExtensions::khr_maintenance1)
  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](crate::instance::InstanceExtensions::khr_get_physical_device_properties2)*/
    pub ext_image_sliced_view_of_3d: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_image_view_min_lod.html)
- Requires all of:
  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](crate::instance::InstanceExtensions::khr_get_physical_device_properties2)*/
    pub ext_image_view_min_lod: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_index_type_uint8.html)
- Promoted to [`khr_index_type_uint8`](crate::device::DeviceExtensions::khr_index_type_uint8)
- Requires all of:
  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](crate::instance::InstanceExtensions::khr_get_physical_device_properties2)*/
    pub ext_index_type_uint8: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_inline_uniform_block.html)
- Promoted to Vulkan 1.3
- Requires all of:
  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](crate::instance::InstanceExtensions::khr_get_physical_device_properties2)
  - Vulkan API version 1.1 or device extension [`khr_maintenance1`](crate::device::DeviceExtensions::khr_maintenance1)*/
    pub ext_inline_uniform_block: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_legacy_dithering.html)
- Requires all of:
  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](crate::instance::InstanceExtensions::khr_get_physical_device_properties2)*/
    pub ext_legacy_dithering: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_line_rasterization.html)
- Promoted to [`khr_line_rasterization`](crate::device::DeviceExtensions::khr_line_rasterization)
- Requires all of:
  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](crate::instance::InstanceExtensions::khr_get_physical_device_properties2)*/
    pub ext_line_rasterization: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_load_store_op_none.html)
- Promoted to [`khr_load_store_op_none`](crate::device::DeviceExtensions::khr_load_store_op_none)*/
    pub ext_load_store_op_none: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_map_memory_placed.html)
- Requires all of:
  - device extension [`khr_map_memory2`](crate::device::DeviceExtensions::khr_map_memory2)*/
    pub ext_map_memory_placed: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_memory_budget.html)
- Requires all of:
  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](crate::instance::InstanceExtensions::khr_get_physical_device_properties2)*/
    pub ext_memory_budget: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_memory_priority.html)
- Requires all of:
  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](crate::instance::InstanceExtensions::khr_get_physical_device_properties2)*/
    pub ext_memory_priority: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_mesh_shader.html)
- Requires all of:
  - Vulkan API version 1.2 or device extension [`khr_spirv_1_4`](crate::device::DeviceExtensions::khr_spirv_1_4)*/
    pub ext_mesh_shader: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_metal_objects.html)
    pub ext_metal_objects: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_multi_draw.html)
- Requires all of:
  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](crate::instance::InstanceExtensions::khr_get_physical_device_properties2)*/
    pub ext_multi_draw: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_multisampled_render_to_single_sampled.html)
- Requires all of:
  - Vulkan API version 1.2 or device extension [`khr_create_renderpass2`](crate::device::DeviceExtensions::khr_create_renderpass2)
  - Vulkan API version 1.2 or device extension [`khr_depth_stencil_resolve`](crate::device::DeviceExtensions::khr_depth_stencil_resolve)*/
    pub ext_multisampled_render_to_single_sampled: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_mutable_descriptor_type.html)
- Requires all of:
  - Vulkan API version 1.1 or device extension [`khr_maintenance3`](crate::device::DeviceExtensions::khr_maintenance3)*/
    pub ext_mutable_descriptor_type: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_nested_command_buffer.html)
- Requires all of:
  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](crate::instance::InstanceExtensions::khr_get_physical_device_properties2)*/
    pub ext_nested_command_buffer: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_non_seamless_cube_map.html)
- Requires all of:
  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](crate::instance::InstanceExtensions::khr_get_physical_device_properties2)*/
    pub ext_non_seamless_cube_map: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_opacity_micromap.html)
- Requires all of:
  - device extension [`khr_acceleration_structure`](crate::device::DeviceExtensions::khr_acceleration_structure)
  - Vulkan API version 1.3 or device extension [`khr_synchronization2`](crate::device::DeviceExtensions::khr_synchronization2)*/
    pub ext_opacity_micromap: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_pageable_device_local_memory.html)
- Requires all of:
  - device extension [`ext_memory_priority`](crate::device::DeviceExtensions::ext_memory_priority)*/
    pub ext_pageable_device_local_memory: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_pci_bus_info.html)
- Requires all of:
  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](crate::instance::InstanceExtensions::khr_get_physical_device_properties2)*/
    pub ext_pci_bus_info: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_physical_device_drm.html)
- Requires all of:
  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](crate::instance::InstanceExtensions::khr_get_physical_device_properties2)*/
    pub ext_physical_device_drm: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_pipeline_creation_cache_control.html)
- Promoted to Vulkan 1.3
- Requires all of:
  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](crate::instance::InstanceExtensions::khr_get_physical_device_properties2)*/
    pub ext_pipeline_creation_cache_control: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_pipeline_creation_feedback.html)
- Promoted to Vulkan 1.3*/
    pub ext_pipeline_creation_feedback: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_pipeline_library_group_handles.html)
- Requires all of:
  - device extension [`khr_ray_tracing_pipeline`](crate::device::DeviceExtensions::khr_ray_tracing_pipeline)
  - device extension [`khr_pipeline_library`](crate::device::DeviceExtensions::khr_pipeline_library)*/
    pub ext_pipeline_library_group_handles: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_pipeline_properties.html)
- Requires all of:
  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](crate::instance::InstanceExtensions::khr_get_physical_device_properties2)*/
    pub ext_pipeline_properties: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_pipeline_protected_access.html)
- Requires all of:
  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](crate::instance::InstanceExtensions::khr_get_physical_device_properties2)*/
    pub ext_pipeline_protected_access: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_pipeline_robustness.html)
- Requires all of:
  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](crate::instance::InstanceExtensions::khr_get_physical_device_properties2)*/
    pub ext_pipeline_robustness: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_post_depth_coverage.html)
    pub ext_post_depth_coverage: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_primitive_topology_list_restart.html)
- Requires all of:
  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](crate::instance::InstanceExtensions::khr_get_physical_device_properties2)*/
    pub ext_primitive_topology_list_restart: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_primitives_generated_query.html)
- Requires all of:
  - device extension [`ext_transform_feedback`](crate::device::DeviceExtensions::ext_transform_feedback)*/
    pub ext_primitives_generated_query: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_private_data.html)
- Promoted to Vulkan 1.3
- Requires all of:
  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](crate::instance::InstanceExtensions::khr_get_physical_device_properties2)*/
    pub ext_private_data: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_provoking_vertex.html)
- Requires all of:
  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](crate::instance::InstanceExtensions::khr_get_physical_device_properties2)*/
    pub ext_provoking_vertex: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_queue_family_foreign.html)
- Requires all of:
  - Vulkan API version 1.1 or device extension [`khr_external_memory`](crate::device::DeviceExtensions::khr_external_memory)*/
    pub ext_queue_family_foreign: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_rasterization_order_attachment_access.html)
- Requires all of:
  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](crate::instance::InstanceExtensions::khr_get_physical_device_properties2)*/
    pub ext_rasterization_order_attachment_access: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_rgba10x6_formats.html)
- Requires all of:
  - Vulkan API version 1.1 or device extension [`khr_sampler_ycbcr_conversion`](crate::device::DeviceExtensions::khr_sampler_ycbcr_conversion)*/
    pub ext_rgba10x6_formats: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_robustness2.html)
- Requires all of:
  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](crate::instance::InstanceExtensions::khr_get_physical_device_properties2)*/
    pub ext_robustness2: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_sample_locations.html)
- Requires all of:
  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](crate::instance::InstanceExtensions::khr_get_physical_device_properties2)*/
    pub ext_sample_locations: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_sampler_filter_minmax.html)
- Promoted to Vulkan 1.2
- Requires all of:
  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](crate::instance::InstanceExtensions::khr_get_physical_device_properties2)*/
    pub ext_sampler_filter_minmax: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_scalar_block_layout.html)
- Promoted to Vulkan 1.2
- Requires all of:
  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](crate::instance::InstanceExtensions::khr_get_physical_device_properties2)*/
    pub ext_scalar_block_layout: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_separate_stencil_usage.html)
- Promoted to Vulkan 1.2*/
    pub ext_separate_stencil_usage: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_shader_atomic_float.html)
- Requires all of:
  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](crate::instance::InstanceExtensions::khr_get_physical_device_properties2)*/
    pub ext_shader_atomic_float: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_shader_atomic_float2.html)
- Requires all of:
  - device extension [`ext_shader_atomic_float`](crate::device::DeviceExtensions::ext_shader_atomic_float)*/
    pub ext_shader_atomic_float2: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_shader_demote_to_helper_invocation.html)
- Promoted to Vulkan 1.3
- Requires all of:
  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](crate::instance::InstanceExtensions::khr_get_physical_device_properties2)*/
    pub ext_shader_demote_to_helper_invocation: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_shader_image_atomic_int64.html)
- Requires all of:
  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](crate::instance::InstanceExtensions::khr_get_physical_device_properties2)*/
    pub ext_shader_image_atomic_int64: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_shader_module_identifier.html)
- Requires all of:
  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](crate::instance::InstanceExtensions::khr_get_physical_device_properties2)
  - Vulkan API version 1.3 or device extension [`ext_pipeline_creation_cache_control`](crate::device::DeviceExtensions::ext_pipeline_creation_cache_control)*/
    pub ext_shader_module_identifier: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_shader_object.html)
- Requires all of:
  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](crate::instance::InstanceExtensions::khr_get_physical_device_properties2)
  - Vulkan API version 1.3 or device extension [`khr_dynamic_rendering`](crate::device::DeviceExtensions::khr_dynamic_rendering)*/
    pub ext_shader_object: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_shader_stencil_export.html)
    pub ext_shader_stencil_export: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_shader_subgroup_ballot.html)
- Deprecated by Vulkan 1.2*/
    pub ext_shader_subgroup_ballot: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_shader_subgroup_vote.html)
- Deprecated by Vulkan 1.1*/
    pub ext_shader_subgroup_vote: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_shader_tile_image.html)
- Requires all of:
  - Vulkan API version 1.3*/
    pub ext_shader_tile_image: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_shader_viewport_index_layer.html)
- Promoted to Vulkan 1.2*/
    pub ext_shader_viewport_index_layer: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_subgroup_size_control.html)
- Promoted to Vulkan 1.3
- Requires all of:
  - Vulkan API version 1.1*/
    pub ext_subgroup_size_control: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_subpass_merge_feedback.html)
- Requires all of:
  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](crate::instance::InstanceExtensions::khr_get_physical_device_properties2)*/
    pub ext_subpass_merge_feedback: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_swapchain_maintenance1.html)
- Requires all of:
  - device extension [`khr_swapchain`](crate::device::DeviceExtensions::khr_swapchain)
  - instance extension [`ext_surface_maintenance1`](crate::instance::InstanceExtensions::ext_surface_maintenance1)
  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](crate::instance::InstanceExtensions::khr_get_physical_device_properties2)*/
    pub ext_swapchain_maintenance1: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_texel_buffer_alignment.html)
- Promoted to Vulkan 1.3
- Requires all of:
  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](crate::instance::InstanceExtensions::khr_get_physical_device_properties2)*/
    pub ext_texel_buffer_alignment: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_texture_compression_astc_hdr.html)
- Promoted to Vulkan 1.3
- Requires all of:
  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](crate::instance::InstanceExtensions::khr_get_physical_device_properties2)*/
    pub ext_texture_compression_astc_hdr: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_tooling_info.html)
- Promoted to Vulkan 1.3*/
    pub ext_tooling_info: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_transform_feedback.html)
- Requires all of:
  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](crate::instance::InstanceExtensions::khr_get_physical_device_properties2)*/
    pub ext_transform_feedback: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_validation_cache.html)
    pub ext_validation_cache: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_vertex_attribute_divisor.html)
- Promoted to [`khr_vertex_attribute_divisor`](crate::device::DeviceExtensions::khr_vertex_attribute_divisor)
- Requires all of:
  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](crate::instance::InstanceExtensions::khr_get_physical_device_properties2)*/
    pub ext_vertex_attribute_divisor: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_vertex_input_dynamic_state.html)
- Requires all of:
  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](crate::instance::InstanceExtensions::khr_get_physical_device_properties2)*/
    pub ext_vertex_input_dynamic_state: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_ycbcr_2plane_444_formats.html)
- Promoted to Vulkan 1.3
- Requires all of:
  - Vulkan API version 1.1 or device extension [`khr_sampler_ycbcr_conversion`](crate::device::DeviceExtensions::khr_sampler_ycbcr_conversion)*/
    pub ext_ycbcr_2plane_444_formats: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_ycbcr_image_arrays.html)
- Requires all of:
  - Vulkan API version 1.1 or device extension [`khr_sampler_ycbcr_conversion`](crate::device::DeviceExtensions::khr_sampler_ycbcr_conversion)*/
    pub ext_ycbcr_image_arrays: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_AMDX_shader_enqueue.html)
- Requires all of:
  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](crate::instance::InstanceExtensions::khr_get_physical_device_properties2)
  - Vulkan API version 1.3 or device extension [`khr_synchronization2`](crate::device::DeviceExtensions::khr_synchronization2)
  - device extension [`khr_pipeline_library`](crate::device::DeviceExtensions::khr_pipeline_library)
  - Vulkan API version 1.2 or device extension [`khr_spirv_1_4`](crate::device::DeviceExtensions::khr_spirv_1_4)*/
    pub amdx_shader_enqueue: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_AMD_buffer_marker.html)
    pub amd_buffer_marker: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_AMD_device_coherent_memory.html)
- Requires all of:
  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](crate::instance::InstanceExtensions::khr_get_physical_device_properties2)*/
    pub amd_device_coherent_memory: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_AMD_display_native_hdr.html)
- Requires all of:
  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](crate::instance::InstanceExtensions::khr_get_physical_device_properties2)
  - instance extension [`khr_get_surface_capabilities2`](crate::instance::InstanceExtensions::khr_get_surface_capabilities2)
  - device extension [`khr_swapchain`](crate::device::DeviceExtensions::khr_swapchain)*/
    pub amd_display_native_hdr: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_AMD_draw_indirect_count.html)
- Promoted to [`khr_draw_indirect_count`](crate::device::DeviceExtensions::khr_draw_indirect_count)*/
    pub amd_draw_indirect_count: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_AMD_gcn_shader.html)
    pub amd_gcn_shader: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_AMD_gpu_shader_half_float.html)
- Deprecated by [`khr_shader_float16_int8`](crate::device::DeviceExtensions::khr_shader_float16_int8)*/
    pub amd_gpu_shader_half_float: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_AMD_gpu_shader_int16.html)
- Deprecated by [`khr_shader_float16_int8`](crate::device::DeviceExtensions::khr_shader_float16_int8)*/
    pub amd_gpu_shader_int16: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_AMD_memory_overallocation_behavior.html)
    pub amd_memory_overallocation_behavior: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_AMD_mixed_attachment_samples.html)
    pub amd_mixed_attachment_samples: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_AMD_pipeline_compiler_control.html)
    pub amd_pipeline_compiler_control: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_AMD_rasterization_order.html)
    pub amd_rasterization_order: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_AMD_shader_ballot.html)
    pub amd_shader_ballot: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_AMD_shader_core_properties.html)
- Requires all of:
  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](crate::instance::InstanceExtensions::khr_get_physical_device_properties2)*/
    pub amd_shader_core_properties: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_AMD_shader_core_properties2.html)
- Requires all of:
  - device extension [`amd_shader_core_properties`](crate::device::DeviceExtensions::amd_shader_core_properties)*/
    pub amd_shader_core_properties2: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_AMD_shader_early_and_late_fragment_tests.html)
- Requires all of:
  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](crate::instance::InstanceExtensions::khr_get_physical_device_properties2)*/
    pub amd_shader_early_and_late_fragment_tests: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_AMD_shader_explicit_vertex_parameter.html)
    pub amd_shader_explicit_vertex_parameter: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_AMD_shader_fragment_mask.html)
    pub amd_shader_fragment_mask: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_AMD_shader_image_load_store_lod.html)
    pub amd_shader_image_load_store_lod: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_AMD_shader_info.html)
    pub amd_shader_info: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_AMD_shader_trinary_minmax.html)
    pub amd_shader_trinary_minmax: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_AMD_texture_gather_bias_lod.html)
- Requires all of:
  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](crate::instance::InstanceExtensions::khr_get_physical_device_properties2)*/
    pub amd_texture_gather_bias_lod: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_ANDROID_external_format_resolve.html)
- Requires all of:
  - device extension [`android_external_memory_android_hardware_buffer`](crate::device::DeviceExtensions::android_external_memory_android_hardware_buffer)*/
    pub android_external_format_resolve: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_ANDROID_external_memory_android_hardware_buffer.html)
- Requires all of:
  - Vulkan API version 1.1 or device extension [`khr_sampler_ycbcr_conversion`](crate::device::DeviceExtensions::khr_sampler_ycbcr_conversion)
  - Vulkan API version 1.1 or device extension [`khr_external_memory`](crate::device::DeviceExtensions::khr_external_memory)
  - Vulkan API version 1.1 or device extension [`khr_dedicated_allocation`](crate::device::DeviceExtensions::khr_dedicated_allocation)
  - device extension [`ext_queue_family_foreign`](crate::device::DeviceExtensions::ext_queue_family_foreign)*/
    pub android_external_memory_android_hardware_buffer: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_ARM_rasterization_order_attachment_access.html)
- Promoted to [`ext_rasterization_order_attachment_access`](crate::device::DeviceExtensions::ext_rasterization_order_attachment_access)
- Requires all of:
  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](crate::instance::InstanceExtensions::khr_get_physical_device_properties2)*/
    pub arm_rasterization_order_attachment_access: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_ARM_render_pass_striped.html)
- Requires all of:
  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](crate::instance::InstanceExtensions::khr_get_physical_device_properties2)
  - Vulkan API version 1.3 or device extension [`khr_synchronization2`](crate::device::DeviceExtensions::khr_synchronization2)*/
    pub arm_render_pass_striped: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_ARM_scheduling_controls.html)
- Requires all of:
  - device extension [`arm_shader_core_builtins`](crate::device::DeviceExtensions::arm_shader_core_builtins)*/
    pub arm_scheduling_controls: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_ARM_shader_core_builtins.html)
- Requires all of:
  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](crate::instance::InstanceExtensions::khr_get_physical_device_properties2)*/
    pub arm_shader_core_builtins: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_ARM_shader_core_properties.html)
- Requires all of:
  - Vulkan API version 1.1*/
    pub arm_shader_core_properties: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_FUCHSIA_buffer_collection.html)
- Requires all of:
  - device extension [`fuchsia_external_memory`](crate::device::DeviceExtensions::fuchsia_external_memory)
  - Vulkan API version 1.1 or device extension [`khr_sampler_ycbcr_conversion`](crate::device::DeviceExtensions::khr_sampler_ycbcr_conversion)*/
    pub fuchsia_buffer_collection: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_FUCHSIA_external_memory.html)
- Requires all of:
  - Vulkan API version 1.1 or instance extension [`khr_external_memory_capabilities`](crate::instance::InstanceExtensions::khr_external_memory_capabilities)
  - Vulkan API version 1.1 or device extension [`khr_external_memory`](crate::device::DeviceExtensions::khr_external_memory)*/
    pub fuchsia_external_memory: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_FUCHSIA_external_semaphore.html)
- Requires all of:
  - Vulkan API version 1.1 or instance extension [`khr_external_semaphore_capabilities`](crate::instance::InstanceExtensions::khr_external_semaphore_capabilities)
  - Vulkan API version 1.1 or device extension [`khr_external_semaphore`](crate::device::DeviceExtensions::khr_external_semaphore)*/
    pub fuchsia_external_semaphore: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_GGP_frame_token.html)
- Requires all of:
  - device extension [`khr_swapchain`](crate::device::DeviceExtensions::khr_swapchain)
  - instance extension [`ggp_stream_descriptor_surface`](crate::instance::InstanceExtensions::ggp_stream_descriptor_surface)*/
    pub ggp_frame_token: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_GOOGLE_decorate_string.html)
    pub google_decorate_string: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_GOOGLE_display_timing.html)
- Requires all of:
  - device extension [`khr_swapchain`](crate::device::DeviceExtensions::khr_swapchain)*/
    pub google_display_timing: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_GOOGLE_hlsl_functionality1.html)
    pub google_hlsl_functionality1: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_GOOGLE_user_type.html)
    pub google_user_type: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_HUAWEI_cluster_culling_shader.html)
- Requires all of:
  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](crate::instance::InstanceExtensions::khr_get_physical_device_properties2)*/
    pub huawei_cluster_culling_shader: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_HUAWEI_invocation_mask.html)
- Requires all of:
  - device extension [`khr_ray_tracing_pipeline`](crate::device::DeviceExtensions::khr_ray_tracing_pipeline)
  - Vulkan API version 1.3 or device extension [`khr_synchronization2`](crate::device::DeviceExtensions::khr_synchronization2)*/
    pub huawei_invocation_mask: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_HUAWEI_subpass_shading.html)
- Requires all of:
  - Vulkan API version 1.2 or device extension [`khr_create_renderpass2`](crate::device::DeviceExtensions::khr_create_renderpass2)
  - Vulkan API version 1.3 or device extension [`khr_synchronization2`](crate::device::DeviceExtensions::khr_synchronization2)*/
    pub huawei_subpass_shading: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_IMG_filter_cubic.html)
    pub img_filter_cubic: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_IMG_format_pvrtc.html)
- Deprecated without a replacement*/
    pub img_format_pvrtc: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_IMG_relaxed_line_rasterization.html)
- Requires all of:
  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](crate::instance::InstanceExtensions::khr_get_physical_device_properties2)*/
    pub img_relaxed_line_rasterization: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_INTEL_performance_query.html)
    pub intel_performance_query: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_INTEL_shader_integer_functions2.html)
- Requires all of:
  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](crate::instance::InstanceExtensions::khr_get_physical_device_properties2)*/
    pub intel_shader_integer_functions2: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_MSFT_layered_driver.html)
- Requires all of:
  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](crate::instance::InstanceExtensions::khr_get_physical_device_properties2)*/
    pub msft_layered_driver: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_NVX_binary_import.html)
    pub nvx_binary_import: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_NVX_image_view_handle.html)
    pub nvx_image_view_handle: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_NVX_multiview_per_view_attributes.html)
- Requires all of:
  - Vulkan API version 1.1 or device extension [`khr_multiview`](crate::device::DeviceExtensions::khr_multiview)*/
    pub nvx_multiview_per_view_attributes: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_NV_acquire_winrt_display.html)
- Requires all of:
  - instance extension [`ext_direct_mode_display`](crate::instance::InstanceExtensions::ext_direct_mode_display)*/
    pub nv_acquire_winrt_display: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_NV_clip_space_w_scaling.html)
    pub nv_clip_space_w_scaling: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_NV_compute_shader_derivatives.html)
- Requires all of:
  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](crate::instance::InstanceExtensions::khr_get_physical_device_properties2)*/
    pub nv_compute_shader_derivatives: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_NV_cooperative_matrix.html)
- Requires all of:
  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](crate::instance::InstanceExtensions::khr_get_physical_device_properties2)*/
    pub nv_cooperative_matrix: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_NV_copy_memory_indirect.html)
- Requires all of:
  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](crate::instance::InstanceExtensions::khr_get_physical_device_properties2)
  - Vulkan API version 1.2 or device extension [`khr_buffer_device_address`](crate::device::DeviceExtensions::khr_buffer_device_address)*/
    pub nv_copy_memory_indirect: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_NV_corner_sampled_image.html)
- Requires all of:
  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](crate::instance::InstanceExtensions::khr_get_physical_device_properties2)*/
    pub nv_corner_sampled_image: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_NV_coverage_reduction_mode.html)
- Requires all of:
  - device extension [`nv_framebuffer_mixed_samples`](crate::device::DeviceExtensions::nv_framebuffer_mixed_samples)
  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](crate::instance::InstanceExtensions::khr_get_physical_device_properties2)*/
    pub nv_coverage_reduction_mode: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_NV_cuda_kernel_launch.html)
    pub nv_cuda_kernel_launch: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_NV_dedicated_allocation.html)
- Deprecated by [`khr_dedicated_allocation`](crate::device::DeviceExtensions::khr_dedicated_allocation)*/
    pub nv_dedicated_allocation: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_NV_dedicated_allocation_image_aliasing.html)
- Requires all of:
  - Vulkan API version 1.1 or device extension [`khr_dedicated_allocation`](crate::device::DeviceExtensions::khr_dedicated_allocation)
  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](crate::instance::InstanceExtensions::khr_get_physical_device_properties2)*/
    pub nv_dedicated_allocation_image_aliasing: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_NV_descriptor_pool_overallocation.html)
- Requires all of:
  - Vulkan API version 1.1*/
    pub nv_descriptor_pool_overallocation: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_NV_device_diagnostic_checkpoints.html)
- Requires all of:
  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](crate::instance::InstanceExtensions::khr_get_physical_device_properties2)*/
    pub nv_device_diagnostic_checkpoints: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_NV_device_diagnostics_config.html)
- Requires all of:
  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](crate::instance::InstanceExtensions::khr_get_physical_device_properties2)*/
    pub nv_device_diagnostics_config: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_NV_device_generated_commands.html)
- Requires all of:
  - Vulkan API version 1.1
  - Vulkan API version 1.2 or device extension [`khr_buffer_device_address`](crate::device::DeviceExtensions::khr_buffer_device_address)*/
    pub nv_device_generated_commands: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_NV_device_generated_commands_compute.html)
- Requires all of:
  - device extension [`nv_device_generated_commands`](crate::device::DeviceExtensions::nv_device_generated_commands)*/
    pub nv_device_generated_commands_compute: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_NV_displacement_micromap.html)
- Requires all of:
  - device extension [`ext_opacity_micromap`](crate::device::DeviceExtensions::ext_opacity_micromap)*/
    pub nv_displacement_micromap: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_NV_extended_sparse_address_space.html)
    pub nv_extended_sparse_address_space: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_NV_external_memory.html)
- Deprecated by [`khr_external_memory`](crate::device::DeviceExtensions::khr_external_memory)
- Requires all of:
  - instance extension [`nv_external_memory_capabilities`](crate::instance::InstanceExtensions::nv_external_memory_capabilities)*/
    pub nv_external_memory: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_NV_external_memory_rdma.html)
- Requires all of:
  - Vulkan API version 1.1 or device extension [`khr_external_memory`](crate::device::DeviceExtensions::khr_external_memory)*/
    pub nv_external_memory_rdma: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_NV_external_memory_win32.html)
- Deprecated by [`khr_external_memory_win32`](crate::device::DeviceExtensions::khr_external_memory_win32)
- Requires all of:
  - device extension [`nv_external_memory`](crate::device::DeviceExtensions::nv_external_memory)*/
    pub nv_external_memory_win32: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_NV_fill_rectangle.html)
    pub nv_fill_rectangle: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_NV_fragment_coverage_to_color.html)
    pub nv_fragment_coverage_to_color: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_NV_fragment_shader_barycentric.html)
- Promoted to [`khr_fragment_shader_barycentric`](crate::device::DeviceExtensions::khr_fragment_shader_barycentric)
- Requires all of:
  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](crate::instance::InstanceExtensions::khr_get_physical_device_properties2)*/
    pub nv_fragment_shader_barycentric: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_NV_fragment_shading_rate_enums.html)
- Requires all of:
  - device extension [`khr_fragment_shading_rate`](crate::device::DeviceExtensions::khr_fragment_shading_rate)*/
    pub nv_fragment_shading_rate_enums: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_NV_framebuffer_mixed_samples.html)
    pub nv_framebuffer_mixed_samples: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_NV_geometry_shader_passthrough.html)
    pub nv_geometry_shader_passthrough: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_NV_glsl_shader.html)
- Deprecated without a replacement*/
    pub nv_glsl_shader: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_NV_inherited_viewport_scissor.html)
- Requires all of:
  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](crate::instance::InstanceExtensions::khr_get_physical_device_properties2)*/
    pub nv_inherited_viewport_scissor: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_NV_linear_color_attachment.html)
- Requires all of:
  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](crate::instance::InstanceExtensions::khr_get_physical_device_properties2)*/
    pub nv_linear_color_attachment: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_NV_low_latency.html)
    pub nv_low_latency: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_NV_low_latency2.html)
- Requires all of:
  - Vulkan API version 1.2 or device extension [`khr_timeline_semaphore`](crate::device::DeviceExtensions::khr_timeline_semaphore)*/
    pub nv_low_latency2: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_NV_memory_decompression.html)
- Requires all of:
  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](crate::instance::InstanceExtensions::khr_get_physical_device_properties2)
  - Vulkan API version 1.2 or device extension [`khr_buffer_device_address`](crate::device::DeviceExtensions::khr_buffer_device_address)*/
    pub nv_memory_decompression: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_NV_mesh_shader.html)
- Requires all of:
  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](crate::instance::InstanceExtensions::khr_get_physical_device_properties2)*/
    pub nv_mesh_shader: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_NV_optical_flow.html)
- Requires all of:
  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](crate::instance::InstanceExtensions::khr_get_physical_device_properties2)
  - Vulkan API version 1.3 or device extension [`khr_format_feature_flags2`](crate::device::DeviceExtensions::khr_format_feature_flags2)
  - Vulkan API version 1.3 or device extension [`khr_synchronization2`](crate::device::DeviceExtensions::khr_synchronization2)*/
    pub nv_optical_flow: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_NV_per_stage_descriptor_set.html)
- Requires all of:
  - device extension [`khr_maintenance6`](crate::device::DeviceExtensions::khr_maintenance6)*/
    pub nv_per_stage_descriptor_set: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_NV_present_barrier.html)
- Requires all of:
  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](crate::instance::InstanceExtensions::khr_get_physical_device_properties2)
  - instance extension [`khr_surface`](crate::instance::InstanceExtensions::khr_surface)
  - instance extension [`khr_get_surface_capabilities2`](crate::instance::InstanceExtensions::khr_get_surface_capabilities2)
  - device extension [`khr_swapchain`](crate::device::DeviceExtensions::khr_swapchain)*/
    pub nv_present_barrier: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_NV_raw_access_chains.html)
    pub nv_raw_access_chains: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_NV_ray_tracing.html)
- Requires all of:
  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](crate::instance::InstanceExtensions::khr_get_physical_device_properties2)
  - Vulkan API version 1.1 or device extension [`khr_get_memory_requirements2`](crate::device::DeviceExtensions::khr_get_memory_requirements2)*/
    pub nv_ray_tracing: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_NV_ray_tracing_invocation_reorder.html)
- Requires all of:
  - device extension [`khr_ray_tracing_pipeline`](crate::device::DeviceExtensions::khr_ray_tracing_pipeline)*/
    pub nv_ray_tracing_invocation_reorder: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_NV_ray_tracing_motion_blur.html)
- Requires all of:
  - device extension [`khr_ray_tracing_pipeline`](crate::device::DeviceExtensions::khr_ray_tracing_pipeline)*/
    pub nv_ray_tracing_motion_blur: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_NV_ray_tracing_validation.html)
    pub nv_ray_tracing_validation: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_NV_representative_fragment_test.html)
- Requires all of:
  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](crate::instance::InstanceExtensions::khr_get_physical_device_properties2)*/
    pub nv_representative_fragment_test: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_NV_sample_mask_override_coverage.html)
    pub nv_sample_mask_override_coverage: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_NV_scissor_exclusive.html)
- Requires all of:
  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](crate::instance::InstanceExtensions::khr_get_physical_device_properties2)*/
    pub nv_scissor_exclusive: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_NV_shader_atomic_float16_vector.html)
    pub nv_shader_atomic_float16_vector: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_NV_shader_image_footprint.html)
- Requires all of:
  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](crate::instance::InstanceExtensions::khr_get_physical_device_properties2)*/
    pub nv_shader_image_footprint: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_NV_shader_sm_builtins.html)
- Requires all of:
  - Vulkan API version 1.1*/
    pub nv_shader_sm_builtins: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_NV_shader_subgroup_partitioned.html)
- Requires all of:
  - Vulkan API version 1.1*/
    pub nv_shader_subgroup_partitioned: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_NV_shading_rate_image.html)
- Requires all of:
  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](crate::instance::InstanceExtensions::khr_get_physical_device_properties2)*/
    pub nv_shading_rate_image: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_NV_viewport_array2.html)
    pub nv_viewport_array2: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_NV_viewport_swizzle.html)
    pub nv_viewport_swizzle: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_NV_win32_keyed_mutex.html)
- Promoted to [`khr_win32_keyed_mutex`](crate::device::DeviceExtensions::khr_win32_keyed_mutex)
- Requires all of:
  - device extension [`nv_external_memory_win32`](crate::device::DeviceExtensions::nv_external_memory_win32)*/
    pub nv_win32_keyed_mutex: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_QCOM_filter_cubic_clamp.html)
- Requires all of:
  - device extension [`ext_filter_cubic`](crate::device::DeviceExtensions::ext_filter_cubic)
  - Vulkan API version 1.2 or device extension [`ext_sampler_filter_minmax`](crate::device::DeviceExtensions::ext_sampler_filter_minmax)*/
    pub qcom_filter_cubic_clamp: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_QCOM_filter_cubic_weights.html)
- Requires all of:
  - device extension [`ext_filter_cubic`](crate::device::DeviceExtensions::ext_filter_cubic)*/
    pub qcom_filter_cubic_weights: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_QCOM_fragment_density_map_offset.html)
- Requires all of:
  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](crate::instance::InstanceExtensions::khr_get_physical_device_properties2)
  - device extension [`ext_fragment_density_map`](crate::device::DeviceExtensions::ext_fragment_density_map)*/
    pub qcom_fragment_density_map_offset: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_QCOM_image_processing.html)
- Requires all of:
  - Vulkan API version 1.3 or device extension [`khr_format_feature_flags2`](crate::device::DeviceExtensions::khr_format_feature_flags2)*/
    pub qcom_image_processing: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_QCOM_image_processing2.html)
- Requires all of:
  - device extension [`qcom_image_processing`](crate::device::DeviceExtensions::qcom_image_processing)*/
    pub qcom_image_processing2: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_QCOM_multiview_per_view_render_areas.html)
    pub qcom_multiview_per_view_render_areas: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_QCOM_multiview_per_view_viewports.html)
- Requires all of:
  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](crate::instance::InstanceExtensions::khr_get_physical_device_properties2)*/
    pub qcom_multiview_per_view_viewports: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_QCOM_render_pass_shader_resolve.html)
    pub qcom_render_pass_shader_resolve: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_QCOM_render_pass_store_ops.html)
    pub qcom_render_pass_store_ops: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_QCOM_render_pass_transform.html)
    pub qcom_render_pass_transform: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_QCOM_rotated_copy_commands.html)
- Requires all of:
  - Vulkan API version 1.3 or device extension [`khr_copy_commands2`](crate::device::DeviceExtensions::khr_copy_commands2)*/
    pub qcom_rotated_copy_commands: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_QCOM_tile_properties.html)
- Requires all of:
  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](crate::instance::InstanceExtensions::khr_get_physical_device_properties2)*/
    pub qcom_tile_properties: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_QCOM_ycbcr_degamma.html)
    pub qcom_ycbcr_degamma: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_QNX_external_memory_screen_buffer.html)
- Requires all of:
  - Vulkan API version 1.1 or device extension [`khr_sampler_ycbcr_conversion`](crate::device::DeviceExtensions::khr_sampler_ycbcr_conversion)
  - Vulkan API version 1.1 or device extension [`khr_external_memory`](crate::device::DeviceExtensions::khr_external_memory)
  - Vulkan API version 1.1 or device extension [`khr_dedicated_allocation`](crate::device::DeviceExtensions::khr_dedicated_allocation)
  - device extension [`ext_queue_family_foreign`](crate::device::DeviceExtensions::ext_queue_family_foreign)*/
    pub qnx_external_memory_screen_buffer: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_SEC_amigo_profiling.html)
- Requires all of:
  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](crate::instance::InstanceExtensions::khr_get_physical_device_properties2)*/
    pub sec_amigo_profiling: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_VALVE_descriptor_set_host_mapping.html)
- Requires all of:
  - Vulkan API version 1.1 or instance extension [`khr_get_physical_device_properties2`](crate::instance::InstanceExtensions::khr_get_physical_device_properties2)*/
    pub valve_descriptor_set_host_mapping: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_VALVE_mutable_descriptor_type.html)
- Promoted to [`ext_mutable_descriptor_type`](crate::device::DeviceExtensions::ext_mutable_descriptor_type)
- Requires all of:
  - Vulkan API version 1.1 or device extension [`khr_maintenance3`](crate::device::DeviceExtensions::khr_maintenance3)*/
    pub valve_mutable_descriptor_type: bool,
    pub _ne: crate::NonExhaustive,
}
impl Default for DeviceExtensions {
    #[inline]
    fn default() -> Self {
        Self::empty()
    }
}
impl DeviceExtensions {
    /// Returns an `Extensions` object with none of the members set.
    #[inline]
    pub const fn empty() -> Self {
        Self {
            khr_16bit_storage: false,
            khr_8bit_storage: false,
            khr_acceleration_structure: false,
            khr_bind_memory2: false,
            khr_buffer_device_address: false,
            khr_calibrated_timestamps: false,
            khr_cooperative_matrix: false,
            khr_copy_commands2: false,
            khr_create_renderpass2: false,
            khr_dedicated_allocation: false,
            khr_deferred_host_operations: false,
            khr_depth_stencil_resolve: false,
            khr_descriptor_update_template: false,
            khr_device_group: false,
            khr_display_swapchain: false,
            khr_draw_indirect_count: false,
            khr_driver_properties: false,
            khr_dynamic_rendering: false,
            khr_dynamic_rendering_local_read: false,
            khr_external_fence: false,
            khr_external_fence_fd: false,
            khr_external_fence_win32: false,
            khr_external_memory: false,
            khr_external_memory_fd: false,
            khr_external_memory_win32: false,
            khr_external_semaphore: false,
            khr_external_semaphore_fd: false,
            khr_external_semaphore_win32: false,
            khr_format_feature_flags2: false,
            khr_fragment_shader_barycentric: false,
            khr_fragment_shading_rate: false,
            khr_get_memory_requirements2: false,
            khr_global_priority: false,
            khr_image_format_list: false,
            khr_imageless_framebuffer: false,
            khr_incremental_present: false,
            khr_index_type_uint8: false,
            khr_line_rasterization: false,
            khr_load_store_op_none: false,
            khr_maintenance1: false,
            khr_maintenance2: false,
            khr_maintenance3: false,
            khr_maintenance4: false,
            khr_maintenance5: false,
            khr_maintenance6: false,
            khr_map_memory2: false,
            khr_multiview: false,
            khr_performance_query: false,
            khr_pipeline_executable_properties: false,
            khr_pipeline_library: false,
            khr_portability_subset: false,
            khr_present_id: false,
            khr_present_wait: false,
            khr_push_descriptor: false,
            khr_ray_query: false,
            khr_ray_tracing_maintenance1: false,
            khr_ray_tracing_pipeline: false,
            khr_ray_tracing_position_fetch: false,
            khr_relaxed_block_layout: false,
            khr_sampler_mirror_clamp_to_edge: false,
            khr_sampler_ycbcr_conversion: false,
            khr_separate_depth_stencil_layouts: false,
            khr_shader_atomic_int64: false,
            khr_shader_clock: false,
            khr_shader_draw_parameters: false,
            khr_shader_expect_assume: false,
            khr_shader_float16_int8: false,
            khr_shader_float_controls: false,
            khr_shader_float_controls2: false,
            khr_shader_integer_dot_product: false,
            khr_shader_maximal_reconvergence: false,
            khr_shader_non_semantic_info: false,
            khr_shader_quad_control: false,
            khr_shader_subgroup_extended_types: false,
            khr_shader_subgroup_rotate: false,
            khr_shader_subgroup_uniform_control_flow: false,
            khr_shader_terminate_invocation: false,
            khr_shared_presentable_image: false,
            khr_spirv_1_4: false,
            khr_storage_buffer_storage_class: false,
            khr_swapchain: false,
            khr_swapchain_mutable_format: false,
            khr_synchronization2: false,
            khr_timeline_semaphore: false,
            khr_uniform_buffer_standard_layout: false,
            khr_variable_pointers: false,
            khr_vertex_attribute_divisor: false,
            khr_video_decode_av1: false,
            khr_video_decode_h264: false,
            khr_video_decode_h265: false,
            khr_video_decode_queue: false,
            khr_video_encode_h264: false,
            khr_video_encode_h265: false,
            khr_video_encode_queue: false,
            khr_video_maintenance1: false,
            khr_video_queue: false,
            khr_vulkan_memory_model: false,
            khr_win32_keyed_mutex: false,
            khr_workgroup_memory_explicit_layout: false,
            khr_zero_initialize_workgroup_memory: false,
            ext_4444_formats: false,
            ext_astc_decode_mode: false,
            ext_attachment_feedback_loop_dynamic_state: false,
            ext_attachment_feedback_loop_layout: false,
            ext_blend_operation_advanced: false,
            ext_border_color_swizzle: false,
            ext_buffer_device_address: false,
            ext_calibrated_timestamps: false,
            ext_color_write_enable: false,
            ext_conditional_rendering: false,
            ext_conservative_rasterization: false,
            ext_custom_border_color: false,
            ext_debug_marker: false,
            ext_depth_bias_control: false,
            ext_depth_clamp_zero_one: false,
            ext_depth_clip_control: false,
            ext_depth_clip_enable: false,
            ext_depth_range_unrestricted: false,
            ext_descriptor_buffer: false,
            ext_descriptor_indexing: false,
            ext_device_address_binding_report: false,
            ext_device_fault: false,
            ext_device_memory_report: false,
            ext_discard_rectangles: false,
            ext_display_control: false,
            ext_dynamic_rendering_unused_attachments: false,
            ext_extended_dynamic_state: false,
            ext_extended_dynamic_state2: false,
            ext_extended_dynamic_state3: false,
            ext_external_memory_acquire_unmodified: false,
            ext_external_memory_dma_buf: false,
            ext_external_memory_host: false,
            ext_filter_cubic: false,
            ext_fragment_density_map: false,
            ext_fragment_density_map2: false,
            ext_fragment_shader_interlock: false,
            ext_frame_boundary: false,
            ext_full_screen_exclusive: false,
            ext_global_priority: false,
            ext_global_priority_query: false,
            ext_graphics_pipeline_library: false,
            ext_hdr_metadata: false,
            ext_host_image_copy: false,
            ext_host_query_reset: false,
            ext_image_2d_view_of_3d: false,
            ext_image_compression_control: false,
            ext_image_compression_control_swapchain: false,
            ext_image_drm_format_modifier: false,
            ext_image_robustness: false,
            ext_image_sliced_view_of_3d: false,
            ext_image_view_min_lod: false,
            ext_index_type_uint8: false,
            ext_inline_uniform_block: false,
            ext_legacy_dithering: false,
            ext_line_rasterization: false,
            ext_load_store_op_none: false,
            ext_map_memory_placed: false,
            ext_memory_budget: false,
            ext_memory_priority: false,
            ext_mesh_shader: false,
            ext_metal_objects: false,
            ext_multi_draw: false,
            ext_multisampled_render_to_single_sampled: false,
            ext_mutable_descriptor_type: false,
            ext_nested_command_buffer: false,
            ext_non_seamless_cube_map: false,
            ext_opacity_micromap: false,
            ext_pageable_device_local_memory: false,
            ext_pci_bus_info: false,
            ext_physical_device_drm: false,
            ext_pipeline_creation_cache_control: false,
            ext_pipeline_creation_feedback: false,
            ext_pipeline_library_group_handles: false,
            ext_pipeline_properties: false,
            ext_pipeline_protected_access: false,
            ext_pipeline_robustness: false,
            ext_post_depth_coverage: false,
            ext_primitive_topology_list_restart: false,
            ext_primitives_generated_query: false,
            ext_private_data: false,
            ext_provoking_vertex: false,
            ext_queue_family_foreign: false,
            ext_rasterization_order_attachment_access: false,
            ext_rgba10x6_formats: false,
            ext_robustness2: false,
            ext_sample_locations: false,
            ext_sampler_filter_minmax: false,
            ext_scalar_block_layout: false,
            ext_separate_stencil_usage: false,
            ext_shader_atomic_float: false,
            ext_shader_atomic_float2: false,
            ext_shader_demote_to_helper_invocation: false,
            ext_shader_image_atomic_int64: false,
            ext_shader_module_identifier: false,
            ext_shader_object: false,
            ext_shader_stencil_export: false,
            ext_shader_subgroup_ballot: false,
            ext_shader_subgroup_vote: false,
            ext_shader_tile_image: false,
            ext_shader_viewport_index_layer: false,
            ext_subgroup_size_control: false,
            ext_subpass_merge_feedback: false,
            ext_swapchain_maintenance1: false,
            ext_texel_buffer_alignment: false,
            ext_texture_compression_astc_hdr: false,
            ext_tooling_info: false,
            ext_transform_feedback: false,
            ext_validation_cache: false,
            ext_vertex_attribute_divisor: false,
            ext_vertex_input_dynamic_state: false,
            ext_ycbcr_2plane_444_formats: false,
            ext_ycbcr_image_arrays: false,
            amdx_shader_enqueue: false,
            amd_buffer_marker: false,
            amd_device_coherent_memory: false,
            amd_display_native_hdr: false,
            amd_draw_indirect_count: false,
            amd_gcn_shader: false,
            amd_gpu_shader_half_float: false,
            amd_gpu_shader_int16: false,
            amd_memory_overallocation_behavior: false,
            amd_mixed_attachment_samples: false,
            amd_pipeline_compiler_control: false,
            amd_rasterization_order: false,
            amd_shader_ballot: false,
            amd_shader_core_properties: false,
            amd_shader_core_properties2: false,
            amd_shader_early_and_late_fragment_tests: false,
            amd_shader_explicit_vertex_parameter: false,
            amd_shader_fragment_mask: false,
            amd_shader_image_load_store_lod: false,
            amd_shader_info: false,
            amd_shader_trinary_minmax: false,
            amd_texture_gather_bias_lod: false,
            android_external_format_resolve: false,
            android_external_memory_android_hardware_buffer: false,
            arm_rasterization_order_attachment_access: false,
            arm_render_pass_striped: false,
            arm_scheduling_controls: false,
            arm_shader_core_builtins: false,
            arm_shader_core_properties: false,
            fuchsia_buffer_collection: false,
            fuchsia_external_memory: false,
            fuchsia_external_semaphore: false,
            ggp_frame_token: false,
            google_decorate_string: false,
            google_display_timing: false,
            google_hlsl_functionality1: false,
            google_user_type: false,
            huawei_cluster_culling_shader: false,
            huawei_invocation_mask: false,
            huawei_subpass_shading: false,
            img_filter_cubic: false,
            img_format_pvrtc: false,
            img_relaxed_line_rasterization: false,
            intel_performance_query: false,
            intel_shader_integer_functions2: false,
            msft_layered_driver: false,
            nvx_binary_import: false,
            nvx_image_view_handle: false,
            nvx_multiview_per_view_attributes: false,
            nv_acquire_winrt_display: false,
            nv_clip_space_w_scaling: false,
            nv_compute_shader_derivatives: false,
            nv_cooperative_matrix: false,
            nv_copy_memory_indirect: false,
            nv_corner_sampled_image: false,
            nv_coverage_reduction_mode: false,
            nv_cuda_kernel_launch: false,
            nv_dedicated_allocation: false,
            nv_dedicated_allocation_image_aliasing: false,
            nv_descriptor_pool_overallocation: false,
            nv_device_diagnostic_checkpoints: false,
            nv_device_diagnostics_config: false,
            nv_device_generated_commands: false,
            nv_device_generated_commands_compute: false,
            nv_displacement_micromap: false,
            nv_extended_sparse_address_space: false,
            nv_external_memory: false,
            nv_external_memory_rdma: false,
            nv_external_memory_win32: false,
            nv_fill_rectangle: false,
            nv_fragment_coverage_to_color: false,
            nv_fragment_shader_barycentric: false,
            nv_fragment_shading_rate_enums: false,
            nv_framebuffer_mixed_samples: false,
            nv_geometry_shader_passthrough: false,
            nv_glsl_shader: false,
            nv_inherited_viewport_scissor: false,
            nv_linear_color_attachment: false,
            nv_low_latency: false,
            nv_low_latency2: false,
            nv_memory_decompression: false,
            nv_mesh_shader: false,
            nv_optical_flow: false,
            nv_per_stage_descriptor_set: false,
            nv_present_barrier: false,
            nv_raw_access_chains: false,
            nv_ray_tracing: false,
            nv_ray_tracing_invocation_reorder: false,
            nv_ray_tracing_motion_blur: false,
            nv_ray_tracing_validation: false,
            nv_representative_fragment_test: false,
            nv_sample_mask_override_coverage: false,
            nv_scissor_exclusive: false,
            nv_shader_atomic_float16_vector: false,
            nv_shader_image_footprint: false,
            nv_shader_sm_builtins: false,
            nv_shader_subgroup_partitioned: false,
            nv_shading_rate_image: false,
            nv_viewport_array2: false,
            nv_viewport_swizzle: false,
            nv_win32_keyed_mutex: false,
            qcom_filter_cubic_clamp: false,
            qcom_filter_cubic_weights: false,
            qcom_fragment_density_map_offset: false,
            qcom_image_processing: false,
            qcom_image_processing2: false,
            qcom_multiview_per_view_render_areas: false,
            qcom_multiview_per_view_viewports: false,
            qcom_render_pass_shader_resolve: false,
            qcom_render_pass_store_ops: false,
            qcom_render_pass_transform: false,
            qcom_rotated_copy_commands: false,
            qcom_tile_properties: false,
            qcom_ycbcr_degamma: false,
            qnx_external_memory_screen_buffer: false,
            sec_amigo_profiling: false,
            valve_descriptor_set_host_mapping: false,
            valve_mutable_descriptor_type: false,
            _ne: crate::NonExhaustive(()),
        }
    }
    /// Returns the number of members set in self.
    #[inline]
    pub const fn count(self) -> u64 {
        self.khr_16bit_storage as u64 + self.khr_8bit_storage as u64
            + self.khr_acceleration_structure as u64 + self.khr_bind_memory2 as u64
            + self.khr_buffer_device_address as u64
            + self.khr_calibrated_timestamps as u64 + self.khr_cooperative_matrix as u64
            + self.khr_copy_commands2 as u64 + self.khr_create_renderpass2 as u64
            + self.khr_dedicated_allocation as u64
            + self.khr_deferred_host_operations as u64
            + self.khr_depth_stencil_resolve as u64
            + self.khr_descriptor_update_template as u64 + self.khr_device_group as u64
            + self.khr_display_swapchain as u64 + self.khr_draw_indirect_count as u64
            + self.khr_driver_properties as u64 + self.khr_dynamic_rendering as u64
            + self.khr_dynamic_rendering_local_read as u64
            + self.khr_external_fence as u64 + self.khr_external_fence_fd as u64
            + self.khr_external_fence_win32 as u64 + self.khr_external_memory as u64
            + self.khr_external_memory_fd as u64 + self.khr_external_memory_win32 as u64
            + self.khr_external_semaphore as u64 + self.khr_external_semaphore_fd as u64
            + self.khr_external_semaphore_win32 as u64
            + self.khr_format_feature_flags2 as u64
            + self.khr_fragment_shader_barycentric as u64
            + self.khr_fragment_shading_rate as u64
            + self.khr_get_memory_requirements2 as u64 + self.khr_global_priority as u64
            + self.khr_image_format_list as u64 + self.khr_imageless_framebuffer as u64
            + self.khr_incremental_present as u64 + self.khr_index_type_uint8 as u64
            + self.khr_line_rasterization as u64 + self.khr_load_store_op_none as u64
            + self.khr_maintenance1 as u64 + self.khr_maintenance2 as u64
            + self.khr_maintenance3 as u64 + self.khr_maintenance4 as u64
            + self.khr_maintenance5 as u64 + self.khr_maintenance6 as u64
            + self.khr_map_memory2 as u64 + self.khr_multiview as u64
            + self.khr_performance_query as u64
            + self.khr_pipeline_executable_properties as u64
            + self.khr_pipeline_library as u64 + self.khr_portability_subset as u64
            + self.khr_present_id as u64 + self.khr_present_wait as u64
            + self.khr_push_descriptor as u64 + self.khr_ray_query as u64
            + self.khr_ray_tracing_maintenance1 as u64
            + self.khr_ray_tracing_pipeline as u64
            + self.khr_ray_tracing_position_fetch as u64
            + self.khr_relaxed_block_layout as u64
            + self.khr_sampler_mirror_clamp_to_edge as u64
            + self.khr_sampler_ycbcr_conversion as u64
            + self.khr_separate_depth_stencil_layouts as u64
            + self.khr_shader_atomic_int64 as u64 + self.khr_shader_clock as u64
            + self.khr_shader_draw_parameters as u64
            + self.khr_shader_expect_assume as u64 + self.khr_shader_float16_int8 as u64
            + self.khr_shader_float_controls as u64
            + self.khr_shader_float_controls2 as u64
            + self.khr_shader_integer_dot_product as u64
            + self.khr_shader_maximal_reconvergence as u64
            + self.khr_shader_non_semantic_info as u64
            + self.khr_shader_quad_control as u64
            + self.khr_shader_subgroup_extended_types as u64
            + self.khr_shader_subgroup_rotate as u64
            + self.khr_shader_subgroup_uniform_control_flow as u64
            + self.khr_shader_terminate_invocation as u64
            + self.khr_shared_presentable_image as u64 + self.khr_spirv_1_4 as u64
            + self.khr_storage_buffer_storage_class as u64 + self.khr_swapchain as u64
            + self.khr_swapchain_mutable_format as u64 + self.khr_synchronization2 as u64
            + self.khr_timeline_semaphore as u64
            + self.khr_uniform_buffer_standard_layout as u64
            + self.khr_variable_pointers as u64
            + self.khr_vertex_attribute_divisor as u64 + self.khr_video_decode_av1 as u64
            + self.khr_video_decode_h264 as u64 + self.khr_video_decode_h265 as u64
            + self.khr_video_decode_queue as u64 + self.khr_video_encode_h264 as u64
            + self.khr_video_encode_h265 as u64 + self.khr_video_encode_queue as u64
            + self.khr_video_maintenance1 as u64 + self.khr_video_queue as u64
            + self.khr_vulkan_memory_model as u64 + self.khr_win32_keyed_mutex as u64
            + self.khr_workgroup_memory_explicit_layout as u64
            + self.khr_zero_initialize_workgroup_memory as u64
            + self.ext_4444_formats as u64 + self.ext_astc_decode_mode as u64
            + self.ext_attachment_feedback_loop_dynamic_state as u64
            + self.ext_attachment_feedback_loop_layout as u64
            + self.ext_blend_operation_advanced as u64
            + self.ext_border_color_swizzle as u64
            + self.ext_buffer_device_address as u64
            + self.ext_calibrated_timestamps as u64 + self.ext_color_write_enable as u64
            + self.ext_conditional_rendering as u64
            + self.ext_conservative_rasterization as u64
            + self.ext_custom_border_color as u64 + self.ext_debug_marker as u64
            + self.ext_depth_bias_control as u64 + self.ext_depth_clamp_zero_one as u64
            + self.ext_depth_clip_control as u64 + self.ext_depth_clip_enable as u64
            + self.ext_depth_range_unrestricted as u64
            + self.ext_descriptor_buffer as u64 + self.ext_descriptor_indexing as u64
            + self.ext_device_address_binding_report as u64
            + self.ext_device_fault as u64 + self.ext_device_memory_report as u64
            + self.ext_discard_rectangles as u64 + self.ext_display_control as u64
            + self.ext_dynamic_rendering_unused_attachments as u64
            + self.ext_extended_dynamic_state as u64
            + self.ext_extended_dynamic_state2 as u64
            + self.ext_extended_dynamic_state3 as u64
            + self.ext_external_memory_acquire_unmodified as u64
            + self.ext_external_memory_dma_buf as u64
            + self.ext_external_memory_host as u64 + self.ext_filter_cubic as u64
            + self.ext_fragment_density_map as u64
            + self.ext_fragment_density_map2 as u64
            + self.ext_fragment_shader_interlock as u64 + self.ext_frame_boundary as u64
            + self.ext_full_screen_exclusive as u64 + self.ext_global_priority as u64
            + self.ext_global_priority_query as u64
            + self.ext_graphics_pipeline_library as u64 + self.ext_hdr_metadata as u64
            + self.ext_host_image_copy as u64 + self.ext_host_query_reset as u64
            + self.ext_image_2d_view_of_3d as u64
            + self.ext_image_compression_control as u64
            + self.ext_image_compression_control_swapchain as u64
            + self.ext_image_drm_format_modifier as u64
            + self.ext_image_robustness as u64 + self.ext_image_sliced_view_of_3d as u64
            + self.ext_image_view_min_lod as u64 + self.ext_index_type_uint8 as u64
            + self.ext_inline_uniform_block as u64 + self.ext_legacy_dithering as u64
            + self.ext_line_rasterization as u64 + self.ext_load_store_op_none as u64
            + self.ext_map_memory_placed as u64 + self.ext_memory_budget as u64
            + self.ext_memory_priority as u64 + self.ext_mesh_shader as u64
            + self.ext_metal_objects as u64 + self.ext_multi_draw as u64
            + self.ext_multisampled_render_to_single_sampled as u64
            + self.ext_mutable_descriptor_type as u64
            + self.ext_nested_command_buffer as u64
            + self.ext_non_seamless_cube_map as u64 + self.ext_opacity_micromap as u64
            + self.ext_pageable_device_local_memory as u64 + self.ext_pci_bus_info as u64
            + self.ext_physical_device_drm as u64
            + self.ext_pipeline_creation_cache_control as u64
            + self.ext_pipeline_creation_feedback as u64
            + self.ext_pipeline_library_group_handles as u64
            + self.ext_pipeline_properties as u64
            + self.ext_pipeline_protected_access as u64
            + self.ext_pipeline_robustness as u64 + self.ext_post_depth_coverage as u64
            + self.ext_primitive_topology_list_restart as u64
            + self.ext_primitives_generated_query as u64 + self.ext_private_data as u64
            + self.ext_provoking_vertex as u64 + self.ext_queue_family_foreign as u64
            + self.ext_rasterization_order_attachment_access as u64
            + self.ext_rgba10x6_formats as u64 + self.ext_robustness2 as u64
            + self.ext_sample_locations as u64 + self.ext_sampler_filter_minmax as u64
            + self.ext_scalar_block_layout as u64
            + self.ext_separate_stencil_usage as u64
            + self.ext_shader_atomic_float as u64 + self.ext_shader_atomic_float2 as u64
            + self.ext_shader_demote_to_helper_invocation as u64
            + self.ext_shader_image_atomic_int64 as u64
            + self.ext_shader_module_identifier as u64 + self.ext_shader_object as u64
            + self.ext_shader_stencil_export as u64
            + self.ext_shader_subgroup_ballot as u64
            + self.ext_shader_subgroup_vote as u64 + self.ext_shader_tile_image as u64
            + self.ext_shader_viewport_index_layer as u64
            + self.ext_subgroup_size_control as u64
            + self.ext_subpass_merge_feedback as u64
            + self.ext_swapchain_maintenance1 as u64
            + self.ext_texel_buffer_alignment as u64
            + self.ext_texture_compression_astc_hdr as u64 + self.ext_tooling_info as u64
            + self.ext_transform_feedback as u64 + self.ext_validation_cache as u64
            + self.ext_vertex_attribute_divisor as u64
            + self.ext_vertex_input_dynamic_state as u64
            + self.ext_ycbcr_2plane_444_formats as u64
            + self.ext_ycbcr_image_arrays as u64 + self.amdx_shader_enqueue as u64
            + self.amd_buffer_marker as u64 + self.amd_device_coherent_memory as u64
            + self.amd_display_native_hdr as u64 + self.amd_draw_indirect_count as u64
            + self.amd_gcn_shader as u64 + self.amd_gpu_shader_half_float as u64
            + self.amd_gpu_shader_int16 as u64
            + self.amd_memory_overallocation_behavior as u64
            + self.amd_mixed_attachment_samples as u64
            + self.amd_pipeline_compiler_control as u64
            + self.amd_rasterization_order as u64 + self.amd_shader_ballot as u64
            + self.amd_shader_core_properties as u64
            + self.amd_shader_core_properties2 as u64
            + self.amd_shader_early_and_late_fragment_tests as u64
            + self.amd_shader_explicit_vertex_parameter as u64
            + self.amd_shader_fragment_mask as u64
            + self.amd_shader_image_load_store_lod as u64 + self.amd_shader_info as u64
            + self.amd_shader_trinary_minmax as u64
            + self.amd_texture_gather_bias_lod as u64
            + self.android_external_format_resolve as u64
            + self.android_external_memory_android_hardware_buffer as u64
            + self.arm_rasterization_order_attachment_access as u64
            + self.arm_render_pass_striped as u64 + self.arm_scheduling_controls as u64
            + self.arm_shader_core_builtins as u64
            + self.arm_shader_core_properties as u64
            + self.fuchsia_buffer_collection as u64 + self.fuchsia_external_memory as u64
            + self.fuchsia_external_semaphore as u64 + self.ggp_frame_token as u64
            + self.google_decorate_string as u64 + self.google_display_timing as u64
            + self.google_hlsl_functionality1 as u64 + self.google_user_type as u64
            + self.huawei_cluster_culling_shader as u64
            + self.huawei_invocation_mask as u64 + self.huawei_subpass_shading as u64
            + self.img_filter_cubic as u64 + self.img_format_pvrtc as u64
            + self.img_relaxed_line_rasterization as u64
            + self.intel_performance_query as u64
            + self.intel_shader_integer_functions2 as u64
            + self.msft_layered_driver as u64 + self.nvx_binary_import as u64
            + self.nvx_image_view_handle as u64
            + self.nvx_multiview_per_view_attributes as u64
            + self.nv_acquire_winrt_display as u64 + self.nv_clip_space_w_scaling as u64
            + self.nv_compute_shader_derivatives as u64
            + self.nv_cooperative_matrix as u64 + self.nv_copy_memory_indirect as u64
            + self.nv_corner_sampled_image as u64
            + self.nv_coverage_reduction_mode as u64 + self.nv_cuda_kernel_launch as u64
            + self.nv_dedicated_allocation as u64
            + self.nv_dedicated_allocation_image_aliasing as u64
            + self.nv_descriptor_pool_overallocation as u64
            + self.nv_device_diagnostic_checkpoints as u64
            + self.nv_device_diagnostics_config as u64
            + self.nv_device_generated_commands as u64
            + self.nv_device_generated_commands_compute as u64
            + self.nv_displacement_micromap as u64
            + self.nv_extended_sparse_address_space as u64
            + self.nv_external_memory as u64 + self.nv_external_memory_rdma as u64
            + self.nv_external_memory_win32 as u64 + self.nv_fill_rectangle as u64
            + self.nv_fragment_coverage_to_color as u64
            + self.nv_fragment_shader_barycentric as u64
            + self.nv_fragment_shading_rate_enums as u64
            + self.nv_framebuffer_mixed_samples as u64
            + self.nv_geometry_shader_passthrough as u64 + self.nv_glsl_shader as u64
            + self.nv_inherited_viewport_scissor as u64
            + self.nv_linear_color_attachment as u64 + self.nv_low_latency as u64
            + self.nv_low_latency2 as u64 + self.nv_memory_decompression as u64
            + self.nv_mesh_shader as u64 + self.nv_optical_flow as u64
            + self.nv_per_stage_descriptor_set as u64 + self.nv_present_barrier as u64
            + self.nv_raw_access_chains as u64 + self.nv_ray_tracing as u64
            + self.nv_ray_tracing_invocation_reorder as u64
            + self.nv_ray_tracing_motion_blur as u64
            + self.nv_ray_tracing_validation as u64
            + self.nv_representative_fragment_test as u64
            + self.nv_sample_mask_override_coverage as u64
            + self.nv_scissor_exclusive as u64
            + self.nv_shader_atomic_float16_vector as u64
            + self.nv_shader_image_footprint as u64 + self.nv_shader_sm_builtins as u64
            + self.nv_shader_subgroup_partitioned as u64
            + self.nv_shading_rate_image as u64 + self.nv_viewport_array2 as u64
            + self.nv_viewport_swizzle as u64 + self.nv_win32_keyed_mutex as u64
            + self.qcom_filter_cubic_clamp as u64 + self.qcom_filter_cubic_weights as u64
            + self.qcom_fragment_density_map_offset as u64
            + self.qcom_image_processing as u64 + self.qcom_image_processing2 as u64
            + self.qcom_multiview_per_view_render_areas as u64
            + self.qcom_multiview_per_view_viewports as u64
            + self.qcom_render_pass_shader_resolve as u64
            + self.qcom_render_pass_store_ops as u64
            + self.qcom_render_pass_transform as u64
            + self.qcom_rotated_copy_commands as u64 + self.qcom_tile_properties as u64
            + self.qcom_ycbcr_degamma as u64
            + self.qnx_external_memory_screen_buffer as u64
            + self.sec_amigo_profiling as u64
            + self.valve_descriptor_set_host_mapping as u64
            + self.valve_mutable_descriptor_type as u64
    }
    /// Returns whether no members are set in `self`.
    #[inline]
    pub const fn is_empty(self) -> bool {
        !(self.khr_16bit_storage || self.khr_8bit_storage
            || self.khr_acceleration_structure || self.khr_bind_memory2
            || self.khr_buffer_device_address || self.khr_calibrated_timestamps
            || self.khr_cooperative_matrix || self.khr_copy_commands2
            || self.khr_create_renderpass2 || self.khr_dedicated_allocation
            || self.khr_deferred_host_operations || self.khr_depth_stencil_resolve
            || self.khr_descriptor_update_template || self.khr_device_group
            || self.khr_display_swapchain || self.khr_draw_indirect_count
            || self.khr_driver_properties || self.khr_dynamic_rendering
            || self.khr_dynamic_rendering_local_read || self.khr_external_fence
            || self.khr_external_fence_fd || self.khr_external_fence_win32
            || self.khr_external_memory || self.khr_external_memory_fd
            || self.khr_external_memory_win32 || self.khr_external_semaphore
            || self.khr_external_semaphore_fd || self.khr_external_semaphore_win32
            || self.khr_format_feature_flags2 || self.khr_fragment_shader_barycentric
            || self.khr_fragment_shading_rate || self.khr_get_memory_requirements2
            || self.khr_global_priority || self.khr_image_format_list
            || self.khr_imageless_framebuffer || self.khr_incremental_present
            || self.khr_index_type_uint8 || self.khr_line_rasterization
            || self.khr_load_store_op_none || self.khr_maintenance1
            || self.khr_maintenance2 || self.khr_maintenance3 || self.khr_maintenance4
            || self.khr_maintenance5 || self.khr_maintenance6 || self.khr_map_memory2
            || self.khr_multiview || self.khr_performance_query
            || self.khr_pipeline_executable_properties || self.khr_pipeline_library
            || self.khr_portability_subset || self.khr_present_id
            || self.khr_present_wait || self.khr_push_descriptor || self.khr_ray_query
            || self.khr_ray_tracing_maintenance1 || self.khr_ray_tracing_pipeline
            || self.khr_ray_tracing_position_fetch || self.khr_relaxed_block_layout
            || self.khr_sampler_mirror_clamp_to_edge || self.khr_sampler_ycbcr_conversion
            || self.khr_separate_depth_stencil_layouts || self.khr_shader_atomic_int64
            || self.khr_shader_clock || self.khr_shader_draw_parameters
            || self.khr_shader_expect_assume || self.khr_shader_float16_int8
            || self.khr_shader_float_controls || self.khr_shader_float_controls2
            || self.khr_shader_integer_dot_product
            || self.khr_shader_maximal_reconvergence || self.khr_shader_non_semantic_info
            || self.khr_shader_quad_control || self.khr_shader_subgroup_extended_types
            || self.khr_shader_subgroup_rotate
            || self.khr_shader_subgroup_uniform_control_flow
            || self.khr_shader_terminate_invocation || self.khr_shared_presentable_image
            || self.khr_spirv_1_4 || self.khr_storage_buffer_storage_class
            || self.khr_swapchain || self.khr_swapchain_mutable_format
            || self.khr_synchronization2 || self.khr_timeline_semaphore
            || self.khr_uniform_buffer_standard_layout || self.khr_variable_pointers
            || self.khr_vertex_attribute_divisor || self.khr_video_decode_av1
            || self.khr_video_decode_h264 || self.khr_video_decode_h265
            || self.khr_video_decode_queue || self.khr_video_encode_h264
            || self.khr_video_encode_h265 || self.khr_video_encode_queue
            || self.khr_video_maintenance1 || self.khr_video_queue
            || self.khr_vulkan_memory_model || self.khr_win32_keyed_mutex
            || self.khr_workgroup_memory_explicit_layout
            || self.khr_zero_initialize_workgroup_memory || self.ext_4444_formats
            || self.ext_astc_decode_mode
            || self.ext_attachment_feedback_loop_dynamic_state
            || self.ext_attachment_feedback_loop_layout
            || self.ext_blend_operation_advanced || self.ext_border_color_swizzle
            || self.ext_buffer_device_address || self.ext_calibrated_timestamps
            || self.ext_color_write_enable || self.ext_conditional_rendering
            || self.ext_conservative_rasterization || self.ext_custom_border_color
            || self.ext_debug_marker || self.ext_depth_bias_control
            || self.ext_depth_clamp_zero_one || self.ext_depth_clip_control
            || self.ext_depth_clip_enable || self.ext_depth_range_unrestricted
            || self.ext_descriptor_buffer || self.ext_descriptor_indexing
            || self.ext_device_address_binding_report || self.ext_device_fault
            || self.ext_device_memory_report || self.ext_discard_rectangles
            || self.ext_display_control || self.ext_dynamic_rendering_unused_attachments
            || self.ext_extended_dynamic_state || self.ext_extended_dynamic_state2
            || self.ext_extended_dynamic_state3
            || self.ext_external_memory_acquire_unmodified
            || self.ext_external_memory_dma_buf || self.ext_external_memory_host
            || self.ext_filter_cubic || self.ext_fragment_density_map
            || self.ext_fragment_density_map2 || self.ext_fragment_shader_interlock
            || self.ext_frame_boundary || self.ext_full_screen_exclusive
            || self.ext_global_priority || self.ext_global_priority_query
            || self.ext_graphics_pipeline_library || self.ext_hdr_metadata
            || self.ext_host_image_copy || self.ext_host_query_reset
            || self.ext_image_2d_view_of_3d || self.ext_image_compression_control
            || self.ext_image_compression_control_swapchain
            || self.ext_image_drm_format_modifier || self.ext_image_robustness
            || self.ext_image_sliced_view_of_3d || self.ext_image_view_min_lod
            || self.ext_index_type_uint8 || self.ext_inline_uniform_block
            || self.ext_legacy_dithering || self.ext_line_rasterization
            || self.ext_load_store_op_none || self.ext_map_memory_placed
            || self.ext_memory_budget || self.ext_memory_priority || self.ext_mesh_shader
            || self.ext_metal_objects || self.ext_multi_draw
            || self.ext_multisampled_render_to_single_sampled
            || self.ext_mutable_descriptor_type || self.ext_nested_command_buffer
            || self.ext_non_seamless_cube_map || self.ext_opacity_micromap
            || self.ext_pageable_device_local_memory || self.ext_pci_bus_info
            || self.ext_physical_device_drm || self.ext_pipeline_creation_cache_control
            || self.ext_pipeline_creation_feedback
            || self.ext_pipeline_library_group_handles || self.ext_pipeline_properties
            || self.ext_pipeline_protected_access || self.ext_pipeline_robustness
            || self.ext_post_depth_coverage || self.ext_primitive_topology_list_restart
            || self.ext_primitives_generated_query || self.ext_private_data
            || self.ext_provoking_vertex || self.ext_queue_family_foreign
            || self.ext_rasterization_order_attachment_access
            || self.ext_rgba10x6_formats || self.ext_robustness2
            || self.ext_sample_locations || self.ext_sampler_filter_minmax
            || self.ext_scalar_block_layout || self.ext_separate_stencil_usage
            || self.ext_shader_atomic_float || self.ext_shader_atomic_float2
            || self.ext_shader_demote_to_helper_invocation
            || self.ext_shader_image_atomic_int64 || self.ext_shader_module_identifier
            || self.ext_shader_object || self.ext_shader_stencil_export
            || self.ext_shader_subgroup_ballot || self.ext_shader_subgroup_vote
            || self.ext_shader_tile_image || self.ext_shader_viewport_index_layer
            || self.ext_subgroup_size_control || self.ext_subpass_merge_feedback
            || self.ext_swapchain_maintenance1 || self.ext_texel_buffer_alignment
            || self.ext_texture_compression_astc_hdr || self.ext_tooling_info
            || self.ext_transform_feedback || self.ext_validation_cache
            || self.ext_vertex_attribute_divisor || self.ext_vertex_input_dynamic_state
            || self.ext_ycbcr_2plane_444_formats || self.ext_ycbcr_image_arrays
            || self.amdx_shader_enqueue || self.amd_buffer_marker
            || self.amd_device_coherent_memory || self.amd_display_native_hdr
            || self.amd_draw_indirect_count || self.amd_gcn_shader
            || self.amd_gpu_shader_half_float || self.amd_gpu_shader_int16
            || self.amd_memory_overallocation_behavior
            || self.amd_mixed_attachment_samples || self.amd_pipeline_compiler_control
            || self.amd_rasterization_order || self.amd_shader_ballot
            || self.amd_shader_core_properties || self.amd_shader_core_properties2
            || self.amd_shader_early_and_late_fragment_tests
            || self.amd_shader_explicit_vertex_parameter || self.amd_shader_fragment_mask
            || self.amd_shader_image_load_store_lod || self.amd_shader_info
            || self.amd_shader_trinary_minmax || self.amd_texture_gather_bias_lod
            || self.android_external_format_resolve
            || self.android_external_memory_android_hardware_buffer
            || self.arm_rasterization_order_attachment_access
            || self.arm_render_pass_striped || self.arm_scheduling_controls
            || self.arm_shader_core_builtins || self.arm_shader_core_properties
            || self.fuchsia_buffer_collection || self.fuchsia_external_memory
            || self.fuchsia_external_semaphore || self.ggp_frame_token
            || self.google_decorate_string || self.google_display_timing
            || self.google_hlsl_functionality1 || self.google_user_type
            || self.huawei_cluster_culling_shader || self.huawei_invocation_mask
            || self.huawei_subpass_shading || self.img_filter_cubic
            || self.img_format_pvrtc || self.img_relaxed_line_rasterization
            || self.intel_performance_query || self.intel_shader_integer_functions2
            || self.msft_layered_driver || self.nvx_binary_import
            || self.nvx_image_view_handle || self.nvx_multiview_per_view_attributes
            || self.nv_acquire_winrt_display || self.nv_clip_space_w_scaling
            || self.nv_compute_shader_derivatives || self.nv_cooperative_matrix
            || self.nv_copy_memory_indirect || self.nv_corner_sampled_image
            || self.nv_coverage_reduction_mode || self.nv_cuda_kernel_launch
            || self.nv_dedicated_allocation
            || self.nv_dedicated_allocation_image_aliasing
            || self.nv_descriptor_pool_overallocation
            || self.nv_device_diagnostic_checkpoints || self.nv_device_diagnostics_config
            || self.nv_device_generated_commands
            || self.nv_device_generated_commands_compute || self.nv_displacement_micromap
            || self.nv_extended_sparse_address_space || self.nv_external_memory
            || self.nv_external_memory_rdma || self.nv_external_memory_win32
            || self.nv_fill_rectangle || self.nv_fragment_coverage_to_color
            || self.nv_fragment_shader_barycentric || self.nv_fragment_shading_rate_enums
            || self.nv_framebuffer_mixed_samples || self.nv_geometry_shader_passthrough
            || self.nv_glsl_shader || self.nv_inherited_viewport_scissor
            || self.nv_linear_color_attachment || self.nv_low_latency
            || self.nv_low_latency2 || self.nv_memory_decompression
            || self.nv_mesh_shader || self.nv_optical_flow
            || self.nv_per_stage_descriptor_set || self.nv_present_barrier
            || self.nv_raw_access_chains || self.nv_ray_tracing
            || self.nv_ray_tracing_invocation_reorder || self.nv_ray_tracing_motion_blur
            || self.nv_ray_tracing_validation || self.nv_representative_fragment_test
            || self.nv_sample_mask_override_coverage || self.nv_scissor_exclusive
            || self.nv_shader_atomic_float16_vector || self.nv_shader_image_footprint
            || self.nv_shader_sm_builtins || self.nv_shader_subgroup_partitioned
            || self.nv_shading_rate_image || self.nv_viewport_array2
            || self.nv_viewport_swizzle || self.nv_win32_keyed_mutex
            || self.qcom_filter_cubic_clamp || self.qcom_filter_cubic_weights
            || self.qcom_fragment_density_map_offset || self.qcom_image_processing
            || self.qcom_image_processing2 || self.qcom_multiview_per_view_render_areas
            || self.qcom_multiview_per_view_viewports
            || self.qcom_render_pass_shader_resolve || self.qcom_render_pass_store_ops
            || self.qcom_render_pass_transform || self.qcom_rotated_copy_commands
            || self.qcom_tile_properties || self.qcom_ycbcr_degamma
            || self.qnx_external_memory_screen_buffer || self.sec_amigo_profiling
            || self.valve_descriptor_set_host_mapping
            || self.valve_mutable_descriptor_type)
    }
    /// Returns whether any members are set in both `self` and `other`.
    #[inline]
    pub const fn intersects(&self, other: &Self) -> bool {
        (self.khr_16bit_storage && other.khr_16bit_storage)
            || (self.khr_8bit_storage && other.khr_8bit_storage)
            || (self.khr_acceleration_structure && other.khr_acceleration_structure)
            || (self.khr_bind_memory2 && other.khr_bind_memory2)
            || (self.khr_buffer_device_address && other.khr_buffer_device_address)
            || (self.khr_calibrated_timestamps && other.khr_calibrated_timestamps)
            || (self.khr_cooperative_matrix && other.khr_cooperative_matrix)
            || (self.khr_copy_commands2 && other.khr_copy_commands2)
            || (self.khr_create_renderpass2 && other.khr_create_renderpass2)
            || (self.khr_dedicated_allocation && other.khr_dedicated_allocation)
            || (self.khr_deferred_host_operations && other.khr_deferred_host_operations)
            || (self.khr_depth_stencil_resolve && other.khr_depth_stencil_resolve)
            || (self.khr_descriptor_update_template
                && other.khr_descriptor_update_template)
            || (self.khr_device_group && other.khr_device_group)
            || (self.khr_display_swapchain && other.khr_display_swapchain)
            || (self.khr_draw_indirect_count && other.khr_draw_indirect_count)
            || (self.khr_driver_properties && other.khr_driver_properties)
            || (self.khr_dynamic_rendering && other.khr_dynamic_rendering)
            || (self.khr_dynamic_rendering_local_read
                && other.khr_dynamic_rendering_local_read)
            || (self.khr_external_fence && other.khr_external_fence)
            || (self.khr_external_fence_fd && other.khr_external_fence_fd)
            || (self.khr_external_fence_win32 && other.khr_external_fence_win32)
            || (self.khr_external_memory && other.khr_external_memory)
            || (self.khr_external_memory_fd && other.khr_external_memory_fd)
            || (self.khr_external_memory_win32 && other.khr_external_memory_win32)
            || (self.khr_external_semaphore && other.khr_external_semaphore)
            || (self.khr_external_semaphore_fd && other.khr_external_semaphore_fd)
            || (self.khr_external_semaphore_win32 && other.khr_external_semaphore_win32)
            || (self.khr_format_feature_flags2 && other.khr_format_feature_flags2)
            || (self.khr_fragment_shader_barycentric
                && other.khr_fragment_shader_barycentric)
            || (self.khr_fragment_shading_rate && other.khr_fragment_shading_rate)
            || (self.khr_get_memory_requirements2 && other.khr_get_memory_requirements2)
            || (self.khr_global_priority && other.khr_global_priority)
            || (self.khr_image_format_list && other.khr_image_format_list)
            || (self.khr_imageless_framebuffer && other.khr_imageless_framebuffer)
            || (self.khr_incremental_present && other.khr_incremental_present)
            || (self.khr_index_type_uint8 && other.khr_index_type_uint8)
            || (self.khr_line_rasterization && other.khr_line_rasterization)
            || (self.khr_load_store_op_none && other.khr_load_store_op_none)
            || (self.khr_maintenance1 && other.khr_maintenance1)
            || (self.khr_maintenance2 && other.khr_maintenance2)
            || (self.khr_maintenance3 && other.khr_maintenance3)
            || (self.khr_maintenance4 && other.khr_maintenance4)
            || (self.khr_maintenance5 && other.khr_maintenance5)
            || (self.khr_maintenance6 && other.khr_maintenance6)
            || (self.khr_map_memory2 && other.khr_map_memory2)
            || (self.khr_multiview && other.khr_multiview)
            || (self.khr_performance_query && other.khr_performance_query)
            || (self.khr_pipeline_executable_properties
                && other.khr_pipeline_executable_properties)
            || (self.khr_pipeline_library && other.khr_pipeline_library)
            || (self.khr_portability_subset && other.khr_portability_subset)
            || (self.khr_present_id && other.khr_present_id)
            || (self.khr_present_wait && other.khr_present_wait)
            || (self.khr_push_descriptor && other.khr_push_descriptor)
            || (self.khr_ray_query && other.khr_ray_query)
            || (self.khr_ray_tracing_maintenance1 && other.khr_ray_tracing_maintenance1)
            || (self.khr_ray_tracing_pipeline && other.khr_ray_tracing_pipeline)
            || (self.khr_ray_tracing_position_fetch
                && other.khr_ray_tracing_position_fetch)
            || (self.khr_relaxed_block_layout && other.khr_relaxed_block_layout)
            || (self.khr_sampler_mirror_clamp_to_edge
                && other.khr_sampler_mirror_clamp_to_edge)
            || (self.khr_sampler_ycbcr_conversion && other.khr_sampler_ycbcr_conversion)
            || (self.khr_separate_depth_stencil_layouts
                && other.khr_separate_depth_stencil_layouts)
            || (self.khr_shader_atomic_int64 && other.khr_shader_atomic_int64)
            || (self.khr_shader_clock && other.khr_shader_clock)
            || (self.khr_shader_draw_parameters && other.khr_shader_draw_parameters)
            || (self.khr_shader_expect_assume && other.khr_shader_expect_assume)
            || (self.khr_shader_float16_int8 && other.khr_shader_float16_int8)
            || (self.khr_shader_float_controls && other.khr_shader_float_controls)
            || (self.khr_shader_float_controls2 && other.khr_shader_float_controls2)
            || (self.khr_shader_integer_dot_product
                && other.khr_shader_integer_dot_product)
            || (self.khr_shader_maximal_reconvergence
                && other.khr_shader_maximal_reconvergence)
            || (self.khr_shader_non_semantic_info && other.khr_shader_non_semantic_info)
            || (self.khr_shader_quad_control && other.khr_shader_quad_control)
            || (self.khr_shader_subgroup_extended_types
                && other.khr_shader_subgroup_extended_types)
            || (self.khr_shader_subgroup_rotate && other.khr_shader_subgroup_rotate)
            || (self.khr_shader_subgroup_uniform_control_flow
                && other.khr_shader_subgroup_uniform_control_flow)
            || (self.khr_shader_terminate_invocation
                && other.khr_shader_terminate_invocation)
            || (self.khr_shared_presentable_image && other.khr_shared_presentable_image)
            || (self.khr_spirv_1_4 && other.khr_spirv_1_4)
            || (self.khr_storage_buffer_storage_class
                && other.khr_storage_buffer_storage_class)
            || (self.khr_swapchain && other.khr_swapchain)
            || (self.khr_swapchain_mutable_format && other.khr_swapchain_mutable_format)
            || (self.khr_synchronization2 && other.khr_synchronization2)
            || (self.khr_timeline_semaphore && other.khr_timeline_semaphore)
            || (self.khr_uniform_buffer_standard_layout
                && other.khr_uniform_buffer_standard_layout)
            || (self.khr_variable_pointers && other.khr_variable_pointers)
            || (self.khr_vertex_attribute_divisor && other.khr_vertex_attribute_divisor)
            || (self.khr_video_decode_av1 && other.khr_video_decode_av1)
            || (self.khr_video_decode_h264 && other.khr_video_decode_h264)
            || (self.khr_video_decode_h265 && other.khr_video_decode_h265)
            || (self.khr_video_decode_queue && other.khr_video_decode_queue)
            || (self.khr_video_encode_h264 && other.khr_video_encode_h264)
            || (self.khr_video_encode_h265 && other.khr_video_encode_h265)
            || (self.khr_video_encode_queue && other.khr_video_encode_queue)
            || (self.khr_video_maintenance1 && other.khr_video_maintenance1)
            || (self.khr_video_queue && other.khr_video_queue)
            || (self.khr_vulkan_memory_model && other.khr_vulkan_memory_model)
            || (self.khr_win32_keyed_mutex && other.khr_win32_keyed_mutex)
            || (self.khr_workgroup_memory_explicit_layout
                && other.khr_workgroup_memory_explicit_layout)
            || (self.khr_zero_initialize_workgroup_memory
                && other.khr_zero_initialize_workgroup_memory)
            || (self.ext_4444_formats && other.ext_4444_formats)
            || (self.ext_astc_decode_mode && other.ext_astc_decode_mode)
            || (self.ext_attachment_feedback_loop_dynamic_state
                && other.ext_attachment_feedback_loop_dynamic_state)
            || (self.ext_attachment_feedback_loop_layout
                && other.ext_attachment_feedback_loop_layout)
            || (self.ext_blend_operation_advanced && other.ext_blend_operation_advanced)
            || (self.ext_border_color_swizzle && other.ext_border_color_swizzle)
            || (self.ext_buffer_device_address && other.ext_buffer_device_address)
            || (self.ext_calibrated_timestamps && other.ext_calibrated_timestamps)
            || (self.ext_color_write_enable && other.ext_color_write_enable)
            || (self.ext_conditional_rendering && other.ext_conditional_rendering)
            || (self.ext_conservative_rasterization
                && other.ext_conservative_rasterization)
            || (self.ext_custom_border_color && other.ext_custom_border_color)
            || (self.ext_debug_marker && other.ext_debug_marker)
            || (self.ext_depth_bias_control && other.ext_depth_bias_control)
            || (self.ext_depth_clamp_zero_one && other.ext_depth_clamp_zero_one)
            || (self.ext_depth_clip_control && other.ext_depth_clip_control)
            || (self.ext_depth_clip_enable && other.ext_depth_clip_enable)
            || (self.ext_depth_range_unrestricted && other.ext_depth_range_unrestricted)
            || (self.ext_descriptor_buffer && other.ext_descriptor_buffer)
            || (self.ext_descriptor_indexing && other.ext_descriptor_indexing)
            || (self.ext_device_address_binding_report
                && other.ext_device_address_binding_report)
            || (self.ext_device_fault && other.ext_device_fault)
            || (self.ext_device_memory_report && other.ext_device_memory_report)
            || (self.ext_discard_rectangles && other.ext_discard_rectangles)
            || (self.ext_display_control && other.ext_display_control)
            || (self.ext_dynamic_rendering_unused_attachments
                && other.ext_dynamic_rendering_unused_attachments)
            || (self.ext_extended_dynamic_state && other.ext_extended_dynamic_state)
            || (self.ext_extended_dynamic_state2 && other.ext_extended_dynamic_state2)
            || (self.ext_extended_dynamic_state3 && other.ext_extended_dynamic_state3)
            || (self.ext_external_memory_acquire_unmodified
                && other.ext_external_memory_acquire_unmodified)
            || (self.ext_external_memory_dma_buf && other.ext_external_memory_dma_buf)
            || (self.ext_external_memory_host && other.ext_external_memory_host)
            || (self.ext_filter_cubic && other.ext_filter_cubic)
            || (self.ext_fragment_density_map && other.ext_fragment_density_map)
            || (self.ext_fragment_density_map2 && other.ext_fragment_density_map2)
            || (self.ext_fragment_shader_interlock
                && other.ext_fragment_shader_interlock)
            || (self.ext_frame_boundary && other.ext_frame_boundary)
            || (self.ext_full_screen_exclusive && other.ext_full_screen_exclusive)
            || (self.ext_global_priority && other.ext_global_priority)
            || (self.ext_global_priority_query && other.ext_global_priority_query)
            || (self.ext_graphics_pipeline_library
                && other.ext_graphics_pipeline_library)
            || (self.ext_hdr_metadata && other.ext_hdr_metadata)
            || (self.ext_host_image_copy && other.ext_host_image_copy)
            || (self.ext_host_query_reset && other.ext_host_query_reset)
            || (self.ext_image_2d_view_of_3d && other.ext_image_2d_view_of_3d)
            || (self.ext_image_compression_control
                && other.ext_image_compression_control)
            || (self.ext_image_compression_control_swapchain
                && other.ext_image_compression_control_swapchain)
            || (self.ext_image_drm_format_modifier
                && other.ext_image_drm_format_modifier)
            || (self.ext_image_robustness && other.ext_image_robustness)
            || (self.ext_image_sliced_view_of_3d && other.ext_image_sliced_view_of_3d)
            || (self.ext_image_view_min_lod && other.ext_image_view_min_lod)
            || (self.ext_index_type_uint8 && other.ext_index_type_uint8)
            || (self.ext_inline_uniform_block && other.ext_inline_uniform_block)
            || (self.ext_legacy_dithering && other.ext_legacy_dithering)
            || (self.ext_line_rasterization && other.ext_line_rasterization)
            || (self.ext_load_store_op_none && other.ext_load_store_op_none)
            || (self.ext_map_memory_placed && other.ext_map_memory_placed)
            || (self.ext_memory_budget && other.ext_memory_budget)
            || (self.ext_memory_priority && other.ext_memory_priority)
            || (self.ext_mesh_shader && other.ext_mesh_shader)
            || (self.ext_metal_objects && other.ext_metal_objects)
            || (self.ext_multi_draw && other.ext_multi_draw)
            || (self.ext_multisampled_render_to_single_sampled
                && other.ext_multisampled_render_to_single_sampled)
            || (self.ext_mutable_descriptor_type && other.ext_mutable_descriptor_type)
            || (self.ext_nested_command_buffer && other.ext_nested_command_buffer)
            || (self.ext_non_seamless_cube_map && other.ext_non_seamless_cube_map)
            || (self.ext_opacity_micromap && other.ext_opacity_micromap)
            || (self.ext_pageable_device_local_memory
                && other.ext_pageable_device_local_memory)
            || (self.ext_pci_bus_info && other.ext_pci_bus_info)
            || (self.ext_physical_device_drm && other.ext_physical_device_drm)
            || (self.ext_pipeline_creation_cache_control
                && other.ext_pipeline_creation_cache_control)
            || (self.ext_pipeline_creation_feedback
                && other.ext_pipeline_creation_feedback)
            || (self.ext_pipeline_library_group_handles
                && other.ext_pipeline_library_group_handles)
            || (self.ext_pipeline_properties && other.ext_pipeline_properties)
            || (self.ext_pipeline_protected_access
                && other.ext_pipeline_protected_access)
            || (self.ext_pipeline_robustness && other.ext_pipeline_robustness)
            || (self.ext_post_depth_coverage && other.ext_post_depth_coverage)
            || (self.ext_primitive_topology_list_restart
                && other.ext_primitive_topology_list_restart)
            || (self.ext_primitives_generated_query
                && other.ext_primitives_generated_query)
            || (self.ext_private_data && other.ext_private_data)
            || (self.ext_provoking_vertex && other.ext_provoking_vertex)
            || (self.ext_queue_family_foreign && other.ext_queue_family_foreign)
            || (self.ext_rasterization_order_attachment_access
                && other.ext_rasterization_order_attachment_access)
            || (self.ext_rgba10x6_formats && other.ext_rgba10x6_formats)
            || (self.ext_robustness2 && other.ext_robustness2)
            || (self.ext_sample_locations && other.ext_sample_locations)
            || (self.ext_sampler_filter_minmax && other.ext_sampler_filter_minmax)
            || (self.ext_scalar_block_layout && other.ext_scalar_block_layout)
            || (self.ext_separate_stencil_usage && other.ext_separate_stencil_usage)
            || (self.ext_shader_atomic_float && other.ext_shader_atomic_float)
            || (self.ext_shader_atomic_float2 && other.ext_shader_atomic_float2)
            || (self.ext_shader_demote_to_helper_invocation
                && other.ext_shader_demote_to_helper_invocation)
            || (self.ext_shader_image_atomic_int64
                && other.ext_shader_image_atomic_int64)
            || (self.ext_shader_module_identifier && other.ext_shader_module_identifier)
            || (self.ext_shader_object && other.ext_shader_object)
            || (self.ext_shader_stencil_export && other.ext_shader_stencil_export)
            || (self.ext_shader_subgroup_ballot && other.ext_shader_subgroup_ballot)
            || (self.ext_shader_subgroup_vote && other.ext_shader_subgroup_vote)
            || (self.ext_shader_tile_image && other.ext_shader_tile_image)
            || (self.ext_shader_viewport_index_layer
                && other.ext_shader_viewport_index_layer)
            || (self.ext_subgroup_size_control && other.ext_subgroup_size_control)
            || (self.ext_subpass_merge_feedback && other.ext_subpass_merge_feedback)
            || (self.ext_swapchain_maintenance1 && other.ext_swapchain_maintenance1)
            || (self.ext_texel_buffer_alignment && other.ext_texel_buffer_alignment)
            || (self.ext_texture_compression_astc_hdr
                && other.ext_texture_compression_astc_hdr)
            || (self.ext_tooling_info && other.ext_tooling_info)
            || (self.ext_transform_feedback && other.ext_transform_feedback)
            || (self.ext_validation_cache && other.ext_validation_cache)
            || (self.ext_vertex_attribute_divisor && other.ext_vertex_attribute_divisor)
            || (self.ext_vertex_input_dynamic_state
                && other.ext_vertex_input_dynamic_state)
            || (self.ext_ycbcr_2plane_444_formats && other.ext_ycbcr_2plane_444_formats)
            || (self.ext_ycbcr_image_arrays && other.ext_ycbcr_image_arrays)
            || (self.amdx_shader_enqueue && other.amdx_shader_enqueue)
            || (self.amd_buffer_marker && other.amd_buffer_marker)
            || (self.amd_device_coherent_memory && other.amd_device_coherent_memory)
            || (self.amd_display_native_hdr && other.amd_display_native_hdr)
            || (self.amd_draw_indirect_count && other.amd_draw_indirect_count)
            || (self.amd_gcn_shader && other.amd_gcn_shader)
            || (self.amd_gpu_shader_half_float && other.amd_gpu_shader_half_float)
            || (self.amd_gpu_shader_int16 && other.amd_gpu_shader_int16)
            || (self.amd_memory_overallocation_behavior
                && other.amd_memory_overallocation_behavior)
            || (self.amd_mixed_attachment_samples && other.amd_mixed_attachment_samples)
            || (self.amd_pipeline_compiler_control
                && other.amd_pipeline_compiler_control)
            || (self.amd_rasterization_order && other.amd_rasterization_order)
            || (self.amd_shader_ballot && other.amd_shader_ballot)
            || (self.amd_shader_core_properties && other.amd_shader_core_properties)
            || (self.amd_shader_core_properties2 && other.amd_shader_core_properties2)
            || (self.amd_shader_early_and_late_fragment_tests
                && other.amd_shader_early_and_late_fragment_tests)
            || (self.amd_shader_explicit_vertex_parameter
                && other.amd_shader_explicit_vertex_parameter)
            || (self.amd_shader_fragment_mask && other.amd_shader_fragment_mask)
            || (self.amd_shader_image_load_store_lod
                && other.amd_shader_image_load_store_lod)
            || (self.amd_shader_info && other.amd_shader_info)
            || (self.amd_shader_trinary_minmax && other.amd_shader_trinary_minmax)
            || (self.amd_texture_gather_bias_lod && other.amd_texture_gather_bias_lod)
            || (self.android_external_format_resolve
                && other.android_external_format_resolve)
            || (self.android_external_memory_android_hardware_buffer
                && other.android_external_memory_android_hardware_buffer)
            || (self.arm_rasterization_order_attachment_access
                && other.arm_rasterization_order_attachment_access)
            || (self.arm_render_pass_striped && other.arm_render_pass_striped)
            || (self.arm_scheduling_controls && other.arm_scheduling_controls)
            || (self.arm_shader_core_builtins && other.arm_shader_core_builtins)
            || (self.arm_shader_core_properties && other.arm_shader_core_properties)
            || (self.fuchsia_buffer_collection && other.fuchsia_buffer_collection)
            || (self.fuchsia_external_memory && other.fuchsia_external_memory)
            || (self.fuchsia_external_semaphore && other.fuchsia_external_semaphore)
            || (self.ggp_frame_token && other.ggp_frame_token)
            || (self.google_decorate_string && other.google_decorate_string)
            || (self.google_display_timing && other.google_display_timing)
            || (self.google_hlsl_functionality1 && other.google_hlsl_functionality1)
            || (self.google_user_type && other.google_user_type)
            || (self.huawei_cluster_culling_shader
                && other.huawei_cluster_culling_shader)
            || (self.huawei_invocation_mask && other.huawei_invocation_mask)
            || (self.huawei_subpass_shading && other.huawei_subpass_shading)
            || (self.img_filter_cubic && other.img_filter_cubic)
            || (self.img_format_pvrtc && other.img_format_pvrtc)
            || (self.img_relaxed_line_rasterization
                && other.img_relaxed_line_rasterization)
            || (self.intel_performance_query && other.intel_performance_query)
            || (self.intel_shader_integer_functions2
                && other.intel_shader_integer_functions2)
            || (self.msft_layered_driver && other.msft_layered_driver)
            || (self.nvx_binary_import && other.nvx_binary_import)
            || (self.nvx_image_view_handle && other.nvx_image_view_handle)
            || (self.nvx_multiview_per_view_attributes
                && other.nvx_multiview_per_view_attributes)
            || (self.nv_acquire_winrt_display && other.nv_acquire_winrt_display)
            || (self.nv_clip_space_w_scaling && other.nv_clip_space_w_scaling)
            || (self.nv_compute_shader_derivatives
                && other.nv_compute_shader_derivatives)
            || (self.nv_cooperative_matrix && other.nv_cooperative_matrix)
            || (self.nv_copy_memory_indirect && other.nv_copy_memory_indirect)
            || (self.nv_corner_sampled_image && other.nv_corner_sampled_image)
            || (self.nv_coverage_reduction_mode && other.nv_coverage_reduction_mode)
            || (self.nv_cuda_kernel_launch && other.nv_cuda_kernel_launch)
            || (self.nv_dedicated_allocation && other.nv_dedicated_allocation)
            || (self.nv_dedicated_allocation_image_aliasing
                && other.nv_dedicated_allocation_image_aliasing)
            || (self.nv_descriptor_pool_overallocation
                && other.nv_descriptor_pool_overallocation)
            || (self.nv_device_diagnostic_checkpoints
                && other.nv_device_diagnostic_checkpoints)
            || (self.nv_device_diagnostics_config && other.nv_device_diagnostics_config)
            || (self.nv_device_generated_commands && other.nv_device_generated_commands)
            || (self.nv_device_generated_commands_compute
                && other.nv_device_generated_commands_compute)
            || (self.nv_displacement_micromap && other.nv_displacement_micromap)
            || (self.nv_extended_sparse_address_space
                && other.nv_extended_sparse_address_space)
            || (self.nv_external_memory && other.nv_external_memory)
            || (self.nv_external_memory_rdma && other.nv_external_memory_rdma)
            || (self.nv_external_memory_win32 && other.nv_external_memory_win32)
            || (self.nv_fill_rectangle && other.nv_fill_rectangle)
            || (self.nv_fragment_coverage_to_color
                && other.nv_fragment_coverage_to_color)
            || (self.nv_fragment_shader_barycentric
                && other.nv_fragment_shader_barycentric)
            || (self.nv_fragment_shading_rate_enums
                && other.nv_fragment_shading_rate_enums)
            || (self.nv_framebuffer_mixed_samples && other.nv_framebuffer_mixed_samples)
            || (self.nv_geometry_shader_passthrough
                && other.nv_geometry_shader_passthrough)
            || (self.nv_glsl_shader && other.nv_glsl_shader)
            || (self.nv_inherited_viewport_scissor
                && other.nv_inherited_viewport_scissor)
            || (self.nv_linear_color_attachment && other.nv_linear_color_attachment)
            || (self.nv_low_latency && other.nv_low_latency)
            || (self.nv_low_latency2 && other.nv_low_latency2)
            || (self.nv_memory_decompression && other.nv_memory_decompression)
            || (self.nv_mesh_shader && other.nv_mesh_shader)
            || (self.nv_optical_flow && other.nv_optical_flow)
            || (self.nv_per_stage_descriptor_set && other.nv_per_stage_descriptor_set)
            || (self.nv_present_barrier && other.nv_present_barrier)
            || (self.nv_raw_access_chains && other.nv_raw_access_chains)
            || (self.nv_ray_tracing && other.nv_ray_tracing)
            || (self.nv_ray_tracing_invocation_reorder
                && other.nv_ray_tracing_invocation_reorder)
            || (self.nv_ray_tracing_motion_blur && other.nv_ray_tracing_motion_blur)
            || (self.nv_ray_tracing_validation && other.nv_ray_tracing_validation)
            || (self.nv_representative_fragment_test
                && other.nv_representative_fragment_test)
            || (self.nv_sample_mask_override_coverage
                && other.nv_sample_mask_override_coverage)
            || (self.nv_scissor_exclusive && other.nv_scissor_exclusive)
            || (self.nv_shader_atomic_float16_vector
                && other.nv_shader_atomic_float16_vector)
            || (self.nv_shader_image_footprint && other.nv_shader_image_footprint)
            || (self.nv_shader_sm_builtins && other.nv_shader_sm_builtins)
            || (self.nv_shader_subgroup_partitioned
                && other.nv_shader_subgroup_partitioned)
            || (self.nv_shading_rate_image && other.nv_shading_rate_image)
            || (self.nv_viewport_array2 && other.nv_viewport_array2)
            || (self.nv_viewport_swizzle && other.nv_viewport_swizzle)
            || (self.nv_win32_keyed_mutex && other.nv_win32_keyed_mutex)
            || (self.qcom_filter_cubic_clamp && other.qcom_filter_cubic_clamp)
            || (self.qcom_filter_cubic_weights && other.qcom_filter_cubic_weights)
            || (self.qcom_fragment_density_map_offset
                && other.qcom_fragment_density_map_offset)
            || (self.qcom_image_processing && other.qcom_image_processing)
            || (self.qcom_image_processing2 && other.qcom_image_processing2)
            || (self.qcom_multiview_per_view_render_areas
                && other.qcom_multiview_per_view_render_areas)
            || (self.qcom_multiview_per_view_viewports
                && other.qcom_multiview_per_view_viewports)
            || (self.qcom_render_pass_shader_resolve
                && other.qcom_render_pass_shader_resolve)
            || (self.qcom_render_pass_store_ops && other.qcom_render_pass_store_ops)
            || (self.qcom_render_pass_transform && other.qcom_render_pass_transform)
            || (self.qcom_rotated_copy_commands && other.qcom_rotated_copy_commands)
            || (self.qcom_tile_properties && other.qcom_tile_properties)
            || (self.qcom_ycbcr_degamma && other.qcom_ycbcr_degamma)
            || (self.qnx_external_memory_screen_buffer
                && other.qnx_external_memory_screen_buffer)
            || (self.sec_amigo_profiling && other.sec_amigo_profiling)
            || (self.valve_descriptor_set_host_mapping
                && other.valve_descriptor_set_host_mapping)
            || (self.valve_mutable_descriptor_type
                && other.valve_mutable_descriptor_type)
    }
    /// Returns whether all members in `other` are set in `self`.
    #[inline]
    pub const fn contains(&self, other: &Self) -> bool {
        (self.khr_16bit_storage || !other.khr_16bit_storage)
            && (self.khr_8bit_storage || !other.khr_8bit_storage)
            && (self.khr_acceleration_structure || !other.khr_acceleration_structure)
            && (self.khr_bind_memory2 || !other.khr_bind_memory2)
            && (self.khr_buffer_device_address || !other.khr_buffer_device_address)
            && (self.khr_calibrated_timestamps || !other.khr_calibrated_timestamps)
            && (self.khr_cooperative_matrix || !other.khr_cooperative_matrix)
            && (self.khr_copy_commands2 || !other.khr_copy_commands2)
            && (self.khr_create_renderpass2 || !other.khr_create_renderpass2)
            && (self.khr_dedicated_allocation || !other.khr_dedicated_allocation)
            && (self.khr_deferred_host_operations || !other.khr_deferred_host_operations)
            && (self.khr_depth_stencil_resolve || !other.khr_depth_stencil_resolve)
            && (self.khr_descriptor_update_template
                || !other.khr_descriptor_update_template)
            && (self.khr_device_group || !other.khr_device_group)
            && (self.khr_display_swapchain || !other.khr_display_swapchain)
            && (self.khr_draw_indirect_count || !other.khr_draw_indirect_count)
            && (self.khr_driver_properties || !other.khr_driver_properties)
            && (self.khr_dynamic_rendering || !other.khr_dynamic_rendering)
            && (self.khr_dynamic_rendering_local_read
                || !other.khr_dynamic_rendering_local_read)
            && (self.khr_external_fence || !other.khr_external_fence)
            && (self.khr_external_fence_fd || !other.khr_external_fence_fd)
            && (self.khr_external_fence_win32 || !other.khr_external_fence_win32)
            && (self.khr_external_memory || !other.khr_external_memory)
            && (self.khr_external_memory_fd || !other.khr_external_memory_fd)
            && (self.khr_external_memory_win32 || !other.khr_external_memory_win32)
            && (self.khr_external_semaphore || !other.khr_external_semaphore)
            && (self.khr_external_semaphore_fd || !other.khr_external_semaphore_fd)
            && (self.khr_external_semaphore_win32 || !other.khr_external_semaphore_win32)
            && (self.khr_format_feature_flags2 || !other.khr_format_feature_flags2)
            && (self.khr_fragment_shader_barycentric
                || !other.khr_fragment_shader_barycentric)
            && (self.khr_fragment_shading_rate || !other.khr_fragment_shading_rate)
            && (self.khr_get_memory_requirements2 || !other.khr_get_memory_requirements2)
            && (self.khr_global_priority || !other.khr_global_priority)
            && (self.khr_image_format_list || !other.khr_image_format_list)
            && (self.khr_imageless_framebuffer || !other.khr_imageless_framebuffer)
            && (self.khr_incremental_present || !other.khr_incremental_present)
            && (self.khr_index_type_uint8 || !other.khr_index_type_uint8)
            && (self.khr_line_rasterization || !other.khr_line_rasterization)
            && (self.khr_load_store_op_none || !other.khr_load_store_op_none)
            && (self.khr_maintenance1 || !other.khr_maintenance1)
            && (self.khr_maintenance2 || !other.khr_maintenance2)
            && (self.khr_maintenance3 || !other.khr_maintenance3)
            && (self.khr_maintenance4 || !other.khr_maintenance4)
            && (self.khr_maintenance5 || !other.khr_maintenance5)
            && (self.khr_maintenance6 || !other.khr_maintenance6)
            && (self.khr_map_memory2 || !other.khr_map_memory2)
            && (self.khr_multiview || !other.khr_multiview)
            && (self.khr_performance_query || !other.khr_performance_query)
            && (self.khr_pipeline_executable_properties
                || !other.khr_pipeline_executable_properties)
            && (self.khr_pipeline_library || !other.khr_pipeline_library)
            && (self.khr_portability_subset || !other.khr_portability_subset)
            && (self.khr_present_id || !other.khr_present_id)
            && (self.khr_present_wait || !other.khr_present_wait)
            && (self.khr_push_descriptor || !other.khr_push_descriptor)
            && (self.khr_ray_query || !other.khr_ray_query)
            && (self.khr_ray_tracing_maintenance1 || !other.khr_ray_tracing_maintenance1)
            && (self.khr_ray_tracing_pipeline || !other.khr_ray_tracing_pipeline)
            && (self.khr_ray_tracing_position_fetch
                || !other.khr_ray_tracing_position_fetch)
            && (self.khr_relaxed_block_layout || !other.khr_relaxed_block_layout)
            && (self.khr_sampler_mirror_clamp_to_edge
                || !other.khr_sampler_mirror_clamp_to_edge)
            && (self.khr_sampler_ycbcr_conversion || !other.khr_sampler_ycbcr_conversion)
            && (self.khr_separate_depth_stencil_layouts
                || !other.khr_separate_depth_stencil_layouts)
            && (self.khr_shader_atomic_int64 || !other.khr_shader_atomic_int64)
            && (self.khr_shader_clock || !other.khr_shader_clock)
            && (self.khr_shader_draw_parameters || !other.khr_shader_draw_parameters)
            && (self.khr_shader_expect_assume || !other.khr_shader_expect_assume)
            && (self.khr_shader_float16_int8 || !other.khr_shader_float16_int8)
            && (self.khr_shader_float_controls || !other.khr_shader_float_controls)
            && (self.khr_shader_float_controls2 || !other.khr_shader_float_controls2)
            && (self.khr_shader_integer_dot_product
                || !other.khr_shader_integer_dot_product)
            && (self.khr_shader_maximal_reconvergence
                || !other.khr_shader_maximal_reconvergence)
            && (self.khr_shader_non_semantic_info || !other.khr_shader_non_semantic_info)
            && (self.khr_shader_quad_control || !other.khr_shader_quad_control)
            && (self.khr_shader_subgroup_extended_types
                || !other.khr_shader_subgroup_extended_types)
            && (self.khr_shader_subgroup_rotate || !other.khr_shader_subgroup_rotate)
            && (self.khr_shader_subgroup_uniform_control_flow
                || !other.khr_shader_subgroup_uniform_control_flow)
            && (self.khr_shader_terminate_invocation
                || !other.khr_shader_terminate_invocation)
            && (self.khr_shared_presentable_image || !other.khr_shared_presentable_image)
            && (self.khr_spirv_1_4 || !other.khr_spirv_1_4)
            && (self.khr_storage_buffer_storage_class
                || !other.khr_storage_buffer_storage_class)
            && (self.khr_swapchain || !other.khr_swapchain)
            && (self.khr_swapchain_mutable_format || !other.khr_swapchain_mutable_format)
            && (self.khr_synchronization2 || !other.khr_synchronization2)
            && (self.khr_timeline_semaphore || !other.khr_timeline_semaphore)
            && (self.khr_uniform_buffer_standard_layout
                || !other.khr_uniform_buffer_standard_layout)
            && (self.khr_variable_pointers || !other.khr_variable_pointers)
            && (self.khr_vertex_attribute_divisor || !other.khr_vertex_attribute_divisor)
            && (self.khr_video_decode_av1 || !other.khr_video_decode_av1)
            && (self.khr_video_decode_h264 || !other.khr_video_decode_h264)
            && (self.khr_video_decode_h265 || !other.khr_video_decode_h265)
            && (self.khr_video_decode_queue || !other.khr_video_decode_queue)
            && (self.khr_video_encode_h264 || !other.khr_video_encode_h264)
            && (self.khr_video_encode_h265 || !other.khr_video_encode_h265)
            && (self.khr_video_encode_queue || !other.khr_video_encode_queue)
            && (self.khr_video_maintenance1 || !other.khr_video_maintenance1)
            && (self.khr_video_queue || !other.khr_video_queue)
            && (self.khr_vulkan_memory_model || !other.khr_vulkan_memory_model)
            && (self.khr_win32_keyed_mutex || !other.khr_win32_keyed_mutex)
            && (self.khr_workgroup_memory_explicit_layout
                || !other.khr_workgroup_memory_explicit_layout)
            && (self.khr_zero_initialize_workgroup_memory
                || !other.khr_zero_initialize_workgroup_memory)
            && (self.ext_4444_formats || !other.ext_4444_formats)
            && (self.ext_astc_decode_mode || !other.ext_astc_decode_mode)
            && (self.ext_attachment_feedback_loop_dynamic_state
                || !other.ext_attachment_feedback_loop_dynamic_state)
            && (self.ext_attachment_feedback_loop_layout
                || !other.ext_attachment_feedback_loop_layout)
            && (self.ext_blend_operation_advanced || !other.ext_blend_operation_advanced)
            && (self.ext_border_color_swizzle || !other.ext_border_color_swizzle)
            && (self.ext_buffer_device_address || !other.ext_buffer_device_address)
            && (self.ext_calibrated_timestamps || !other.ext_calibrated_timestamps)
            && (self.ext_color_write_enable || !other.ext_color_write_enable)
            && (self.ext_conditional_rendering || !other.ext_conditional_rendering)
            && (self.ext_conservative_rasterization
                || !other.ext_conservative_rasterization)
            && (self.ext_custom_border_color || !other.ext_custom_border_color)
            && (self.ext_debug_marker || !other.ext_debug_marker)
            && (self.ext_depth_bias_control || !other.ext_depth_bias_control)
            && (self.ext_depth_clamp_zero_one || !other.ext_depth_clamp_zero_one)
            && (self.ext_depth_clip_control || !other.ext_depth_clip_control)
            && (self.ext_depth_clip_enable || !other.ext_depth_clip_enable)
            && (self.ext_depth_range_unrestricted || !other.ext_depth_range_unrestricted)
            && (self.ext_descriptor_buffer || !other.ext_descriptor_buffer)
            && (self.ext_descriptor_indexing || !other.ext_descriptor_indexing)
            && (self.ext_device_address_binding_report
                || !other.ext_device_address_binding_report)
            && (self.ext_device_fault || !other.ext_device_fault)
            && (self.ext_device_memory_report || !other.ext_device_memory_report)
            && (self.ext_discard_rectangles || !other.ext_discard_rectangles)
            && (self.ext_display_control || !other.ext_display_control)
            && (self.ext_dynamic_rendering_unused_attachments
                || !other.ext_dynamic_rendering_unused_attachments)
            && (self.ext_extended_dynamic_state || !other.ext_extended_dynamic_state)
            && (self.ext_extended_dynamic_state2 || !other.ext_extended_dynamic_state2)
            && (self.ext_extended_dynamic_state3 || !other.ext_extended_dynamic_state3)
            && (self.ext_external_memory_acquire_unmodified
                || !other.ext_external_memory_acquire_unmodified)
            && (self.ext_external_memory_dma_buf || !other.ext_external_memory_dma_buf)
            && (self.ext_external_memory_host || !other.ext_external_memory_host)
            && (self.ext_filter_cubic || !other.ext_filter_cubic)
            && (self.ext_fragment_density_map || !other.ext_fragment_density_map)
            && (self.ext_fragment_density_map2 || !other.ext_fragment_density_map2)
            && (self.ext_fragment_shader_interlock
                || !other.ext_fragment_shader_interlock)
            && (self.ext_frame_boundary || !other.ext_frame_boundary)
            && (self.ext_full_screen_exclusive || !other.ext_full_screen_exclusive)
            && (self.ext_global_priority || !other.ext_global_priority)
            && (self.ext_global_priority_query || !other.ext_global_priority_query)
            && (self.ext_graphics_pipeline_library
                || !other.ext_graphics_pipeline_library)
            && (self.ext_hdr_metadata || !other.ext_hdr_metadata)
            && (self.ext_host_image_copy || !other.ext_host_image_copy)
            && (self.ext_host_query_reset || !other.ext_host_query_reset)
            && (self.ext_image_2d_view_of_3d || !other.ext_image_2d_view_of_3d)
            && (self.ext_image_compression_control
                || !other.ext_image_compression_control)
            && (self.ext_image_compression_control_swapchain
                || !other.ext_image_compression_control_swapchain)
            && (self.ext_image_drm_format_modifier
                || !other.ext_image_drm_format_modifier)
            && (self.ext_image_robustness || !other.ext_image_robustness)
            && (self.ext_image_sliced_view_of_3d || !other.ext_image_sliced_view_of_3d)
            && (self.ext_image_view_min_lod || !other.ext_image_view_min_lod)
            && (self.ext_index_type_uint8 || !other.ext_index_type_uint8)
            && (self.ext_inline_uniform_block || !other.ext_inline_uniform_block)
            && (self.ext_legacy_dithering || !other.ext_legacy_dithering)
            && (self.ext_line_rasterization || !other.ext_line_rasterization)
            && (self.ext_load_store_op_none || !other.ext_load_store_op_none)
            && (self.ext_map_memory_placed || !other.ext_map_memory_placed)
            && (self.ext_memory_budget || !other.ext_memory_budget)
            && (self.ext_memory_priority || !other.ext_memory_priority)
            && (self.ext_mesh_shader || !other.ext_mesh_shader)
            && (self.ext_metal_objects || !other.ext_metal_objects)
            && (self.ext_multi_draw || !other.ext_multi_draw)
            && (self.ext_multisampled_render_to_single_sampled
                || !other.ext_multisampled_render_to_single_sampled)
            && (self.ext_mutable_descriptor_type || !other.ext_mutable_descriptor_type)
            && (self.ext_nested_command_buffer || !other.ext_nested_command_buffer)
            && (self.ext_non_seamless_cube_map || !other.ext_non_seamless_cube_map)
            && (self.ext_opacity_micromap || !other.ext_opacity_micromap)
            && (self.ext_pageable_device_local_memory
                || !other.ext_pageable_device_local_memory)
            && (self.ext_pci_bus_info || !other.ext_pci_bus_info)
            && (self.ext_physical_device_drm || !other.ext_physical_device_drm)
            && (self.ext_pipeline_creation_cache_control
                || !other.ext_pipeline_creation_cache_control)
            && (self.ext_pipeline_creation_feedback
                || !other.ext_pipeline_creation_feedback)
            && (self.ext_pipeline_library_group_handles
                || !other.ext_pipeline_library_group_handles)
            && (self.ext_pipeline_properties || !other.ext_pipeline_properties)
            && (self.ext_pipeline_protected_access
                || !other.ext_pipeline_protected_access)
            && (self.ext_pipeline_robustness || !other.ext_pipeline_robustness)
            && (self.ext_post_depth_coverage || !other.ext_post_depth_coverage)
            && (self.ext_primitive_topology_list_restart
                || !other.ext_primitive_topology_list_restart)
            && (self.ext_primitives_generated_query
                || !other.ext_primitives_generated_query)
            && (self.ext_private_data || !other.ext_private_data)
            && (self.ext_provoking_vertex || !other.ext_provoking_vertex)
            && (self.ext_queue_family_foreign || !other.ext_queue_family_foreign)
            && (self.ext_rasterization_order_attachment_access
                || !other.ext_rasterization_order_attachment_access)
            && (self.ext_rgba10x6_formats || !other.ext_rgba10x6_formats)
            && (self.ext_robustness2 || !other.ext_robustness2)
            && (self.ext_sample_locations || !other.ext_sample_locations)
            && (self.ext_sampler_filter_minmax || !other.ext_sampler_filter_minmax)
            && (self.ext_scalar_block_layout || !other.ext_scalar_block_layout)
            && (self.ext_separate_stencil_usage || !other.ext_separate_stencil_usage)
            && (self.ext_shader_atomic_float || !other.ext_shader_atomic_float)
            && (self.ext_shader_atomic_float2 || !other.ext_shader_atomic_float2)
            && (self.ext_shader_demote_to_helper_invocation
                || !other.ext_shader_demote_to_helper_invocation)
            && (self.ext_shader_image_atomic_int64
                || !other.ext_shader_image_atomic_int64)
            && (self.ext_shader_module_identifier || !other.ext_shader_module_identifier)
            && (self.ext_shader_object || !other.ext_shader_object)
            && (self.ext_shader_stencil_export || !other.ext_shader_stencil_export)
            && (self.ext_shader_subgroup_ballot || !other.ext_shader_subgroup_ballot)
            && (self.ext_shader_subgroup_vote || !other.ext_shader_subgroup_vote)
            && (self.ext_shader_tile_image || !other.ext_shader_tile_image)
            && (self.ext_shader_viewport_index_layer
                || !other.ext_shader_viewport_index_layer)
            && (self.ext_subgroup_size_control || !other.ext_subgroup_size_control)
            && (self.ext_subpass_merge_feedback || !other.ext_subpass_merge_feedback)
            && (self.ext_swapchain_maintenance1 || !other.ext_swapchain_maintenance1)
            && (self.ext_texel_buffer_alignment || !other.ext_texel_buffer_alignment)
            && (self.ext_texture_compression_astc_hdr
                || !other.ext_texture_compression_astc_hdr)
            && (self.ext_tooling_info || !other.ext_tooling_info)
            && (self.ext_transform_feedback || !other.ext_transform_feedback)
            && (self.ext_validation_cache || !other.ext_validation_cache)
            && (self.ext_vertex_attribute_divisor || !other.ext_vertex_attribute_divisor)
            && (self.ext_vertex_input_dynamic_state
                || !other.ext_vertex_input_dynamic_state)
            && (self.ext_ycbcr_2plane_444_formats || !other.ext_ycbcr_2plane_444_formats)
            && (self.ext_ycbcr_image_arrays || !other.ext_ycbcr_image_arrays)
            && (self.amdx_shader_enqueue || !other.amdx_shader_enqueue)
            && (self.amd_buffer_marker || !other.amd_buffer_marker)
            && (self.amd_device_coherent_memory || !other.amd_device_coherent_memory)
            && (self.amd_display_native_hdr || !other.amd_display_native_hdr)
            && (self.amd_draw_indirect_count || !other.amd_draw_indirect_count)
            && (self.amd_gcn_shader || !other.amd_gcn_shader)
            && (self.amd_gpu_shader_half_float || !other.amd_gpu_shader_half_float)
            && (self.amd_gpu_shader_int16 || !other.amd_gpu_shader_int16)
            && (self.amd_memory_overallocation_behavior
                || !other.amd_memory_overallocation_behavior)
            && (self.amd_mixed_attachment_samples || !other.amd_mixed_attachment_samples)
            && (self.amd_pipeline_compiler_control
                || !other.amd_pipeline_compiler_control)
            && (self.amd_rasterization_order || !other.amd_rasterization_order)
            && (self.amd_shader_ballot || !other.amd_shader_ballot)
            && (self.amd_shader_core_properties || !other.amd_shader_core_properties)
            && (self.amd_shader_core_properties2 || !other.amd_shader_core_properties2)
            && (self.amd_shader_early_and_late_fragment_tests
                || !other.amd_shader_early_and_late_fragment_tests)
            && (self.amd_shader_explicit_vertex_parameter
                || !other.amd_shader_explicit_vertex_parameter)
            && (self.amd_shader_fragment_mask || !other.amd_shader_fragment_mask)
            && (self.amd_shader_image_load_store_lod
                || !other.amd_shader_image_load_store_lod)
            && (self.amd_shader_info || !other.amd_shader_info)
            && (self.amd_shader_trinary_minmax || !other.amd_shader_trinary_minmax)
            && (self.amd_texture_gather_bias_lod || !other.amd_texture_gather_bias_lod)
            && (self.android_external_format_resolve
                || !other.android_external_format_resolve)
            && (self.android_external_memory_android_hardware_buffer
                || !other.android_external_memory_android_hardware_buffer)
            && (self.arm_rasterization_order_attachment_access
                || !other.arm_rasterization_order_attachment_access)
            && (self.arm_render_pass_striped || !other.arm_render_pass_striped)
            && (self.arm_scheduling_controls || !other.arm_scheduling_controls)
            && (self.arm_shader_core_builtins || !other.arm_shader_core_builtins)
            && (self.arm_shader_core_properties || !other.arm_shader_core_properties)
            && (self.fuchsia_buffer_collection || !other.fuchsia_buffer_collection)
            && (self.fuchsia_external_memory || !other.fuchsia_external_memory)
            && (self.fuchsia_external_semaphore || !other.fuchsia_external_semaphore)
            && (self.ggp_frame_token || !other.ggp_frame_token)
            && (self.google_decorate_string || !other.google_decorate_string)
            && (self.google_display_timing || !other.google_display_timing)
            && (self.google_hlsl_functionality1 || !other.google_hlsl_functionality1)
            && (self.google_user_type || !other.google_user_type)
            && (self.huawei_cluster_culling_shader
                || !other.huawei_cluster_culling_shader)
            && (self.huawei_invocation_mask || !other.huawei_invocation_mask)
            && (self.huawei_subpass_shading || !other.huawei_subpass_shading)
            && (self.img_filter_cubic || !other.img_filter_cubic)
            && (self.img_format_pvrtc || !other.img_format_pvrtc)
            && (self.img_relaxed_line_rasterization
                || !other.img_relaxed_line_rasterization)
            && (self.intel_performance_query || !other.intel_performance_query)
            && (self.intel_shader_integer_functions2
                || !other.intel_shader_integer_functions2)
            && (self.msft_layered_driver || !other.msft_layered_driver)
            && (self.nvx_binary_import || !other.nvx_binary_import)
            && (self.nvx_image_view_handle || !other.nvx_image_view_handle)
            && (self.nvx_multiview_per_view_attributes
                || !other.nvx_multiview_per_view_attributes)
            && (self.nv_acquire_winrt_display || !other.nv_acquire_winrt_display)
            && (self.nv_clip_space_w_scaling || !other.nv_clip_space_w_scaling)
            && (self.nv_compute_shader_derivatives
                || !other.nv_compute_shader_derivatives)
            && (self.nv_cooperative_matrix || !other.nv_cooperative_matrix)
            && (self.nv_copy_memory_indirect || !other.nv_copy_memory_indirect)
            && (self.nv_corner_sampled_image || !other.nv_corner_sampled_image)
            && (self.nv_coverage_reduction_mode || !other.nv_coverage_reduction_mode)
            && (self.nv_cuda_kernel_launch || !other.nv_cuda_kernel_launch)
            && (self.nv_dedicated_allocation || !other.nv_dedicated_allocation)
            && (self.nv_dedicated_allocation_image_aliasing
                || !other.nv_dedicated_allocation_image_aliasing)
            && (self.nv_descriptor_pool_overallocation
                || !other.nv_descriptor_pool_overallocation)
            && (self.nv_device_diagnostic_checkpoints
                || !other.nv_device_diagnostic_checkpoints)
            && (self.nv_device_diagnostics_config || !other.nv_device_diagnostics_config)
            && (self.nv_device_generated_commands || !other.nv_device_generated_commands)
            && (self.nv_device_generated_commands_compute
                || !other.nv_device_generated_commands_compute)
            && (self.nv_displacement_micromap || !other.nv_displacement_micromap)
            && (self.nv_extended_sparse_address_space
                || !other.nv_extended_sparse_address_space)
            && (self.nv_external_memory || !other.nv_external_memory)
            && (self.nv_external_memory_rdma || !other.nv_external_memory_rdma)
            && (self.nv_external_memory_win32 || !other.nv_external_memory_win32)
            && (self.nv_fill_rectangle || !other.nv_fill_rectangle)
            && (self.nv_fragment_coverage_to_color
                || !other.nv_fragment_coverage_to_color)
            && (self.nv_fragment_shader_barycentric
                || !other.nv_fragment_shader_barycentric)
            && (self.nv_fragment_shading_rate_enums
                || !other.nv_fragment_shading_rate_enums)
            && (self.nv_framebuffer_mixed_samples || !other.nv_framebuffer_mixed_samples)
            && (self.nv_geometry_shader_passthrough
                || !other.nv_geometry_shader_passthrough)
            && (self.nv_glsl_shader || !other.nv_glsl_shader)
            && (self.nv_inherited_viewport_scissor
                || !other.nv_inherited_viewport_scissor)
            && (self.nv_linear_color_attachment || !other.nv_linear_color_attachment)
            && (self.nv_low_latency || !other.nv_low_latency)
            && (self.nv_low_latency2 || !other.nv_low_latency2)
            && (self.nv_memory_decompression || !other.nv_memory_decompression)
            && (self.nv_mesh_shader || !other.nv_mesh_shader)
            && (self.nv_optical_flow || !other.nv_optical_flow)
            && (self.nv_per_stage_descriptor_set || !other.nv_per_stage_descriptor_set)
            && (self.nv_present_barrier || !other.nv_present_barrier)
            && (self.nv_raw_access_chains || !other.nv_raw_access_chains)
            && (self.nv_ray_tracing || !other.nv_ray_tracing)
            && (self.nv_ray_tracing_invocation_reorder
                || !other.nv_ray_tracing_invocation_reorder)
            && (self.nv_ray_tracing_motion_blur || !other.nv_ray_tracing_motion_blur)
            && (self.nv_ray_tracing_validation || !other.nv_ray_tracing_validation)
            && (self.nv_representative_fragment_test
                || !other.nv_representative_fragment_test)
            && (self.nv_sample_mask_override_coverage
                || !other.nv_sample_mask_override_coverage)
            && (self.nv_scissor_exclusive || !other.nv_scissor_exclusive)
            && (self.nv_shader_atomic_float16_vector
                || !other.nv_shader_atomic_float16_vector)
            && (self.nv_shader_image_footprint || !other.nv_shader_image_footprint)
            && (self.nv_shader_sm_builtins || !other.nv_shader_sm_builtins)
            && (self.nv_shader_subgroup_partitioned
                || !other.nv_shader_subgroup_partitioned)
            && (self.nv_shading_rate_image || !other.nv_shading_rate_image)
            && (self.nv_viewport_array2 || !other.nv_viewport_array2)
            && (self.nv_viewport_swizzle || !other.nv_viewport_swizzle)
            && (self.nv_win32_keyed_mutex || !other.nv_win32_keyed_mutex)
            && (self.qcom_filter_cubic_clamp || !other.qcom_filter_cubic_clamp)
            && (self.qcom_filter_cubic_weights || !other.qcom_filter_cubic_weights)
            && (self.qcom_fragment_density_map_offset
                || !other.qcom_fragment_density_map_offset)
            && (self.qcom_image_processing || !other.qcom_image_processing)
            && (self.qcom_image_processing2 || !other.qcom_image_processing2)
            && (self.qcom_multiview_per_view_render_areas
                || !other.qcom_multiview_per_view_render_areas)
            && (self.qcom_multiview_per_view_viewports
                || !other.qcom_multiview_per_view_viewports)
            && (self.qcom_render_pass_shader_resolve
                || !other.qcom_render_pass_shader_resolve)
            && (self.qcom_render_pass_store_ops || !other.qcom_render_pass_store_ops)
            && (self.qcom_render_pass_transform || !other.qcom_render_pass_transform)
            && (self.qcom_rotated_copy_commands || !other.qcom_rotated_copy_commands)
            && (self.qcom_tile_properties || !other.qcom_tile_properties)
            && (self.qcom_ycbcr_degamma || !other.qcom_ycbcr_degamma)
            && (self.qnx_external_memory_screen_buffer
                || !other.qnx_external_memory_screen_buffer)
            && (self.sec_amigo_profiling || !other.sec_amigo_profiling)
            && (self.valve_descriptor_set_host_mapping
                || !other.valve_descriptor_set_host_mapping)
            && (self.valve_mutable_descriptor_type
                || !other.valve_mutable_descriptor_type)
    }
    /// Returns the union of `self` and `other`.
    #[inline]
    pub const fn union(&self, other: &Self) -> Self {
        Self {
            khr_16bit_storage: self.khr_16bit_storage || other.khr_16bit_storage,
            khr_8bit_storage: self.khr_8bit_storage || other.khr_8bit_storage,
            khr_acceleration_structure: self.khr_acceleration_structure
                || other.khr_acceleration_structure,
            khr_bind_memory2: self.khr_bind_memory2 || other.khr_bind_memory2,
            khr_buffer_device_address: self.khr_buffer_device_address
                || other.khr_buffer_device_address,
            khr_calibrated_timestamps: self.khr_calibrated_timestamps
                || other.khr_calibrated_timestamps,
            khr_cooperative_matrix: self.khr_cooperative_matrix
                || other.khr_cooperative_matrix,
            khr_copy_commands2: self.khr_copy_commands2 || other.khr_copy_commands2,
            khr_create_renderpass2: self.khr_create_renderpass2
                || other.khr_create_renderpass2,
            khr_dedicated_allocation: self.khr_dedicated_allocation
                || other.khr_dedicated_allocation,
            khr_deferred_host_operations: self.khr_deferred_host_operations
                || other.khr_deferred_host_operations,
            khr_depth_stencil_resolve: self.khr_depth_stencil_resolve
                || other.khr_depth_stencil_resolve,
            khr_descriptor_update_template: self.khr_descriptor_update_template
                || other.khr_descriptor_update_template,
            khr_device_group: self.khr_device_group || other.khr_device_group,
            khr_display_swapchain: self.khr_display_swapchain
                || other.khr_display_swapchain,
            khr_draw_indirect_count: self.khr_draw_indirect_count
                || other.khr_draw_indirect_count,
            khr_driver_properties: self.khr_driver_properties
                || other.khr_driver_properties,
            khr_dynamic_rendering: self.khr_dynamic_rendering
                || other.khr_dynamic_rendering,
            khr_dynamic_rendering_local_read: self.khr_dynamic_rendering_local_read
                || other.khr_dynamic_rendering_local_read,
            khr_external_fence: self.khr_external_fence || other.khr_external_fence,
            khr_external_fence_fd: self.khr_external_fence_fd
                || other.khr_external_fence_fd,
            khr_external_fence_win32: self.khr_external_fence_win32
                || other.khr_external_fence_win32,
            khr_external_memory: self.khr_external_memory || other.khr_external_memory,
            khr_external_memory_fd: self.khr_external_memory_fd
                || other.khr_external_memory_fd,
            khr_external_memory_win32: self.khr_external_memory_win32
                || other.khr_external_memory_win32,
            khr_external_semaphore: self.khr_external_semaphore
                || other.khr_external_semaphore,
            khr_external_semaphore_fd: self.khr_external_semaphore_fd
                || other.khr_external_semaphore_fd,
            khr_external_semaphore_win32: self.khr_external_semaphore_win32
                || other.khr_external_semaphore_win32,
            khr_format_feature_flags2: self.khr_format_feature_flags2
                || other.khr_format_feature_flags2,
            khr_fragment_shader_barycentric: self.khr_fragment_shader_barycentric
                || other.khr_fragment_shader_barycentric,
            khr_fragment_shading_rate: self.khr_fragment_shading_rate
                || other.khr_fragment_shading_rate,
            khr_get_memory_requirements2: self.khr_get_memory_requirements2
                || other.khr_get_memory_requirements2,
            khr_global_priority: self.khr_global_priority || other.khr_global_priority,
            khr_image_format_list: self.khr_image_format_list
                || other.khr_image_format_list,
            khr_imageless_framebuffer: self.khr_imageless_framebuffer
                || other.khr_imageless_framebuffer,
            khr_incremental_present: self.khr_incremental_present
                || other.khr_incremental_present,
            khr_index_type_uint8: self.khr_index_type_uint8
                || other.khr_index_type_uint8,
            khr_line_rasterization: self.khr_line_rasterization
                || other.khr_line_rasterization,
            khr_load_store_op_none: self.khr_load_store_op_none
                || other.khr_load_store_op_none,
            khr_maintenance1: self.khr_maintenance1 || other.khr_maintenance1,
            khr_maintenance2: self.khr_maintenance2 || other.khr_maintenance2,
            khr_maintenance3: self.khr_maintenance3 || other.khr_maintenance3,
            khr_maintenance4: self.khr_maintenance4 || other.khr_maintenance4,
            khr_maintenance5: self.khr_maintenance5 || other.khr_maintenance5,
            khr_maintenance6: self.khr_maintenance6 || other.khr_maintenance6,
            khr_map_memory2: self.khr_map_memory2 || other.khr_map_memory2,
            khr_multiview: self.khr_multiview || other.khr_multiview,
            khr_performance_query: self.khr_performance_query
                || other.khr_performance_query,
            khr_pipeline_executable_properties: self.khr_pipeline_executable_properties
                || other.khr_pipeline_executable_properties,
            khr_pipeline_library: self.khr_pipeline_library
                || other.khr_pipeline_library,
            khr_portability_subset: self.khr_portability_subset
                || other.khr_portability_subset,
            khr_present_id: self.khr_present_id || other.khr_present_id,
            khr_present_wait: self.khr_present_wait || other.khr_present_wait,
            khr_push_descriptor: self.khr_push_descriptor || other.khr_push_descriptor,
            khr_ray_query: self.khr_ray_query || other.khr_ray_query,
            khr_ray_tracing_maintenance1: self.khr_ray_tracing_maintenance1
                || other.khr_ray_tracing_maintenance1,
            khr_ray_tracing_pipeline: self.khr_ray_tracing_pipeline
                || other.khr_ray_tracing_pipeline,
            khr_ray_tracing_position_fetch: self.khr_ray_tracing_position_fetch
                || other.khr_ray_tracing_position_fetch,
            khr_relaxed_block_layout: self.khr_relaxed_block_layout
                || other.khr_relaxed_block_layout,
            khr_sampler_mirror_clamp_to_edge: self.khr_sampler_mirror_clamp_to_edge
                || other.khr_sampler_mirror_clamp_to_edge,
            khr_sampler_ycbcr_conversion: self.khr_sampler_ycbcr_conversion
                || other.khr_sampler_ycbcr_conversion,
            khr_separate_depth_stencil_layouts: self.khr_separate_depth_stencil_layouts
                || other.khr_separate_depth_stencil_layouts,
            khr_shader_atomic_int64: self.khr_shader_atomic_int64
                || other.khr_shader_atomic_int64,
            khr_shader_clock: self.khr_shader_clock || other.khr_shader_clock,
            khr_shader_draw_parameters: self.khr_shader_draw_parameters
                || other.khr_shader_draw_parameters,
            khr_shader_expect_assume: self.khr_shader_expect_assume
                || other.khr_shader_expect_assume,
            khr_shader_float16_int8: self.khr_shader_float16_int8
                || other.khr_shader_float16_int8,
            khr_shader_float_controls: self.khr_shader_float_controls
                || other.khr_shader_float_controls,
            khr_shader_float_controls2: self.khr_shader_float_controls2
                || other.khr_shader_float_controls2,
            khr_shader_integer_dot_product: self.khr_shader_integer_dot_product
                || other.khr_shader_integer_dot_product,
            khr_shader_maximal_reconvergence: self.khr_shader_maximal_reconvergence
                || other.khr_shader_maximal_reconvergence,
            khr_shader_non_semantic_info: self.khr_shader_non_semantic_info
                || other.khr_shader_non_semantic_info,
            khr_shader_quad_control: self.khr_shader_quad_control
                || other.khr_shader_quad_control,
            khr_shader_subgroup_extended_types: self.khr_shader_subgroup_extended_types
                || other.khr_shader_subgroup_extended_types,
            khr_shader_subgroup_rotate: self.khr_shader_subgroup_rotate
                || other.khr_shader_subgroup_rotate,
            khr_shader_subgroup_uniform_control_flow: self
                .khr_shader_subgroup_uniform_control_flow
                || other.khr_shader_subgroup_uniform_control_flow,
            khr_shader_terminate_invocation: self.khr_shader_terminate_invocation
                || other.khr_shader_terminate_invocation,
            khr_shared_presentable_image: self.khr_shared_presentable_image
                || other.khr_shared_presentable_image,
            khr_spirv_1_4: self.khr_spirv_1_4 || other.khr_spirv_1_4,
            khr_storage_buffer_storage_class: self.khr_storage_buffer_storage_class
                || other.khr_storage_buffer_storage_class,
            khr_swapchain: self.khr_swapchain || other.khr_swapchain,
            khr_swapchain_mutable_format: self.khr_swapchain_mutable_format
                || other.khr_swapchain_mutable_format,
            khr_synchronization2: self.khr_synchronization2
                || other.khr_synchronization2,
            khr_timeline_semaphore: self.khr_timeline_semaphore
                || other.khr_timeline_semaphore,
            khr_uniform_buffer_standard_layout: self.khr_uniform_buffer_standard_layout
                || other.khr_uniform_buffer_standard_layout,
            khr_variable_pointers: self.khr_variable_pointers
                || other.khr_variable_pointers,
            khr_vertex_attribute_divisor: self.khr_vertex_attribute_divisor
                || other.khr_vertex_attribute_divisor,
            khr_video_decode_av1: self.khr_video_decode_av1
                || other.khr_video_decode_av1,
            khr_video_decode_h264: self.khr_video_decode_h264
                || other.khr_video_decode_h264,
            khr_video_decode_h265: self.khr_video_decode_h265
                || other.khr_video_decode_h265,
            khr_video_decode_queue: self.khr_video_decode_queue
                || other.khr_video_decode_queue,
            khr_video_encode_h264: self.khr_video_encode_h264
                || other.khr_video_encode_h264,
            khr_video_encode_h265: self.khr_video_encode_h265
                || other.khr_video_encode_h265,
            khr_video_encode_queue: self.khr_video_encode_queue
                || other.khr_video_encode_queue,
            khr_video_maintenance1: self.khr_video_maintenance1
                || other.khr_video_maintenance1,
            khr_video_queue: self.khr_video_queue || other.khr_video_queue,
            khr_vulkan_memory_model: self.khr_vulkan_memory_model
                || other.khr_vulkan_memory_model,
            khr_win32_keyed_mutex: self.khr_win32_keyed_mutex
                || other.khr_win32_keyed_mutex,
            khr_workgroup_memory_explicit_layout: self
                .khr_workgroup_memory_explicit_layout
                || other.khr_workgroup_memory_explicit_layout,
            khr_zero_initialize_workgroup_memory: self
                .khr_zero_initialize_workgroup_memory
                || other.khr_zero_initialize_workgroup_memory,
            ext_4444_formats: self.ext_4444_formats || other.ext_4444_formats,
            ext_astc_decode_mode: self.ext_astc_decode_mode
                || other.ext_astc_decode_mode,
            ext_attachment_feedback_loop_dynamic_state: self
                .ext_attachment_feedback_loop_dynamic_state
                || other.ext_attachment_feedback_loop_dynamic_state,
            ext_attachment_feedback_loop_layout: self.ext_attachment_feedback_loop_layout
                || other.ext_attachment_feedback_loop_layout,
            ext_blend_operation_advanced: self.ext_blend_operation_advanced
                || other.ext_blend_operation_advanced,
            ext_border_color_swizzle: self.ext_border_color_swizzle
                || other.ext_border_color_swizzle,
            ext_buffer_device_address: self.ext_buffer_device_address
                || other.ext_buffer_device_address,
            ext_calibrated_timestamps: self.ext_calibrated_timestamps
                || other.ext_calibrated_timestamps,
            ext_color_write_enable: self.ext_color_write_enable
                || other.ext_color_write_enable,
            ext_conditional_rendering: self.ext_conditional_rendering
                || other.ext_conditional_rendering,
            ext_conservative_rasterization: self.ext_conservative_rasterization
                || other.ext_conservative_rasterization,
            ext_custom_border_color: self.ext_custom_border_color
                || other.ext_custom_border_color,
            ext_debug_marker: self.ext_debug_marker || other.ext_debug_marker,
            ext_depth_bias_control: self.ext_depth_bias_control
                || other.ext_depth_bias_control,
            ext_depth_clamp_zero_one: self.ext_depth_clamp_zero_one
                || other.ext_depth_clamp_zero_one,
            ext_depth_clip_control: self.ext_depth_clip_control
                || other.ext_depth_clip_control,
            ext_depth_clip_enable: self.ext_depth_clip_enable
                || other.ext_depth_clip_enable,
            ext_depth_range_unrestricted: self.ext_depth_range_unrestricted
                || other.ext_depth_range_unrestricted,
            ext_descriptor_buffer: self.ext_descriptor_buffer
                || other.ext_descriptor_buffer,
            ext_descriptor_indexing: self.ext_descriptor_indexing
                || other.ext_descriptor_indexing,
            ext_device_address_binding_report: self.ext_device_address_binding_report
                || other.ext_device_address_binding_report,
            ext_device_fault: self.ext_device_fault || other.ext_device_fault,
            ext_device_memory_report: self.ext_device_memory_report
                || other.ext_device_memory_report,
            ext_discard_rectangles: self.ext_discard_rectangles
                || other.ext_discard_rectangles,
            ext_display_control: self.ext_display_control || other.ext_display_control,
            ext_dynamic_rendering_unused_attachments: self
                .ext_dynamic_rendering_unused_attachments
                || other.ext_dynamic_rendering_unused_attachments,
            ext_extended_dynamic_state: self.ext_extended_dynamic_state
                || other.ext_extended_dynamic_state,
            ext_extended_dynamic_state2: self.ext_extended_dynamic_state2
                || other.ext_extended_dynamic_state2,
            ext_extended_dynamic_state3: self.ext_extended_dynamic_state3
                || other.ext_extended_dynamic_state3,
            ext_external_memory_acquire_unmodified: self
                .ext_external_memory_acquire_unmodified
                || other.ext_external_memory_acquire_unmodified,
            ext_external_memory_dma_buf: self.ext_external_memory_dma_buf
                || other.ext_external_memory_dma_buf,
            ext_external_memory_host: self.ext_external_memory_host
                || other.ext_external_memory_host,
            ext_filter_cubic: self.ext_filter_cubic || other.ext_filter_cubic,
            ext_fragment_density_map: self.ext_fragment_density_map
                || other.ext_fragment_density_map,
            ext_fragment_density_map2: self.ext_fragment_density_map2
                || other.ext_fragment_density_map2,
            ext_fragment_shader_interlock: self.ext_fragment_shader_interlock
                || other.ext_fragment_shader_interlock,
            ext_frame_boundary: self.ext_frame_boundary || other.ext_frame_boundary,
            ext_full_screen_exclusive: self.ext_full_screen_exclusive
                || other.ext_full_screen_exclusive,
            ext_global_priority: self.ext_global_priority || other.ext_global_priority,
            ext_global_priority_query: self.ext_global_priority_query
                || other.ext_global_priority_query,
            ext_graphics_pipeline_library: self.ext_graphics_pipeline_library
                || other.ext_graphics_pipeline_library,
            ext_hdr_metadata: self.ext_hdr_metadata || other.ext_hdr_metadata,
            ext_host_image_copy: self.ext_host_image_copy || other.ext_host_image_copy,
            ext_host_query_reset: self.ext_host_query_reset
                || other.ext_host_query_reset,
            ext_image_2d_view_of_3d: self.ext_image_2d_view_of_3d
                || other.ext_image_2d_view_of_3d,
            ext_image_compression_control: self.ext_image_compression_control
                || other.ext_image_compression_control,
            ext_image_compression_control_swapchain: self
                .ext_image_compression_control_swapchain
                || other.ext_image_compression_control_swapchain,
            ext_image_drm_format_modifier: self.ext_image_drm_format_modifier
                || other.ext_image_drm_format_modifier,
            ext_image_robustness: self.ext_image_robustness
                || other.ext_image_robustness,
            ext_image_sliced_view_of_3d: self.ext_image_sliced_view_of_3d
                || other.ext_image_sliced_view_of_3d,
            ext_image_view_min_lod: self.ext_image_view_min_lod
                || other.ext_image_view_min_lod,
            ext_index_type_uint8: self.ext_index_type_uint8
                || other.ext_index_type_uint8,
            ext_inline_uniform_block: self.ext_inline_uniform_block
                || other.ext_inline_uniform_block,
            ext_legacy_dithering: self.ext_legacy_dithering
                || other.ext_legacy_dithering,
            ext_line_rasterization: self.ext_line_rasterization
                || other.ext_line_rasterization,
            ext_load_store_op_none: self.ext_load_store_op_none
                || other.ext_load_store_op_none,
            ext_map_memory_placed: self.ext_map_memory_placed
                || other.ext_map_memory_placed,
            ext_memory_budget: self.ext_memory_budget || other.ext_memory_budget,
            ext_memory_priority: self.ext_memory_priority || other.ext_memory_priority,
            ext_mesh_shader: self.ext_mesh_shader || other.ext_mesh_shader,
            ext_metal_objects: self.ext_metal_objects || other.ext_metal_objects,
            ext_multi_draw: self.ext_multi_draw || other.ext_multi_draw,
            ext_multisampled_render_to_single_sampled: self
                .ext_multisampled_render_to_single_sampled
                || other.ext_multisampled_render_to_single_sampled,
            ext_mutable_descriptor_type: self.ext_mutable_descriptor_type
                || other.ext_mutable_descriptor_type,
            ext_nested_command_buffer: self.ext_nested_command_buffer
                || other.ext_nested_command_buffer,
            ext_non_seamless_cube_map: self.ext_non_seamless_cube_map
                || other.ext_non_seamless_cube_map,
            ext_opacity_micromap: self.ext_opacity_micromap
                || other.ext_opacity_micromap,
            ext_pageable_device_local_memory: self.ext_pageable_device_local_memory
                || other.ext_pageable_device_local_memory,
            ext_pci_bus_info: self.ext_pci_bus_info || other.ext_pci_bus_info,
            ext_physical_device_drm: self.ext_physical_device_drm
                || other.ext_physical_device_drm,
            ext_pipeline_creation_cache_control: self.ext_pipeline_creation_cache_control
                || other.ext_pipeline_creation_cache_control,
            ext_pipeline_creation_feedback: self.ext_pipeline_creation_feedback
                || other.ext_pipeline_creation_feedback,
            ext_pipeline_library_group_handles: self.ext_pipeline_library_group_handles
                || other.ext_pipeline_library_group_handles,
            ext_pipeline_properties: self.ext_pipeline_properties
                || other.ext_pipeline_properties,
            ext_pipeline_protected_access: self.ext_pipeline_protected_access
                || other.ext_pipeline_protected_access,
            ext_pipeline_robustness: self.ext_pipeline_robustness
                || other.ext_pipeline_robustness,
            ext_post_depth_coverage: self.ext_post_depth_coverage
                || other.ext_post_depth_coverage,
            ext_primitive_topology_list_restart: self.ext_primitive_topology_list_restart
                || other.ext_primitive_topology_list_restart,
            ext_primitives_generated_query: self.ext_primitives_generated_query
                || other.ext_primitives_generated_query,
            ext_private_data: self.ext_private_data || other.ext_private_data,
            ext_provoking_vertex: self.ext_provoking_vertex
                || other.ext_provoking_vertex,
            ext_queue_family_foreign: self.ext_queue_family_foreign
                || other.ext_queue_family_foreign,
            ext_rasterization_order_attachment_access: self
                .ext_rasterization_order_attachment_access
                || other.ext_rasterization_order_attachment_access,
            ext_rgba10x6_formats: self.ext_rgba10x6_formats
                || other.ext_rgba10x6_formats,
            ext_robustness2: self.ext_robustness2 || other.ext_robustness2,
            ext_sample_locations: self.ext_sample_locations
                || other.ext_sample_locations,
            ext_sampler_filter_minmax: self.ext_sampler_filter_minmax
                || other.ext_sampler_filter_minmax,
            ext_scalar_block_layout: self.ext_scalar_block_layout
                || other.ext_scalar_block_layout,
            ext_separate_stencil_usage: self.ext_separate_stencil_usage
                || other.ext_separate_stencil_usage,
            ext_shader_atomic_float: self.ext_shader_atomic_float
                || other.ext_shader_atomic_float,
            ext_shader_atomic_float2: self.ext_shader_atomic_float2
                || other.ext_shader_atomic_float2,
            ext_shader_demote_to_helper_invocation: self
                .ext_shader_demote_to_helper_invocation
                || other.ext_shader_demote_to_helper_invocation,
            ext_shader_image_atomic_int64: self.ext_shader_image_atomic_int64
                || other.ext_shader_image_atomic_int64,
            ext_shader_module_identifier: self.ext_shader_module_identifier
                || other.ext_shader_module_identifier,
            ext_shader_object: self.ext_shader_object || other.ext_shader_object,
            ext_shader_stencil_export: self.ext_shader_stencil_export
                || other.ext_shader_stencil_export,
            ext_shader_subgroup_ballot: self.ext_shader_subgroup_ballot
                || other.ext_shader_subgroup_ballot,
            ext_shader_subgroup_vote: self.ext_shader_subgroup_vote
                || other.ext_shader_subgroup_vote,
            ext_shader_tile_image: self.ext_shader_tile_image
                || other.ext_shader_tile_image,
            ext_shader_viewport_index_layer: self.ext_shader_viewport_index_layer
                || other.ext_shader_viewport_index_layer,
            ext_subgroup_size_control: self.ext_subgroup_size_control
                || other.ext_subgroup_size_control,
            ext_subpass_merge_feedback: self.ext_subpass_merge_feedback
                || other.ext_subpass_merge_feedback,
            ext_swapchain_maintenance1: self.ext_swapchain_maintenance1
                || other.ext_swapchain_maintenance1,
            ext_texel_buffer_alignment: self.ext_texel_buffer_alignment
                || other.ext_texel_buffer_alignment,
            ext_texture_compression_astc_hdr: self.ext_texture_compression_astc_hdr
                || other.ext_texture_compression_astc_hdr,
            ext_tooling_info: self.ext_tooling_info || other.ext_tooling_info,
            ext_transform_feedback: self.ext_transform_feedback
                || other.ext_transform_feedback,
            ext_validation_cache: self.ext_validation_cache
                || other.ext_validation_cache,
            ext_vertex_attribute_divisor: self.ext_vertex_attribute_divisor
                || other.ext_vertex_attribute_divisor,
            ext_vertex_input_dynamic_state: self.ext_vertex_input_dynamic_state
                || other.ext_vertex_input_dynamic_state,
            ext_ycbcr_2plane_444_formats: self.ext_ycbcr_2plane_444_formats
                || other.ext_ycbcr_2plane_444_formats,
            ext_ycbcr_image_arrays: self.ext_ycbcr_image_arrays
                || other.ext_ycbcr_image_arrays,
            amdx_shader_enqueue: self.amdx_shader_enqueue || other.amdx_shader_enqueue,
            amd_buffer_marker: self.amd_buffer_marker || other.amd_buffer_marker,
            amd_device_coherent_memory: self.amd_device_coherent_memory
                || other.amd_device_coherent_memory,
            amd_display_native_hdr: self.amd_display_native_hdr
                || other.amd_display_native_hdr,
            amd_draw_indirect_count: self.amd_draw_indirect_count
                || other.amd_draw_indirect_count,
            amd_gcn_shader: self.amd_gcn_shader || other.amd_gcn_shader,
            amd_gpu_shader_half_float: self.amd_gpu_shader_half_float
                || other.amd_gpu_shader_half_float,
            amd_gpu_shader_int16: self.amd_gpu_shader_int16
                || other.amd_gpu_shader_int16,
            amd_memory_overallocation_behavior: self.amd_memory_overallocation_behavior
                || other.amd_memory_overallocation_behavior,
            amd_mixed_attachment_samples: self.amd_mixed_attachment_samples
                || other.amd_mixed_attachment_samples,
            amd_pipeline_compiler_control: self.amd_pipeline_compiler_control
                || other.amd_pipeline_compiler_control,
            amd_rasterization_order: self.amd_rasterization_order
                || other.amd_rasterization_order,
            amd_shader_ballot: self.amd_shader_ballot || other.amd_shader_ballot,
            amd_shader_core_properties: self.amd_shader_core_properties
                || other.amd_shader_core_properties,
            amd_shader_core_properties2: self.amd_shader_core_properties2
                || other.amd_shader_core_properties2,
            amd_shader_early_and_late_fragment_tests: self
                .amd_shader_early_and_late_fragment_tests
                || other.amd_shader_early_and_late_fragment_tests,
            amd_shader_explicit_vertex_parameter: self
                .amd_shader_explicit_vertex_parameter
                || other.amd_shader_explicit_vertex_parameter,
            amd_shader_fragment_mask: self.amd_shader_fragment_mask
                || other.amd_shader_fragment_mask,
            amd_shader_image_load_store_lod: self.amd_shader_image_load_store_lod
                || other.amd_shader_image_load_store_lod,
            amd_shader_info: self.amd_shader_info || other.amd_shader_info,
            amd_shader_trinary_minmax: self.amd_shader_trinary_minmax
                || other.amd_shader_trinary_minmax,
            amd_texture_gather_bias_lod: self.amd_texture_gather_bias_lod
                || other.amd_texture_gather_bias_lod,
            android_external_format_resolve: self.android_external_format_resolve
                || other.android_external_format_resolve,
            android_external_memory_android_hardware_buffer: self
                .android_external_memory_android_hardware_buffer
                || other.android_external_memory_android_hardware_buffer,
            arm_rasterization_order_attachment_access: self
                .arm_rasterization_order_attachment_access
                || other.arm_rasterization_order_attachment_access,
            arm_render_pass_striped: self.arm_render_pass_striped
                || other.arm_render_pass_striped,
            arm_scheduling_controls: self.arm_scheduling_controls
                || other.arm_scheduling_controls,
            arm_shader_core_builtins: self.arm_shader_core_builtins
                || other.arm_shader_core_builtins,
            arm_shader_core_properties: self.arm_shader_core_properties
                || other.arm_shader_core_properties,
            fuchsia_buffer_collection: self.fuchsia_buffer_collection
                || other.fuchsia_buffer_collection,
            fuchsia_external_memory: self.fuchsia_external_memory
                || other.fuchsia_external_memory,
            fuchsia_external_semaphore: self.fuchsia_external_semaphore
                || other.fuchsia_external_semaphore,
            ggp_frame_token: self.ggp_frame_token || other.ggp_frame_token,
            google_decorate_string: self.google_decorate_string
                || other.google_decorate_string,
            google_display_timing: self.google_display_timing
                || other.google_display_timing,
            google_hlsl_functionality1: self.google_hlsl_functionality1
                || other.google_hlsl_functionality1,
            google_user_type: self.google_user_type || other.google_user_type,
            huawei_cluster_culling_shader: self.huawei_cluster_culling_shader
                || other.huawei_cluster_culling_shader,
            huawei_invocation_mask: self.huawei_invocation_mask
                || other.huawei_invocation_mask,
            huawei_subpass_shading: self.huawei_subpass_shading
                || other.huawei_subpass_shading,
            img_filter_cubic: self.img_filter_cubic || other.img_filter_cubic,
            img_format_pvrtc: self.img_format_pvrtc || other.img_format_pvrtc,
            img_relaxed_line_rasterization: self.img_relaxed_line_rasterization
                || other.img_relaxed_line_rasterization,
            intel_performance_query: self.intel_performance_query
                || other.intel_performance_query,
            intel_shader_integer_functions2: self.intel_shader_integer_functions2
                || other.intel_shader_integer_functions2,
            msft_layered_driver: self.msft_layered_driver || other.msft_layered_driver,
            nvx_binary_import: self.nvx_binary_import || other.nvx_binary_import,
            nvx_image_view_handle: self.nvx_image_view_handle
                || other.nvx_image_view_handle,
            nvx_multiview_per_view_attributes: self.nvx_multiview_per_view_attributes
                || other.nvx_multiview_per_view_attributes,
            nv_acquire_winrt_display: self.nv_acquire_winrt_display
                || other.nv_acquire_winrt_display,
            nv_clip_space_w_scaling: self.nv_clip_space_w_scaling
                || other.nv_clip_space_w_scaling,
            nv_compute_shader_derivatives: self.nv_compute_shader_derivatives
                || other.nv_compute_shader_derivatives,
            nv_cooperative_matrix: self.nv_cooperative_matrix
                || other.nv_cooperative_matrix,
            nv_copy_memory_indirect: self.nv_copy_memory_indirect
                || other.nv_copy_memory_indirect,
            nv_corner_sampled_image: self.nv_corner_sampled_image
                || other.nv_corner_sampled_image,
            nv_coverage_reduction_mode: self.nv_coverage_reduction_mode
                || other.nv_coverage_reduction_mode,
            nv_cuda_kernel_launch: self.nv_cuda_kernel_launch
                || other.nv_cuda_kernel_launch,
            nv_dedicated_allocation: self.nv_dedicated_allocation
                || other.nv_dedicated_allocation,
            nv_dedicated_allocation_image_aliasing: self
                .nv_dedicated_allocation_image_aliasing
                || other.nv_dedicated_allocation_image_aliasing,
            nv_descriptor_pool_overallocation: self.nv_descriptor_pool_overallocation
                || other.nv_descriptor_pool_overallocation,
            nv_device_diagnostic_checkpoints: self.nv_device_diagnostic_checkpoints
                || other.nv_device_diagnostic_checkpoints,
            nv_device_diagnostics_config: self.nv_device_diagnostics_config
                || other.nv_device_diagnostics_config,
            nv_device_generated_commands: self.nv_device_generated_commands
                || other.nv_device_generated_commands,
            nv_device_generated_commands_compute: self
                .nv_device_generated_commands_compute
                || other.nv_device_generated_commands_compute,
            nv_displacement_micromap: self.nv_displacement_micromap
                || other.nv_displacement_micromap,
            nv_extended_sparse_address_space: self.nv_extended_sparse_address_space
                || other.nv_extended_sparse_address_space,
            nv_external_memory: self.nv_external_memory || other.nv_external_memory,
            nv_external_memory_rdma: self.nv_external_memory_rdma
                || other.nv_external_memory_rdma,
            nv_external_memory_win32: self.nv_external_memory_win32
                || other.nv_external_memory_win32,
            nv_fill_rectangle: self.nv_fill_rectangle || other.nv_fill_rectangle,
            nv_fragment_coverage_to_color: self.nv_fragment_coverage_to_color
                || other.nv_fragment_coverage_to_color,
            nv_fragment_shader_barycentric: self.nv_fragment_shader_barycentric
                || other.nv_fragment_shader_barycentric,
            nv_fragment_shading_rate_enums: self.nv_fragment_shading_rate_enums
                || other.nv_fragment_shading_rate_enums,
            nv_framebuffer_mixed_samples: self.nv_framebuffer_mixed_samples
                || other.nv_framebuffer_mixed_samples,
            nv_geometry_shader_passthrough: self.nv_geometry_shader_passthrough
                || other.nv_geometry_shader_passthrough,
            nv_glsl_shader: self.nv_glsl_shader || other.nv_glsl_shader,
            nv_inherited_viewport_scissor: self.nv_inherited_viewport_scissor
                || other.nv_inherited_viewport_scissor,
            nv_linear_color_attachment: self.nv_linear_color_attachment
                || other.nv_linear_color_attachment,
            nv_low_latency: self.nv_low_latency || other.nv_low_latency,
            nv_low_latency2: self.nv_low_latency2 || other.nv_low_latency2,
            nv_memory_decompression: self.nv_memory_decompression
                || other.nv_memory_decompression,
            nv_mesh_shader: self.nv_mesh_shader || other.nv_mesh_shader,
            nv_optical_flow: self.nv_optical_flow || other.nv_optical_flow,
            nv_per_stage_descriptor_set: self.nv_per_stage_descriptor_set
                || other.nv_per_stage_descriptor_set,
            nv_present_barrier: self.nv_present_barrier || other.nv_present_barrier,
            nv_raw_access_chains: self.nv_raw_access_chains
                || other.nv_raw_access_chains,
            nv_ray_tracing: self.nv_ray_tracing || other.nv_ray_tracing,
            nv_ray_tracing_invocation_reorder: self.nv_ray_tracing_invocation_reorder
                || other.nv_ray_tracing_invocation_reorder,
            nv_ray_tracing_motion_blur: self.nv_ray_tracing_motion_blur
                || other.nv_ray_tracing_motion_blur,
            nv_ray_tracing_validation: self.nv_ray_tracing_validation
                || other.nv_ray_tracing_validation,
            nv_representative_fragment_test: self.nv_representative_fragment_test
                || other.nv_representative_fragment_test,
            nv_sample_mask_override_coverage: self.nv_sample_mask_override_coverage
                || other.nv_sample_mask_override_coverage,
            nv_scissor_exclusive: self.nv_scissor_exclusive
                || other.nv_scissor_exclusive,
            nv_shader_atomic_float16_vector: self.nv_shader_atomic_float16_vector
                || other.nv_shader_atomic_float16_vector,
            nv_shader_image_footprint: self.nv_shader_image_footprint
                || other.nv_shader_image_footprint,
            nv_shader_sm_builtins: self.nv_shader_sm_builtins
                || other.nv_shader_sm_builtins,
            nv_shader_subgroup_partitioned: self.nv_shader_subgroup_partitioned
                || other.nv_shader_subgroup_partitioned,
            nv_shading_rate_image: self.nv_shading_rate_image
                || other.nv_shading_rate_image,
            nv_viewport_array2: self.nv_viewport_array2 || other.nv_viewport_array2,
            nv_viewport_swizzle: self.nv_viewport_swizzle || other.nv_viewport_swizzle,
            nv_win32_keyed_mutex: self.nv_win32_keyed_mutex
                || other.nv_win32_keyed_mutex,
            qcom_filter_cubic_clamp: self.qcom_filter_cubic_clamp
                || other.qcom_filter_cubic_clamp,
            qcom_filter_cubic_weights: self.qcom_filter_cubic_weights
                || other.qcom_filter_cubic_weights,
            qcom_fragment_density_map_offset: self.qcom_fragment_density_map_offset
                || other.qcom_fragment_density_map_offset,
            qcom_image_processing: self.qcom_image_processing
                || other.qcom_image_processing,
            qcom_image_processing2: self.qcom_image_processing2
                || other.qcom_image_processing2,
            qcom_multiview_per_view_render_areas: self
                .qcom_multiview_per_view_render_areas
                || other.qcom_multiview_per_view_render_areas,
            qcom_multiview_per_view_viewports: self.qcom_multiview_per_view_viewports
                || other.qcom_multiview_per_view_viewports,
            qcom_render_pass_shader_resolve: self.qcom_render_pass_shader_resolve
                || other.qcom_render_pass_shader_resolve,
            qcom_render_pass_store_ops: self.qcom_render_pass_store_ops
                || other.qcom_render_pass_store_ops,
            qcom_render_pass_transform: self.qcom_render_pass_transform
                || other.qcom_render_pass_transform,
            qcom_rotated_copy_commands: self.qcom_rotated_copy_commands
                || other.qcom_rotated_copy_commands,
            qcom_tile_properties: self.qcom_tile_properties
                || other.qcom_tile_properties,
            qcom_ycbcr_degamma: self.qcom_ycbcr_degamma || other.qcom_ycbcr_degamma,
            qnx_external_memory_screen_buffer: self.qnx_external_memory_screen_buffer
                || other.qnx_external_memory_screen_buffer,
            sec_amigo_profiling: self.sec_amigo_profiling || other.sec_amigo_profiling,
            valve_descriptor_set_host_mapping: self.valve_descriptor_set_host_mapping
                || other.valve_descriptor_set_host_mapping,
            valve_mutable_descriptor_type: self.valve_mutable_descriptor_type
                || other.valve_mutable_descriptor_type,
            _ne: crate::NonExhaustive(()),
        }
    }
    /// Returns the intersection of `self` and `other`.
    #[inline]
    pub const fn intersection(&self, other: &Self) -> Self {
        Self {
            khr_16bit_storage: self.khr_16bit_storage && other.khr_16bit_storage,
            khr_8bit_storage: self.khr_8bit_storage && other.khr_8bit_storage,
            khr_acceleration_structure: self.khr_acceleration_structure
                && other.khr_acceleration_structure,
            khr_bind_memory2: self.khr_bind_memory2 && other.khr_bind_memory2,
            khr_buffer_device_address: self.khr_buffer_device_address
                && other.khr_buffer_device_address,
            khr_calibrated_timestamps: self.khr_calibrated_timestamps
                && other.khr_calibrated_timestamps,
            khr_cooperative_matrix: self.khr_cooperative_matrix
                && other.khr_cooperative_matrix,
            khr_copy_commands2: self.khr_copy_commands2 && other.khr_copy_commands2,
            khr_create_renderpass2: self.khr_create_renderpass2
                && other.khr_create_renderpass2,
            khr_dedicated_allocation: self.khr_dedicated_allocation
                && other.khr_dedicated_allocation,
            khr_deferred_host_operations: self.khr_deferred_host_operations
                && other.khr_deferred_host_operations,
            khr_depth_stencil_resolve: self.khr_depth_stencil_resolve
                && other.khr_depth_stencil_resolve,
            khr_descriptor_update_template: self.khr_descriptor_update_template
                && other.khr_descriptor_update_template,
            khr_device_group: self.khr_device_group && other.khr_device_group,
            khr_display_swapchain: self.khr_display_swapchain
                && other.khr_display_swapchain,
            khr_draw_indirect_count: self.khr_draw_indirect_count
                && other.khr_draw_indirect_count,
            khr_driver_properties: self.khr_driver_properties
                && other.khr_driver_properties,
            khr_dynamic_rendering: self.khr_dynamic_rendering
                && other.khr_dynamic_rendering,
            khr_dynamic_rendering_local_read: self.khr_dynamic_rendering_local_read
                && other.khr_dynamic_rendering_local_read,
            khr_external_fence: self.khr_external_fence && other.khr_external_fence,
            khr_external_fence_fd: self.khr_external_fence_fd
                && other.khr_external_fence_fd,
            khr_external_fence_win32: self.khr_external_fence_win32
                && other.khr_external_fence_win32,
            khr_external_memory: self.khr_external_memory && other.khr_external_memory,
            khr_external_memory_fd: self.khr_external_memory_fd
                && other.khr_external_memory_fd,
            khr_external_memory_win32: self.khr_external_memory_win32
                && other.khr_external_memory_win32,
            khr_external_semaphore: self.khr_external_semaphore
                && other.khr_external_semaphore,
            khr_external_semaphore_fd: self.khr_external_semaphore_fd
                && other.khr_external_semaphore_fd,
            khr_external_semaphore_win32: self.khr_external_semaphore_win32
                && other.khr_external_semaphore_win32,
            khr_format_feature_flags2: self.khr_format_feature_flags2
                && other.khr_format_feature_flags2,
            khr_fragment_shader_barycentric: self.khr_fragment_shader_barycentric
                && other.khr_fragment_shader_barycentric,
            khr_fragment_shading_rate: self.khr_fragment_shading_rate
                && other.khr_fragment_shading_rate,
            khr_get_memory_requirements2: self.khr_get_memory_requirements2
                && other.khr_get_memory_requirements2,
            khr_global_priority: self.khr_global_priority && other.khr_global_priority,
            khr_image_format_list: self.khr_image_format_list
                && other.khr_image_format_list,
            khr_imageless_framebuffer: self.khr_imageless_framebuffer
                && other.khr_imageless_framebuffer,
            khr_incremental_present: self.khr_incremental_present
                && other.khr_incremental_present,
            khr_index_type_uint8: self.khr_index_type_uint8
                && other.khr_index_type_uint8,
            khr_line_rasterization: self.khr_line_rasterization
                && other.khr_line_rasterization,
            khr_load_store_op_none: self.khr_load_store_op_none
                && other.khr_load_store_op_none,
            khr_maintenance1: self.khr_maintenance1 && other.khr_maintenance1,
            khr_maintenance2: self.khr_maintenance2 && other.khr_maintenance2,
            khr_maintenance3: self.khr_maintenance3 && other.khr_maintenance3,
            khr_maintenance4: self.khr_maintenance4 && other.khr_maintenance4,
            khr_maintenance5: self.khr_maintenance5 && other.khr_maintenance5,
            khr_maintenance6: self.khr_maintenance6 && other.khr_maintenance6,
            khr_map_memory2: self.khr_map_memory2 && other.khr_map_memory2,
            khr_multiview: self.khr_multiview && other.khr_multiview,
            khr_performance_query: self.khr_performance_query
                && other.khr_performance_query,
            khr_pipeline_executable_properties: self.khr_pipeline_executable_properties
                && other.khr_pipeline_executable_properties,
            khr_pipeline_library: self.khr_pipeline_library
                && other.khr_pipeline_library,
            khr_portability_subset: self.khr_portability_subset
                && other.khr_portability_subset,
            khr_present_id: self.khr_present_id && other.khr_present_id,
            khr_present_wait: self.khr_present_wait && other.khr_present_wait,
            khr_push_descriptor: self.khr_push_descriptor && other.khr_push_descriptor,
            khr_ray_query: self.khr_ray_query && other.khr_ray_query,
            khr_ray_tracing_maintenance1: self.khr_ray_tracing_maintenance1
                && other.khr_ray_tracing_maintenance1,
            khr_ray_tracing_pipeline: self.khr_ray_tracing_pipeline
                && other.khr_ray_tracing_pipeline,
            khr_ray_tracing_position_fetch: self.khr_ray_tracing_position_fetch
                && other.khr_ray_tracing_position_fetch,
            khr_relaxed_block_layout: self.khr_relaxed_block_layout
                && other.khr_relaxed_block_layout,
            khr_sampler_mirror_clamp_to_edge: self.khr_sampler_mirror_clamp_to_edge
                && other.khr_sampler_mirror_clamp_to_edge,
            khr_sampler_ycbcr_conversion: self.khr_sampler_ycbcr_conversion
                && other.khr_sampler_ycbcr_conversion,
            khr_separate_depth_stencil_layouts: self.khr_separate_depth_stencil_layouts
                && other.khr_separate_depth_stencil_layouts,
            khr_shader_atomic_int64: self.khr_shader_atomic_int64
                && other.khr_shader_atomic_int64,
            khr_shader_clock: self.khr_shader_clock && other.khr_shader_clock,
            khr_shader_draw_parameters: self.khr_shader_draw_parameters
                && other.khr_shader_draw_parameters,
            khr_shader_expect_assume: self.khr_shader_expect_assume
                && other.khr_shader_expect_assume,
            khr_shader_float16_int8: self.khr_shader_float16_int8
                && other.khr_shader_float16_int8,
            khr_shader_float_controls: self.khr_shader_float_controls
                && other.khr_shader_float_controls,
            khr_shader_float_controls2: self.khr_shader_float_controls2
                && other.khr_shader_float_controls2,
            khr_shader_integer_dot_product: self.khr_shader_integer_dot_product
                && other.khr_shader_integer_dot_product,
            khr_shader_maximal_reconvergence: self.khr_shader_maximal_reconvergence
                && other.khr_shader_maximal_reconvergence,
            khr_shader_non_semantic_info: self.khr_shader_non_semantic_info
                && other.khr_shader_non_semantic_info,
            khr_shader_quad_control: self.khr_shader_quad_control
                && other.khr_shader_quad_control,
            khr_shader_subgroup_extended_types: self.khr_shader_subgroup_extended_types
                && other.khr_shader_subgroup_extended_types,
            khr_shader_subgroup_rotate: self.khr_shader_subgroup_rotate
                && other.khr_shader_subgroup_rotate,
            khr_shader_subgroup_uniform_control_flow: self
                .khr_shader_subgroup_uniform_control_flow
                && other.khr_shader_subgroup_uniform_control_flow,
            khr_shader_terminate_invocation: self.khr_shader_terminate_invocation
                && other.khr_shader_terminate_invocation,
            khr_shared_presentable_image: self.khr_shared_presentable_image
                && other.khr_shared_presentable_image,
            khr_spirv_1_4: self.khr_spirv_1_4 && other.khr_spirv_1_4,
            khr_storage_buffer_storage_class: self.khr_storage_buffer_storage_class
                && other.khr_storage_buffer_storage_class,
            khr_swapchain: self.khr_swapchain && other.khr_swapchain,
            khr_swapchain_mutable_format: self.khr_swapchain_mutable_format
                && other.khr_swapchain_mutable_format,
            khr_synchronization2: self.khr_synchronization2
                && other.khr_synchronization2,
            khr_timeline_semaphore: self.khr_timeline_semaphore
                && other.khr_timeline_semaphore,
            khr_uniform_buffer_standard_layout: self.khr_uniform_buffer_standard_layout
                && other.khr_uniform_buffer_standard_layout,
            khr_variable_pointers: self.khr_variable_pointers
                && other.khr_variable_pointers,
            khr_vertex_attribute_divisor: self.khr_vertex_attribute_divisor
                && other.khr_vertex_attribute_divisor,
            khr_video_decode_av1: self.khr_video_decode_av1
                && other.khr_video_decode_av1,
            khr_video_decode_h264: self.khr_video_decode_h264
                && other.khr_video_decode_h264,
            khr_video_decode_h265: self.khr_video_decode_h265
                && other.khr_video_decode_h265,
            khr_video_decode_queue: self.khr_video_decode_queue
                && other.khr_video_decode_queue,
            khr_video_encode_h264: self.khr_video_encode_h264
                && other.khr_video_encode_h264,
            khr_video_encode_h265: self.khr_video_encode_h265
                && other.khr_video_encode_h265,
            khr_video_encode_queue: self.khr_video_encode_queue
                && other.khr_video_encode_queue,
            khr_video_maintenance1: self.khr_video_maintenance1
                && other.khr_video_maintenance1,
            khr_video_queue: self.khr_video_queue && other.khr_video_queue,
            khr_vulkan_memory_model: self.khr_vulkan_memory_model
                && other.khr_vulkan_memory_model,
            khr_win32_keyed_mutex: self.khr_win32_keyed_mutex
                && other.khr_win32_keyed_mutex,
            khr_workgroup_memory_explicit_layout: self
                .khr_workgroup_memory_explicit_layout
                && other.khr_workgroup_memory_explicit_layout,
            khr_zero_initialize_workgroup_memory: self
                .khr_zero_initialize_workgroup_memory
                && other.khr_zero_initialize_workgroup_memory,
            ext_4444_formats: self.ext_4444_formats && other.ext_4444_formats,
            ext_astc_decode_mode: self.ext_astc_decode_mode
                && other.ext_astc_decode_mode,
            ext_attachment_feedback_loop_dynamic_state: self
                .ext_attachment_feedback_loop_dynamic_state
                && other.ext_attachment_feedback_loop_dynamic_state,
            ext_attachment_feedback_loop_layout: self.ext_attachment_feedback_loop_layout
                && other.ext_attachment_feedback_loop_layout,
            ext_blend_operation_advanced: self.ext_blend_operation_advanced
                && other.ext_blend_operation_advanced,
            ext_border_color_swizzle: self.ext_border_color_swizzle
                && other.ext_border_color_swizzle,
            ext_buffer_device_address: self.ext_buffer_device_address
                && other.ext_buffer_device_address,
            ext_calibrated_timestamps: self.ext_calibrated_timestamps
                && other.ext_calibrated_timestamps,
            ext_color_write_enable: self.ext_color_write_enable
                && other.ext_color_write_enable,
            ext_conditional_rendering: self.ext_conditional_rendering
                && other.ext_conditional_rendering,
            ext_conservative_rasterization: self.ext_conservative_rasterization
                && other.ext_conservative_rasterization,
            ext_custom_border_color: self.ext_custom_border_color
                && other.ext_custom_border_color,
            ext_debug_marker: self.ext_debug_marker && other.ext_debug_marker,
            ext_depth_bias_control: self.ext_depth_bias_control
                && other.ext_depth_bias_control,
            ext_depth_clamp_zero_one: self.ext_depth_clamp_zero_one
                && other.ext_depth_clamp_zero_one,
            ext_depth_clip_control: self.ext_depth_clip_control
                && other.ext_depth_clip_control,
            ext_depth_clip_enable: self.ext_depth_clip_enable
                && other.ext_depth_clip_enable,
            ext_depth_range_unrestricted: self.ext_depth_range_unrestricted
                && other.ext_depth_range_unrestricted,
            ext_descriptor_buffer: self.ext_descriptor_buffer
                && other.ext_descriptor_buffer,
            ext_descriptor_indexing: self.ext_descriptor_indexing
                && other.ext_descriptor_indexing,
            ext_device_address_binding_report: self.ext_device_address_binding_report
                && other.ext_device_address_binding_report,
            ext_device_fault: self.ext_device_fault && other.ext_device_fault,
            ext_device_memory_report: self.ext_device_memory_report
                && other.ext_device_memory_report,
            ext_discard_rectangles: self.ext_discard_rectangles
                && other.ext_discard_rectangles,
            ext_display_control: self.ext_display_control && other.ext_display_control,
            ext_dynamic_rendering_unused_attachments: self
                .ext_dynamic_rendering_unused_attachments
                && other.ext_dynamic_rendering_unused_attachments,
            ext_extended_dynamic_state: self.ext_extended_dynamic_state
                && other.ext_extended_dynamic_state,
            ext_extended_dynamic_state2: self.ext_extended_dynamic_state2
                && other.ext_extended_dynamic_state2,
            ext_extended_dynamic_state3: self.ext_extended_dynamic_state3
                && other.ext_extended_dynamic_state3,
            ext_external_memory_acquire_unmodified: self
                .ext_external_memory_acquire_unmodified
                && other.ext_external_memory_acquire_unmodified,
            ext_external_memory_dma_buf: self.ext_external_memory_dma_buf
                && other.ext_external_memory_dma_buf,
            ext_external_memory_host: self.ext_external_memory_host
                && other.ext_external_memory_host,
            ext_filter_cubic: self.ext_filter_cubic && other.ext_filter_cubic,
            ext_fragment_density_map: self.ext_fragment_density_map
                && other.ext_fragment_density_map,
            ext_fragment_density_map2: self.ext_fragment_density_map2
                && other.ext_fragment_density_map2,
            ext_fragment_shader_interlock: self.ext_fragment_shader_interlock
                && other.ext_fragment_shader_interlock,
            ext_frame_boundary: self.ext_frame_boundary && other.ext_frame_boundary,
            ext_full_screen_exclusive: self.ext_full_screen_exclusive
                && other.ext_full_screen_exclusive,
            ext_global_priority: self.ext_global_priority && other.ext_global_priority,
            ext_global_priority_query: self.ext_global_priority_query
                && other.ext_global_priority_query,
            ext_graphics_pipeline_library: self.ext_graphics_pipeline_library
                && other.ext_graphics_pipeline_library,
            ext_hdr_metadata: self.ext_hdr_metadata && other.ext_hdr_metadata,
            ext_host_image_copy: self.ext_host_image_copy && other.ext_host_image_copy,
            ext_host_query_reset: self.ext_host_query_reset
                && other.ext_host_query_reset,
            ext_image_2d_view_of_3d: self.ext_image_2d_view_of_3d
                && other.ext_image_2d_view_of_3d,
            ext_image_compression_control: self.ext_image_compression_control
                && other.ext_image_compression_control,
            ext_image_compression_control_swapchain: self
                .ext_image_compression_control_swapchain
                && other.ext_image_compression_control_swapchain,
            ext_image_drm_format_modifier: self.ext_image_drm_format_modifier
                && other.ext_image_drm_format_modifier,
            ext_image_robustness: self.ext_image_robustness
                && other.ext_image_robustness,
            ext_image_sliced_view_of_3d: self.ext_image_sliced_view_of_3d
                && other.ext_image_sliced_view_of_3d,
            ext_image_view_min_lod: self.ext_image_view_min_lod
                && other.ext_image_view_min_lod,
            ext_index_type_uint8: self.ext_index_type_uint8
                && other.ext_index_type_uint8,
            ext_inline_uniform_block: self.ext_inline_uniform_block
                && other.ext_inline_uniform_block,
            ext_legacy_dithering: self.ext_legacy_dithering
                && other.ext_legacy_dithering,
            ext_line_rasterization: self.ext_line_rasterization
                && other.ext_line_rasterization,
            ext_load_store_op_none: self.ext_load_store_op_none
                && other.ext_load_store_op_none,
            ext_map_memory_placed: self.ext_map_memory_placed
                && other.ext_map_memory_placed,
            ext_memory_budget: self.ext_memory_budget && other.ext_memory_budget,
            ext_memory_priority: self.ext_memory_priority && other.ext_memory_priority,
            ext_mesh_shader: self.ext_mesh_shader && other.ext_mesh_shader,
            ext_metal_objects: self.ext_metal_objects && other.ext_metal_objects,
            ext_multi_draw: self.ext_multi_draw && other.ext_multi_draw,
            ext_multisampled_render_to_single_sampled: self
                .ext_multisampled_render_to_single_sampled
                && other.ext_multisampled_render_to_single_sampled,
            ext_mutable_descriptor_type: self.ext_mutable_descriptor_type
                && other.ext_mutable_descriptor_type,
            ext_nested_command_buffer: self.ext_nested_command_buffer
                && other.ext_nested_command_buffer,
            ext_non_seamless_cube_map: self.ext_non_seamless_cube_map
                && other.ext_non_seamless_cube_map,
            ext_opacity_micromap: self.ext_opacity_micromap
                && other.ext_opacity_micromap,
            ext_pageable_device_local_memory: self.ext_pageable_device_local_memory
                && other.ext_pageable_device_local_memory,
            ext_pci_bus_info: self.ext_pci_bus_info && other.ext_pci_bus_info,
            ext_physical_device_drm: self.ext_physical_device_drm
                && other.ext_physical_device_drm,
            ext_pipeline_creation_cache_control: self.ext_pipeline_creation_cache_control
                && other.ext_pipeline_creation_cache_control,
            ext_pipeline_creation_feedback: self.ext_pipeline_creation_feedback
                && other.ext_pipeline_creation_feedback,
            ext_pipeline_library_group_handles: self.ext_pipeline_library_group_handles
                && other.ext_pipeline_library_group_handles,
            ext_pipeline_properties: self.ext_pipeline_properties
                && other.ext_pipeline_properties,
            ext_pipeline_protected_access: self.ext_pipeline_protected_access
                && other.ext_pipeline_protected_access,
            ext_pipeline_robustness: self.ext_pipeline_robustness
                && other.ext_pipeline_robustness,
            ext_post_depth_coverage: self.ext_post_depth_coverage
                && other.ext_post_depth_coverage,
            ext_primitive_topology_list_restart: self.ext_primitive_topology_list_restart
                && other.ext_primitive_topology_list_restart,
            ext_primitives_generated_query: self.ext_primitives_generated_query
                && other.ext_primitives_generated_query,
            ext_private_data: self.ext_private_data && other.ext_private_data,
            ext_provoking_vertex: self.ext_provoking_vertex
                && other.ext_provoking_vertex,
            ext_queue_family_foreign: self.ext_queue_family_foreign
                && other.ext_queue_family_foreign,
            ext_rasterization_order_attachment_access: self
                .ext_rasterization_order_attachment_access
                && other.ext_rasterization_order_attachment_access,
            ext_rgba10x6_formats: self.ext_rgba10x6_formats
                && other.ext_rgba10x6_formats,
            ext_robustness2: self.ext_robustness2 && other.ext_robustness2,
            ext_sample_locations: self.ext_sample_locations
                && other.ext_sample_locations,
            ext_sampler_filter_minmax: self.ext_sampler_filter_minmax
                && other.ext_sampler_filter_minmax,
            ext_scalar_block_layout: self.ext_scalar_block_layout
                && other.ext_scalar_block_layout,
            ext_separate_stencil_usage: self.ext_separate_stencil_usage
                && other.ext_separate_stencil_usage,
            ext_shader_atomic_float: self.ext_shader_atomic_float
                && other.ext_shader_atomic_float,
            ext_shader_atomic_float2: self.ext_shader_atomic_float2
                && other.ext_shader_atomic_float2,
            ext_shader_demote_to_helper_invocation: self
                .ext_shader_demote_to_helper_invocation
                && other.ext_shader_demote_to_helper_invocation,
            ext_shader_image_atomic_int64: self.ext_shader_image_atomic_int64
                && other.ext_shader_image_atomic_int64,
            ext_shader_module_identifier: self.ext_shader_module_identifier
                && other.ext_shader_module_identifier,
            ext_shader_object: self.ext_shader_object && other.ext_shader_object,
            ext_shader_stencil_export: self.ext_shader_stencil_export
                && other.ext_shader_stencil_export,
            ext_shader_subgroup_ballot: self.ext_shader_subgroup_ballot
                && other.ext_shader_subgroup_ballot,
            ext_shader_subgroup_vote: self.ext_shader_subgroup_vote
                && other.ext_shader_subgroup_vote,
            ext_shader_tile_image: self.ext_shader_tile_image
                && other.ext_shader_tile_image,
            ext_shader_viewport_index_layer: self.ext_shader_viewport_index_layer
                && other.ext_shader_viewport_index_layer,
            ext_subgroup_size_control: self.ext_subgroup_size_control
                && other.ext_subgroup_size_control,
            ext_subpass_merge_feedback: self.ext_subpass_merge_feedback
                && other.ext_subpass_merge_feedback,
            ext_swapchain_maintenance1: self.ext_swapchain_maintenance1
                && other.ext_swapchain_maintenance1,
            ext_texel_buffer_alignment: self.ext_texel_buffer_alignment
                && other.ext_texel_buffer_alignment,
            ext_texture_compression_astc_hdr: self.ext_texture_compression_astc_hdr
                && other.ext_texture_compression_astc_hdr,
            ext_tooling_info: self.ext_tooling_info && other.ext_tooling_info,
            ext_transform_feedback: self.ext_transform_feedback
                && other.ext_transform_feedback,
            ext_validation_cache: self.ext_validation_cache
                && other.ext_validation_cache,
            ext_vertex_attribute_divisor: self.ext_vertex_attribute_divisor
                && other.ext_vertex_attribute_divisor,
            ext_vertex_input_dynamic_state: self.ext_vertex_input_dynamic_state
                && other.ext_vertex_input_dynamic_state,
            ext_ycbcr_2plane_444_formats: self.ext_ycbcr_2plane_444_formats
                && other.ext_ycbcr_2plane_444_formats,
            ext_ycbcr_image_arrays: self.ext_ycbcr_image_arrays
                && other.ext_ycbcr_image_arrays,
            amdx_shader_enqueue: self.amdx_shader_enqueue && other.amdx_shader_enqueue,
            amd_buffer_marker: self.amd_buffer_marker && other.amd_buffer_marker,
            amd_device_coherent_memory: self.amd_device_coherent_memory
                && other.amd_device_coherent_memory,
            amd_display_native_hdr: self.amd_display_native_hdr
                && other.amd_display_native_hdr,
            amd_draw_indirect_count: self.amd_draw_indirect_count
                && other.amd_draw_indirect_count,
            amd_gcn_shader: self.amd_gcn_shader && other.amd_gcn_shader,
            amd_gpu_shader_half_float: self.amd_gpu_shader_half_float
                && other.amd_gpu_shader_half_float,
            amd_gpu_shader_int16: self.amd_gpu_shader_int16
                && other.amd_gpu_shader_int16,
            amd_memory_overallocation_behavior: self.amd_memory_overallocation_behavior
                && other.amd_memory_overallocation_behavior,
            amd_mixed_attachment_samples: self.amd_mixed_attachment_samples
                && other.amd_mixed_attachment_samples,
            amd_pipeline_compiler_control: self.amd_pipeline_compiler_control
                && other.amd_pipeline_compiler_control,
            amd_rasterization_order: self.amd_rasterization_order
                && other.amd_rasterization_order,
            amd_shader_ballot: self.amd_shader_ballot && other.amd_shader_ballot,
            amd_shader_core_properties: self.amd_shader_core_properties
                && other.amd_shader_core_properties,
            amd_shader_core_properties2: self.amd_shader_core_properties2
                && other.amd_shader_core_properties2,
            amd_shader_early_and_late_fragment_tests: self
                .amd_shader_early_and_late_fragment_tests
                && other.amd_shader_early_and_late_fragment_tests,
            amd_shader_explicit_vertex_parameter: self
                .amd_shader_explicit_vertex_parameter
                && other.amd_shader_explicit_vertex_parameter,
            amd_shader_fragment_mask: self.amd_shader_fragment_mask
                && other.amd_shader_fragment_mask,
            amd_shader_image_load_store_lod: self.amd_shader_image_load_store_lod
                && other.amd_shader_image_load_store_lod,
            amd_shader_info: self.amd_shader_info && other.amd_shader_info,
            amd_shader_trinary_minmax: self.amd_shader_trinary_minmax
                && other.amd_shader_trinary_minmax,
            amd_texture_gather_bias_lod: self.amd_texture_gather_bias_lod
                && other.amd_texture_gather_bias_lod,
            android_external_format_resolve: self.android_external_format_resolve
                && other.android_external_format_resolve,
            android_external_memory_android_hardware_buffer: self
                .android_external_memory_android_hardware_buffer
                && other.android_external_memory_android_hardware_buffer,
            arm_rasterization_order_attachment_access: self
                .arm_rasterization_order_attachment_access
                && other.arm_rasterization_order_attachment_access,
            arm_render_pass_striped: self.arm_render_pass_striped
                && other.arm_render_pass_striped,
            arm_scheduling_controls: self.arm_scheduling_controls
                && other.arm_scheduling_controls,
            arm_shader_core_builtins: self.arm_shader_core_builtins
                && other.arm_shader_core_builtins,
            arm_shader_core_properties: self.arm_shader_core_properties
                && other.arm_shader_core_properties,
            fuchsia_buffer_collection: self.fuchsia_buffer_collection
                && other.fuchsia_buffer_collection,
            fuchsia_external_memory: self.fuchsia_external_memory
                && other.fuchsia_external_memory,
            fuchsia_external_semaphore: self.fuchsia_external_semaphore
                && other.fuchsia_external_semaphore,
            ggp_frame_token: self.ggp_frame_token && other.ggp_frame_token,
            google_decorate_string: self.google_decorate_string
                && other.google_decorate_string,
            google_display_timing: self.google_display_timing
                && other.google_display_timing,
            google_hlsl_functionality1: self.google_hlsl_functionality1
                && other.google_hlsl_functionality1,
            google_user_type: self.google_user_type && other.google_user_type,
            huawei_cluster_culling_shader: self.huawei_cluster_culling_shader
                && other.huawei_cluster_culling_shader,
            huawei_invocation_mask: self.huawei_invocation_mask
                && other.huawei_invocation_mask,
            huawei_subpass_shading: self.huawei_subpass_shading
                && other.huawei_subpass_shading,
            img_filter_cubic: self.img_filter_cubic && other.img_filter_cubic,
            img_format_pvrtc: self.img_format_pvrtc && other.img_format_pvrtc,
            img_relaxed_line_rasterization: self.img_relaxed_line_rasterization
                && other.img_relaxed_line_rasterization,
            intel_performance_query: self.intel_performance_query
                && other.intel_performance_query,
            intel_shader_integer_functions2: self.intel_shader_integer_functions2
                && other.intel_shader_integer_functions2,
            msft_layered_driver: self.msft_layered_driver && other.msft_layered_driver,
            nvx_binary_import: self.nvx_binary_import && other.nvx_binary_import,
            nvx_image_view_handle: self.nvx_image_view_handle
                && other.nvx_image_view_handle,
            nvx_multiview_per_view_attributes: self.nvx_multiview_per_view_attributes
                && other.nvx_multiview_per_view_attributes,
            nv_acquire_winrt_display: self.nv_acquire_winrt_display
                && other.nv_acquire_winrt_display,
            nv_clip_space_w_scaling: self.nv_clip_space_w_scaling
                && other.nv_clip_space_w_scaling,
            nv_compute_shader_derivatives: self.nv_compute_shader_derivatives
                && other.nv_compute_shader_derivatives,
            nv_cooperative_matrix: self.nv_cooperative_matrix
                && other.nv_cooperative_matrix,
            nv_copy_memory_indirect: self.nv_copy_memory_indirect
                && other.nv_copy_memory_indirect,
            nv_corner_sampled_image: self.nv_corner_sampled_image
                && other.nv_corner_sampled_image,
            nv_coverage_reduction_mode: self.nv_coverage_reduction_mode
                && other.nv_coverage_reduction_mode,
            nv_cuda_kernel_launch: self.nv_cuda_kernel_launch
                && other.nv_cuda_kernel_launch,
            nv_dedicated_allocation: self.nv_dedicated_allocation
                && other.nv_dedicated_allocation,
            nv_dedicated_allocation_image_aliasing: self
                .nv_dedicated_allocation_image_aliasing
                && other.nv_dedicated_allocation_image_aliasing,
            nv_descriptor_pool_overallocation: self.nv_descriptor_pool_overallocation
                && other.nv_descriptor_pool_overallocation,
            nv_device_diagnostic_checkpoints: self.nv_device_diagnostic_checkpoints
                && other.nv_device_diagnostic_checkpoints,
            nv_device_diagnostics_config: self.nv_device_diagnostics_config
                && other.nv_device_diagnostics_config,
            nv_device_generated_commands: self.nv_device_generated_commands
                && other.nv_device_generated_commands,
            nv_device_generated_commands_compute: self
                .nv_device_generated_commands_compute
                && other.nv_device_generated_commands_compute,
            nv_displacement_micromap: self.nv_displacement_micromap
                && other.nv_displacement_micromap,
            nv_extended_sparse_address_space: self.nv_extended_sparse_address_space
                && other.nv_extended_sparse_address_space,
            nv_external_memory: self.nv_external_memory && other.nv_external_memory,
            nv_external_memory_rdma: self.nv_external_memory_rdma
                && other.nv_external_memory_rdma,
            nv_external_memory_win32: self.nv_external_memory_win32
                && other.nv_external_memory_win32,
            nv_fill_rectangle: self.nv_fill_rectangle && other.nv_fill_rectangle,
            nv_fragment_coverage_to_color: self.nv_fragment_coverage_to_color
                && other.nv_fragment_coverage_to_color,
            nv_fragment_shader_barycentric: self.nv_fragment_shader_barycentric
                && other.nv_fragment_shader_barycentric,
            nv_fragment_shading_rate_enums: self.nv_fragment_shading_rate_enums
                && other.nv_fragment_shading_rate_enums,
            nv_framebuffer_mixed_samples: self.nv_framebuffer_mixed_samples
                && other.nv_framebuffer_mixed_samples,
            nv_geometry_shader_passthrough: self.nv_geometry_shader_passthrough
                && other.nv_geometry_shader_passthrough,
            nv_glsl_shader: self.nv_glsl_shader && other.nv_glsl_shader,
            nv_inherited_viewport_scissor: self.nv_inherited_viewport_scissor
                && other.nv_inherited_viewport_scissor,
            nv_linear_color_attachment: self.nv_linear_color_attachment
                && other.nv_linear_color_attachment,
            nv_low_latency: self.nv_low_latency && other.nv_low_latency,
            nv_low_latency2: self.nv_low_latency2 && other.nv_low_latency2,
            nv_memory_decompression: self.nv_memory_decompression
                && other.nv_memory_decompression,
            nv_mesh_shader: self.nv_mesh_shader && other.nv_mesh_shader,
            nv_optical_flow: self.nv_optical_flow && other.nv_optical_flow,
            nv_per_stage_descriptor_set: self.nv_per_stage_descriptor_set
                && other.nv_per_stage_descriptor_set,
            nv_present_barrier: self.nv_present_barrier && other.nv_present_barrier,
            nv_raw_access_chains: self.nv_raw_access_chains
                && other.nv_raw_access_chains,
            nv_ray_tracing: self.nv_ray_tracing && other.nv_ray_tracing,
            nv_ray_tracing_invocation_reorder: self.nv_ray_tracing_invocation_reorder
                && other.nv_ray_tracing_invocation_reorder,
            nv_ray_tracing_motion_blur: self.nv_ray_tracing_motion_blur
                && other.nv_ray_tracing_motion_blur,
            nv_ray_tracing_validation: self.nv_ray_tracing_validation
                && other.nv_ray_tracing_validation,
            nv_representative_fragment_test: self.nv_representative_fragment_test
                && other.nv_representative_fragment_test,
            nv_sample_mask_override_coverage: self.nv_sample_mask_override_coverage
                && other.nv_sample_mask_override_coverage,
            nv_scissor_exclusive: self.nv_scissor_exclusive
                && other.nv_scissor_exclusive,
            nv_shader_atomic_float16_vector: self.nv_shader_atomic_float16_vector
                && other.nv_shader_atomic_float16_vector,
            nv_shader_image_footprint: self.nv_shader_image_footprint
                && other.nv_shader_image_footprint,
            nv_shader_sm_builtins: self.nv_shader_sm_builtins
                && other.nv_shader_sm_builtins,
            nv_shader_subgroup_partitioned: self.nv_shader_subgroup_partitioned
                && other.nv_shader_subgroup_partitioned,
            nv_shading_rate_image: self.nv_shading_rate_image
                && other.nv_shading_rate_image,
            nv_viewport_array2: self.nv_viewport_array2 && other.nv_viewport_array2,
            nv_viewport_swizzle: self.nv_viewport_swizzle && other.nv_viewport_swizzle,
            nv_win32_keyed_mutex: self.nv_win32_keyed_mutex
                && other.nv_win32_keyed_mutex,
            qcom_filter_cubic_clamp: self.qcom_filter_cubic_clamp
                && other.qcom_filter_cubic_clamp,
            qcom_filter_cubic_weights: self.qcom_filter_cubic_weights
                && other.qcom_filter_cubic_weights,
            qcom_fragment_density_map_offset: self.qcom_fragment_density_map_offset
                && other.qcom_fragment_density_map_offset,
            qcom_image_processing: self.qcom_image_processing
                && other.qcom_image_processing,
            qcom_image_processing2: self.qcom_image_processing2
                && other.qcom_image_processing2,
            qcom_multiview_per_view_render_areas: self
                .qcom_multiview_per_view_render_areas
                && other.qcom_multiview_per_view_render_areas,
            qcom_multiview_per_view_viewports: self.qcom_multiview_per_view_viewports
                && other.qcom_multiview_per_view_viewports,
            qcom_render_pass_shader_resolve: self.qcom_render_pass_shader_resolve
                && other.qcom_render_pass_shader_resolve,
            qcom_render_pass_store_ops: self.qcom_render_pass_store_ops
                && other.qcom_render_pass_store_ops,
            qcom_render_pass_transform: self.qcom_render_pass_transform
                && other.qcom_render_pass_transform,
            qcom_rotated_copy_commands: self.qcom_rotated_copy_commands
                && other.qcom_rotated_copy_commands,
            qcom_tile_properties: self.qcom_tile_properties
                && other.qcom_tile_properties,
            qcom_ycbcr_degamma: self.qcom_ycbcr_degamma && other.qcom_ycbcr_degamma,
            qnx_external_memory_screen_buffer: self.qnx_external_memory_screen_buffer
                && other.qnx_external_memory_screen_buffer,
            sec_amigo_profiling: self.sec_amigo_profiling && other.sec_amigo_profiling,
            valve_descriptor_set_host_mapping: self.valve_descriptor_set_host_mapping
                && other.valve_descriptor_set_host_mapping,
            valve_mutable_descriptor_type: self.valve_mutable_descriptor_type
                && other.valve_mutable_descriptor_type,
            _ne: crate::NonExhaustive(()),
        }
    }
    /// Returns `self` without the members set in `other`.
    #[inline]
    pub const fn difference(&self, other: &Self) -> Self {
        Self {
            khr_16bit_storage: self.khr_16bit_storage && !other.khr_16bit_storage,
            khr_8bit_storage: self.khr_8bit_storage && !other.khr_8bit_storage,
            khr_acceleration_structure: self.khr_acceleration_structure
                && !other.khr_acceleration_structure,
            khr_bind_memory2: self.khr_bind_memory2 && !other.khr_bind_memory2,
            khr_buffer_device_address: self.khr_buffer_device_address
                && !other.khr_buffer_device_address,
            khr_calibrated_timestamps: self.khr_calibrated_timestamps
                && !other.khr_calibrated_timestamps,
            khr_cooperative_matrix: self.khr_cooperative_matrix
                && !other.khr_cooperative_matrix,
            khr_copy_commands2: self.khr_copy_commands2 && !other.khr_copy_commands2,
            khr_create_renderpass2: self.khr_create_renderpass2
                && !other.khr_create_renderpass2,
            khr_dedicated_allocation: self.khr_dedicated_allocation
                && !other.khr_dedicated_allocation,
            khr_deferred_host_operations: self.khr_deferred_host_operations
                && !other.khr_deferred_host_operations,
            khr_depth_stencil_resolve: self.khr_depth_stencil_resolve
                && !other.khr_depth_stencil_resolve,
            khr_descriptor_update_template: self.khr_descriptor_update_template
                && !other.khr_descriptor_update_template,
            khr_device_group: self.khr_device_group && !other.khr_device_group,
            khr_display_swapchain: self.khr_display_swapchain
                && !other.khr_display_swapchain,
            khr_draw_indirect_count: self.khr_draw_indirect_count
                && !other.khr_draw_indirect_count,
            khr_driver_properties: self.khr_driver_properties
                && !other.khr_driver_properties,
            khr_dynamic_rendering: self.khr_dynamic_rendering
                && !other.khr_dynamic_rendering,
            khr_dynamic_rendering_local_read: self.khr_dynamic_rendering_local_read
                && !other.khr_dynamic_rendering_local_read,
            khr_external_fence: self.khr_external_fence && !other.khr_external_fence,
            khr_external_fence_fd: self.khr_external_fence_fd
                && !other.khr_external_fence_fd,
            khr_external_fence_win32: self.khr_external_fence_win32
                && !other.khr_external_fence_win32,
            khr_external_memory: self.khr_external_memory && !other.khr_external_memory,
            khr_external_memory_fd: self.khr_external_memory_fd
                && !other.khr_external_memory_fd,
            khr_external_memory_win32: self.khr_external_memory_win32
                && !other.khr_external_memory_win32,
            khr_external_semaphore: self.khr_external_semaphore
                && !other.khr_external_semaphore,
            khr_external_semaphore_fd: self.khr_external_semaphore_fd
                && !other.khr_external_semaphore_fd,
            khr_external_semaphore_win32: self.khr_external_semaphore_win32
                && !other.khr_external_semaphore_win32,
            khr_format_feature_flags2: self.khr_format_feature_flags2
                && !other.khr_format_feature_flags2,
            khr_fragment_shader_barycentric: self.khr_fragment_shader_barycentric
                && !other.khr_fragment_shader_barycentric,
            khr_fragment_shading_rate: self.khr_fragment_shading_rate
                && !other.khr_fragment_shading_rate,
            khr_get_memory_requirements2: self.khr_get_memory_requirements2
                && !other.khr_get_memory_requirements2,
            khr_global_priority: self.khr_global_priority && !other.khr_global_priority,
            khr_image_format_list: self.khr_image_format_list
                && !other.khr_image_format_list,
            khr_imageless_framebuffer: self.khr_imageless_framebuffer
                && !other.khr_imageless_framebuffer,
            khr_incremental_present: self.khr_incremental_present
                && !other.khr_incremental_present,
            khr_index_type_uint8: self.khr_index_type_uint8
                && !other.khr_index_type_uint8,
            khr_line_rasterization: self.khr_line_rasterization
                && !other.khr_line_rasterization,
            khr_load_store_op_none: self.khr_load_store_op_none
                && !other.khr_load_store_op_none,
            khr_maintenance1: self.khr_maintenance1 && !other.khr_maintenance1,
            khr_maintenance2: self.khr_maintenance2 && !other.khr_maintenance2,
            khr_maintenance3: self.khr_maintenance3 && !other.khr_maintenance3,
            khr_maintenance4: self.khr_maintenance4 && !other.khr_maintenance4,
            khr_maintenance5: self.khr_maintenance5 && !other.khr_maintenance5,
            khr_maintenance6: self.khr_maintenance6 && !other.khr_maintenance6,
            khr_map_memory2: self.khr_map_memory2 && !other.khr_map_memory2,
            khr_multiview: self.khr_multiview && !other.khr_multiview,
            khr_performance_query: self.khr_performance_query
                && !other.khr_performance_query,
            khr_pipeline_executable_properties: self.khr_pipeline_executable_properties
                && !other.khr_pipeline_executable_properties,
            khr_pipeline_library: self.khr_pipeline_library
                && !other.khr_pipeline_library,
            khr_portability_subset: self.khr_portability_subset
                && !other.khr_portability_subset,
            khr_present_id: self.khr_present_id && !other.khr_present_id,
            khr_present_wait: self.khr_present_wait && !other.khr_present_wait,
            khr_push_descriptor: self.khr_push_descriptor && !other.khr_push_descriptor,
            khr_ray_query: self.khr_ray_query && !other.khr_ray_query,
            khr_ray_tracing_maintenance1: self.khr_ray_tracing_maintenance1
                && !other.khr_ray_tracing_maintenance1,
            khr_ray_tracing_pipeline: self.khr_ray_tracing_pipeline
                && !other.khr_ray_tracing_pipeline,
            khr_ray_tracing_position_fetch: self.khr_ray_tracing_position_fetch
                && !other.khr_ray_tracing_position_fetch,
            khr_relaxed_block_layout: self.khr_relaxed_block_layout
                && !other.khr_relaxed_block_layout,
            khr_sampler_mirror_clamp_to_edge: self.khr_sampler_mirror_clamp_to_edge
                && !other.khr_sampler_mirror_clamp_to_edge,
            khr_sampler_ycbcr_conversion: self.khr_sampler_ycbcr_conversion
                && !other.khr_sampler_ycbcr_conversion,
            khr_separate_depth_stencil_layouts: self.khr_separate_depth_stencil_layouts
                && !other.khr_separate_depth_stencil_layouts,
            khr_shader_atomic_int64: self.khr_shader_atomic_int64
                && !other.khr_shader_atomic_int64,
            khr_shader_clock: self.khr_shader_clock && !other.khr_shader_clock,
            khr_shader_draw_parameters: self.khr_shader_draw_parameters
                && !other.khr_shader_draw_parameters,
            khr_shader_expect_assume: self.khr_shader_expect_assume
                && !other.khr_shader_expect_assume,
            khr_shader_float16_int8: self.khr_shader_float16_int8
                && !other.khr_shader_float16_int8,
            khr_shader_float_controls: self.khr_shader_float_controls
                && !other.khr_shader_float_controls,
            khr_shader_float_controls2: self.khr_shader_float_controls2
                && !other.khr_shader_float_controls2,
            khr_shader_integer_dot_product: self.khr_shader_integer_dot_product
                && !other.khr_shader_integer_dot_product,
            khr_shader_maximal_reconvergence: self.khr_shader_maximal_reconvergence
                && !other.khr_shader_maximal_reconvergence,
            khr_shader_non_semantic_info: self.khr_shader_non_semantic_info
                && !other.khr_shader_non_semantic_info,
            khr_shader_quad_control: self.khr_shader_quad_control
                && !other.khr_shader_quad_control,
            khr_shader_subgroup_extended_types: self.khr_shader_subgroup_extended_types
                && !other.khr_shader_subgroup_extended_types,
            khr_shader_subgroup_rotate: self.khr_shader_subgroup_rotate
                && !other.khr_shader_subgroup_rotate,
            khr_shader_subgroup_uniform_control_flow: self
                .khr_shader_subgroup_uniform_control_flow
                && !other.khr_shader_subgroup_uniform_control_flow,
            khr_shader_terminate_invocation: self.khr_shader_terminate_invocation
                && !other.khr_shader_terminate_invocation,
            khr_shared_presentable_image: self.khr_shared_presentable_image
                && !other.khr_shared_presentable_image,
            khr_spirv_1_4: self.khr_spirv_1_4 && !other.khr_spirv_1_4,
            khr_storage_buffer_storage_class: self.khr_storage_buffer_storage_class
                && !other.khr_storage_buffer_storage_class,
            khr_swapchain: self.khr_swapchain && !other.khr_swapchain,
            khr_swapchain_mutable_format: self.khr_swapchain_mutable_format
                && !other.khr_swapchain_mutable_format,
            khr_synchronization2: self.khr_synchronization2
                && !other.khr_synchronization2,
            khr_timeline_semaphore: self.khr_timeline_semaphore
                && !other.khr_timeline_semaphore,
            khr_uniform_buffer_standard_layout: self.khr_uniform_buffer_standard_layout
                && !other.khr_uniform_buffer_standard_layout,
            khr_variable_pointers: self.khr_variable_pointers
                && !other.khr_variable_pointers,
            khr_vertex_attribute_divisor: self.khr_vertex_attribute_divisor
                && !other.khr_vertex_attribute_divisor,
            khr_video_decode_av1: self.khr_video_decode_av1
                && !other.khr_video_decode_av1,
            khr_video_decode_h264: self.khr_video_decode_h264
                && !other.khr_video_decode_h264,
            khr_video_decode_h265: self.khr_video_decode_h265
                && !other.khr_video_decode_h265,
            khr_video_decode_queue: self.khr_video_decode_queue
                && !other.khr_video_decode_queue,
            khr_video_encode_h264: self.khr_video_encode_h264
                && !other.khr_video_encode_h264,
            khr_video_encode_h265: self.khr_video_encode_h265
                && !other.khr_video_encode_h265,
            khr_video_encode_queue: self.khr_video_encode_queue
                && !other.khr_video_encode_queue,
            khr_video_maintenance1: self.khr_video_maintenance1
                && !other.khr_video_maintenance1,
            khr_video_queue: self.khr_video_queue && !other.khr_video_queue,
            khr_vulkan_memory_model: self.khr_vulkan_memory_model
                && !other.khr_vulkan_memory_model,
            khr_win32_keyed_mutex: self.khr_win32_keyed_mutex
                && !other.khr_win32_keyed_mutex,
            khr_workgroup_memory_explicit_layout: self
                .khr_workgroup_memory_explicit_layout
                && !other.khr_workgroup_memory_explicit_layout,
            khr_zero_initialize_workgroup_memory: self
                .khr_zero_initialize_workgroup_memory
                && !other.khr_zero_initialize_workgroup_memory,
            ext_4444_formats: self.ext_4444_formats && !other.ext_4444_formats,
            ext_astc_decode_mode: self.ext_astc_decode_mode
                && !other.ext_astc_decode_mode,
            ext_attachment_feedback_loop_dynamic_state: self
                .ext_attachment_feedback_loop_dynamic_state
                && !other.ext_attachment_feedback_loop_dynamic_state,
            ext_attachment_feedback_loop_layout: self.ext_attachment_feedback_loop_layout
                && !other.ext_attachment_feedback_loop_layout,
            ext_blend_operation_advanced: self.ext_blend_operation_advanced
                && !other.ext_blend_operation_advanced,
            ext_border_color_swizzle: self.ext_border_color_swizzle
                && !other.ext_border_color_swizzle,
            ext_buffer_device_address: self.ext_buffer_device_address
                && !other.ext_buffer_device_address,
            ext_calibrated_timestamps: self.ext_calibrated_timestamps
                && !other.ext_calibrated_timestamps,
            ext_color_write_enable: self.ext_color_write_enable
                && !other.ext_color_write_enable,
            ext_conditional_rendering: self.ext_conditional_rendering
                && !other.ext_conditional_rendering,
            ext_conservative_rasterization: self.ext_conservative_rasterization
                && !other.ext_conservative_rasterization,
            ext_custom_border_color: self.ext_custom_border_color
                && !other.ext_custom_border_color,
            ext_debug_marker: self.ext_debug_marker && !other.ext_debug_marker,
            ext_depth_bias_control: self.ext_depth_bias_control
                && !other.ext_depth_bias_control,
            ext_depth_clamp_zero_one: self.ext_depth_clamp_zero_one
                && !other.ext_depth_clamp_zero_one,
            ext_depth_clip_control: self.ext_depth_clip_control
                && !other.ext_depth_clip_control,
            ext_depth_clip_enable: self.ext_depth_clip_enable
                && !other.ext_depth_clip_enable,
            ext_depth_range_unrestricted: self.ext_depth_range_unrestricted
                && !other.ext_depth_range_unrestricted,
            ext_descriptor_buffer: self.ext_descriptor_buffer
                && !other.ext_descriptor_buffer,
            ext_descriptor_indexing: self.ext_descriptor_indexing
                && !other.ext_descriptor_indexing,
            ext_device_address_binding_report: self.ext_device_address_binding_report
                && !other.ext_device_address_binding_report,
            ext_device_fault: self.ext_device_fault && !other.ext_device_fault,
            ext_device_memory_report: self.ext_device_memory_report
                && !other.ext_device_memory_report,
            ext_discard_rectangles: self.ext_discard_rectangles
                && !other.ext_discard_rectangles,
            ext_display_control: self.ext_display_control && !other.ext_display_control,
            ext_dynamic_rendering_unused_attachments: self
                .ext_dynamic_rendering_unused_attachments
                && !other.ext_dynamic_rendering_unused_attachments,
            ext_extended_dynamic_state: self.ext_extended_dynamic_state
                && !other.ext_extended_dynamic_state,
            ext_extended_dynamic_state2: self.ext_extended_dynamic_state2
                && !other.ext_extended_dynamic_state2,
            ext_extended_dynamic_state3: self.ext_extended_dynamic_state3
                && !other.ext_extended_dynamic_state3,
            ext_external_memory_acquire_unmodified: self
                .ext_external_memory_acquire_unmodified
                && !other.ext_external_memory_acquire_unmodified,
            ext_external_memory_dma_buf: self.ext_external_memory_dma_buf
                && !other.ext_external_memory_dma_buf,
            ext_external_memory_host: self.ext_external_memory_host
                && !other.ext_external_memory_host,
            ext_filter_cubic: self.ext_filter_cubic && !other.ext_filter_cubic,
            ext_fragment_density_map: self.ext_fragment_density_map
                && !other.ext_fragment_density_map,
            ext_fragment_density_map2: self.ext_fragment_density_map2
                && !other.ext_fragment_density_map2,
            ext_fragment_shader_interlock: self.ext_fragment_shader_interlock
                && !other.ext_fragment_shader_interlock,
            ext_frame_boundary: self.ext_frame_boundary && !other.ext_frame_boundary,
            ext_full_screen_exclusive: self.ext_full_screen_exclusive
                && !other.ext_full_screen_exclusive,
            ext_global_priority: self.ext_global_priority && !other.ext_global_priority,
            ext_global_priority_query: self.ext_global_priority_query
                && !other.ext_global_priority_query,
            ext_graphics_pipeline_library: self.ext_graphics_pipeline_library
                && !other.ext_graphics_pipeline_library,
            ext_hdr_metadata: self.ext_hdr_metadata && !other.ext_hdr_metadata,
            ext_host_image_copy: self.ext_host_image_copy && !other.ext_host_image_copy,
            ext_host_query_reset: self.ext_host_query_reset
                && !other.ext_host_query_reset,
            ext_image_2d_view_of_3d: self.ext_image_2d_view_of_3d
                && !other.ext_image_2d_view_of_3d,
            ext_image_compression_control: self.ext_image_compression_control
                && !other.ext_image_compression_control,
            ext_image_compression_control_swapchain: self
                .ext_image_compression_control_swapchain
                && !other.ext_image_compression_control_swapchain,
            ext_image_drm_format_modifier: self.ext_image_drm_format_modifier
                && !other.ext_image_drm_format_modifier,
            ext_image_robustness: self.ext_image_robustness
                && !other.ext_image_robustness,
            ext_image_sliced_view_of_3d: self.ext_image_sliced_view_of_3d
                && !other.ext_image_sliced_view_of_3d,
            ext_image_view_min_lod: self.ext_image_view_min_lod
                && !other.ext_image_view_min_lod,
            ext_index_type_uint8: self.ext_index_type_uint8
                && !other.ext_index_type_uint8,
            ext_inline_uniform_block: self.ext_inline_uniform_block
                && !other.ext_inline_uniform_block,
            ext_legacy_dithering: self.ext_legacy_dithering
                && !other.ext_legacy_dithering,
            ext_line_rasterization: self.ext_line_rasterization
                && !other.ext_line_rasterization,
            ext_load_store_op_none: self.ext_load_store_op_none
                && !other.ext_load_store_op_none,
            ext_map_memory_placed: self.ext_map_memory_placed
                && !other.ext_map_memory_placed,
            ext_memory_budget: self.ext_memory_budget && !other.ext_memory_budget,
            ext_memory_priority: self.ext_memory_priority && !other.ext_memory_priority,
            ext_mesh_shader: self.ext_mesh_shader && !other.ext_mesh_shader,
            ext_metal_objects: self.ext_metal_objects && !other.ext_metal_objects,
            ext_multi_draw: self.ext_multi_draw && !other.ext_multi_draw,
            ext_multisampled_render_to_single_sampled: self
                .ext_multisampled_render_to_single_sampled
                && !other.ext_multisampled_render_to_single_sampled,
            ext_mutable_descriptor_type: self.ext_mutable_descriptor_type
                && !other.ext_mutable_descriptor_type,
            ext_nested_command_buffer: self.ext_nested_command_buffer
                && !other.ext_nested_command_buffer,
            ext_non_seamless_cube_map: self.ext_non_seamless_cube_map
                && !other.ext_non_seamless_cube_map,
            ext_opacity_micromap: self.ext_opacity_micromap
                && !other.ext_opacity_micromap,
            ext_pageable_device_local_memory: self.ext_pageable_device_local_memory
                && !other.ext_pageable_device_local_memory,
            ext_pci_bus_info: self.ext_pci_bus_info && !other.ext_pci_bus_info,
            ext_physical_device_drm: self.ext_physical_device_drm
                && !other.ext_physical_device_drm,
            ext_pipeline_creation_cache_control: self.ext_pipeline_creation_cache_control
                && !other.ext_pipeline_creation_cache_control,
            ext_pipeline_creation_feedback: self.ext_pipeline_creation_feedback
                && !other.ext_pipeline_creation_feedback,
            ext_pipeline_library_group_handles: self.ext_pipeline_library_group_handles
                && !other.ext_pipeline_library_group_handles,
            ext_pipeline_properties: self.ext_pipeline_properties
                && !other.ext_pipeline_properties,
            ext_pipeline_protected_access: self.ext_pipeline_protected_access
                && !other.ext_pipeline_protected_access,
            ext_pipeline_robustness: self.ext_pipeline_robustness
                && !other.ext_pipeline_robustness,
            ext_post_depth_coverage: self.ext_post_depth_coverage
                && !other.ext_post_depth_coverage,
            ext_primitive_topology_list_restart: self.ext_primitive_topology_list_restart
                && !other.ext_primitive_topology_list_restart,
            ext_primitives_generated_query: self.ext_primitives_generated_query
                && !other.ext_primitives_generated_query,
            ext_private_data: self.ext_private_data && !other.ext_private_data,
            ext_provoking_vertex: self.ext_provoking_vertex
                && !other.ext_provoking_vertex,
            ext_queue_family_foreign: self.ext_queue_family_foreign
                && !other.ext_queue_family_foreign,
            ext_rasterization_order_attachment_access: self
                .ext_rasterization_order_attachment_access
                && !other.ext_rasterization_order_attachment_access,
            ext_rgba10x6_formats: self.ext_rgba10x6_formats
                && !other.ext_rgba10x6_formats,
            ext_robustness2: self.ext_robustness2 && !other.ext_robustness2,
            ext_sample_locations: self.ext_sample_locations
                && !other.ext_sample_locations,
            ext_sampler_filter_minmax: self.ext_sampler_filter_minmax
                && !other.ext_sampler_filter_minmax,
            ext_scalar_block_layout: self.ext_scalar_block_layout
                && !other.ext_scalar_block_layout,
            ext_separate_stencil_usage: self.ext_separate_stencil_usage
                && !other.ext_separate_stencil_usage,
            ext_shader_atomic_float: self.ext_shader_atomic_float
                && !other.ext_shader_atomic_float,
            ext_shader_atomic_float2: self.ext_shader_atomic_float2
                && !other.ext_shader_atomic_float2,
            ext_shader_demote_to_helper_invocation: self
                .ext_shader_demote_to_helper_invocation
                && !other.ext_shader_demote_to_helper_invocation,
            ext_shader_image_atomic_int64: self.ext_shader_image_atomic_int64
                && !other.ext_shader_image_atomic_int64,
            ext_shader_module_identifier: self.ext_shader_module_identifier
                && !other.ext_shader_module_identifier,
            ext_shader_object: self.ext_shader_object && !other.ext_shader_object,
            ext_shader_stencil_export: self.ext_shader_stencil_export
                && !other.ext_shader_stencil_export,
            ext_shader_subgroup_ballot: self.ext_shader_subgroup_ballot
                && !other.ext_shader_subgroup_ballot,
            ext_shader_subgroup_vote: self.ext_shader_subgroup_vote
                && !other.ext_shader_subgroup_vote,
            ext_shader_tile_image: self.ext_shader_tile_image
                && !other.ext_shader_tile_image,
            ext_shader_viewport_index_layer: self.ext_shader_viewport_index_layer
                && !other.ext_shader_viewport_index_layer,
            ext_subgroup_size_control: self.ext_subgroup_size_control
                && !other.ext_subgroup_size_control,
            ext_subpass_merge_feedback: self.ext_subpass_merge_feedback
                && !other.ext_subpass_merge_feedback,
            ext_swapchain_maintenance1: self.ext_swapchain_maintenance1
                && !other.ext_swapchain_maintenance1,
            ext_texel_buffer_alignment: self.ext_texel_buffer_alignment
                && !other.ext_texel_buffer_alignment,
            ext_texture_compression_astc_hdr: self.ext_texture_compression_astc_hdr
                && !other.ext_texture_compression_astc_hdr,
            ext_tooling_info: self.ext_tooling_info && !other.ext_tooling_info,
            ext_transform_feedback: self.ext_transform_feedback
                && !other.ext_transform_feedback,
            ext_validation_cache: self.ext_validation_cache
                && !other.ext_validation_cache,
            ext_vertex_attribute_divisor: self.ext_vertex_attribute_divisor
                && !other.ext_vertex_attribute_divisor,
            ext_vertex_input_dynamic_state: self.ext_vertex_input_dynamic_state
                && !other.ext_vertex_input_dynamic_state,
            ext_ycbcr_2plane_444_formats: self.ext_ycbcr_2plane_444_formats
                && !other.ext_ycbcr_2plane_444_formats,
            ext_ycbcr_image_arrays: self.ext_ycbcr_image_arrays
                && !other.ext_ycbcr_image_arrays,
            amdx_shader_enqueue: self.amdx_shader_enqueue && !other.amdx_shader_enqueue,
            amd_buffer_marker: self.amd_buffer_marker && !other.amd_buffer_marker,
            amd_device_coherent_memory: self.amd_device_coherent_memory
                && !other.amd_device_coherent_memory,
            amd_display_native_hdr: self.amd_display_native_hdr
                && !other.amd_display_native_hdr,
            amd_draw_indirect_count: self.amd_draw_indirect_count
                && !other.amd_draw_indirect_count,
            amd_gcn_shader: self.amd_gcn_shader && !other.amd_gcn_shader,
            amd_gpu_shader_half_float: self.amd_gpu_shader_half_float
                && !other.amd_gpu_shader_half_float,
            amd_gpu_shader_int16: self.amd_gpu_shader_int16
                && !other.amd_gpu_shader_int16,
            amd_memory_overallocation_behavior: self.amd_memory_overallocation_behavior
                && !other.amd_memory_overallocation_behavior,
            amd_mixed_attachment_samples: self.amd_mixed_attachment_samples
                && !other.amd_mixed_attachment_samples,
            amd_pipeline_compiler_control: self.amd_pipeline_compiler_control
                && !other.amd_pipeline_compiler_control,
            amd_rasterization_order: self.amd_rasterization_order
                && !other.amd_rasterization_order,
            amd_shader_ballot: self.amd_shader_ballot && !other.amd_shader_ballot,
            amd_shader_core_properties: self.amd_shader_core_properties
                && !other.amd_shader_core_properties,
            amd_shader_core_properties2: self.amd_shader_core_properties2
                && !other.amd_shader_core_properties2,
            amd_shader_early_and_late_fragment_tests: self
                .amd_shader_early_and_late_fragment_tests
                && !other.amd_shader_early_and_late_fragment_tests,
            amd_shader_explicit_vertex_parameter: self
                .amd_shader_explicit_vertex_parameter
                && !other.amd_shader_explicit_vertex_parameter,
            amd_shader_fragment_mask: self.amd_shader_fragment_mask
                && !other.amd_shader_fragment_mask,
            amd_shader_image_load_store_lod: self.amd_shader_image_load_store_lod
                && !other.amd_shader_image_load_store_lod,
            amd_shader_info: self.amd_shader_info && !other.amd_shader_info,
            amd_shader_trinary_minmax: self.amd_shader_trinary_minmax
                && !other.amd_shader_trinary_minmax,
            amd_texture_gather_bias_lod: self.amd_texture_gather_bias_lod
                && !other.amd_texture_gather_bias_lod,
            android_external_format_resolve: self.android_external_format_resolve
                && !other.android_external_format_resolve,
            android_external_memory_android_hardware_buffer: self
                .android_external_memory_android_hardware_buffer
                && !other.android_external_memory_android_hardware_buffer,
            arm_rasterization_order_attachment_access: self
                .arm_rasterization_order_attachment_access
                && !other.arm_rasterization_order_attachment_access,
            arm_render_pass_striped: self.arm_render_pass_striped
                && !other.arm_render_pass_striped,
            arm_scheduling_controls: self.arm_scheduling_controls
                && !other.arm_scheduling_controls,
            arm_shader_core_builtins: self.arm_shader_core_builtins
                && !other.arm_shader_core_builtins,
            arm_shader_core_properties: self.arm_shader_core_properties
                && !other.arm_shader_core_properties,
            fuchsia_buffer_collection: self.fuchsia_buffer_collection
                && !other.fuchsia_buffer_collection,
            fuchsia_external_memory: self.fuchsia_external_memory
                && !other.fuchsia_external_memory,
            fuchsia_external_semaphore: self.fuchsia_external_semaphore
                && !other.fuchsia_external_semaphore,
            ggp_frame_token: self.ggp_frame_token && !other.ggp_frame_token,
            google_decorate_string: self.google_decorate_string
                && !other.google_decorate_string,
            google_display_timing: self.google_display_timing
                && !other.google_display_timing,
            google_hlsl_functionality1: self.google_hlsl_functionality1
                && !other.google_hlsl_functionality1,
            google_user_type: self.google_user_type && !other.google_user_type,
            huawei_cluster_culling_shader: self.huawei_cluster_culling_shader
                && !other.huawei_cluster_culling_shader,
            huawei_invocation_mask: self.huawei_invocation_mask
                && !other.huawei_invocation_mask,
            huawei_subpass_shading: self.huawei_subpass_shading
                && !other.huawei_subpass_shading,
            img_filter_cubic: self.img_filter_cubic && !other.img_filter_cubic,
            img_format_pvrtc: self.img_format_pvrtc && !other.img_format_pvrtc,
            img_relaxed_line_rasterization: self.img_relaxed_line_rasterization
                && !other.img_relaxed_line_rasterization,
            intel_performance_query: self.intel_performance_query
                && !other.intel_performance_query,
            intel_shader_integer_functions2: self.intel_shader_integer_functions2
                && !other.intel_shader_integer_functions2,
            msft_layered_driver: self.msft_layered_driver && !other.msft_layered_driver,
            nvx_binary_import: self.nvx_binary_import && !other.nvx_binary_import,
            nvx_image_view_handle: self.nvx_image_view_handle
                && !other.nvx_image_view_handle,
            nvx_multiview_per_view_attributes: self.nvx_multiview_per_view_attributes
                && !other.nvx_multiview_per_view_attributes,
            nv_acquire_winrt_display: self.nv_acquire_winrt_display
                && !other.nv_acquire_winrt_display,
            nv_clip_space_w_scaling: self.nv_clip_space_w_scaling
                && !other.nv_clip_space_w_scaling,
            nv_compute_shader_derivatives: self.nv_compute_shader_derivatives
                && !other.nv_compute_shader_derivatives,
            nv_cooperative_matrix: self.nv_cooperative_matrix
                && !other.nv_cooperative_matrix,
            nv_copy_memory_indirect: self.nv_copy_memory_indirect
                && !other.nv_copy_memory_indirect,
            nv_corner_sampled_image: self.nv_corner_sampled_image
                && !other.nv_corner_sampled_image,
            nv_coverage_reduction_mode: self.nv_coverage_reduction_mode
                && !other.nv_coverage_reduction_mode,
            nv_cuda_kernel_launch: self.nv_cuda_kernel_launch
                && !other.nv_cuda_kernel_launch,
            nv_dedicated_allocation: self.nv_dedicated_allocation
                && !other.nv_dedicated_allocation,
            nv_dedicated_allocation_image_aliasing: self
                .nv_dedicated_allocation_image_aliasing
                && !other.nv_dedicated_allocation_image_aliasing,
            nv_descriptor_pool_overallocation: self.nv_descriptor_pool_overallocation
                && !other.nv_descriptor_pool_overallocation,
            nv_device_diagnostic_checkpoints: self.nv_device_diagnostic_checkpoints
                && !other.nv_device_diagnostic_checkpoints,
            nv_device_diagnostics_config: self.nv_device_diagnostics_config
                && !other.nv_device_diagnostics_config,
            nv_device_generated_commands: self.nv_device_generated_commands
                && !other.nv_device_generated_commands,
            nv_device_generated_commands_compute: self
                .nv_device_generated_commands_compute
                && !other.nv_device_generated_commands_compute,
            nv_displacement_micromap: self.nv_displacement_micromap
                && !other.nv_displacement_micromap,
            nv_extended_sparse_address_space: self.nv_extended_sparse_address_space
                && !other.nv_extended_sparse_address_space,
            nv_external_memory: self.nv_external_memory && !other.nv_external_memory,
            nv_external_memory_rdma: self.nv_external_memory_rdma
                && !other.nv_external_memory_rdma,
            nv_external_memory_win32: self.nv_external_memory_win32
                && !other.nv_external_memory_win32,
            nv_fill_rectangle: self.nv_fill_rectangle && !other.nv_fill_rectangle,
            nv_fragment_coverage_to_color: self.nv_fragment_coverage_to_color
                && !other.nv_fragment_coverage_to_color,
            nv_fragment_shader_barycentric: self.nv_fragment_shader_barycentric
                && !other.nv_fragment_shader_barycentric,
            nv_fragment_shading_rate_enums: self.nv_fragment_shading_rate_enums
                && !other.nv_fragment_shading_rate_enums,
            nv_framebuffer_mixed_samples: self.nv_framebuffer_mixed_samples
                && !other.nv_framebuffer_mixed_samples,
            nv_geometry_shader_passthrough: self.nv_geometry_shader_passthrough
                && !other.nv_geometry_shader_passthrough,
            nv_glsl_shader: self.nv_glsl_shader && !other.nv_glsl_shader,
            nv_inherited_viewport_scissor: self.nv_inherited_viewport_scissor
                && !other.nv_inherited_viewport_scissor,
            nv_linear_color_attachment: self.nv_linear_color_attachment
                && !other.nv_linear_color_attachment,
            nv_low_latency: self.nv_low_latency && !other.nv_low_latency,
            nv_low_latency2: self.nv_low_latency2 && !other.nv_low_latency2,
            nv_memory_decompression: self.nv_memory_decompression
                && !other.nv_memory_decompression,
            nv_mesh_shader: self.nv_mesh_shader && !other.nv_mesh_shader,
            nv_optical_flow: self.nv_optical_flow && !other.nv_optical_flow,
            nv_per_stage_descriptor_set: self.nv_per_stage_descriptor_set
                && !other.nv_per_stage_descriptor_set,
            nv_present_barrier: self.nv_present_barrier && !other.nv_present_barrier,
            nv_raw_access_chains: self.nv_raw_access_chains
                && !other.nv_raw_access_chains,
            nv_ray_tracing: self.nv_ray_tracing && !other.nv_ray_tracing,
            nv_ray_tracing_invocation_reorder: self.nv_ray_tracing_invocation_reorder
                && !other.nv_ray_tracing_invocation_reorder,
            nv_ray_tracing_motion_blur: self.nv_ray_tracing_motion_blur
                && !other.nv_ray_tracing_motion_blur,
            nv_ray_tracing_validation: self.nv_ray_tracing_validation
                && !other.nv_ray_tracing_validation,
            nv_representative_fragment_test: self.nv_representative_fragment_test
                && !other.nv_representative_fragment_test,
            nv_sample_mask_override_coverage: self.nv_sample_mask_override_coverage
                && !other.nv_sample_mask_override_coverage,
            nv_scissor_exclusive: self.nv_scissor_exclusive
                && !other.nv_scissor_exclusive,
            nv_shader_atomic_float16_vector: self.nv_shader_atomic_float16_vector
                && !other.nv_shader_atomic_float16_vector,
            nv_shader_image_footprint: self.nv_shader_image_footprint
                && !other.nv_shader_image_footprint,
            nv_shader_sm_builtins: self.nv_shader_sm_builtins
                && !other.nv_shader_sm_builtins,
            nv_shader_subgroup_partitioned: self.nv_shader_subgroup_partitioned
                && !other.nv_shader_subgroup_partitioned,
            nv_shading_rate_image: self.nv_shading_rate_image
                && !other.nv_shading_rate_image,
            nv_viewport_array2: self.nv_viewport_array2 && !other.nv_viewport_array2,
            nv_viewport_swizzle: self.nv_viewport_swizzle && !other.nv_viewport_swizzle,
            nv_win32_keyed_mutex: self.nv_win32_keyed_mutex
                && !other.nv_win32_keyed_mutex,
            qcom_filter_cubic_clamp: self.qcom_filter_cubic_clamp
                && !other.qcom_filter_cubic_clamp,
            qcom_filter_cubic_weights: self.qcom_filter_cubic_weights
                && !other.qcom_filter_cubic_weights,
            qcom_fragment_density_map_offset: self.qcom_fragment_density_map_offset
                && !other.qcom_fragment_density_map_offset,
            qcom_image_processing: self.qcom_image_processing
                && !other.qcom_image_processing,
            qcom_image_processing2: self.qcom_image_processing2
                && !other.qcom_image_processing2,
            qcom_multiview_per_view_render_areas: self
                .qcom_multiview_per_view_render_areas
                && !other.qcom_multiview_per_view_render_areas,
            qcom_multiview_per_view_viewports: self.qcom_multiview_per_view_viewports
                && !other.qcom_multiview_per_view_viewports,
            qcom_render_pass_shader_resolve: self.qcom_render_pass_shader_resolve
                && !other.qcom_render_pass_shader_resolve,
            qcom_render_pass_store_ops: self.qcom_render_pass_store_ops
                && !other.qcom_render_pass_store_ops,
            qcom_render_pass_transform: self.qcom_render_pass_transform
                && !other.qcom_render_pass_transform,
            qcom_rotated_copy_commands: self.qcom_rotated_copy_commands
                && !other.qcom_rotated_copy_commands,
            qcom_tile_properties: self.qcom_tile_properties
                && !other.qcom_tile_properties,
            qcom_ycbcr_degamma: self.qcom_ycbcr_degamma && !other.qcom_ycbcr_degamma,
            qnx_external_memory_screen_buffer: self.qnx_external_memory_screen_buffer
                && !other.qnx_external_memory_screen_buffer,
            sec_amigo_profiling: self.sec_amigo_profiling && !other.sec_amigo_profiling,
            valve_descriptor_set_host_mapping: self.valve_descriptor_set_host_mapping
                && !other.valve_descriptor_set_host_mapping,
            valve_mutable_descriptor_type: self.valve_mutable_descriptor_type
                && !other.valve_mutable_descriptor_type,
            _ne: crate::NonExhaustive(()),
        }
    }
    /// Returns the members set in `self` or `other`, but not both.
    #[inline]
    pub const fn symmetric_difference(&self, other: &Self) -> Self {
        Self {
            khr_16bit_storage: self.khr_16bit_storage ^ other.khr_16bit_storage,
            khr_8bit_storage: self.khr_8bit_storage ^ other.khr_8bit_storage,
            khr_acceleration_structure: self.khr_acceleration_structure
                ^ other.khr_acceleration_structure,
            khr_bind_memory2: self.khr_bind_memory2 ^ other.khr_bind_memory2,
            khr_buffer_device_address: self.khr_buffer_device_address
                ^ other.khr_buffer_device_address,
            khr_calibrated_timestamps: self.khr_calibrated_timestamps
                ^ other.khr_calibrated_timestamps,
            khr_cooperative_matrix: self.khr_cooperative_matrix
                ^ other.khr_cooperative_matrix,
            khr_copy_commands2: self.khr_copy_commands2 ^ other.khr_copy_commands2,
            khr_create_renderpass2: self.khr_create_renderpass2
                ^ other.khr_create_renderpass2,
            khr_dedicated_allocation: self.khr_dedicated_allocation
                ^ other.khr_dedicated_allocation,
            khr_deferred_host_operations: self.khr_deferred_host_operations
                ^ other.khr_deferred_host_operations,
            khr_depth_stencil_resolve: self.khr_depth_stencil_resolve
                ^ other.khr_depth_stencil_resolve,
            khr_descriptor_update_template: self.khr_descriptor_update_template
                ^ other.khr_descriptor_update_template,
            khr_device_group: self.khr_device_group ^ other.khr_device_group,
            khr_display_swapchain: self.khr_display_swapchain
                ^ other.khr_display_swapchain,
            khr_draw_indirect_count: self.khr_draw_indirect_count
                ^ other.khr_draw_indirect_count,
            khr_driver_properties: self.khr_driver_properties
                ^ other.khr_driver_properties,
            khr_dynamic_rendering: self.khr_dynamic_rendering
                ^ other.khr_dynamic_rendering,
            khr_dynamic_rendering_local_read: self.khr_dynamic_rendering_local_read
                ^ other.khr_dynamic_rendering_local_read,
            khr_external_fence: self.khr_external_fence ^ other.khr_external_fence,
            khr_external_fence_fd: self.khr_external_fence_fd
                ^ other.khr_external_fence_fd,
            khr_external_fence_win32: self.khr_external_fence_win32
                ^ other.khr_external_fence_win32,
            khr_external_memory: self.khr_external_memory ^ other.khr_external_memory,
            khr_external_memory_fd: self.khr_external_memory_fd
                ^ other.khr_external_memory_fd,
            khr_external_memory_win32: self.khr_external_memory_win32
                ^ other.khr_external_memory_win32,
            khr_external_semaphore: self.khr_external_semaphore
                ^ other.khr_external_semaphore,
            khr_external_semaphore_fd: self.khr_external_semaphore_fd
                ^ other.khr_external_semaphore_fd,
            khr_external_semaphore_win32: self.khr_external_semaphore_win32
                ^ other.khr_external_semaphore_win32,
            khr_format_feature_flags2: self.khr_format_feature_flags2
                ^ other.khr_format_feature_flags2,
            khr_fragment_shader_barycentric: self.khr_fragment_shader_barycentric
                ^ other.khr_fragment_shader_barycentric,
            khr_fragment_shading_rate: self.khr_fragment_shading_rate
                ^ other.khr_fragment_shading_rate,
            khr_get_memory_requirements2: self.khr_get_memory_requirements2
                ^ other.khr_get_memory_requirements2,
            khr_global_priority: self.khr_global_priority ^ other.khr_global_priority,
            khr_image_format_list: self.khr_image_format_list
                ^ other.khr_image_format_list,
            khr_imageless_framebuffer: self.khr_imageless_framebuffer
                ^ other.khr_imageless_framebuffer,
            khr_incremental_present: self.khr_incremental_present
                ^ other.khr_incremental_present,
            khr_index_type_uint8: self.khr_index_type_uint8 ^ other.khr_index_type_uint8,
            khr_line_rasterization: self.khr_line_rasterization
                ^ other.khr_line_rasterization,
            khr_load_store_op_none: self.khr_load_store_op_none
                ^ other.khr_load_store_op_none,
            khr_maintenance1: self.khr_maintenance1 ^ other.khr_maintenance1,
            khr_maintenance2: self.khr_maintenance2 ^ other.khr_maintenance2,
            khr_maintenance3: self.khr_maintenance3 ^ other.khr_maintenance3,
            khr_maintenance4: self.khr_maintenance4 ^ other.khr_maintenance4,
            khr_maintenance5: self.khr_maintenance5 ^ other.khr_maintenance5,
            khr_maintenance6: self.khr_maintenance6 ^ other.khr_maintenance6,
            khr_map_memory2: self.khr_map_memory2 ^ other.khr_map_memory2,
            khr_multiview: self.khr_multiview ^ other.khr_multiview,
            khr_performance_query: self.khr_performance_query
                ^ other.khr_performance_query,
            khr_pipeline_executable_properties: self.khr_pipeline_executable_properties
                ^ other.khr_pipeline_executable_properties,
            khr_pipeline_library: self.khr_pipeline_library ^ other.khr_pipeline_library,
            khr_portability_subset: self.khr_portability_subset
                ^ other.khr_portability_subset,
            khr_present_id: self.khr_present_id ^ other.khr_present_id,
            khr_present_wait: self.khr_present_wait ^ other.khr_present_wait,
            khr_push_descriptor: self.khr_push_descriptor ^ other.khr_push_descriptor,
            khr_ray_query: self.khr_ray_query ^ other.khr_ray_query,
            khr_ray_tracing_maintenance1: self.khr_ray_tracing_maintenance1
                ^ other.khr_ray_tracing_maintenance1,
            khr_ray_tracing_pipeline: self.khr_ray_tracing_pipeline
                ^ other.khr_ray_tracing_pipeline,
            khr_ray_tracing_position_fetch: self.khr_ray_tracing_position_fetch
                ^ other.khr_ray_tracing_position_fetch,
            khr_relaxed_block_layout: self.khr_relaxed_block_layout
                ^ other.khr_relaxed_block_layout,
            khr_sampler_mirror_clamp_to_edge: self.khr_sampler_mirror_clamp_to_edge
                ^ other.khr_sampler_mirror_clamp_to_edge,
            khr_sampler_ycbcr_conversion: self.khr_sampler_ycbcr_conversion
                ^ other.khr_sampler_ycbcr_conversion,
            khr_separate_depth_stencil_layouts: self.khr_separate_depth_stencil_layouts
                ^ other.khr_separate_depth_stencil_layouts,
            khr_shader_atomic_int64: self.khr_shader_atomic_int64
                ^ other.khr_shader_atomic_int64,
            khr_shader_clock: self.khr_shader_clock ^ other.khr_shader_clock,
            khr_shader_draw_parameters: self.khr_shader_draw_parameters
                ^ other.khr_shader_draw_parameters,
            khr_shader_expect_assume: self.khr_shader_expect_assume
                ^ other.khr_shader_expect_assume,
            khr_shader_float16_int8: self.khr_shader_float16_int8
                ^ other.khr_shader_float16_int8,
            khr_shader_float_controls: self.khr_shader_float_controls
                ^ other.khr_shader_float_controls,
            khr_shader_float_controls2: self.khr_shader_float_controls2
                ^ other.khr_shader_float_controls2,
            khr_shader_integer_dot_product: self.khr_shader_integer_dot_product
                ^ other.khr_shader_integer_dot_product,
            khr_shader_maximal_reconvergence: self.khr_shader_maximal_reconvergence
                ^ other.khr_shader_maximal_reconvergence,
            khr_shader_non_semantic_info: self.khr_shader_non_semantic_info
                ^ other.khr_shader_non_semantic_info,
            khr_shader_quad_control: self.khr_shader_quad_control
                ^ other.khr_shader_quad_control,
            khr_shader_subgroup_extended_types: self.khr_shader_subgroup_extended_types
                ^ other.khr_shader_subgroup_extended_types,
            khr_shader_subgroup_rotate: self.khr_shader_subgroup_rotate
                ^ other.khr_shader_subgroup_rotate,
            khr_shader_subgroup_uniform_control_flow: self
                .khr_shader_subgroup_uniform_control_flow
                ^ other.khr_shader_subgroup_uniform_control_flow,
            khr_shader_terminate_invocation: self.khr_shader_terminate_invocation
                ^ other.khr_shader_terminate_invocation,
            khr_shared_presentable_image: self.khr_shared_presentable_image
                ^ other.khr_shared_presentable_image,
            khr_spirv_1_4: self.khr_spirv_1_4 ^ other.khr_spirv_1_4,
            khr_storage_buffer_storage_class: self.khr_storage_buffer_storage_class
                ^ other.khr_storage_buffer_storage_class,
            khr_swapchain: self.khr_swapchain ^ other.khr_swapchain,
            khr_swapchain_mutable_format: self.khr_swapchain_mutable_format
                ^ other.khr_swapchain_mutable_format,
            khr_synchronization2: self.khr_synchronization2 ^ other.khr_synchronization2,
            khr_timeline_semaphore: self.khr_timeline_semaphore
                ^ other.khr_timeline_semaphore,
            khr_uniform_buffer_standard_layout: self.khr_uniform_buffer_standard_layout
                ^ other.khr_uniform_buffer_standard_layout,
            khr_variable_pointers: self.khr_variable_pointers
                ^ other.khr_variable_pointers,
            khr_vertex_attribute_divisor: self.khr_vertex_attribute_divisor
                ^ other.khr_vertex_attribute_divisor,
            khr_video_decode_av1: self.khr_video_decode_av1 ^ other.khr_video_decode_av1,
            khr_video_decode_h264: self.khr_video_decode_h264
                ^ other.khr_video_decode_h264,
            khr_video_decode_h265: self.khr_video_decode_h265
                ^ other.khr_video_decode_h265,
            khr_video_decode_queue: self.khr_video_decode_queue
                ^ other.khr_video_decode_queue,
            khr_video_encode_h264: self.khr_video_encode_h264
                ^ other.khr_video_encode_h264,
            khr_video_encode_h265: self.khr_video_encode_h265
                ^ other.khr_video_encode_h265,
            khr_video_encode_queue: self.khr_video_encode_queue
                ^ other.khr_video_encode_queue,
            khr_video_maintenance1: self.khr_video_maintenance1
                ^ other.khr_video_maintenance1,
            khr_video_queue: self.khr_video_queue ^ other.khr_video_queue,
            khr_vulkan_memory_model: self.khr_vulkan_memory_model
                ^ other.khr_vulkan_memory_model,
            khr_win32_keyed_mutex: self.khr_win32_keyed_mutex
                ^ other.khr_win32_keyed_mutex,
            khr_workgroup_memory_explicit_layout: self
                .khr_workgroup_memory_explicit_layout
                ^ other.khr_workgroup_memory_explicit_layout,
            khr_zero_initialize_workgroup_memory: self
                .khr_zero_initialize_workgroup_memory
                ^ other.khr_zero_initialize_workgroup_memory,
            ext_4444_formats: self.ext_4444_formats ^ other.ext_4444_formats,
            ext_astc_decode_mode: self.ext_astc_decode_mode ^ other.ext_astc_decode_mode,
            ext_attachment_feedback_loop_dynamic_state: self
                .ext_attachment_feedback_loop_dynamic_state
                ^ other.ext_attachment_feedback_loop_dynamic_state,
            ext_attachment_feedback_loop_layout: self.ext_attachment_feedback_loop_layout
                ^ other.ext_attachment_feedback_loop_layout,
            ext_blend_operation_advanced: self.ext_blend_operation_advanced
                ^ other.ext_blend_operation_advanced,
            ext_border_color_swizzle: self.ext_border_color_swizzle
                ^ other.ext_border_color_swizzle,
            ext_buffer_device_address: self.ext_buffer_device_address
                ^ other.ext_buffer_device_address,
            ext_calibrated_timestamps: self.ext_calibrated_timestamps
                ^ other.ext_calibrated_timestamps,
            ext_color_write_enable: self.ext_color_write_enable
                ^ other.ext_color_write_enable,
            ext_conditional_rendering: self.ext_conditional_rendering
                ^ other.ext_conditional_rendering,
            ext_conservative_rasterization: self.ext_conservative_rasterization
                ^ other.ext_conservative_rasterization,
            ext_custom_border_color: self.ext_custom_border_color
                ^ other.ext_custom_border_color,
            ext_debug_marker: self.ext_debug_marker ^ other.ext_debug_marker,
            ext_depth_bias_control: self.ext_depth_bias_control
                ^ other.ext_depth_bias_control,
            ext_depth_clamp_zero_one: self.ext_depth_clamp_zero_one
                ^ other.ext_depth_clamp_zero_one,
            ext_depth_clip_control: self.ext_depth_clip_control
                ^ other.ext_depth_clip_control,
            ext_depth_clip_enable: self.ext_depth_clip_enable
                ^ other.ext_depth_clip_enable,
            ext_depth_range_unrestricted: self.ext_depth_range_unrestricted
                ^ other.ext_depth_range_unrestricted,
            ext_descriptor_buffer: self.ext_descriptor_buffer
                ^ other.ext_descriptor_buffer,
            ext_descriptor_indexing: self.ext_descriptor_indexing
                ^ other.ext_descriptor_indexing,
            ext_device_address_binding_report: self.ext_device_address_binding_report
                ^ other.ext_device_address_binding_report,
            ext_device_fault: self.ext_device_fault ^ other.ext_device_fault,
            ext_device_memory_report: self.ext_device_memory_report
                ^ other.ext_device_memory_report,
            ext_discard_rectangles: self.ext_discard_rectangles
                ^ other.ext_discard_rectangles,
            ext_display_control: self.ext_display_control ^ other.ext_display_control,
            ext_dynamic_rendering_unused_attachments: self
                .ext_dynamic_rendering_unused_attachments
                ^ other.ext_dynamic_rendering_unused_attachments,
            ext_extended_dynamic_state: self.ext_extended_dynamic_state
                ^ other.ext_extended_dynamic_state,
            ext_extended_dynamic_state2: self.ext_extended_dynamic_state2
                ^ other.ext_extended_dynamic_state2,
            ext_extended_dynamic_state3: self.ext_extended_dynamic_state3
                ^ other.ext_extended_dynamic_state3,
            ext_external_memory_acquire_unmodified: self
                .ext_external_memory_acquire_unmodified
                ^ other.ext_external_memory_acquire_unmodified,
            ext_external_memory_dma_buf: self.ext_external_memory_dma_buf
                ^ other.ext_external_memory_dma_buf,
            ext_external_memory_host: self.ext_external_memory_host
                ^ other.ext_external_memory_host,
            ext_filter_cubic: self.ext_filter_cubic ^ other.ext_filter_cubic,
            ext_fragment_density_map: self.ext_fragment_density_map
                ^ other.ext_fragment_density_map,
            ext_fragment_density_map2: self.ext_fragment_density_map2
                ^ other.ext_fragment_density_map2,
            ext_fragment_shader_interlock: self.ext_fragment_shader_interlock
                ^ other.ext_fragment_shader_interlock,
            ext_frame_boundary: self.ext_frame_boundary ^ other.ext_frame_boundary,
            ext_full_screen_exclusive: self.ext_full_screen_exclusive
                ^ other.ext_full_screen_exclusive,
            ext_global_priority: self.ext_global_priority ^ other.ext_global_priority,
            ext_global_priority_query: self.ext_global_priority_query
                ^ other.ext_global_priority_query,
            ext_graphics_pipeline_library: self.ext_graphics_pipeline_library
                ^ other.ext_graphics_pipeline_library,
            ext_hdr_metadata: self.ext_hdr_metadata ^ other.ext_hdr_metadata,
            ext_host_image_copy: self.ext_host_image_copy ^ other.ext_host_image_copy,
            ext_host_query_reset: self.ext_host_query_reset ^ other.ext_host_query_reset,
            ext_image_2d_view_of_3d: self.ext_image_2d_view_of_3d
                ^ other.ext_image_2d_view_of_3d,
            ext_image_compression_control: self.ext_image_compression_control
                ^ other.ext_image_compression_control,
            ext_image_compression_control_swapchain: self
                .ext_image_compression_control_swapchain
                ^ other.ext_image_compression_control_swapchain,
            ext_image_drm_format_modifier: self.ext_image_drm_format_modifier
                ^ other.ext_image_drm_format_modifier,
            ext_image_robustness: self.ext_image_robustness ^ other.ext_image_robustness,
            ext_image_sliced_view_of_3d: self.ext_image_sliced_view_of_3d
                ^ other.ext_image_sliced_view_of_3d,
            ext_image_view_min_lod: self.ext_image_view_min_lod
                ^ other.ext_image_view_min_lod,
            ext_index_type_uint8: self.ext_index_type_uint8 ^ other.ext_index_type_uint8,
            ext_inline_uniform_block: self.ext_inline_uniform_block
                ^ other.ext_inline_uniform_block,
            ext_legacy_dithering: self.ext_legacy_dithering ^ other.ext_legacy_dithering,
            ext_line_rasterization: self.ext_line_rasterization
                ^ other.ext_line_rasterization,
            ext_load_store_op_none: self.ext_load_store_op_none
                ^ other.ext_load_store_op_none,
            ext_map_memory_placed: self.ext_map_memory_placed
                ^ other.ext_map_memory_placed,
            ext_memory_budget: self.ext_memory_budget ^ other.ext_memory_budget,
            ext_memory_priority: self.ext_memory_priority ^ other.ext_memory_priority,
            ext_mesh_shader: self.ext_mesh_shader ^ other.ext_mesh_shader,
            ext_metal_objects: self.ext_metal_objects ^ other.ext_metal_objects,
            ext_multi_draw: self.ext_multi_draw ^ other.ext_multi_draw,
            ext_multisampled_render_to_single_sampled: self
                .ext_multisampled_render_to_single_sampled
                ^ other.ext_multisampled_render_to_single_sampled,
            ext_mutable_descriptor_type: self.ext_mutable_descriptor_type
                ^ other.ext_mutable_descriptor_type,
            ext_nested_command_buffer: self.ext_nested_command_buffer
                ^ other.ext_nested_command_buffer,
            ext_non_seamless_cube_map: self.ext_non_seamless_cube_map
                ^ other.ext_non_seamless_cube_map,
            ext_opacity_micromap: self.ext_opacity_micromap ^ other.ext_opacity_micromap,
            ext_pageable_device_local_memory: self.ext_pageable_device_local_memory
                ^ other.ext_pageable_device_local_memory,
            ext_pci_bus_info: self.ext_pci_bus_info ^ other.ext_pci_bus_info,
            ext_physical_device_drm: self.ext_physical_device_drm
                ^ other.ext_physical_device_drm,
            ext_pipeline_creation_cache_control: self.ext_pipeline_creation_cache_control
                ^ other.ext_pipeline_creation_cache_control,
            ext_pipeline_creation_feedback: self.ext_pipeline_creation_feedback
                ^ other.ext_pipeline_creation_feedback,
            ext_pipeline_library_group_handles: self.ext_pipeline_library_group_handles
                ^ other.ext_pipeline_library_group_handles,
            ext_pipeline_properties: self.ext_pipeline_properties
                ^ other.ext_pipeline_properties,
            ext_pipeline_protected_access: self.ext_pipeline_protected_access
                ^ other.ext_pipeline_protected_access,
            ext_pipeline_robustness: self.ext_pipeline_robustness
                ^ other.ext_pipeline_robustness,
            ext_post_depth_coverage: self.ext_post_depth_coverage
                ^ other.ext_post_depth_coverage,
            ext_primitive_topology_list_restart: self.ext_primitive_topology_list_restart
                ^ other.ext_primitive_topology_list_restart,
            ext_primitives_generated_query: self.ext_primitives_generated_query
                ^ other.ext_primitives_generated_query,
            ext_private_data: self.ext_private_data ^ other.ext_private_data,
            ext_provoking_vertex: self.ext_provoking_vertex ^ other.ext_provoking_vertex,
            ext_queue_family_foreign: self.ext_queue_family_foreign
                ^ other.ext_queue_family_foreign,
            ext_rasterization_order_attachment_access: self
                .ext_rasterization_order_attachment_access
                ^ other.ext_rasterization_order_attachment_access,
            ext_rgba10x6_formats: self.ext_rgba10x6_formats ^ other.ext_rgba10x6_formats,
            ext_robustness2: self.ext_robustness2 ^ other.ext_robustness2,
            ext_sample_locations: self.ext_sample_locations ^ other.ext_sample_locations,
            ext_sampler_filter_minmax: self.ext_sampler_filter_minmax
                ^ other.ext_sampler_filter_minmax,
            ext_scalar_block_layout: self.ext_scalar_block_layout
                ^ other.ext_scalar_block_layout,
            ext_separate_stencil_usage: self.ext_separate_stencil_usage
                ^ other.ext_separate_stencil_usage,
            ext_shader_atomic_float: self.ext_shader_atomic_float
                ^ other.ext_shader_atomic_float,
            ext_shader_atomic_float2: self.ext_shader_atomic_float2
                ^ other.ext_shader_atomic_float2,
            ext_shader_demote_to_helper_invocation: self
                .ext_shader_demote_to_helper_invocation
                ^ other.ext_shader_demote_to_helper_invocation,
            ext_shader_image_atomic_int64: self.ext_shader_image_atomic_int64
                ^ other.ext_shader_image_atomic_int64,
            ext_shader_module_identifier: self.ext_shader_module_identifier
                ^ other.ext_shader_module_identifier,
            ext_shader_object: self.ext_shader_object ^ other.ext_shader_object,
            ext_shader_stencil_export: self.ext_shader_stencil_export
                ^ other.ext_shader_stencil_export,
            ext_shader_subgroup_ballot: self.ext_shader_subgroup_ballot
                ^ other.ext_shader_subgroup_ballot,
            ext_shader_subgroup_vote: self.ext_shader_subgroup_vote
                ^ other.ext_shader_subgroup_vote,
            ext_shader_tile_image: self.ext_shader_tile_image
                ^ other.ext_shader_tile_image,
            ext_shader_viewport_index_layer: self.ext_shader_viewport_index_layer
                ^ other.ext_shader_viewport_index_layer,
            ext_subgroup_size_control: self.ext_subgroup_size_control
                ^ other.ext_subgroup_size_control,
            ext_subpass_merge_feedback: self.ext_subpass_merge_feedback
                ^ other.ext_subpass_merge_feedback,
            ext_swapchain_maintenance1: self.ext_swapchain_maintenance1
                ^ other.ext_swapchain_maintenance1,
            ext_texel_buffer_alignment: self.ext_texel_buffer_alignment
                ^ other.ext_texel_buffer_alignment,
            ext_texture_compression_astc_hdr: self.ext_texture_compression_astc_hdr
                ^ other.ext_texture_compression_astc_hdr,
            ext_tooling_info: self.ext_tooling_info ^ other.ext_tooling_info,
            ext_transform_feedback: self.ext_transform_feedback
                ^ other.ext_transform_feedback,
            ext_validation_cache: self.ext_validation_cache ^ other.ext_validation_cache,
            ext_vertex_attribute_divisor: self.ext_vertex_attribute_divisor
                ^ other.ext_vertex_attribute_divisor,
            ext_vertex_input_dynamic_state: self.ext_vertex_input_dynamic_state
                ^ other.ext_vertex_input_dynamic_state,
            ext_ycbcr_2plane_444_formats: self.ext_ycbcr_2plane_444_formats
                ^ other.ext_ycbcr_2plane_444_formats,
            ext_ycbcr_image_arrays: self.ext_ycbcr_image_arrays
                ^ other.ext_ycbcr_image_arrays,
            amdx_shader_enqueue: self.amdx_shader_enqueue ^ other.amdx_shader_enqueue,
            amd_buffer_marker: self.amd_buffer_marker ^ other.amd_buffer_marker,
            amd_device_coherent_memory: self.amd_device_coherent_memory
                ^ other.amd_device_coherent_memory,
            amd_display_native_hdr: self.amd_display_native_hdr
                ^ other.amd_display_native_hdr,
            amd_draw_indirect_count: self.amd_draw_indirect_count
                ^ other.amd_draw_indirect_count,
            amd_gcn_shader: self.amd_gcn_shader ^ other.amd_gcn_shader,
            amd_gpu_shader_half_float: self.amd_gpu_shader_half_float
                ^ other.amd_gpu_shader_half_float,
            amd_gpu_shader_int16: self.amd_gpu_shader_int16 ^ other.amd_gpu_shader_int16,
            amd_memory_overallocation_behavior: self.amd_memory_overallocation_behavior
                ^ other.amd_memory_overallocation_behavior,
            amd_mixed_attachment_samples: self.amd_mixed_attachment_samples
                ^ other.amd_mixed_attachment_samples,
            amd_pipeline_compiler_control: self.amd_pipeline_compiler_control
                ^ other.amd_pipeline_compiler_control,
            amd_rasterization_order: self.amd_rasterization_order
                ^ other.amd_rasterization_order,
            amd_shader_ballot: self.amd_shader_ballot ^ other.amd_shader_ballot,
            amd_shader_core_properties: self.amd_shader_core_properties
                ^ other.amd_shader_core_properties,
            amd_shader_core_properties2: self.amd_shader_core_properties2
                ^ other.amd_shader_core_properties2,
            amd_shader_early_and_late_fragment_tests: self
                .amd_shader_early_and_late_fragment_tests
                ^ other.amd_shader_early_and_late_fragment_tests,
            amd_shader_explicit_vertex_parameter: self
                .amd_shader_explicit_vertex_parameter
                ^ other.amd_shader_explicit_vertex_parameter,
            amd_shader_fragment_mask: self.amd_shader_fragment_mask
                ^ other.amd_shader_fragment_mask,
            amd_shader_image_load_store_lod: self.amd_shader_image_load_store_lod
                ^ other.amd_shader_image_load_store_lod,
            amd_shader_info: self.amd_shader_info ^ other.amd_shader_info,
            amd_shader_trinary_minmax: self.amd_shader_trinary_minmax
                ^ other.amd_shader_trinary_minmax,
            amd_texture_gather_bias_lod: self.amd_texture_gather_bias_lod
                ^ other.amd_texture_gather_bias_lod,
            android_external_format_resolve: self.android_external_format_resolve
                ^ other.android_external_format_resolve,
            android_external_memory_android_hardware_buffer: self
                .android_external_memory_android_hardware_buffer
                ^ other.android_external_memory_android_hardware_buffer,
            arm_rasterization_order_attachment_access: self
                .arm_rasterization_order_attachment_access
                ^ other.arm_rasterization_order_attachment_access,
            arm_render_pass_striped: self.arm_render_pass_striped
                ^ other.arm_render_pass_striped,
            arm_scheduling_controls: self.arm_scheduling_controls
                ^ other.arm_scheduling_controls,
            arm_shader_core_builtins: self.arm_shader_core_builtins
                ^ other.arm_shader_core_builtins,
            arm_shader_core_properties: self.arm_shader_core_properties
                ^ other.arm_shader_core_properties,
            fuchsia_buffer_collection: self.fuchsia_buffer_collection
                ^ other.fuchsia_buffer_collection,
            fuchsia_external_memory: self.fuchsia_external_memory
                ^ other.fuchsia_external_memory,
            fuchsia_external_semaphore: self.fuchsia_external_semaphore
                ^ other.fuchsia_external_semaphore,
            ggp_frame_token: self.ggp_frame_token ^ other.ggp_frame_token,
            google_decorate_string: self.google_decorate_string
                ^ other.google_decorate_string,
            google_display_timing: self.google_display_timing
                ^ other.google_display_timing,
            google_hlsl_functionality1: self.google_hlsl_functionality1
                ^ other.google_hlsl_functionality1,
            google_user_type: self.google_user_type ^ other.google_user_type,
            huawei_cluster_culling_shader: self.huawei_cluster_culling_shader
                ^ other.huawei_cluster_culling_shader,
            huawei_invocation_mask: self.huawei_invocation_mask
                ^ other.huawei_invocation_mask,
            huawei_subpass_shading: self.huawei_subpass_shading
                ^ other.huawei_subpass_shading,
            img_filter_cubic: self.img_filter_cubic ^ other.img_filter_cubic,
            img_format_pvrtc: self.img_format_pvrtc ^ other.img_format_pvrtc,
            img_relaxed_line_rasterization: self.img_relaxed_line_rasterization
                ^ other.img_relaxed_line_rasterization,
            intel_performance_query: self.intel_performance_query
                ^ other.intel_performance_query,
            intel_shader_integer_functions2: self.intel_shader_integer_functions2
                ^ other.intel_shader_integer_functions2,
            msft_layered_driver: self.msft_layered_driver ^ other.msft_layered_driver,
            nvx_binary_import: self.nvx_binary_import ^ other.nvx_binary_import,
            nvx_image_view_handle: self.nvx_image_view_handle
                ^ other.nvx_image_view_handle,
            nvx_multiview_per_view_attributes: self.nvx_multiview_per_view_attributes
                ^ other.nvx_multiview_per_view_attributes,
            nv_acquire_winrt_display: self.nv_acquire_winrt_display
                ^ other.nv_acquire_winrt_display,
            nv_clip_space_w_scaling: self.nv_clip_space_w_scaling
                ^ other.nv_clip_space_w_scaling,
            nv_compute_shader_derivatives: self.nv_compute_shader_derivatives
                ^ other.nv_compute_shader_derivatives,
            nv_cooperative_matrix: self.nv_cooperative_matrix
                ^ other.nv_cooperative_matrix,
            nv_copy_memory_indirect: self.nv_copy_memory_indirect
                ^ other.nv_copy_memory_indirect,
            nv_corner_sampled_image: self.nv_corner_sampled_image
                ^ other.nv_corner_sampled_image,
            nv_coverage_reduction_mode: self.nv_coverage_reduction_mode
                ^ other.nv_coverage_reduction_mode,
            nv_cuda_kernel_launch: self.nv_cuda_kernel_launch
                ^ other.nv_cuda_kernel_launch,
            nv_dedicated_allocation: self.nv_dedicated_allocation
                ^ other.nv_dedicated_allocation,
            nv_dedicated_allocation_image_aliasing: self
                .nv_dedicated_allocation_image_aliasing
                ^ other.nv_dedicated_allocation_image_aliasing,
            nv_descriptor_pool_overallocation: self.nv_descriptor_pool_overallocation
                ^ other.nv_descriptor_pool_overallocation,
            nv_device_diagnostic_checkpoints: self.nv_device_diagnostic_checkpoints
                ^ other.nv_device_diagnostic_checkpoints,
            nv_device_diagnostics_config: self.nv_device_diagnostics_config
                ^ other.nv_device_diagnostics_config,
            nv_device_generated_commands: self.nv_device_generated_commands
                ^ other.nv_device_generated_commands,
            nv_device_generated_commands_compute: self
                .nv_device_generated_commands_compute
                ^ other.nv_device_generated_commands_compute,
            nv_displacement_micromap: self.nv_displacement_micromap
                ^ other.nv_displacement_micromap,
            nv_extended_sparse_address_space: self.nv_extended_sparse_address_space
                ^ other.nv_extended_sparse_address_space,
            nv_external_memory: self.nv_external_memory ^ other.nv_external_memory,
            nv_external_memory_rdma: self.nv_external_memory_rdma
                ^ other.nv_external_memory_rdma,
            nv_external_memory_win32: self.nv_external_memory_win32
                ^ other.nv_external_memory_win32,
            nv_fill_rectangle: self.nv_fill_rectangle ^ other.nv_fill_rectangle,
            nv_fragment_coverage_to_color: self.nv_fragment_coverage_to_color
                ^ other.nv_fragment_coverage_to_color,
            nv_fragment_shader_barycentric: self.nv_fragment_shader_barycentric
                ^ other.nv_fragment_shader_barycentric,
            nv_fragment_shading_rate_enums: self.nv_fragment_shading_rate_enums
                ^ other.nv_fragment_shading_rate_enums,
            nv_framebuffer_mixed_samples: self.nv_framebuffer_mixed_samples
                ^ other.nv_framebuffer_mixed_samples,
            nv_geometry_shader_passthrough: self.nv_geometry_shader_passthrough
                ^ other.nv_geometry_shader_passthrough,
            nv_glsl_shader: self.nv_glsl_shader ^ other.nv_glsl_shader,
            nv_inherited_viewport_scissor: self.nv_inherited_viewport_scissor
                ^ other.nv_inherited_viewport_scissor,
            nv_linear_color_attachment: self.nv_linear_color_attachment
                ^ other.nv_linear_color_attachment,
            nv_low_latency: self.nv_low_latency ^ other.nv_low_latency,
            nv_low_latency2: self.nv_low_latency2 ^ other.nv_low_latency2,
            nv_memory_decompression: self.nv_memory_decompression
                ^ other.nv_memory_decompression,
            nv_mesh_shader: self.nv_mesh_shader ^ other.nv_mesh_shader,
            nv_optical_flow: self.nv_optical_flow ^ other.nv_optical_flow,
            nv_per_stage_descriptor_set: self.nv_per_stage_descriptor_set
                ^ other.nv_per_stage_descriptor_set,
            nv_present_barrier: self.nv_present_barrier ^ other.nv_present_barrier,
            nv_raw_access_chains: self.nv_raw_access_chains ^ other.nv_raw_access_chains,
            nv_ray_tracing: self.nv_ray_tracing ^ other.nv_ray_tracing,
            nv_ray_tracing_invocation_reorder: self.nv_ray_tracing_invocation_reorder
                ^ other.nv_ray_tracing_invocation_reorder,
            nv_ray_tracing_motion_blur: self.nv_ray_tracing_motion_blur
                ^ other.nv_ray_tracing_motion_blur,
            nv_ray_tracing_validation: self.nv_ray_tracing_validation
                ^ other.nv_ray_tracing_validation,
            nv_representative_fragment_test: self.nv_representative_fragment_test
                ^ other.nv_representative_fragment_test,
            nv_sample_mask_override_coverage: self.nv_sample_mask_override_coverage
                ^ other.nv_sample_mask_override_coverage,
            nv_scissor_exclusive: self.nv_scissor_exclusive ^ other.nv_scissor_exclusive,
            nv_shader_atomic_float16_vector: self.nv_shader_atomic_float16_vector
                ^ other.nv_shader_atomic_float16_vector,
            nv_shader_image_footprint: self.nv_shader_image_footprint
                ^ other.nv_shader_image_footprint,
            nv_shader_sm_builtins: self.nv_shader_sm_builtins
                ^ other.nv_shader_sm_builtins,
            nv_shader_subgroup_partitioned: self.nv_shader_subgroup_partitioned
                ^ other.nv_shader_subgroup_partitioned,
            nv_shading_rate_image: self.nv_shading_rate_image
                ^ other.nv_shading_rate_image,
            nv_viewport_array2: self.nv_viewport_array2 ^ other.nv_viewport_array2,
            nv_viewport_swizzle: self.nv_viewport_swizzle ^ other.nv_viewport_swizzle,
            nv_win32_keyed_mutex: self.nv_win32_keyed_mutex ^ other.nv_win32_keyed_mutex,
            qcom_filter_cubic_clamp: self.qcom_filter_cubic_clamp
                ^ other.qcom_filter_cubic_clamp,
            qcom_filter_cubic_weights: self.qcom_filter_cubic_weights
                ^ other.qcom_filter_cubic_weights,
            qcom_fragment_density_map_offset: self.qcom_fragment_density_map_offset
                ^ other.qcom_fragment_density_map_offset,
            qcom_image_processing: self.qcom_image_processing
                ^ other.qcom_image_processing,
            qcom_image_processing2: self.qcom_image_processing2
                ^ other.qcom_image_processing2,
            qcom_multiview_per_view_render_areas: self
                .qcom_multiview_per_view_render_areas
                ^ other.qcom_multiview_per_view_render_areas,
            qcom_multiview_per_view_viewports: self.qcom_multiview_per_view_viewports
                ^ other.qcom_multiview_per_view_viewports,
            qcom_render_pass_shader_resolve: self.qcom_render_pass_shader_resolve
                ^ other.qcom_render_pass_shader_resolve,
            qcom_render_pass_store_ops: self.qcom_render_pass_store_ops
                ^ other.qcom_render_pass_store_ops,
            qcom_render_pass_transform: self.qcom_render_pass_transform
                ^ other.qcom_render_pass_transform,
            qcom_rotated_copy_commands: self.qcom_rotated_copy_commands
                ^ other.qcom_rotated_copy_commands,
            qcom_tile_properties: self.qcom_tile_properties ^ other.qcom_tile_properties,
            qcom_ycbcr_degamma: self.qcom_ycbcr_degamma ^ other.qcom_ycbcr_degamma,
            qnx_external_memory_screen_buffer: self.qnx_external_memory_screen_buffer
                ^ other.qnx_external_memory_screen_buffer,
            sec_amigo_profiling: self.sec_amigo_profiling ^ other.sec_amigo_profiling,
            valve_descriptor_set_host_mapping: self.valve_descriptor_set_host_mapping
                ^ other.valve_descriptor_set_host_mapping,
            valve_mutable_descriptor_type: self.valve_mutable_descriptor_type
                ^ other.valve_mutable_descriptor_type,
            _ne: crate::NonExhaustive(()),
        }
    }
}
impl std::ops::BitAnd for DeviceExtensions {
    type Output = DeviceExtensions;
    #[inline]
    fn bitand(self, rhs: Self) -> Self::Output {
        self.intersection(&rhs)
    }
}
impl std::ops::BitAndAssign for DeviceExtensions {
    #[inline]
    fn bitand_assign(&mut self, rhs: Self) {
        *self = self.intersection(&rhs);
    }
}
impl std::ops::BitOr for DeviceExtensions {
    type Output = DeviceExtensions;
    #[inline]
    fn bitor(self, rhs: Self) -> Self::Output {
        self.union(&rhs)
    }
}
impl std::ops::BitOrAssign for DeviceExtensions {
    #[inline]
    fn bitor_assign(&mut self, rhs: Self) {
        *self = self.union(&rhs);
    }
}
impl std::ops::BitXor for DeviceExtensions {
    type Output = DeviceExtensions;
    #[inline]
    fn bitxor(self, rhs: Self) -> Self::Output {
        self.symmetric_difference(&rhs)
    }
}
impl std::ops::BitXorAssign for DeviceExtensions {
    #[inline]
    fn bitxor_assign(&mut self, rhs: Self) {
        *self = self.symmetric_difference(&rhs);
    }
}
impl std::ops::Sub for DeviceExtensions {
    type Output = DeviceExtensions;
    #[inline]
    fn sub(self, rhs: Self) -> Self::Output {
        self.difference(&rhs)
    }
}
impl std::ops::SubAssign for DeviceExtensions {
    #[inline]
    fn sub_assign(&mut self, rhs: Self) {
        *self = self.difference(&rhs);
    }
}
impl std::fmt::Debug for DeviceExtensions {
    #[allow(unused_assignments)]
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(f, "[")?;
        let mut first = true;
        if self.khr_16bit_storage {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_KHR_16bit_storage")?;
        }
        if self.khr_8bit_storage {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_KHR_8bit_storage")?;
        }
        if self.khr_acceleration_structure {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_KHR_acceleration_structure")?;
        }
        if self.khr_bind_memory2 {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_KHR_bind_memory2")?;
        }
        if self.khr_buffer_device_address {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_KHR_buffer_device_address")?;
        }
        if self.khr_calibrated_timestamps {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_KHR_calibrated_timestamps")?;
        }
        if self.khr_cooperative_matrix {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_KHR_cooperative_matrix")?;
        }
        if self.khr_copy_commands2 {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_KHR_copy_commands2")?;
        }
        if self.khr_create_renderpass2 {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_KHR_create_renderpass2")?;
        }
        if self.khr_dedicated_allocation {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_KHR_dedicated_allocation")?;
        }
        if self.khr_deferred_host_operations {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_KHR_deferred_host_operations")?;
        }
        if self.khr_depth_stencil_resolve {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_KHR_depth_stencil_resolve")?;
        }
        if self.khr_descriptor_update_template {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_KHR_descriptor_update_template")?;
        }
        if self.khr_device_group {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_KHR_device_group")?;
        }
        if self.khr_display_swapchain {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_KHR_display_swapchain")?;
        }
        if self.khr_draw_indirect_count {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_KHR_draw_indirect_count")?;
        }
        if self.khr_driver_properties {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_KHR_driver_properties")?;
        }
        if self.khr_dynamic_rendering {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_KHR_dynamic_rendering")?;
        }
        if self.khr_dynamic_rendering_local_read {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_KHR_dynamic_rendering_local_read")?;
        }
        if self.khr_external_fence {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_KHR_external_fence")?;
        }
        if self.khr_external_fence_fd {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_KHR_external_fence_fd")?;
        }
        if self.khr_external_fence_win32 {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_KHR_external_fence_win32")?;
        }
        if self.khr_external_memory {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_KHR_external_memory")?;
        }
        if self.khr_external_memory_fd {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_KHR_external_memory_fd")?;
        }
        if self.khr_external_memory_win32 {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_KHR_external_memory_win32")?;
        }
        if self.khr_external_semaphore {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_KHR_external_semaphore")?;
        }
        if self.khr_external_semaphore_fd {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_KHR_external_semaphore_fd")?;
        }
        if self.khr_external_semaphore_win32 {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_KHR_external_semaphore_win32")?;
        }
        if self.khr_format_feature_flags2 {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_KHR_format_feature_flags2")?;
        }
        if self.khr_fragment_shader_barycentric {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_KHR_fragment_shader_barycentric")?;
        }
        if self.khr_fragment_shading_rate {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_KHR_fragment_shading_rate")?;
        }
        if self.khr_get_memory_requirements2 {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_KHR_get_memory_requirements2")?;
        }
        if self.khr_global_priority {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_KHR_global_priority")?;
        }
        if self.khr_image_format_list {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_KHR_image_format_list")?;
        }
        if self.khr_imageless_framebuffer {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_KHR_imageless_framebuffer")?;
        }
        if self.khr_incremental_present {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_KHR_incremental_present")?;
        }
        if self.khr_index_type_uint8 {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_KHR_index_type_uint8")?;
        }
        if self.khr_line_rasterization {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_KHR_line_rasterization")?;
        }
        if self.khr_load_store_op_none {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_KHR_load_store_op_none")?;
        }
        if self.khr_maintenance1 {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_KHR_maintenance1")?;
        }
        if self.khr_maintenance2 {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_KHR_maintenance2")?;
        }
        if self.khr_maintenance3 {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_KHR_maintenance3")?;
        }
        if self.khr_maintenance4 {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_KHR_maintenance4")?;
        }
        if self.khr_maintenance5 {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_KHR_maintenance5")?;
        }
        if self.khr_maintenance6 {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_KHR_maintenance6")?;
        }
        if self.khr_map_memory2 {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_KHR_map_memory2")?;
        }
        if self.khr_multiview {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_KHR_multiview")?;
        }
        if self.khr_performance_query {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_KHR_performance_query")?;
        }
        if self.khr_pipeline_executable_properties {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_KHR_pipeline_executable_properties")?;
        }
        if self.khr_pipeline_library {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_KHR_pipeline_library")?;
        }
        if self.khr_portability_subset {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_KHR_portability_subset")?;
        }
        if self.khr_present_id {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_KHR_present_id")?;
        }
        if self.khr_present_wait {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_KHR_present_wait")?;
        }
        if self.khr_push_descriptor {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_KHR_push_descriptor")?;
        }
        if self.khr_ray_query {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_KHR_ray_query")?;
        }
        if self.khr_ray_tracing_maintenance1 {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_KHR_ray_tracing_maintenance1")?;
        }
        if self.khr_ray_tracing_pipeline {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_KHR_ray_tracing_pipeline")?;
        }
        if self.khr_ray_tracing_position_fetch {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_KHR_ray_tracing_position_fetch")?;
        }
        if self.khr_relaxed_block_layout {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_KHR_relaxed_block_layout")?;
        }
        if self.khr_sampler_mirror_clamp_to_edge {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_KHR_sampler_mirror_clamp_to_edge")?;
        }
        if self.khr_sampler_ycbcr_conversion {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_KHR_sampler_ycbcr_conversion")?;
        }
        if self.khr_separate_depth_stencil_layouts {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_KHR_separate_depth_stencil_layouts")?;
        }
        if self.khr_shader_atomic_int64 {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_KHR_shader_atomic_int64")?;
        }
        if self.khr_shader_clock {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_KHR_shader_clock")?;
        }
        if self.khr_shader_draw_parameters {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_KHR_shader_draw_parameters")?;
        }
        if self.khr_shader_expect_assume {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_KHR_shader_expect_assume")?;
        }
        if self.khr_shader_float16_int8 {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_KHR_shader_float16_int8")?;
        }
        if self.khr_shader_float_controls {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_KHR_shader_float_controls")?;
        }
        if self.khr_shader_float_controls2 {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_KHR_shader_float_controls2")?;
        }
        if self.khr_shader_integer_dot_product {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_KHR_shader_integer_dot_product")?;
        }
        if self.khr_shader_maximal_reconvergence {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_KHR_shader_maximal_reconvergence")?;
        }
        if self.khr_shader_non_semantic_info {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_KHR_shader_non_semantic_info")?;
        }
        if self.khr_shader_quad_control {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_KHR_shader_quad_control")?;
        }
        if self.khr_shader_subgroup_extended_types {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_KHR_shader_subgroup_extended_types")?;
        }
        if self.khr_shader_subgroup_rotate {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_KHR_shader_subgroup_rotate")?;
        }
        if self.khr_shader_subgroup_uniform_control_flow {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_KHR_shader_subgroup_uniform_control_flow")?;
        }
        if self.khr_shader_terminate_invocation {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_KHR_shader_terminate_invocation")?;
        }
        if self.khr_shared_presentable_image {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_KHR_shared_presentable_image")?;
        }
        if self.khr_spirv_1_4 {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_KHR_spirv_1_4")?;
        }
        if self.khr_storage_buffer_storage_class {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_KHR_storage_buffer_storage_class")?;
        }
        if self.khr_swapchain {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_KHR_swapchain")?;
        }
        if self.khr_swapchain_mutable_format {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_KHR_swapchain_mutable_format")?;
        }
        if self.khr_synchronization2 {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_KHR_synchronization2")?;
        }
        if self.khr_timeline_semaphore {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_KHR_timeline_semaphore")?;
        }
        if self.khr_uniform_buffer_standard_layout {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_KHR_uniform_buffer_standard_layout")?;
        }
        if self.khr_variable_pointers {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_KHR_variable_pointers")?;
        }
        if self.khr_vertex_attribute_divisor {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_KHR_vertex_attribute_divisor")?;
        }
        if self.khr_video_decode_av1 {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_KHR_video_decode_av1")?;
        }
        if self.khr_video_decode_h264 {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_KHR_video_decode_h264")?;
        }
        if self.khr_video_decode_h265 {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_KHR_video_decode_h265")?;
        }
        if self.khr_video_decode_queue {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_KHR_video_decode_queue")?;
        }
        if self.khr_video_encode_h264 {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_KHR_video_encode_h264")?;
        }
        if self.khr_video_encode_h265 {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_KHR_video_encode_h265")?;
        }
        if self.khr_video_encode_queue {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_KHR_video_encode_queue")?;
        }
        if self.khr_video_maintenance1 {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_KHR_video_maintenance1")?;
        }
        if self.khr_video_queue {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_KHR_video_queue")?;
        }
        if self.khr_vulkan_memory_model {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_KHR_vulkan_memory_model")?;
        }
        if self.khr_win32_keyed_mutex {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_KHR_win32_keyed_mutex")?;
        }
        if self.khr_workgroup_memory_explicit_layout {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_KHR_workgroup_memory_explicit_layout")?;
        }
        if self.khr_zero_initialize_workgroup_memory {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_KHR_zero_initialize_workgroup_memory")?;
        }
        if self.ext_4444_formats {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_EXT_4444_formats")?;
        }
        if self.ext_astc_decode_mode {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_EXT_astc_decode_mode")?;
        }
        if self.ext_attachment_feedback_loop_dynamic_state {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_EXT_attachment_feedback_loop_dynamic_state")?;
        }
        if self.ext_attachment_feedback_loop_layout {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_EXT_attachment_feedback_loop_layout")?;
        }
        if self.ext_blend_operation_advanced {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_EXT_blend_operation_advanced")?;
        }
        if self.ext_border_color_swizzle {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_EXT_border_color_swizzle")?;
        }
        if self.ext_buffer_device_address {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_EXT_buffer_device_address")?;
        }
        if self.ext_calibrated_timestamps {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_EXT_calibrated_timestamps")?;
        }
        if self.ext_color_write_enable {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_EXT_color_write_enable")?;
        }
        if self.ext_conditional_rendering {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_EXT_conditional_rendering")?;
        }
        if self.ext_conservative_rasterization {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_EXT_conservative_rasterization")?;
        }
        if self.ext_custom_border_color {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_EXT_custom_border_color")?;
        }
        if self.ext_debug_marker {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_EXT_debug_marker")?;
        }
        if self.ext_depth_bias_control {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_EXT_depth_bias_control")?;
        }
        if self.ext_depth_clamp_zero_one {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_EXT_depth_clamp_zero_one")?;
        }
        if self.ext_depth_clip_control {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_EXT_depth_clip_control")?;
        }
        if self.ext_depth_clip_enable {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_EXT_depth_clip_enable")?;
        }
        if self.ext_depth_range_unrestricted {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_EXT_depth_range_unrestricted")?;
        }
        if self.ext_descriptor_buffer {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_EXT_descriptor_buffer")?;
        }
        if self.ext_descriptor_indexing {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_EXT_descriptor_indexing")?;
        }
        if self.ext_device_address_binding_report {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_EXT_device_address_binding_report")?;
        }
        if self.ext_device_fault {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_EXT_device_fault")?;
        }
        if self.ext_device_memory_report {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_EXT_device_memory_report")?;
        }
        if self.ext_discard_rectangles {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_EXT_discard_rectangles")?;
        }
        if self.ext_display_control {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_EXT_display_control")?;
        }
        if self.ext_dynamic_rendering_unused_attachments {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_EXT_dynamic_rendering_unused_attachments")?;
        }
        if self.ext_extended_dynamic_state {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_EXT_extended_dynamic_state")?;
        }
        if self.ext_extended_dynamic_state2 {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_EXT_extended_dynamic_state2")?;
        }
        if self.ext_extended_dynamic_state3 {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_EXT_extended_dynamic_state3")?;
        }
        if self.ext_external_memory_acquire_unmodified {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_EXT_external_memory_acquire_unmodified")?;
        }
        if self.ext_external_memory_dma_buf {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_EXT_external_memory_dma_buf")?;
        }
        if self.ext_external_memory_host {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_EXT_external_memory_host")?;
        }
        if self.ext_filter_cubic {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_EXT_filter_cubic")?;
        }
        if self.ext_fragment_density_map {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_EXT_fragment_density_map")?;
        }
        if self.ext_fragment_density_map2 {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_EXT_fragment_density_map2")?;
        }
        if self.ext_fragment_shader_interlock {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_EXT_fragment_shader_interlock")?;
        }
        if self.ext_frame_boundary {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_EXT_frame_boundary")?;
        }
        if self.ext_full_screen_exclusive {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_EXT_full_screen_exclusive")?;
        }
        if self.ext_global_priority {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_EXT_global_priority")?;
        }
        if self.ext_global_priority_query {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_EXT_global_priority_query")?;
        }
        if self.ext_graphics_pipeline_library {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_EXT_graphics_pipeline_library")?;
        }
        if self.ext_hdr_metadata {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_EXT_hdr_metadata")?;
        }
        if self.ext_host_image_copy {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_EXT_host_image_copy")?;
        }
        if self.ext_host_query_reset {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_EXT_host_query_reset")?;
        }
        if self.ext_image_2d_view_of_3d {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_EXT_image_2d_view_of_3d")?;
        }
        if self.ext_image_compression_control {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_EXT_image_compression_control")?;
        }
        if self.ext_image_compression_control_swapchain {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_EXT_image_compression_control_swapchain")?;
        }
        if self.ext_image_drm_format_modifier {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_EXT_image_drm_format_modifier")?;
        }
        if self.ext_image_robustness {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_EXT_image_robustness")?;
        }
        if self.ext_image_sliced_view_of_3d {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_EXT_image_sliced_view_of_3d")?;
        }
        if self.ext_image_view_min_lod {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_EXT_image_view_min_lod")?;
        }
        if self.ext_index_type_uint8 {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_EXT_index_type_uint8")?;
        }
        if self.ext_inline_uniform_block {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_EXT_inline_uniform_block")?;
        }
        if self.ext_legacy_dithering {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_EXT_legacy_dithering")?;
        }
        if self.ext_line_rasterization {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_EXT_line_rasterization")?;
        }
        if self.ext_load_store_op_none {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_EXT_load_store_op_none")?;
        }
        if self.ext_map_memory_placed {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_EXT_map_memory_placed")?;
        }
        if self.ext_memory_budget {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_EXT_memory_budget")?;
        }
        if self.ext_memory_priority {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_EXT_memory_priority")?;
        }
        if self.ext_mesh_shader {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_EXT_mesh_shader")?;
        }
        if self.ext_metal_objects {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_EXT_metal_objects")?;
        }
        if self.ext_multi_draw {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_EXT_multi_draw")?;
        }
        if self.ext_multisampled_render_to_single_sampled {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_EXT_multisampled_render_to_single_sampled")?;
        }
        if self.ext_mutable_descriptor_type {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_EXT_mutable_descriptor_type")?;
        }
        if self.ext_nested_command_buffer {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_EXT_nested_command_buffer")?;
        }
        if self.ext_non_seamless_cube_map {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_EXT_non_seamless_cube_map")?;
        }
        if self.ext_opacity_micromap {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_EXT_opacity_micromap")?;
        }
        if self.ext_pageable_device_local_memory {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_EXT_pageable_device_local_memory")?;
        }
        if self.ext_pci_bus_info {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_EXT_pci_bus_info")?;
        }
        if self.ext_physical_device_drm {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_EXT_physical_device_drm")?;
        }
        if self.ext_pipeline_creation_cache_control {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_EXT_pipeline_creation_cache_control")?;
        }
        if self.ext_pipeline_creation_feedback {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_EXT_pipeline_creation_feedback")?;
        }
        if self.ext_pipeline_library_group_handles {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_EXT_pipeline_library_group_handles")?;
        }
        if self.ext_pipeline_properties {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_EXT_pipeline_properties")?;
        }
        if self.ext_pipeline_protected_access {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_EXT_pipeline_protected_access")?;
        }
        if self.ext_pipeline_robustness {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_EXT_pipeline_robustness")?;
        }
        if self.ext_post_depth_coverage {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_EXT_post_depth_coverage")?;
        }
        if self.ext_primitive_topology_list_restart {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_EXT_primitive_topology_list_restart")?;
        }
        if self.ext_primitives_generated_query {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_EXT_primitives_generated_query")?;
        }
        if self.ext_private_data {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_EXT_private_data")?;
        }
        if self.ext_provoking_vertex {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_EXT_provoking_vertex")?;
        }
        if self.ext_queue_family_foreign {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_EXT_queue_family_foreign")?;
        }
        if self.ext_rasterization_order_attachment_access {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_EXT_rasterization_order_attachment_access")?;
        }
        if self.ext_rgba10x6_formats {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_EXT_rgba10x6_formats")?;
        }
        if self.ext_robustness2 {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_EXT_robustness2")?;
        }
        if self.ext_sample_locations {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_EXT_sample_locations")?;
        }
        if self.ext_sampler_filter_minmax {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_EXT_sampler_filter_minmax")?;
        }
        if self.ext_scalar_block_layout {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_EXT_scalar_block_layout")?;
        }
        if self.ext_separate_stencil_usage {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_EXT_separate_stencil_usage")?;
        }
        if self.ext_shader_atomic_float {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_EXT_shader_atomic_float")?;
        }
        if self.ext_shader_atomic_float2 {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_EXT_shader_atomic_float2")?;
        }
        if self.ext_shader_demote_to_helper_invocation {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_EXT_shader_demote_to_helper_invocation")?;
        }
        if self.ext_shader_image_atomic_int64 {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_EXT_shader_image_atomic_int64")?;
        }
        if self.ext_shader_module_identifier {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_EXT_shader_module_identifier")?;
        }
        if self.ext_shader_object {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_EXT_shader_object")?;
        }
        if self.ext_shader_stencil_export {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_EXT_shader_stencil_export")?;
        }
        if self.ext_shader_subgroup_ballot {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_EXT_shader_subgroup_ballot")?;
        }
        if self.ext_shader_subgroup_vote {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_EXT_shader_subgroup_vote")?;
        }
        if self.ext_shader_tile_image {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_EXT_shader_tile_image")?;
        }
        if self.ext_shader_viewport_index_layer {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_EXT_shader_viewport_index_layer")?;
        }
        if self.ext_subgroup_size_control {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_EXT_subgroup_size_control")?;
        }
        if self.ext_subpass_merge_feedback {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_EXT_subpass_merge_feedback")?;
        }
        if self.ext_swapchain_maintenance1 {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_EXT_swapchain_maintenance1")?;
        }
        if self.ext_texel_buffer_alignment {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_EXT_texel_buffer_alignment")?;
        }
        if self.ext_texture_compression_astc_hdr {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_EXT_texture_compression_astc_hdr")?;
        }
        if self.ext_tooling_info {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_EXT_tooling_info")?;
        }
        if self.ext_transform_feedback {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_EXT_transform_feedback")?;
        }
        if self.ext_validation_cache {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_EXT_validation_cache")?;
        }
        if self.ext_vertex_attribute_divisor {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_EXT_vertex_attribute_divisor")?;
        }
        if self.ext_vertex_input_dynamic_state {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_EXT_vertex_input_dynamic_state")?;
        }
        if self.ext_ycbcr_2plane_444_formats {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_EXT_ycbcr_2plane_444_formats")?;
        }
        if self.ext_ycbcr_image_arrays {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_EXT_ycbcr_image_arrays")?;
        }
        if self.amdx_shader_enqueue {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_AMDX_shader_enqueue")?;
        }
        if self.amd_buffer_marker {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_AMD_buffer_marker")?;
        }
        if self.amd_device_coherent_memory {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_AMD_device_coherent_memory")?;
        }
        if self.amd_display_native_hdr {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_AMD_display_native_hdr")?;
        }
        if self.amd_draw_indirect_count {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_AMD_draw_indirect_count")?;
        }
        if self.amd_gcn_shader {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_AMD_gcn_shader")?;
        }
        if self.amd_gpu_shader_half_float {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_AMD_gpu_shader_half_float")?;
        }
        if self.amd_gpu_shader_int16 {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_AMD_gpu_shader_int16")?;
        }
        if self.amd_memory_overallocation_behavior {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_AMD_memory_overallocation_behavior")?;
        }
        if self.amd_mixed_attachment_samples {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_AMD_mixed_attachment_samples")?;
        }
        if self.amd_pipeline_compiler_control {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_AMD_pipeline_compiler_control")?;
        }
        if self.amd_rasterization_order {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_AMD_rasterization_order")?;
        }
        if self.amd_shader_ballot {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_AMD_shader_ballot")?;
        }
        if self.amd_shader_core_properties {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_AMD_shader_core_properties")?;
        }
        if self.amd_shader_core_properties2 {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_AMD_shader_core_properties2")?;
        }
        if self.amd_shader_early_and_late_fragment_tests {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_AMD_shader_early_and_late_fragment_tests")?;
        }
        if self.amd_shader_explicit_vertex_parameter {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_AMD_shader_explicit_vertex_parameter")?;
        }
        if self.amd_shader_fragment_mask {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_AMD_shader_fragment_mask")?;
        }
        if self.amd_shader_image_load_store_lod {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_AMD_shader_image_load_store_lod")?;
        }
        if self.amd_shader_info {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_AMD_shader_info")?;
        }
        if self.amd_shader_trinary_minmax {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_AMD_shader_trinary_minmax")?;
        }
        if self.amd_texture_gather_bias_lod {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_AMD_texture_gather_bias_lod")?;
        }
        if self.android_external_format_resolve {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_ANDROID_external_format_resolve")?;
        }
        if self.android_external_memory_android_hardware_buffer {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_ANDROID_external_memory_android_hardware_buffer")?;
        }
        if self.arm_rasterization_order_attachment_access {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_ARM_rasterization_order_attachment_access")?;
        }
        if self.arm_render_pass_striped {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_ARM_render_pass_striped")?;
        }
        if self.arm_scheduling_controls {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_ARM_scheduling_controls")?;
        }
        if self.arm_shader_core_builtins {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_ARM_shader_core_builtins")?;
        }
        if self.arm_shader_core_properties {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_ARM_shader_core_properties")?;
        }
        if self.fuchsia_buffer_collection {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_FUCHSIA_buffer_collection")?;
        }
        if self.fuchsia_external_memory {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_FUCHSIA_external_memory")?;
        }
        if self.fuchsia_external_semaphore {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_FUCHSIA_external_semaphore")?;
        }
        if self.ggp_frame_token {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_GGP_frame_token")?;
        }
        if self.google_decorate_string {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_GOOGLE_decorate_string")?;
        }
        if self.google_display_timing {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_GOOGLE_display_timing")?;
        }
        if self.google_hlsl_functionality1 {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_GOOGLE_hlsl_functionality1")?;
        }
        if self.google_user_type {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_GOOGLE_user_type")?;
        }
        if self.huawei_cluster_culling_shader {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_HUAWEI_cluster_culling_shader")?;
        }
        if self.huawei_invocation_mask {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_HUAWEI_invocation_mask")?;
        }
        if self.huawei_subpass_shading {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_HUAWEI_subpass_shading")?;
        }
        if self.img_filter_cubic {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_IMG_filter_cubic")?;
        }
        if self.img_format_pvrtc {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_IMG_format_pvrtc")?;
        }
        if self.img_relaxed_line_rasterization {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_IMG_relaxed_line_rasterization")?;
        }
        if self.intel_performance_query {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_INTEL_performance_query")?;
        }
        if self.intel_shader_integer_functions2 {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_INTEL_shader_integer_functions2")?;
        }
        if self.msft_layered_driver {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_MSFT_layered_driver")?;
        }
        if self.nvx_binary_import {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_NVX_binary_import")?;
        }
        if self.nvx_image_view_handle {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_NVX_image_view_handle")?;
        }
        if self.nvx_multiview_per_view_attributes {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_NVX_multiview_per_view_attributes")?;
        }
        if self.nv_acquire_winrt_display {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_NV_acquire_winrt_display")?;
        }
        if self.nv_clip_space_w_scaling {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_NV_clip_space_w_scaling")?;
        }
        if self.nv_compute_shader_derivatives {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_NV_compute_shader_derivatives")?;
        }
        if self.nv_cooperative_matrix {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_NV_cooperative_matrix")?;
        }
        if self.nv_copy_memory_indirect {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_NV_copy_memory_indirect")?;
        }
        if self.nv_corner_sampled_image {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_NV_corner_sampled_image")?;
        }
        if self.nv_coverage_reduction_mode {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_NV_coverage_reduction_mode")?;
        }
        if self.nv_cuda_kernel_launch {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_NV_cuda_kernel_launch")?;
        }
        if self.nv_dedicated_allocation {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_NV_dedicated_allocation")?;
        }
        if self.nv_dedicated_allocation_image_aliasing {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_NV_dedicated_allocation_image_aliasing")?;
        }
        if self.nv_descriptor_pool_overallocation {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_NV_descriptor_pool_overallocation")?;
        }
        if self.nv_device_diagnostic_checkpoints {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_NV_device_diagnostic_checkpoints")?;
        }
        if self.nv_device_diagnostics_config {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_NV_device_diagnostics_config")?;
        }
        if self.nv_device_generated_commands {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_NV_device_generated_commands")?;
        }
        if self.nv_device_generated_commands_compute {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_NV_device_generated_commands_compute")?;
        }
        if self.nv_displacement_micromap {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_NV_displacement_micromap")?;
        }
        if self.nv_extended_sparse_address_space {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_NV_extended_sparse_address_space")?;
        }
        if self.nv_external_memory {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_NV_external_memory")?;
        }
        if self.nv_external_memory_rdma {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_NV_external_memory_rdma")?;
        }
        if self.nv_external_memory_win32 {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_NV_external_memory_win32")?;
        }
        if self.nv_fill_rectangle {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_NV_fill_rectangle")?;
        }
        if self.nv_fragment_coverage_to_color {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_NV_fragment_coverage_to_color")?;
        }
        if self.nv_fragment_shader_barycentric {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_NV_fragment_shader_barycentric")?;
        }
        if self.nv_fragment_shading_rate_enums {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_NV_fragment_shading_rate_enums")?;
        }
        if self.nv_framebuffer_mixed_samples {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_NV_framebuffer_mixed_samples")?;
        }
        if self.nv_geometry_shader_passthrough {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_NV_geometry_shader_passthrough")?;
        }
        if self.nv_glsl_shader {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_NV_glsl_shader")?;
        }
        if self.nv_inherited_viewport_scissor {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_NV_inherited_viewport_scissor")?;
        }
        if self.nv_linear_color_attachment {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_NV_linear_color_attachment")?;
        }
        if self.nv_low_latency {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_NV_low_latency")?;
        }
        if self.nv_low_latency2 {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_NV_low_latency2")?;
        }
        if self.nv_memory_decompression {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_NV_memory_decompression")?;
        }
        if self.nv_mesh_shader {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_NV_mesh_shader")?;
        }
        if self.nv_optical_flow {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_NV_optical_flow")?;
        }
        if self.nv_per_stage_descriptor_set {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_NV_per_stage_descriptor_set")?;
        }
        if self.nv_present_barrier {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_NV_present_barrier")?;
        }
        if self.nv_raw_access_chains {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_NV_raw_access_chains")?;
        }
        if self.nv_ray_tracing {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_NV_ray_tracing")?;
        }
        if self.nv_ray_tracing_invocation_reorder {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_NV_ray_tracing_invocation_reorder")?;
        }
        if self.nv_ray_tracing_motion_blur {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_NV_ray_tracing_motion_blur")?;
        }
        if self.nv_ray_tracing_validation {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_NV_ray_tracing_validation")?;
        }
        if self.nv_representative_fragment_test {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_NV_representative_fragment_test")?;
        }
        if self.nv_sample_mask_override_coverage {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_NV_sample_mask_override_coverage")?;
        }
        if self.nv_scissor_exclusive {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_NV_scissor_exclusive")?;
        }
        if self.nv_shader_atomic_float16_vector {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_NV_shader_atomic_float16_vector")?;
        }
        if self.nv_shader_image_footprint {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_NV_shader_image_footprint")?;
        }
        if self.nv_shader_sm_builtins {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_NV_shader_sm_builtins")?;
        }
        if self.nv_shader_subgroup_partitioned {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_NV_shader_subgroup_partitioned")?;
        }
        if self.nv_shading_rate_image {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_NV_shading_rate_image")?;
        }
        if self.nv_viewport_array2 {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_NV_viewport_array2")?;
        }
        if self.nv_viewport_swizzle {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_NV_viewport_swizzle")?;
        }
        if self.nv_win32_keyed_mutex {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_NV_win32_keyed_mutex")?;
        }
        if self.qcom_filter_cubic_clamp {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_QCOM_filter_cubic_clamp")?;
        }
        if self.qcom_filter_cubic_weights {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_QCOM_filter_cubic_weights")?;
        }
        if self.qcom_fragment_density_map_offset {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_QCOM_fragment_density_map_offset")?;
        }
        if self.qcom_image_processing {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_QCOM_image_processing")?;
        }
        if self.qcom_image_processing2 {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_QCOM_image_processing2")?;
        }
        if self.qcom_multiview_per_view_render_areas {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_QCOM_multiview_per_view_render_areas")?;
        }
        if self.qcom_multiview_per_view_viewports {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_QCOM_multiview_per_view_viewports")?;
        }
        if self.qcom_render_pass_shader_resolve {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_QCOM_render_pass_shader_resolve")?;
        }
        if self.qcom_render_pass_store_ops {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_QCOM_render_pass_store_ops")?;
        }
        if self.qcom_render_pass_transform {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_QCOM_render_pass_transform")?;
        }
        if self.qcom_rotated_copy_commands {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_QCOM_rotated_copy_commands")?;
        }
        if self.qcom_tile_properties {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_QCOM_tile_properties")?;
        }
        if self.qcom_ycbcr_degamma {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_QCOM_ycbcr_degamma")?;
        }
        if self.qnx_external_memory_screen_buffer {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_QNX_external_memory_screen_buffer")?;
        }
        if self.sec_amigo_profiling {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_SEC_amigo_profiling")?;
        }
        if self.valve_descriptor_set_host_mapping {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_VALVE_descriptor_set_host_mapping")?;
        }
        if self.valve_mutable_descriptor_type {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("VK_VALVE_mutable_descriptor_type")?;
        }
        write!(f, "]")
    }
}
impl<'a> FromIterator<&'a str> for DeviceExtensions {
    fn from_iter<I>(iter: I) -> Self
    where
        I: IntoIterator<Item = &'a str>,
    {
        let mut extensions = Self::empty();
        for name in iter {
            match name {
                "VK_KHR_16bit_storage" => {
                    extensions.khr_16bit_storage = true;
                }
                "VK_KHR_8bit_storage" => {
                    extensions.khr_8bit_storage = true;
                }
                "VK_KHR_acceleration_structure" => {
                    extensions.khr_acceleration_structure = true;
                }
                "VK_KHR_bind_memory2" => {
                    extensions.khr_bind_memory2 = true;
                }
                "VK_KHR_buffer_device_address" => {
                    extensions.khr_buffer_device_address = true;
                }
                "VK_KHR_calibrated_timestamps" => {
                    extensions.khr_calibrated_timestamps = true;
                }
                "VK_KHR_cooperative_matrix" => {
                    extensions.khr_cooperative_matrix = true;
                }
                "VK_KHR_copy_commands2" => {
                    extensions.khr_copy_commands2 = true;
                }
                "VK_KHR_create_renderpass2" => {
                    extensions.khr_create_renderpass2 = true;
                }
                "VK_KHR_dedicated_allocation" => {
                    extensions.khr_dedicated_allocation = true;
                }
                "VK_KHR_deferred_host_operations" => {
                    extensions.khr_deferred_host_operations = true;
                }
                "VK_KHR_depth_stencil_resolve" => {
                    extensions.khr_depth_stencil_resolve = true;
                }
                "VK_KHR_descriptor_update_template" => {
                    extensions.khr_descriptor_update_template = true;
                }
                "VK_KHR_device_group" => {
                    extensions.khr_device_group = true;
                }
                "VK_KHR_display_swapchain" => {
                    extensions.khr_display_swapchain = true;
                }
                "VK_KHR_draw_indirect_count" => {
                    extensions.khr_draw_indirect_count = true;
                }
                "VK_KHR_driver_properties" => {
                    extensions.khr_driver_properties = true;
                }
                "VK_KHR_dynamic_rendering" => {
                    extensions.khr_dynamic_rendering = true;
                }
                "VK_KHR_dynamic_rendering_local_read" => {
                    extensions.khr_dynamic_rendering_local_read = true;
                }
                "VK_KHR_external_fence" => {
                    extensions.khr_external_fence = true;
                }
                "VK_KHR_external_fence_fd" => {
                    extensions.khr_external_fence_fd = true;
                }
                "VK_KHR_external_fence_win32" => {
                    extensions.khr_external_fence_win32 = true;
                }
                "VK_KHR_external_memory" => {
                    extensions.khr_external_memory = true;
                }
                "VK_KHR_external_memory_fd" => {
                    extensions.khr_external_memory_fd = true;
                }
                "VK_KHR_external_memory_win32" => {
                    extensions.khr_external_memory_win32 = true;
                }
                "VK_KHR_external_semaphore" => {
                    extensions.khr_external_semaphore = true;
                }
                "VK_KHR_external_semaphore_fd" => {
                    extensions.khr_external_semaphore_fd = true;
                }
                "VK_KHR_external_semaphore_win32" => {
                    extensions.khr_external_semaphore_win32 = true;
                }
                "VK_KHR_format_feature_flags2" => {
                    extensions.khr_format_feature_flags2 = true;
                }
                "VK_KHR_fragment_shader_barycentric" => {
                    extensions.khr_fragment_shader_barycentric = true;
                }
                "VK_KHR_fragment_shading_rate" => {
                    extensions.khr_fragment_shading_rate = true;
                }
                "VK_KHR_get_memory_requirements2" => {
                    extensions.khr_get_memory_requirements2 = true;
                }
                "VK_KHR_global_priority" => {
                    extensions.khr_global_priority = true;
                }
                "VK_KHR_image_format_list" => {
                    extensions.khr_image_format_list = true;
                }
                "VK_KHR_imageless_framebuffer" => {
                    extensions.khr_imageless_framebuffer = true;
                }
                "VK_KHR_incremental_present" => {
                    extensions.khr_incremental_present = true;
                }
                "VK_KHR_index_type_uint8" => {
                    extensions.khr_index_type_uint8 = true;
                }
                "VK_KHR_line_rasterization" => {
                    extensions.khr_line_rasterization = true;
                }
                "VK_KHR_load_store_op_none" => {
                    extensions.khr_load_store_op_none = true;
                }
                "VK_KHR_maintenance1" => {
                    extensions.khr_maintenance1 = true;
                }
                "VK_KHR_maintenance2" => {
                    extensions.khr_maintenance2 = true;
                }
                "VK_KHR_maintenance3" => {
                    extensions.khr_maintenance3 = true;
                }
                "VK_KHR_maintenance4" => {
                    extensions.khr_maintenance4 = true;
                }
                "VK_KHR_maintenance5" => {
                    extensions.khr_maintenance5 = true;
                }
                "VK_KHR_maintenance6" => {
                    extensions.khr_maintenance6 = true;
                }
                "VK_KHR_map_memory2" => {
                    extensions.khr_map_memory2 = true;
                }
                "VK_KHR_multiview" => {
                    extensions.khr_multiview = true;
                }
                "VK_KHR_performance_query" => {
                    extensions.khr_performance_query = true;
                }
                "VK_KHR_pipeline_executable_properties" => {
                    extensions.khr_pipeline_executable_properties = true;
                }
                "VK_KHR_pipeline_library" => {
                    extensions.khr_pipeline_library = true;
                }
                "VK_KHR_portability_subset" => {
                    extensions.khr_portability_subset = true;
                }
                "VK_KHR_present_id" => {
                    extensions.khr_present_id = true;
                }
                "VK_KHR_present_wait" => {
                    extensions.khr_present_wait = true;
                }
                "VK_KHR_push_descriptor" => {
                    extensions.khr_push_descriptor = true;
                }
                "VK_KHR_ray_query" => {
                    extensions.khr_ray_query = true;
                }
                "VK_KHR_ray_tracing_maintenance1" => {
                    extensions.khr_ray_tracing_maintenance1 = true;
                }
                "VK_KHR_ray_tracing_pipeline" => {
                    extensions.khr_ray_tracing_pipeline = true;
                }
                "VK_KHR_ray_tracing_position_fetch" => {
                    extensions.khr_ray_tracing_position_fetch = true;
                }
                "VK_KHR_relaxed_block_layout" => {
                    extensions.khr_relaxed_block_layout = true;
                }
                "VK_KHR_sampler_mirror_clamp_to_edge" => {
                    extensions.khr_sampler_mirror_clamp_to_edge = true;
                }
                "VK_KHR_sampler_ycbcr_conversion" => {
                    extensions.khr_sampler_ycbcr_conversion = true;
                }
                "VK_KHR_separate_depth_stencil_layouts" => {
                    extensions.khr_separate_depth_stencil_layouts = true;
                }
                "VK_KHR_shader_atomic_int64" => {
                    extensions.khr_shader_atomic_int64 = true;
                }
                "VK_KHR_shader_clock" => {
                    extensions.khr_shader_clock = true;
                }
                "VK_KHR_shader_draw_parameters" => {
                    extensions.khr_shader_draw_parameters = true;
                }
                "VK_KHR_shader_expect_assume" => {
                    extensions.khr_shader_expect_assume = true;
                }
                "VK_KHR_shader_float16_int8" => {
                    extensions.khr_shader_float16_int8 = true;
                }
                "VK_KHR_shader_float_controls" => {
                    extensions.khr_shader_float_controls = true;
                }
                "VK_KHR_shader_float_controls2" => {
                    extensions.khr_shader_float_controls2 = true;
                }
                "VK_KHR_shader_integer_dot_product" => {
                    extensions.khr_shader_integer_dot_product = true;
                }
                "VK_KHR_shader_maximal_reconvergence" => {
                    extensions.khr_shader_maximal_reconvergence = true;
                }
                "VK_KHR_shader_non_semantic_info" => {
                    extensions.khr_shader_non_semantic_info = true;
                }
                "VK_KHR_shader_quad_control" => {
                    extensions.khr_shader_quad_control = true;
                }
                "VK_KHR_shader_subgroup_extended_types" => {
                    extensions.khr_shader_subgroup_extended_types = true;
                }
                "VK_KHR_shader_subgroup_rotate" => {
                    extensions.khr_shader_subgroup_rotate = true;
                }
                "VK_KHR_shader_subgroup_uniform_control_flow" => {
                    extensions.khr_shader_subgroup_uniform_control_flow = true;
                }
                "VK_KHR_shader_terminate_invocation" => {
                    extensions.khr_shader_terminate_invocation = true;
                }
                "VK_KHR_shared_presentable_image" => {
                    extensions.khr_shared_presentable_image = true;
                }
                "VK_KHR_spirv_1_4" => {
                    extensions.khr_spirv_1_4 = true;
                }
                "VK_KHR_storage_buffer_storage_class" => {
                    extensions.khr_storage_buffer_storage_class = true;
                }
                "VK_KHR_swapchain" => {
                    extensions.khr_swapchain = true;
                }
                "VK_KHR_swapchain_mutable_format" => {
                    extensions.khr_swapchain_mutable_format = true;
                }
                "VK_KHR_synchronization2" => {
                    extensions.khr_synchronization2 = true;
                }
                "VK_KHR_timeline_semaphore" => {
                    extensions.khr_timeline_semaphore = true;
                }
                "VK_KHR_uniform_buffer_standard_layout" => {
                    extensions.khr_uniform_buffer_standard_layout = true;
                }
                "VK_KHR_variable_pointers" => {
                    extensions.khr_variable_pointers = true;
                }
                "VK_KHR_vertex_attribute_divisor" => {
                    extensions.khr_vertex_attribute_divisor = true;
                }
                "VK_KHR_video_decode_av1" => {
                    extensions.khr_video_decode_av1 = true;
                }
                "VK_KHR_video_decode_h264" => {
                    extensions.khr_video_decode_h264 = true;
                }
                "VK_KHR_video_decode_h265" => {
                    extensions.khr_video_decode_h265 = true;
                }
                "VK_KHR_video_decode_queue" => {
                    extensions.khr_video_decode_queue = true;
                }
                "VK_KHR_video_encode_h264" => {
                    extensions.khr_video_encode_h264 = true;
                }
                "VK_KHR_video_encode_h265" => {
                    extensions.khr_video_encode_h265 = true;
                }
                "VK_KHR_video_encode_queue" => {
                    extensions.khr_video_encode_queue = true;
                }
                "VK_KHR_video_maintenance1" => {
                    extensions.khr_video_maintenance1 = true;
                }
                "VK_KHR_video_queue" => {
                    extensions.khr_video_queue = true;
                }
                "VK_KHR_vulkan_memory_model" => {
                    extensions.khr_vulkan_memory_model = true;
                }
                "VK_KHR_win32_keyed_mutex" => {
                    extensions.khr_win32_keyed_mutex = true;
                }
                "VK_KHR_workgroup_memory_explicit_layout" => {
                    extensions.khr_workgroup_memory_explicit_layout = true;
                }
                "VK_KHR_zero_initialize_workgroup_memory" => {
                    extensions.khr_zero_initialize_workgroup_memory = true;
                }
                "VK_EXT_4444_formats" => {
                    extensions.ext_4444_formats = true;
                }
                "VK_EXT_astc_decode_mode" => {
                    extensions.ext_astc_decode_mode = true;
                }
                "VK_EXT_attachment_feedback_loop_dynamic_state" => {
                    extensions.ext_attachment_feedback_loop_dynamic_state = true;
                }
                "VK_EXT_attachment_feedback_loop_layout" => {
                    extensions.ext_attachment_feedback_loop_layout = true;
                }
                "VK_EXT_blend_operation_advanced" => {
                    extensions.ext_blend_operation_advanced = true;
                }
                "VK_EXT_border_color_swizzle" => {
                    extensions.ext_border_color_swizzle = true;
                }
                "VK_EXT_buffer_device_address" => {
                    extensions.ext_buffer_device_address = true;
                }
                "VK_EXT_calibrated_timestamps" => {
                    extensions.ext_calibrated_timestamps = true;
                }
                "VK_EXT_color_write_enable" => {
                    extensions.ext_color_write_enable = true;
                }
                "VK_EXT_conditional_rendering" => {
                    extensions.ext_conditional_rendering = true;
                }
                "VK_EXT_conservative_rasterization" => {
                    extensions.ext_conservative_rasterization = true;
                }
                "VK_EXT_custom_border_color" => {
                    extensions.ext_custom_border_color = true;
                }
                "VK_EXT_debug_marker" => {
                    extensions.ext_debug_marker = true;
                }
                "VK_EXT_depth_bias_control" => {
                    extensions.ext_depth_bias_control = true;
                }
                "VK_EXT_depth_clamp_zero_one" => {
                    extensions.ext_depth_clamp_zero_one = true;
                }
                "VK_EXT_depth_clip_control" => {
                    extensions.ext_depth_clip_control = true;
                }
                "VK_EXT_depth_clip_enable" => {
                    extensions.ext_depth_clip_enable = true;
                }
                "VK_EXT_depth_range_unrestricted" => {
                    extensions.ext_depth_range_unrestricted = true;
                }
                "VK_EXT_descriptor_buffer" => {
                    extensions.ext_descriptor_buffer = true;
                }
                "VK_EXT_descriptor_indexing" => {
                    extensions.ext_descriptor_indexing = true;
                }
                "VK_EXT_device_address_binding_report" => {
                    extensions.ext_device_address_binding_report = true;
                }
                "VK_EXT_device_fault" => {
                    extensions.ext_device_fault = true;
                }
                "VK_EXT_device_memory_report" => {
                    extensions.ext_device_memory_report = true;
                }
                "VK_EXT_discard_rectangles" => {
                    extensions.ext_discard_rectangles = true;
                }
                "VK_EXT_display_control" => {
                    extensions.ext_display_control = true;
                }
                "VK_EXT_dynamic_rendering_unused_attachments" => {
                    extensions.ext_dynamic_rendering_unused_attachments = true;
                }
                "VK_EXT_extended_dynamic_state" => {
                    extensions.ext_extended_dynamic_state = true;
                }
                "VK_EXT_extended_dynamic_state2" => {
                    extensions.ext_extended_dynamic_state2 = true;
                }
                "VK_EXT_extended_dynamic_state3" => {
                    extensions.ext_extended_dynamic_state3 = true;
                }
                "VK_EXT_external_memory_acquire_unmodified" => {
                    extensions.ext_external_memory_acquire_unmodified = true;
                }
                "VK_EXT_external_memory_dma_buf" => {
                    extensions.ext_external_memory_dma_buf = true;
                }
                "VK_EXT_external_memory_host" => {
                    extensions.ext_external_memory_host = true;
                }
                "VK_EXT_filter_cubic" => {
                    extensions.ext_filter_cubic = true;
                }
                "VK_EXT_fragment_density_map" => {
                    extensions.ext_fragment_density_map = true;
                }
                "VK_EXT_fragment_density_map2" => {
                    extensions.ext_fragment_density_map2 = true;
                }
                "VK_EXT_fragment_shader_interlock" => {
                    extensions.ext_fragment_shader_interlock = true;
                }
                "VK_EXT_frame_boundary" => {
                    extensions.ext_frame_boundary = true;
                }
                "VK_EXT_full_screen_exclusive" => {
                    extensions.ext_full_screen_exclusive = true;
                }
                "VK_EXT_global_priority" => {
                    extensions.ext_global_priority = true;
                }
                "VK_EXT_global_priority_query" => {
                    extensions.ext_global_priority_query = true;
                }
                "VK_EXT_graphics_pipeline_library" => {
                    extensions.ext_graphics_pipeline_library = true;
                }
                "VK_EXT_hdr_metadata" => {
                    extensions.ext_hdr_metadata = true;
                }
                "VK_EXT_host_image_copy" => {
                    extensions.ext_host_image_copy = true;
                }
                "VK_EXT_host_query_reset" => {
                    extensions.ext_host_query_reset = true;
                }
                "VK_EXT_image_2d_view_of_3d" => {
                    extensions.ext_image_2d_view_of_3d = true;
                }
                "VK_EXT_image_compression_control" => {
                    extensions.ext_image_compression_control = true;
                }
                "VK_EXT_image_compression_control_swapchain" => {
                    extensions.ext_image_compression_control_swapchain = true;
                }
                "VK_EXT_image_drm_format_modifier" => {
                    extensions.ext_image_drm_format_modifier = true;
                }
                "VK_EXT_image_robustness" => {
                    extensions.ext_image_robustness = true;
                }
                "VK_EXT_image_sliced_view_of_3d" => {
                    extensions.ext_image_sliced_view_of_3d = true;
                }
                "VK_EXT_image_view_min_lod" => {
                    extensions.ext_image_view_min_lod = true;
                }
                "VK_EXT_index_type_uint8" => {
                    extensions.ext_index_type_uint8 = true;
                }
                "VK_EXT_inline_uniform_block" => {
                    extensions.ext_inline_uniform_block = true;
                }
                "VK_EXT_legacy_dithering" => {
                    extensions.ext_legacy_dithering = true;
                }
                "VK_EXT_line_rasterization" => {
                    extensions.ext_line_rasterization = true;
                }
                "VK_EXT_load_store_op_none" => {
                    extensions.ext_load_store_op_none = true;
                }
                "VK_EXT_map_memory_placed" => {
                    extensions.ext_map_memory_placed = true;
                }
                "VK_EXT_memory_budget" => {
                    extensions.ext_memory_budget = true;
                }
                "VK_EXT_memory_priority" => {
                    extensions.ext_memory_priority = true;
                }
                "VK_EXT_mesh_shader" => {
                    extensions.ext_mesh_shader = true;
                }
                "VK_EXT_metal_objects" => {
                    extensions.ext_metal_objects = true;
                }
                "VK_EXT_multi_draw" => {
                    extensions.ext_multi_draw = true;
                }
                "VK_EXT_multisampled_render_to_single_sampled" => {
                    extensions.ext_multisampled_render_to_single_sampled = true;
                }
                "VK_EXT_mutable_descriptor_type" => {
                    extensions.ext_mutable_descriptor_type = true;
                }
                "VK_EXT_nested_command_buffer" => {
                    extensions.ext_nested_command_buffer = true;
                }
                "VK_EXT_non_seamless_cube_map" => {
                    extensions.ext_non_seamless_cube_map = true;
                }
                "VK_EXT_opacity_micromap" => {
                    extensions.ext_opacity_micromap = true;
                }
                "VK_EXT_pageable_device_local_memory" => {
                    extensions.ext_pageable_device_local_memory = true;
                }
                "VK_EXT_pci_bus_info" => {
                    extensions.ext_pci_bus_info = true;
                }
                "VK_EXT_physical_device_drm" => {
                    extensions.ext_physical_device_drm = true;
                }
                "VK_EXT_pipeline_creation_cache_control" => {
                    extensions.ext_pipeline_creation_cache_control = true;
                }
                "VK_EXT_pipeline_creation_feedback" => {
                    extensions.ext_pipeline_creation_feedback = true;
                }
                "VK_EXT_pipeline_library_group_handles" => {
                    extensions.ext_pipeline_library_group_handles = true;
                }
                "VK_EXT_pipeline_properties" => {
                    extensions.ext_pipeline_properties = true;
                }
                "VK_EXT_pipeline_protected_access" => {
                    extensions.ext_pipeline_protected_access = true;
                }
                "VK_EXT_pipeline_robustness" => {
                    extensions.ext_pipeline_robustness = true;
                }
                "VK_EXT_post_depth_coverage" => {
                    extensions.ext_post_depth_coverage = true;
                }
                "VK_EXT_primitive_topology_list_restart" => {
                    extensions.ext_primitive_topology_list_restart = true;
                }
                "VK_EXT_primitives_generated_query" => {
                    extensions.ext_primitives_generated_query = true;
                }
                "VK_EXT_private_data" => {
                    extensions.ext_private_data = true;
                }
                "VK_EXT_provoking_vertex" => {
                    extensions.ext_provoking_vertex = true;
                }
                "VK_EXT_queue_family_foreign" => {
                    extensions.ext_queue_family_foreign = true;
                }
                "VK_EXT_rasterization_order_attachment_access" => {
                    extensions.ext_rasterization_order_attachment_access = true;
                }
                "VK_EXT_rgba10x6_formats" => {
                    extensions.ext_rgba10x6_formats = true;
                }
                "VK_EXT_robustness2" => {
                    extensions.ext_robustness2 = true;
                }
                "VK_EXT_sample_locations" => {
                    extensions.ext_sample_locations = true;
                }
                "VK_EXT_sampler_filter_minmax" => {
                    extensions.ext_sampler_filter_minmax = true;
                }
                "VK_EXT_scalar_block_layout" => {
                    extensions.ext_scalar_block_layout = true;
                }
                "VK_EXT_separate_stencil_usage" => {
                    extensions.ext_separate_stencil_usage = true;
                }
                "VK_EXT_shader_atomic_float" => {
                    extensions.ext_shader_atomic_float = true;
                }
                "VK_EXT_shader_atomic_float2" => {
                    extensions.ext_shader_atomic_float2 = true;
                }
                "VK_EXT_shader_demote_to_helper_invocation" => {
                    extensions.ext_shader_demote_to_helper_invocation = true;
                }
                "VK_EXT_shader_image_atomic_int64" => {
                    extensions.ext_shader_image_atomic_int64 = true;
                }
                "VK_EXT_shader_module_identifier" => {
                    extensions.ext_shader_module_identifier = true;
                }
                "VK_EXT_shader_object" => {
                    extensions.ext_shader_object = true;
                }
                "VK_EXT_shader_stencil_export" => {
                    extensions.ext_shader_stencil_export = true;
                }
                "VK_EXT_shader_subgroup_ballot" => {
                    extensions.ext_shader_subgroup_ballot = true;
                }
                "VK_EXT_shader_subgroup_vote" => {
                    extensions.ext_shader_subgroup_vote = true;
                }
                "VK_EXT_shader_tile_image" => {
                    extensions.ext_shader_tile_image = true;
                }
                "VK_EXT_shader_viewport_index_layer" => {
                    extensions.ext_shader_viewport_index_layer = true;
                }
                "VK_EXT_subgroup_size_control" => {
                    extensions.ext_subgroup_size_control = true;
                }
                "VK_EXT_subpass_merge_feedback" => {
                    extensions.ext_subpass_merge_feedback = true;
                }
                "VK_EXT_swapchain_maintenance1" => {
                    extensions.ext_swapchain_maintenance1 = true;
                }
                "VK_EXT_texel_buffer_alignment" => {
                    extensions.ext_texel_buffer_alignment = true;
                }
                "VK_EXT_texture_compression_astc_hdr" => {
                    extensions.ext_texture_compression_astc_hdr = true;
                }
                "VK_EXT_tooling_info" => {
                    extensions.ext_tooling_info = true;
                }
                "VK_EXT_transform_feedback" => {
                    extensions.ext_transform_feedback = true;
                }
                "VK_EXT_validation_cache" => {
                    extensions.ext_validation_cache = true;
                }
                "VK_EXT_vertex_attribute_divisor" => {
                    extensions.ext_vertex_attribute_divisor = true;
                }
                "VK_EXT_vertex_input_dynamic_state" => {
                    extensions.ext_vertex_input_dynamic_state = true;
                }
                "VK_EXT_ycbcr_2plane_444_formats" => {
                    extensions.ext_ycbcr_2plane_444_formats = true;
                }
                "VK_EXT_ycbcr_image_arrays" => {
                    extensions.ext_ycbcr_image_arrays = true;
                }
                "VK_AMDX_shader_enqueue" => {
                    extensions.amdx_shader_enqueue = true;
                }
                "VK_AMD_buffer_marker" => {
                    extensions.amd_buffer_marker = true;
                }
                "VK_AMD_device_coherent_memory" => {
                    extensions.amd_device_coherent_memory = true;
                }
                "VK_AMD_display_native_hdr" => {
                    extensions.amd_display_native_hdr = true;
                }
                "VK_AMD_draw_indirect_count" => {
                    extensions.amd_draw_indirect_count = true;
                }
                "VK_AMD_gcn_shader" => {
                    extensions.amd_gcn_shader = true;
                }
                "VK_AMD_gpu_shader_half_float" => {
                    extensions.amd_gpu_shader_half_float = true;
                }
                "VK_AMD_gpu_shader_int16" => {
                    extensions.amd_gpu_shader_int16 = true;
                }
                "VK_AMD_memory_overallocation_behavior" => {
                    extensions.amd_memory_overallocation_behavior = true;
                }
                "VK_AMD_mixed_attachment_samples" => {
                    extensions.amd_mixed_attachment_samples = true;
                }
                "VK_AMD_pipeline_compiler_control" => {
                    extensions.amd_pipeline_compiler_control = true;
                }
                "VK_AMD_rasterization_order" => {
                    extensions.amd_rasterization_order = true;
                }
                "VK_AMD_shader_ballot" => {
                    extensions.amd_shader_ballot = true;
                }
                "VK_AMD_shader_core_properties" => {
                    extensions.amd_shader_core_properties = true;
                }
                "VK_AMD_shader_core_properties2" => {
                    extensions.amd_shader_core_properties2 = true;
                }
                "VK_AMD_shader_early_and_late_fragment_tests" => {
                    extensions.amd_shader_early_and_late_fragment_tests = true;
                }
                "VK_AMD_shader_explicit_vertex_parameter" => {
                    extensions.amd_shader_explicit_vertex_parameter = true;
                }
                "VK_AMD_shader_fragment_mask" => {
                    extensions.amd_shader_fragment_mask = true;
                }
                "VK_AMD_shader_image_load_store_lod" => {
                    extensions.amd_shader_image_load_store_lod = true;
                }
                "VK_AMD_shader_info" => {
                    extensions.amd_shader_info = true;
                }
                "VK_AMD_shader_trinary_minmax" => {
                    extensions.amd_shader_trinary_minmax = true;
                }
                "VK_AMD_texture_gather_bias_lod" => {
                    extensions.amd_texture_gather_bias_lod = true;
                }
                "VK_ANDROID_external_format_resolve" => {
                    extensions.android_external_format_resolve = true;
                }
                "VK_ANDROID_external_memory_android_hardware_buffer" => {
                    extensions.android_external_memory_android_hardware_buffer = true;
                }
                "VK_ARM_rasterization_order_attachment_access" => {
                    extensions.arm_rasterization_order_attachment_access = true;
                }
                "VK_ARM_render_pass_striped" => {
                    extensions.arm_render_pass_striped = true;
                }
                "VK_ARM_scheduling_controls" => {
                    extensions.arm_scheduling_controls = true;
                }
                "VK_ARM_shader_core_builtins" => {
                    extensions.arm_shader_core_builtins = true;
                }
                "VK_ARM_shader_core_properties" => {
                    extensions.arm_shader_core_properties = true;
                }
                "VK_FUCHSIA_buffer_collection" => {
                    extensions.fuchsia_buffer_collection = true;
                }
                "VK_FUCHSIA_external_memory" => {
                    extensions.fuchsia_external_memory = true;
                }
                "VK_FUCHSIA_external_semaphore" => {
                    extensions.fuchsia_external_semaphore = true;
                }
                "VK_GGP_frame_token" => {
                    extensions.ggp_frame_token = true;
                }
                "VK_GOOGLE_decorate_string" => {
                    extensions.google_decorate_string = true;
                }
                "VK_GOOGLE_display_timing" => {
                    extensions.google_display_timing = true;
                }
                "VK_GOOGLE_hlsl_functionality1" => {
                    extensions.google_hlsl_functionality1 = true;
                }
                "VK_GOOGLE_user_type" => {
                    extensions.google_user_type = true;
                }
                "VK_HUAWEI_cluster_culling_shader" => {
                    extensions.huawei_cluster_culling_shader = true;
                }
                "VK_HUAWEI_invocation_mask" => {
                    extensions.huawei_invocation_mask = true;
                }
                "VK_HUAWEI_subpass_shading" => {
                    extensions.huawei_subpass_shading = true;
                }
                "VK_IMG_filter_cubic" => {
                    extensions.img_filter_cubic = true;
                }
                "VK_IMG_format_pvrtc" => {
                    extensions.img_format_pvrtc = true;
                }
                "VK_IMG_relaxed_line_rasterization" => {
                    extensions.img_relaxed_line_rasterization = true;
                }
                "VK_INTEL_performance_query" => {
                    extensions.intel_performance_query = true;
                }
                "VK_INTEL_shader_integer_functions2" => {
                    extensions.intel_shader_integer_functions2 = true;
                }
                "VK_MSFT_layered_driver" => {
                    extensions.msft_layered_driver = true;
                }
                "VK_NVX_binary_import" => {
                    extensions.nvx_binary_import = true;
                }
                "VK_NVX_image_view_handle" => {
                    extensions.nvx_image_view_handle = true;
                }
                "VK_NVX_multiview_per_view_attributes" => {
                    extensions.nvx_multiview_per_view_attributes = true;
                }
                "VK_NV_acquire_winrt_display" => {
                    extensions.nv_acquire_winrt_display = true;
                }
                "VK_NV_clip_space_w_scaling" => {
                    extensions.nv_clip_space_w_scaling = true;
                }
                "VK_NV_compute_shader_derivatives" => {
                    extensions.nv_compute_shader_derivatives = true;
                }
                "VK_NV_cooperative_matrix" => {
                    extensions.nv_cooperative_matrix = true;
                }
                "VK_NV_copy_memory_indirect" => {
                    extensions.nv_copy_memory_indirect = true;
                }
                "VK_NV_corner_sampled_image" => {
                    extensions.nv_corner_sampled_image = true;
                }
                "VK_NV_coverage_reduction_mode" => {
                    extensions.nv_coverage_reduction_mode = true;
                }
                "VK_NV_cuda_kernel_launch" => {
                    extensions.nv_cuda_kernel_launch = true;
                }
                "VK_NV_dedicated_allocation" => {
                    extensions.nv_dedicated_allocation = true;
                }
                "VK_NV_dedicated_allocation_image_aliasing" => {
                    extensions.nv_dedicated_allocation_image_aliasing = true;
                }
                "VK_NV_descriptor_pool_overallocation" => {
                    extensions.nv_descriptor_pool_overallocation = true;
                }
                "VK_NV_device_diagnostic_checkpoints" => {
                    extensions.nv_device_diagnostic_checkpoints = true;
                }
                "VK_NV_device_diagnostics_config" => {
                    extensions.nv_device_diagnostics_config = true;
                }
                "VK_NV_device_generated_commands" => {
                    extensions.nv_device_generated_commands = true;
                }
                "VK_NV_device_generated_commands_compute" => {
                    extensions.nv_device_generated_commands_compute = true;
                }
                "VK_NV_displacement_micromap" => {
                    extensions.nv_displacement_micromap = true;
                }
                "VK_NV_extended_sparse_address_space" => {
                    extensions.nv_extended_sparse_address_space = true;
                }
                "VK_NV_external_memory" => {
                    extensions.nv_external_memory = true;
                }
                "VK_NV_external_memory_rdma" => {
                    extensions.nv_external_memory_rdma = true;
                }
                "VK_NV_external_memory_win32" => {
                    extensions.nv_external_memory_win32 = true;
                }
                "VK_NV_fill_rectangle" => {
                    extensions.nv_fill_rectangle = true;
                }
                "VK_NV_fragment_coverage_to_color" => {
                    extensions.nv_fragment_coverage_to_color = true;
                }
                "VK_NV_fragment_shader_barycentric" => {
                    extensions.nv_fragment_shader_barycentric = true;
                }
                "VK_NV_fragment_shading_rate_enums" => {
                    extensions.nv_fragment_shading_rate_enums = true;
                }
                "VK_NV_framebuffer_mixed_samples" => {
                    extensions.nv_framebuffer_mixed_samples = true;
                }
                "VK_NV_geometry_shader_passthrough" => {
                    extensions.nv_geometry_shader_passthrough = true;
                }
                "VK_NV_glsl_shader" => {
                    extensions.nv_glsl_shader = true;
                }
                "VK_NV_inherited_viewport_scissor" => {
                    extensions.nv_inherited_viewport_scissor = true;
                }
                "VK_NV_linear_color_attachment" => {
                    extensions.nv_linear_color_attachment = true;
                }
                "VK_NV_low_latency" => {
                    extensions.nv_low_latency = true;
                }
                "VK_NV_low_latency2" => {
                    extensions.nv_low_latency2 = true;
                }
                "VK_NV_memory_decompression" => {
                    extensions.nv_memory_decompression = true;
                }
                "VK_NV_mesh_shader" => {
                    extensions.nv_mesh_shader = true;
                }
                "VK_NV_optical_flow" => {
                    extensions.nv_optical_flow = true;
                }
                "VK_NV_per_stage_descriptor_set" => {
                    extensions.nv_per_stage_descriptor_set = true;
                }
                "VK_NV_present_barrier" => {
                    extensions.nv_present_barrier = true;
                }
                "VK_NV_raw_access_chains" => {
                    extensions.nv_raw_access_chains = true;
                }
                "VK_NV_ray_tracing" => {
                    extensions.nv_ray_tracing = true;
                }
                "VK_NV_ray_tracing_invocation_reorder" => {
                    extensions.nv_ray_tracing_invocation_reorder = true;
                }
                "VK_NV_ray_tracing_motion_blur" => {
                    extensions.nv_ray_tracing_motion_blur = true;
                }
                "VK_NV_ray_tracing_validation" => {
                    extensions.nv_ray_tracing_validation = true;
                }
                "VK_NV_representative_fragment_test" => {
                    extensions.nv_representative_fragment_test = true;
                }
                "VK_NV_sample_mask_override_coverage" => {
                    extensions.nv_sample_mask_override_coverage = true;
                }
                "VK_NV_scissor_exclusive" => {
                    extensions.nv_scissor_exclusive = true;
                }
                "VK_NV_shader_atomic_float16_vector" => {
                    extensions.nv_shader_atomic_float16_vector = true;
                }
                "VK_NV_shader_image_footprint" => {
                    extensions.nv_shader_image_footprint = true;
                }
                "VK_NV_shader_sm_builtins" => {
                    extensions.nv_shader_sm_builtins = true;
                }
                "VK_NV_shader_subgroup_partitioned" => {
                    extensions.nv_shader_subgroup_partitioned = true;
                }
                "VK_NV_shading_rate_image" => {
                    extensions.nv_shading_rate_image = true;
                }
                "VK_NV_viewport_array2" => {
                    extensions.nv_viewport_array2 = true;
                }
                "VK_NV_viewport_swizzle" => {
                    extensions.nv_viewport_swizzle = true;
                }
                "VK_NV_win32_keyed_mutex" => {
                    extensions.nv_win32_keyed_mutex = true;
                }
                "VK_QCOM_filter_cubic_clamp" => {
                    extensions.qcom_filter_cubic_clamp = true;
                }
                "VK_QCOM_filter_cubic_weights" => {
                    extensions.qcom_filter_cubic_weights = true;
                }
                "VK_QCOM_fragment_density_map_offset" => {
                    extensions.qcom_fragment_density_map_offset = true;
                }
                "VK_QCOM_image_processing" => {
                    extensions.qcom_image_processing = true;
                }
                "VK_QCOM_image_processing2" => {
                    extensions.qcom_image_processing2 = true;
                }
                "VK_QCOM_multiview_per_view_render_areas" => {
                    extensions.qcom_multiview_per_view_render_areas = true;
                }
                "VK_QCOM_multiview_per_view_viewports" => {
                    extensions.qcom_multiview_per_view_viewports = true;
                }
                "VK_QCOM_render_pass_shader_resolve" => {
                    extensions.qcom_render_pass_shader_resolve = true;
                }
                "VK_QCOM_render_pass_store_ops" => {
                    extensions.qcom_render_pass_store_ops = true;
                }
                "VK_QCOM_render_pass_transform" => {
                    extensions.qcom_render_pass_transform = true;
                }
                "VK_QCOM_rotated_copy_commands" => {
                    extensions.qcom_rotated_copy_commands = true;
                }
                "VK_QCOM_tile_properties" => {
                    extensions.qcom_tile_properties = true;
                }
                "VK_QCOM_ycbcr_degamma" => {
                    extensions.qcom_ycbcr_degamma = true;
                }
                "VK_QNX_external_memory_screen_buffer" => {
                    extensions.qnx_external_memory_screen_buffer = true;
                }
                "VK_SEC_amigo_profiling" => {
                    extensions.sec_amigo_profiling = true;
                }
                "VK_VALVE_descriptor_set_host_mapping" => {
                    extensions.valve_descriptor_set_host_mapping = true;
                }
                "VK_VALVE_mutable_descriptor_type" => {
                    extensions.valve_mutable_descriptor_type = true;
                }
                _ => {}
            }
        }
        extensions
    }
}
impl<'a> From<&'a DeviceExtensions> for Vec<std::ffi::CString> {
    fn from(x: &'a DeviceExtensions) -> Self {
        let mut data = Self::new();
        if x.khr_16bit_storage {
            data.push(std::ffi::CString::new("VK_KHR_16bit_storage").unwrap());
        }
        if x.khr_8bit_storage {
            data.push(std::ffi::CString::new("VK_KHR_8bit_storage").unwrap());
        }
        if x.khr_acceleration_structure {
            data.push(std::ffi::CString::new("VK_KHR_acceleration_structure").unwrap());
        }
        if x.khr_bind_memory2 {
            data.push(std::ffi::CString::new("VK_KHR_bind_memory2").unwrap());
        }
        if x.khr_buffer_device_address {
            data.push(std::ffi::CString::new("VK_KHR_buffer_device_address").unwrap());
        }
        if x.khr_calibrated_timestamps {
            data.push(std::ffi::CString::new("VK_KHR_calibrated_timestamps").unwrap());
        }
        if x.khr_cooperative_matrix {
            data.push(std::ffi::CString::new("VK_KHR_cooperative_matrix").unwrap());
        }
        if x.khr_copy_commands2 {
            data.push(std::ffi::CString::new("VK_KHR_copy_commands2").unwrap());
        }
        if x.khr_create_renderpass2 {
            data.push(std::ffi::CString::new("VK_KHR_create_renderpass2").unwrap());
        }
        if x.khr_dedicated_allocation {
            data.push(std::ffi::CString::new("VK_KHR_dedicated_allocation").unwrap());
        }
        if x.khr_deferred_host_operations {
            data.push(
                std::ffi::CString::new("VK_KHR_deferred_host_operations").unwrap(),
            );
        }
        if x.khr_depth_stencil_resolve {
            data.push(std::ffi::CString::new("VK_KHR_depth_stencil_resolve").unwrap());
        }
        if x.khr_descriptor_update_template {
            data.push(
                std::ffi::CString::new("VK_KHR_descriptor_update_template").unwrap(),
            );
        }
        if x.khr_device_group {
            data.push(std::ffi::CString::new("VK_KHR_device_group").unwrap());
        }
        if x.khr_display_swapchain {
            data.push(std::ffi::CString::new("VK_KHR_display_swapchain").unwrap());
        }
        if x.khr_draw_indirect_count {
            data.push(std::ffi::CString::new("VK_KHR_draw_indirect_count").unwrap());
        }
        if x.khr_driver_properties {
            data.push(std::ffi::CString::new("VK_KHR_driver_properties").unwrap());
        }
        if x.khr_dynamic_rendering {
            data.push(std::ffi::CString::new("VK_KHR_dynamic_rendering").unwrap());
        }
        if x.khr_dynamic_rendering_local_read {
            data.push(
                std::ffi::CString::new("VK_KHR_dynamic_rendering_local_read").unwrap(),
            );
        }
        if x.khr_external_fence {
            data.push(std::ffi::CString::new("VK_KHR_external_fence").unwrap());
        }
        if x.khr_external_fence_fd {
            data.push(std::ffi::CString::new("VK_KHR_external_fence_fd").unwrap());
        }
        if x.khr_external_fence_win32 {
            data.push(std::ffi::CString::new("VK_KHR_external_fence_win32").unwrap());
        }
        if x.khr_external_memory {
            data.push(std::ffi::CString::new("VK_KHR_external_memory").unwrap());
        }
        if x.khr_external_memory_fd {
            data.push(std::ffi::CString::new("VK_KHR_external_memory_fd").unwrap());
        }
        if x.khr_external_memory_win32 {
            data.push(std::ffi::CString::new("VK_KHR_external_memory_win32").unwrap());
        }
        if x.khr_external_semaphore {
            data.push(std::ffi::CString::new("VK_KHR_external_semaphore").unwrap());
        }
        if x.khr_external_semaphore_fd {
            data.push(std::ffi::CString::new("VK_KHR_external_semaphore_fd").unwrap());
        }
        if x.khr_external_semaphore_win32 {
            data.push(
                std::ffi::CString::new("VK_KHR_external_semaphore_win32").unwrap(),
            );
        }
        if x.khr_format_feature_flags2 {
            data.push(std::ffi::CString::new("VK_KHR_format_feature_flags2").unwrap());
        }
        if x.khr_fragment_shader_barycentric {
            data.push(
                std::ffi::CString::new("VK_KHR_fragment_shader_barycentric").unwrap(),
            );
        }
        if x.khr_fragment_shading_rate {
            data.push(std::ffi::CString::new("VK_KHR_fragment_shading_rate").unwrap());
        }
        if x.khr_get_memory_requirements2 {
            data.push(
                std::ffi::CString::new("VK_KHR_get_memory_requirements2").unwrap(),
            );
        }
        if x.khr_global_priority {
            data.push(std::ffi::CString::new("VK_KHR_global_priority").unwrap());
        }
        if x.khr_image_format_list {
            data.push(std::ffi::CString::new("VK_KHR_image_format_list").unwrap());
        }
        if x.khr_imageless_framebuffer {
            data.push(std::ffi::CString::new("VK_KHR_imageless_framebuffer").unwrap());
        }
        if x.khr_incremental_present {
            data.push(std::ffi::CString::new("VK_KHR_incremental_present").unwrap());
        }
        if x.khr_index_type_uint8 {
            data.push(std::ffi::CString::new("VK_KHR_index_type_uint8").unwrap());
        }
        if x.khr_line_rasterization {
            data.push(std::ffi::CString::new("VK_KHR_line_rasterization").unwrap());
        }
        if x.khr_load_store_op_none {
            data.push(std::ffi::CString::new("VK_KHR_load_store_op_none").unwrap());
        }
        if x.khr_maintenance1 {
            data.push(std::ffi::CString::new("VK_KHR_maintenance1").unwrap());
        }
        if x.khr_maintenance2 {
            data.push(std::ffi::CString::new("VK_KHR_maintenance2").unwrap());
        }
        if x.khr_maintenance3 {
            data.push(std::ffi::CString::new("VK_KHR_maintenance3").unwrap());
        }
        if x.khr_maintenance4 {
            data.push(std::ffi::CString::new("VK_KHR_maintenance4").unwrap());
        }
        if x.khr_maintenance5 {
            data.push(std::ffi::CString::new("VK_KHR_maintenance5").unwrap());
        }
        if x.khr_maintenance6 {
            data.push(std::ffi::CString::new("VK_KHR_maintenance6").unwrap());
        }
        if x.khr_map_memory2 {
            data.push(std::ffi::CString::new("VK_KHR_map_memory2").unwrap());
        }
        if x.khr_multiview {
            data.push(std::ffi::CString::new("VK_KHR_multiview").unwrap());
        }
        if x.khr_performance_query {
            data.push(std::ffi::CString::new("VK_KHR_performance_query").unwrap());
        }
        if x.khr_pipeline_executable_properties {
            data.push(
                std::ffi::CString::new("VK_KHR_pipeline_executable_properties").unwrap(),
            );
        }
        if x.khr_pipeline_library {
            data.push(std::ffi::CString::new("VK_KHR_pipeline_library").unwrap());
        }
        if x.khr_portability_subset {
            data.push(std::ffi::CString::new("VK_KHR_portability_subset").unwrap());
        }
        if x.khr_present_id {
            data.push(std::ffi::CString::new("VK_KHR_present_id").unwrap());
        }
        if x.khr_present_wait {
            data.push(std::ffi::CString::new("VK_KHR_present_wait").unwrap());
        }
        if x.khr_push_descriptor {
            data.push(std::ffi::CString::new("VK_KHR_push_descriptor").unwrap());
        }
        if x.khr_ray_query {
            data.push(std::ffi::CString::new("VK_KHR_ray_query").unwrap());
        }
        if x.khr_ray_tracing_maintenance1 {
            data.push(
                std::ffi::CString::new("VK_KHR_ray_tracing_maintenance1").unwrap(),
            );
        }
        if x.khr_ray_tracing_pipeline {
            data.push(std::ffi::CString::new("VK_KHR_ray_tracing_pipeline").unwrap());
        }
        if x.khr_ray_tracing_position_fetch {
            data.push(
                std::ffi::CString::new("VK_KHR_ray_tracing_position_fetch").unwrap(),
            );
        }
        if x.khr_relaxed_block_layout {
            data.push(std::ffi::CString::new("VK_KHR_relaxed_block_layout").unwrap());
        }
        if x.khr_sampler_mirror_clamp_to_edge {
            data.push(
                std::ffi::CString::new("VK_KHR_sampler_mirror_clamp_to_edge").unwrap(),
            );
        }
        if x.khr_sampler_ycbcr_conversion {
            data.push(
                std::ffi::CString::new("VK_KHR_sampler_ycbcr_conversion").unwrap(),
            );
        }
        if x.khr_separate_depth_stencil_layouts {
            data.push(
                std::ffi::CString::new("VK_KHR_separate_depth_stencil_layouts").unwrap(),
            );
        }
        if x.khr_shader_atomic_int64 {
            data.push(std::ffi::CString::new("VK_KHR_shader_atomic_int64").unwrap());
        }
        if x.khr_shader_clock {
            data.push(std::ffi::CString::new("VK_KHR_shader_clock").unwrap());
        }
        if x.khr_shader_draw_parameters {
            data.push(std::ffi::CString::new("VK_KHR_shader_draw_parameters").unwrap());
        }
        if x.khr_shader_expect_assume {
            data.push(std::ffi::CString::new("VK_KHR_shader_expect_assume").unwrap());
        }
        if x.khr_shader_float16_int8 {
            data.push(std::ffi::CString::new("VK_KHR_shader_float16_int8").unwrap());
        }
        if x.khr_shader_float_controls {
            data.push(std::ffi::CString::new("VK_KHR_shader_float_controls").unwrap());
        }
        if x.khr_shader_float_controls2 {
            data.push(std::ffi::CString::new("VK_KHR_shader_float_controls2").unwrap());
        }
        if x.khr_shader_integer_dot_product {
            data.push(
                std::ffi::CString::new("VK_KHR_shader_integer_dot_product").unwrap(),
            );
        }
        if x.khr_shader_maximal_reconvergence {
            data.push(
                std::ffi::CString::new("VK_KHR_shader_maximal_reconvergence").unwrap(),
            );
        }
        if x.khr_shader_non_semantic_info {
            data.push(
                std::ffi::CString::new("VK_KHR_shader_non_semantic_info").unwrap(),
            );
        }
        if x.khr_shader_quad_control {
            data.push(std::ffi::CString::new("VK_KHR_shader_quad_control").unwrap());
        }
        if x.khr_shader_subgroup_extended_types {
            data.push(
                std::ffi::CString::new("VK_KHR_shader_subgroup_extended_types").unwrap(),
            );
        }
        if x.khr_shader_subgroup_rotate {
            data.push(std::ffi::CString::new("VK_KHR_shader_subgroup_rotate").unwrap());
        }
        if x.khr_shader_subgroup_uniform_control_flow {
            data.push(
                std::ffi::CString::new("VK_KHR_shader_subgroup_uniform_control_flow")
                    .unwrap(),
            );
        }
        if x.khr_shader_terminate_invocation {
            data.push(
                std::ffi::CString::new("VK_KHR_shader_terminate_invocation").unwrap(),
            );
        }
        if x.khr_shared_presentable_image {
            data.push(
                std::ffi::CString::new("VK_KHR_shared_presentable_image").unwrap(),
            );
        }
        if x.khr_spirv_1_4 {
            data.push(std::ffi::CString::new("VK_KHR_spirv_1_4").unwrap());
        }
        if x.khr_storage_buffer_storage_class {
            data.push(
                std::ffi::CString::new("VK_KHR_storage_buffer_storage_class").unwrap(),
            );
        }
        if x.khr_swapchain {
            data.push(std::ffi::CString::new("VK_KHR_swapchain").unwrap());
        }
        if x.khr_swapchain_mutable_format {
            data.push(
                std::ffi::CString::new("VK_KHR_swapchain_mutable_format").unwrap(),
            );
        }
        if x.khr_synchronization2 {
            data.push(std::ffi::CString::new("VK_KHR_synchronization2").unwrap());
        }
        if x.khr_timeline_semaphore {
            data.push(std::ffi::CString::new("VK_KHR_timeline_semaphore").unwrap());
        }
        if x.khr_uniform_buffer_standard_layout {
            data.push(
                std::ffi::CString::new("VK_KHR_uniform_buffer_standard_layout").unwrap(),
            );
        }
        if x.khr_variable_pointers {
            data.push(std::ffi::CString::new("VK_KHR_variable_pointers").unwrap());
        }
        if x.khr_vertex_attribute_divisor {
            data.push(
                std::ffi::CString::new("VK_KHR_vertex_attribute_divisor").unwrap(),
            );
        }
        if x.khr_video_decode_av1 {
            data.push(std::ffi::CString::new("VK_KHR_video_decode_av1").unwrap());
        }
        if x.khr_video_decode_h264 {
            data.push(std::ffi::CString::new("VK_KHR_video_decode_h264").unwrap());
        }
        if x.khr_video_decode_h265 {
            data.push(std::ffi::CString::new("VK_KHR_video_decode_h265").unwrap());
        }
        if x.khr_video_decode_queue {
            data.push(std::ffi::CString::new("VK_KHR_video_decode_queue").unwrap());
        }
        if x.khr_video_encode_h264 {
            data.push(std::ffi::CString::new("VK_KHR_video_encode_h264").unwrap());
        }
        if x.khr_video_encode_h265 {
            data.push(std::ffi::CString::new("VK_KHR_video_encode_h265").unwrap());
        }
        if x.khr_video_encode_queue {
            data.push(std::ffi::CString::new("VK_KHR_video_encode_queue").unwrap());
        }
        if x.khr_video_maintenance1 {
            data.push(std::ffi::CString::new("VK_KHR_video_maintenance1").unwrap());
        }
        if x.khr_video_queue {
            data.push(std::ffi::CString::new("VK_KHR_video_queue").unwrap());
        }
        if x.khr_vulkan_memory_model {
            data.push(std::ffi::CString::new("VK_KHR_vulkan_memory_model").unwrap());
        }
        if x.khr_win32_keyed_mutex {
            data.push(std::ffi::CString::new("VK_KHR_win32_keyed_mutex").unwrap());
        }
        if x.khr_workgroup_memory_explicit_layout {
            data.push(
                std::ffi::CString::new("VK_KHR_workgroup_memory_explicit_layout")
                    .unwrap(),
            );
        }
        if x.khr_zero_initialize_workgroup_memory {
            data.push(
                std::ffi::CString::new("VK_KHR_zero_initialize_workgroup_memory")
                    .unwrap(),
            );
        }
        if x.ext_4444_formats {
            data.push(std::ffi::CString::new("VK_EXT_4444_formats").unwrap());
        }
        if x.ext_astc_decode_mode {
            data.push(std::ffi::CString::new("VK_EXT_astc_decode_mode").unwrap());
        }
        if x.ext_attachment_feedback_loop_dynamic_state {
            data.push(
                std::ffi::CString::new("VK_EXT_attachment_feedback_loop_dynamic_state")
                    .unwrap(),
            );
        }
        if x.ext_attachment_feedback_loop_layout {
            data.push(
                std::ffi::CString::new("VK_EXT_attachment_feedback_loop_layout").unwrap(),
            );
        }
        if x.ext_blend_operation_advanced {
            data.push(
                std::ffi::CString::new("VK_EXT_blend_operation_advanced").unwrap(),
            );
        }
        if x.ext_border_color_swizzle {
            data.push(std::ffi::CString::new("VK_EXT_border_color_swizzle").unwrap());
        }
        if x.ext_buffer_device_address {
            data.push(std::ffi::CString::new("VK_EXT_buffer_device_address").unwrap());
        }
        if x.ext_calibrated_timestamps {
            data.push(std::ffi::CString::new("VK_EXT_calibrated_timestamps").unwrap());
        }
        if x.ext_color_write_enable {
            data.push(std::ffi::CString::new("VK_EXT_color_write_enable").unwrap());
        }
        if x.ext_conditional_rendering {
            data.push(std::ffi::CString::new("VK_EXT_conditional_rendering").unwrap());
        }
        if x.ext_conservative_rasterization {
            data.push(
                std::ffi::CString::new("VK_EXT_conservative_rasterization").unwrap(),
            );
        }
        if x.ext_custom_border_color {
            data.push(std::ffi::CString::new("VK_EXT_custom_border_color").unwrap());
        }
        if x.ext_debug_marker {
            data.push(std::ffi::CString::new("VK_EXT_debug_marker").unwrap());
        }
        if x.ext_depth_bias_control {
            data.push(std::ffi::CString::new("VK_EXT_depth_bias_control").unwrap());
        }
        if x.ext_depth_clamp_zero_one {
            data.push(std::ffi::CString::new("VK_EXT_depth_clamp_zero_one").unwrap());
        }
        if x.ext_depth_clip_control {
            data.push(std::ffi::CString::new("VK_EXT_depth_clip_control").unwrap());
        }
        if x.ext_depth_clip_enable {
            data.push(std::ffi::CString::new("VK_EXT_depth_clip_enable").unwrap());
        }
        if x.ext_depth_range_unrestricted {
            data.push(
                std::ffi::CString::new("VK_EXT_depth_range_unrestricted").unwrap(),
            );
        }
        if x.ext_descriptor_buffer {
            data.push(std::ffi::CString::new("VK_EXT_descriptor_buffer").unwrap());
        }
        if x.ext_descriptor_indexing {
            data.push(std::ffi::CString::new("VK_EXT_descriptor_indexing").unwrap());
        }
        if x.ext_device_address_binding_report {
            data.push(
                std::ffi::CString::new("VK_EXT_device_address_binding_report").unwrap(),
            );
        }
        if x.ext_device_fault {
            data.push(std::ffi::CString::new("VK_EXT_device_fault").unwrap());
        }
        if x.ext_device_memory_report {
            data.push(std::ffi::CString::new("VK_EXT_device_memory_report").unwrap());
        }
        if x.ext_discard_rectangles {
            data.push(std::ffi::CString::new("VK_EXT_discard_rectangles").unwrap());
        }
        if x.ext_display_control {
            data.push(std::ffi::CString::new("VK_EXT_display_control").unwrap());
        }
        if x.ext_dynamic_rendering_unused_attachments {
            data.push(
                std::ffi::CString::new("VK_EXT_dynamic_rendering_unused_attachments")
                    .unwrap(),
            );
        }
        if x.ext_extended_dynamic_state {
            data.push(std::ffi::CString::new("VK_EXT_extended_dynamic_state").unwrap());
        }
        if x.ext_extended_dynamic_state2 {
            data.push(std::ffi::CString::new("VK_EXT_extended_dynamic_state2").unwrap());
        }
        if x.ext_extended_dynamic_state3 {
            data.push(std::ffi::CString::new("VK_EXT_extended_dynamic_state3").unwrap());
        }
        if x.ext_external_memory_acquire_unmodified {
            data.push(
                std::ffi::CString::new("VK_EXT_external_memory_acquire_unmodified")
                    .unwrap(),
            );
        }
        if x.ext_external_memory_dma_buf {
            data.push(std::ffi::CString::new("VK_EXT_external_memory_dma_buf").unwrap());
        }
        if x.ext_external_memory_host {
            data.push(std::ffi::CString::new("VK_EXT_external_memory_host").unwrap());
        }
        if x.ext_filter_cubic {
            data.push(std::ffi::CString::new("VK_EXT_filter_cubic").unwrap());
        }
        if x.ext_fragment_density_map {
            data.push(std::ffi::CString::new("VK_EXT_fragment_density_map").unwrap());
        }
        if x.ext_fragment_density_map2 {
            data.push(std::ffi::CString::new("VK_EXT_fragment_density_map2").unwrap());
        }
        if x.ext_fragment_shader_interlock {
            data.push(
                std::ffi::CString::new("VK_EXT_fragment_shader_interlock").unwrap(),
            );
        }
        if x.ext_frame_boundary {
            data.push(std::ffi::CString::new("VK_EXT_frame_boundary").unwrap());
        }
        if x.ext_full_screen_exclusive {
            data.push(std::ffi::CString::new("VK_EXT_full_screen_exclusive").unwrap());
        }
        if x.ext_global_priority {
            data.push(std::ffi::CString::new("VK_EXT_global_priority").unwrap());
        }
        if x.ext_global_priority_query {
            data.push(std::ffi::CString::new("VK_EXT_global_priority_query").unwrap());
        }
        if x.ext_graphics_pipeline_library {
            data.push(
                std::ffi::CString::new("VK_EXT_graphics_pipeline_library").unwrap(),
            );
        }
        if x.ext_hdr_metadata {
            data.push(std::ffi::CString::new("VK_EXT_hdr_metadata").unwrap());
        }
        if x.ext_host_image_copy {
            data.push(std::ffi::CString::new("VK_EXT_host_image_copy").unwrap());
        }
        if x.ext_host_query_reset {
            data.push(std::ffi::CString::new("VK_EXT_host_query_reset").unwrap());
        }
        if x.ext_image_2d_view_of_3d {
            data.push(std::ffi::CString::new("VK_EXT_image_2d_view_of_3d").unwrap());
        }
        if x.ext_image_compression_control {
            data.push(
                std::ffi::CString::new("VK_EXT_image_compression_control").unwrap(),
            );
        }
        if x.ext_image_compression_control_swapchain {
            data.push(
                std::ffi::CString::new("VK_EXT_image_compression_control_swapchain")
                    .unwrap(),
            );
        }
        if x.ext_image_drm_format_modifier {
            data.push(
                std::ffi::CString::new("VK_EXT_image_drm_format_modifier").unwrap(),
            );
        }
        if x.ext_image_robustness {
            data.push(std::ffi::CString::new("VK_EXT_image_robustness").unwrap());
        }
        if x.ext_image_sliced_view_of_3d {
            data.push(std::ffi::CString::new("VK_EXT_image_sliced_view_of_3d").unwrap());
        }
        if x.ext_image_view_min_lod {
            data.push(std::ffi::CString::new("VK_EXT_image_view_min_lod").unwrap());
        }
        if x.ext_index_type_uint8 {
            data.push(std::ffi::CString::new("VK_EXT_index_type_uint8").unwrap());
        }
        if x.ext_inline_uniform_block {
            data.push(std::ffi::CString::new("VK_EXT_inline_uniform_block").unwrap());
        }
        if x.ext_legacy_dithering {
            data.push(std::ffi::CString::new("VK_EXT_legacy_dithering").unwrap());
        }
        if x.ext_line_rasterization {
            data.push(std::ffi::CString::new("VK_EXT_line_rasterization").unwrap());
        }
        if x.ext_load_store_op_none {
            data.push(std::ffi::CString::new("VK_EXT_load_store_op_none").unwrap());
        }
        if x.ext_map_memory_placed {
            data.push(std::ffi::CString::new("VK_EXT_map_memory_placed").unwrap());
        }
        if x.ext_memory_budget {
            data.push(std::ffi::CString::new("VK_EXT_memory_budget").unwrap());
        }
        if x.ext_memory_priority {
            data.push(std::ffi::CString::new("VK_EXT_memory_priority").unwrap());
        }
        if x.ext_mesh_shader {
            data.push(std::ffi::CString::new("VK_EXT_mesh_shader").unwrap());
        }
        if x.ext_metal_objects {
            data.push(std::ffi::CString::new("VK_EXT_metal_objects").unwrap());
        }
        if x.ext_multi_draw {
            data.push(std::ffi::CString::new("VK_EXT_multi_draw").unwrap());
        }
        if x.ext_multisampled_render_to_single_sampled {
            data.push(
                std::ffi::CString::new("VK_EXT_multisampled_render_to_single_sampled")
                    .unwrap(),
            );
        }
        if x.ext_mutable_descriptor_type {
            data.push(std::ffi::CString::new("VK_EXT_mutable_descriptor_type").unwrap());
        }
        if x.ext_nested_command_buffer {
            data.push(std::ffi::CString::new("VK_EXT_nested_command_buffer").unwrap());
        }
        if x.ext_non_seamless_cube_map {
            data.push(std::ffi::CString::new("VK_EXT_non_seamless_cube_map").unwrap());
        }
        if x.ext_opacity_micromap {
            data.push(std::ffi::CString::new("VK_EXT_opacity_micromap").unwrap());
        }
        if x.ext_pageable_device_local_memory {
            data.push(
                std::ffi::CString::new("VK_EXT_pageable_device_local_memory").unwrap(),
            );
        }
        if x.ext_pci_bus_info {
            data.push(std::ffi::CString::new("VK_EXT_pci_bus_info").unwrap());
        }
        if x.ext_physical_device_drm {
            data.push(std::ffi::CString::new("VK_EXT_physical_device_drm").unwrap());
        }
        if x.ext_pipeline_creation_cache_control {
            data.push(
                std::ffi::CString::new("VK_EXT_pipeline_creation_cache_control").unwrap(),
            );
        }
        if x.ext_pipeline_creation_feedback {
            data.push(
                std::ffi::CString::new("VK_EXT_pipeline_creation_feedback").unwrap(),
            );
        }
        if x.ext_pipeline_library_group_handles {
            data.push(
                std::ffi::CString::new("VK_EXT_pipeline_library_group_handles").unwrap(),
            );
        }
        if x.ext_pipeline_properties {
            data.push(std::ffi::CString::new("VK_EXT_pipeline_properties").unwrap());
        }
        if x.ext_pipeline_protected_access {
            data.push(
                std::ffi::CString::new("VK_EXT_pipeline_protected_access").unwrap(),
            );
        }
        if x.ext_pipeline_robustness {
            data.push(std::ffi::CString::new("VK_EXT_pipeline_robustness").unwrap());
        }
        if x.ext_post_depth_coverage {
            data.push(std::ffi::CString::new("VK_EXT_post_depth_coverage").unwrap());
        }
        if x.ext_primitive_topology_list_restart {
            data.push(
                std::ffi::CString::new("VK_EXT_primitive_topology_list_restart").unwrap(),
            );
        }
        if x.ext_primitives_generated_query {
            data.push(
                std::ffi::CString::new("VK_EXT_primitives_generated_query").unwrap(),
            );
        }
        if x.ext_private_data {
            data.push(std::ffi::CString::new("VK_EXT_private_data").unwrap());
        }
        if x.ext_provoking_vertex {
            data.push(std::ffi::CString::new("VK_EXT_provoking_vertex").unwrap());
        }
        if x.ext_queue_family_foreign {
            data.push(std::ffi::CString::new("VK_EXT_queue_family_foreign").unwrap());
        }
        if x.ext_rasterization_order_attachment_access {
            data.push(
                std::ffi::CString::new("VK_EXT_rasterization_order_attachment_access")
                    .unwrap(),
            );
        }
        if x.ext_rgba10x6_formats {
            data.push(std::ffi::CString::new("VK_EXT_rgba10x6_formats").unwrap());
        }
        if x.ext_robustness2 {
            data.push(std::ffi::CString::new("VK_EXT_robustness2").unwrap());
        }
        if x.ext_sample_locations {
            data.push(std::ffi::CString::new("VK_EXT_sample_locations").unwrap());
        }
        if x.ext_sampler_filter_minmax {
            data.push(std::ffi::CString::new("VK_EXT_sampler_filter_minmax").unwrap());
        }
        if x.ext_scalar_block_layout {
            data.push(std::ffi::CString::new("VK_EXT_scalar_block_layout").unwrap());
        }
        if x.ext_separate_stencil_usage {
            data.push(std::ffi::CString::new("VK_EXT_separate_stencil_usage").unwrap());
        }
        if x.ext_shader_atomic_float {
            data.push(std::ffi::CString::new("VK_EXT_shader_atomic_float").unwrap());
        }
        if x.ext_shader_atomic_float2 {
            data.push(std::ffi::CString::new("VK_EXT_shader_atomic_float2").unwrap());
        }
        if x.ext_shader_demote_to_helper_invocation {
            data.push(
                std::ffi::CString::new("VK_EXT_shader_demote_to_helper_invocation")
                    .unwrap(),
            );
        }
        if x.ext_shader_image_atomic_int64 {
            data.push(
                std::ffi::CString::new("VK_EXT_shader_image_atomic_int64").unwrap(),
            );
        }
        if x.ext_shader_module_identifier {
            data.push(
                std::ffi::CString::new("VK_EXT_shader_module_identifier").unwrap(),
            );
        }
        if x.ext_shader_object {
            data.push(std::ffi::CString::new("VK_EXT_shader_object").unwrap());
        }
        if x.ext_shader_stencil_export {
            data.push(std::ffi::CString::new("VK_EXT_shader_stencil_export").unwrap());
        }
        if x.ext_shader_subgroup_ballot {
            data.push(std::ffi::CString::new("VK_EXT_shader_subgroup_ballot").unwrap());
        }
        if x.ext_shader_subgroup_vote {
            data.push(std::ffi::CString::new("VK_EXT_shader_subgroup_vote").unwrap());
        }
        if x.ext_shader_tile_image {
            data.push(std::ffi::CString::new("VK_EXT_shader_tile_image").unwrap());
        }
        if x.ext_shader_viewport_index_layer {
            data.push(
                std::ffi::CString::new("VK_EXT_shader_viewport_index_layer").unwrap(),
            );
        }
        if x.ext_subgroup_size_control {
            data.push(std::ffi::CString::new("VK_EXT_subgroup_size_control").unwrap());
        }
        if x.ext_subpass_merge_feedback {
            data.push(std::ffi::CString::new("VK_EXT_subpass_merge_feedback").unwrap());
        }
        if x.ext_swapchain_maintenance1 {
            data.push(std::ffi::CString::new("VK_EXT_swapchain_maintenance1").unwrap());
        }
        if x.ext_texel_buffer_alignment {
            data.push(std::ffi::CString::new("VK_EXT_texel_buffer_alignment").unwrap());
        }
        if x.ext_texture_compression_astc_hdr {
            data.push(
                std::ffi::CString::new("VK_EXT_texture_compression_astc_hdr").unwrap(),
            );
        }
        if x.ext_tooling_info {
            data.push(std::ffi::CString::new("VK_EXT_tooling_info").unwrap());
        }
        if x.ext_transform_feedback {
            data.push(std::ffi::CString::new("VK_EXT_transform_feedback").unwrap());
        }
        if x.ext_validation_cache {
            data.push(std::ffi::CString::new("VK_EXT_validation_cache").unwrap());
        }
        if x.ext_vertex_attribute_divisor {
            data.push(
                std::ffi::CString::new("VK_EXT_vertex_attribute_divisor").unwrap(),
            );
        }
        if x.ext_vertex_input_dynamic_state {
            data.push(
                std::ffi::CString::new("VK_EXT_vertex_input_dynamic_state").unwrap(),
            );
        }
        if x.ext_ycbcr_2plane_444_formats {
            data.push(
                std::ffi::CString::new("VK_EXT_ycbcr_2plane_444_formats").unwrap(),
            );
        }
        if x.ext_ycbcr_image_arrays {
            data.push(std::ffi::CString::new("VK_EXT_ycbcr_image_arrays").unwrap());
        }
        if x.amdx_shader_enqueue {
            data.push(std::ffi::CString::new("VK_AMDX_shader_enqueue").unwrap());
        }
        if x.amd_buffer_marker {
            data.push(std::ffi::CString::new("VK_AMD_buffer_marker").unwrap());
        }
        if x.amd_device_coherent_memory {
            data.push(std::ffi::CString::new("VK_AMD_device_coherent_memory").unwrap());
        }
        if x.amd_display_native_hdr {
            data.push(std::ffi::CString::new("VK_AMD_display_native_hdr").unwrap());
        }
        if x.amd_draw_indirect_count {
            data.push(std::ffi::CString::new("VK_AMD_draw_indirect_count").unwrap());
        }
        if x.amd_gcn_shader {
            data.push(std::ffi::CString::new("VK_AMD_gcn_shader").unwrap());
        }
        if x.amd_gpu_shader_half_float {
            data.push(std::ffi::CString::new("VK_AMD_gpu_shader_half_float").unwrap());
        }
        if x.amd_gpu_shader_int16 {
            data.push(std::ffi::CString::new("VK_AMD_gpu_shader_int16").unwrap());
        }
        if x.amd_memory_overallocation_behavior {
            data.push(
                std::ffi::CString::new("VK_AMD_memory_overallocation_behavior").unwrap(),
            );
        }
        if x.amd_mixed_attachment_samples {
            data.push(
                std::ffi::CString::new("VK_AMD_mixed_attachment_samples").unwrap(),
            );
        }
        if x.amd_pipeline_compiler_control {
            data.push(
                std::ffi::CString::new("VK_AMD_pipeline_compiler_control").unwrap(),
            );
        }
        if x.amd_rasterization_order {
            data.push(std::ffi::CString::new("VK_AMD_rasterization_order").unwrap());
        }
        if x.amd_shader_ballot {
            data.push(std::ffi::CString::new("VK_AMD_shader_ballot").unwrap());
        }
        if x.amd_shader_core_properties {
            data.push(std::ffi::CString::new("VK_AMD_shader_core_properties").unwrap());
        }
        if x.amd_shader_core_properties2 {
            data.push(std::ffi::CString::new("VK_AMD_shader_core_properties2").unwrap());
        }
        if x.amd_shader_early_and_late_fragment_tests {
            data.push(
                std::ffi::CString::new("VK_AMD_shader_early_and_late_fragment_tests")
                    .unwrap(),
            );
        }
        if x.amd_shader_explicit_vertex_parameter {
            data.push(
                std::ffi::CString::new("VK_AMD_shader_explicit_vertex_parameter")
                    .unwrap(),
            );
        }
        if x.amd_shader_fragment_mask {
            data.push(std::ffi::CString::new("VK_AMD_shader_fragment_mask").unwrap());
        }
        if x.amd_shader_image_load_store_lod {
            data.push(
                std::ffi::CString::new("VK_AMD_shader_image_load_store_lod").unwrap(),
            );
        }
        if x.amd_shader_info {
            data.push(std::ffi::CString::new("VK_AMD_shader_info").unwrap());
        }
        if x.amd_shader_trinary_minmax {
            data.push(std::ffi::CString::new("VK_AMD_shader_trinary_minmax").unwrap());
        }
        if x.amd_texture_gather_bias_lod {
            data.push(std::ffi::CString::new("VK_AMD_texture_gather_bias_lod").unwrap());
        }
        if x.android_external_format_resolve {
            data.push(
                std::ffi::CString::new("VK_ANDROID_external_format_resolve").unwrap(),
            );
        }
        if x.android_external_memory_android_hardware_buffer {
            data.push(
                std::ffi::CString::new(
                        "VK_ANDROID_external_memory_android_hardware_buffer",
                    )
                    .unwrap(),
            );
        }
        if x.arm_rasterization_order_attachment_access {
            data.push(
                std::ffi::CString::new("VK_ARM_rasterization_order_attachment_access")
                    .unwrap(),
            );
        }
        if x.arm_render_pass_striped {
            data.push(std::ffi::CString::new("VK_ARM_render_pass_striped").unwrap());
        }
        if x.arm_scheduling_controls {
            data.push(std::ffi::CString::new("VK_ARM_scheduling_controls").unwrap());
        }
        if x.arm_shader_core_builtins {
            data.push(std::ffi::CString::new("VK_ARM_shader_core_builtins").unwrap());
        }
        if x.arm_shader_core_properties {
            data.push(std::ffi::CString::new("VK_ARM_shader_core_properties").unwrap());
        }
        if x.fuchsia_buffer_collection {
            data.push(std::ffi::CString::new("VK_FUCHSIA_buffer_collection").unwrap());
        }
        if x.fuchsia_external_memory {
            data.push(std::ffi::CString::new("VK_FUCHSIA_external_memory").unwrap());
        }
        if x.fuchsia_external_semaphore {
            data.push(std::ffi::CString::new("VK_FUCHSIA_external_semaphore").unwrap());
        }
        if x.ggp_frame_token {
            data.push(std::ffi::CString::new("VK_GGP_frame_token").unwrap());
        }
        if x.google_decorate_string {
            data.push(std::ffi::CString::new("VK_GOOGLE_decorate_string").unwrap());
        }
        if x.google_display_timing {
            data.push(std::ffi::CString::new("VK_GOOGLE_display_timing").unwrap());
        }
        if x.google_hlsl_functionality1 {
            data.push(std::ffi::CString::new("VK_GOOGLE_hlsl_functionality1").unwrap());
        }
        if x.google_user_type {
            data.push(std::ffi::CString::new("VK_GOOGLE_user_type").unwrap());
        }
        if x.huawei_cluster_culling_shader {
            data.push(
                std::ffi::CString::new("VK_HUAWEI_cluster_culling_shader").unwrap(),
            );
        }
        if x.huawei_invocation_mask {
            data.push(std::ffi::CString::new("VK_HUAWEI_invocation_mask").unwrap());
        }
        if x.huawei_subpass_shading {
            data.push(std::ffi::CString::new("VK_HUAWEI_subpass_shading").unwrap());
        }
        if x.img_filter_cubic {
            data.push(std::ffi::CString::new("VK_IMG_filter_cubic").unwrap());
        }
        if x.img_format_pvrtc {
            data.push(std::ffi::CString::new("VK_IMG_format_pvrtc").unwrap());
        }
        if x.img_relaxed_line_rasterization {
            data.push(
                std::ffi::CString::new("VK_IMG_relaxed_line_rasterization").unwrap(),
            );
        }
        if x.intel_performance_query {
            data.push(std::ffi::CString::new("VK_INTEL_performance_query").unwrap());
        }
        if x.intel_shader_integer_functions2 {
            data.push(
                std::ffi::CString::new("VK_INTEL_shader_integer_functions2").unwrap(),
            );
        }
        if x.msft_layered_driver {
            data.push(std::ffi::CString::new("VK_MSFT_layered_driver").unwrap());
        }
        if x.nvx_binary_import {
            data.push(std::ffi::CString::new("VK_NVX_binary_import").unwrap());
        }
        if x.nvx_image_view_handle {
            data.push(std::ffi::CString::new("VK_NVX_image_view_handle").unwrap());
        }
        if x.nvx_multiview_per_view_attributes {
            data.push(
                std::ffi::CString::new("VK_NVX_multiview_per_view_attributes").unwrap(),
            );
        }
        if x.nv_acquire_winrt_display {
            data.push(std::ffi::CString::new("VK_NV_acquire_winrt_display").unwrap());
        }
        if x.nv_clip_space_w_scaling {
            data.push(std::ffi::CString::new("VK_NV_clip_space_w_scaling").unwrap());
        }
        if x.nv_compute_shader_derivatives {
            data.push(
                std::ffi::CString::new("VK_NV_compute_shader_derivatives").unwrap(),
            );
        }
        if x.nv_cooperative_matrix {
            data.push(std::ffi::CString::new("VK_NV_cooperative_matrix").unwrap());
        }
        if x.nv_copy_memory_indirect {
            data.push(std::ffi::CString::new("VK_NV_copy_memory_indirect").unwrap());
        }
        if x.nv_corner_sampled_image {
            data.push(std::ffi::CString::new("VK_NV_corner_sampled_image").unwrap());
        }
        if x.nv_coverage_reduction_mode {
            data.push(std::ffi::CString::new("VK_NV_coverage_reduction_mode").unwrap());
        }
        if x.nv_cuda_kernel_launch {
            data.push(std::ffi::CString::new("VK_NV_cuda_kernel_launch").unwrap());
        }
        if x.nv_dedicated_allocation {
            data.push(std::ffi::CString::new("VK_NV_dedicated_allocation").unwrap());
        }
        if x.nv_dedicated_allocation_image_aliasing {
            data.push(
                std::ffi::CString::new("VK_NV_dedicated_allocation_image_aliasing")
                    .unwrap(),
            );
        }
        if x.nv_descriptor_pool_overallocation {
            data.push(
                std::ffi::CString::new("VK_NV_descriptor_pool_overallocation").unwrap(),
            );
        }
        if x.nv_device_diagnostic_checkpoints {
            data.push(
                std::ffi::CString::new("VK_NV_device_diagnostic_checkpoints").unwrap(),
            );
        }
        if x.nv_device_diagnostics_config {
            data.push(
                std::ffi::CString::new("VK_NV_device_diagnostics_config").unwrap(),
            );
        }
        if x.nv_device_generated_commands {
            data.push(
                std::ffi::CString::new("VK_NV_device_generated_commands").unwrap(),
            );
        }
        if x.nv_device_generated_commands_compute {
            data.push(
                std::ffi::CString::new("VK_NV_device_generated_commands_compute")
                    .unwrap(),
            );
        }
        if x.nv_displacement_micromap {
            data.push(std::ffi::CString::new("VK_NV_displacement_micromap").unwrap());
        }
        if x.nv_extended_sparse_address_space {
            data.push(
                std::ffi::CString::new("VK_NV_extended_sparse_address_space").unwrap(),
            );
        }
        if x.nv_external_memory {
            data.push(std::ffi::CString::new("VK_NV_external_memory").unwrap());
        }
        if x.nv_external_memory_rdma {
            data.push(std::ffi::CString::new("VK_NV_external_memory_rdma").unwrap());
        }
        if x.nv_external_memory_win32 {
            data.push(std::ffi::CString::new("VK_NV_external_memory_win32").unwrap());
        }
        if x.nv_fill_rectangle {
            data.push(std::ffi::CString::new("VK_NV_fill_rectangle").unwrap());
        }
        if x.nv_fragment_coverage_to_color {
            data.push(
                std::ffi::CString::new("VK_NV_fragment_coverage_to_color").unwrap(),
            );
        }
        if x.nv_fragment_shader_barycentric {
            data.push(
                std::ffi::CString::new("VK_NV_fragment_shader_barycentric").unwrap(),
            );
        }
        if x.nv_fragment_shading_rate_enums {
            data.push(
                std::ffi::CString::new("VK_NV_fragment_shading_rate_enums").unwrap(),
            );
        }
        if x.nv_framebuffer_mixed_samples {
            data.push(
                std::ffi::CString::new("VK_NV_framebuffer_mixed_samples").unwrap(),
            );
        }
        if x.nv_geometry_shader_passthrough {
            data.push(
                std::ffi::CString::new("VK_NV_geometry_shader_passthrough").unwrap(),
            );
        }
        if x.nv_glsl_shader {
            data.push(std::ffi::CString::new("VK_NV_glsl_shader").unwrap());
        }
        if x.nv_inherited_viewport_scissor {
            data.push(
                std::ffi::CString::new("VK_NV_inherited_viewport_scissor").unwrap(),
            );
        }
        if x.nv_linear_color_attachment {
            data.push(std::ffi::CString::new("VK_NV_linear_color_attachment").unwrap());
        }
        if x.nv_low_latency {
            data.push(std::ffi::CString::new("VK_NV_low_latency").unwrap());
        }
        if x.nv_low_latency2 {
            data.push(std::ffi::CString::new("VK_NV_low_latency2").unwrap());
        }
        if x.nv_memory_decompression {
            data.push(std::ffi::CString::new("VK_NV_memory_decompression").unwrap());
        }
        if x.nv_mesh_shader {
            data.push(std::ffi::CString::new("VK_NV_mesh_shader").unwrap());
        }
        if x.nv_optical_flow {
            data.push(std::ffi::CString::new("VK_NV_optical_flow").unwrap());
        }
        if x.nv_per_stage_descriptor_set {
            data.push(std::ffi::CString::new("VK_NV_per_stage_descriptor_set").unwrap());
        }
        if x.nv_present_barrier {
            data.push(std::ffi::CString::new("VK_NV_present_barrier").unwrap());
        }
        if x.nv_raw_access_chains {
            data.push(std::ffi::CString::new("VK_NV_raw_access_chains").unwrap());
        }
        if x.nv_ray_tracing {
            data.push(std::ffi::CString::new("VK_NV_ray_tracing").unwrap());
        }
        if x.nv_ray_tracing_invocation_reorder {
            data.push(
                std::ffi::CString::new("VK_NV_ray_tracing_invocation_reorder").unwrap(),
            );
        }
        if x.nv_ray_tracing_motion_blur {
            data.push(std::ffi::CString::new("VK_NV_ray_tracing_motion_blur").unwrap());
        }
        if x.nv_ray_tracing_validation {
            data.push(std::ffi::CString::new("VK_NV_ray_tracing_validation").unwrap());
        }
        if x.nv_representative_fragment_test {
            data.push(
                std::ffi::CString::new("VK_NV_representative_fragment_test").unwrap(),
            );
        }
        if x.nv_sample_mask_override_coverage {
            data.push(
                std::ffi::CString::new("VK_NV_sample_mask_override_coverage").unwrap(),
            );
        }
        if x.nv_scissor_exclusive {
            data.push(std::ffi::CString::new("VK_NV_scissor_exclusive").unwrap());
        }
        if x.nv_shader_atomic_float16_vector {
            data.push(
                std::ffi::CString::new("VK_NV_shader_atomic_float16_vector").unwrap(),
            );
        }
        if x.nv_shader_image_footprint {
            data.push(std::ffi::CString::new("VK_NV_shader_image_footprint").unwrap());
        }
        if x.nv_shader_sm_builtins {
            data.push(std::ffi::CString::new("VK_NV_shader_sm_builtins").unwrap());
        }
        if x.nv_shader_subgroup_partitioned {
            data.push(
                std::ffi::CString::new("VK_NV_shader_subgroup_partitioned").unwrap(),
            );
        }
        if x.nv_shading_rate_image {
            data.push(std::ffi::CString::new("VK_NV_shading_rate_image").unwrap());
        }
        if x.nv_viewport_array2 {
            data.push(std::ffi::CString::new("VK_NV_viewport_array2").unwrap());
        }
        if x.nv_viewport_swizzle {
            data.push(std::ffi::CString::new("VK_NV_viewport_swizzle").unwrap());
        }
        if x.nv_win32_keyed_mutex {
            data.push(std::ffi::CString::new("VK_NV_win32_keyed_mutex").unwrap());
        }
        if x.qcom_filter_cubic_clamp {
            data.push(std::ffi::CString::new("VK_QCOM_filter_cubic_clamp").unwrap());
        }
        if x.qcom_filter_cubic_weights {
            data.push(std::ffi::CString::new("VK_QCOM_filter_cubic_weights").unwrap());
        }
        if x.qcom_fragment_density_map_offset {
            data.push(
                std::ffi::CString::new("VK_QCOM_fragment_density_map_offset").unwrap(),
            );
        }
        if x.qcom_image_processing {
            data.push(std::ffi::CString::new("VK_QCOM_image_processing").unwrap());
        }
        if x.qcom_image_processing2 {
            data.push(std::ffi::CString::new("VK_QCOM_image_processing2").unwrap());
        }
        if x.qcom_multiview_per_view_render_areas {
            data.push(
                std::ffi::CString::new("VK_QCOM_multiview_per_view_render_areas")
                    .unwrap(),
            );
        }
        if x.qcom_multiview_per_view_viewports {
            data.push(
                std::ffi::CString::new("VK_QCOM_multiview_per_view_viewports").unwrap(),
            );
        }
        if x.qcom_render_pass_shader_resolve {
            data.push(
                std::ffi::CString::new("VK_QCOM_render_pass_shader_resolve").unwrap(),
            );
        }
        if x.qcom_render_pass_store_ops {
            data.push(std::ffi::CString::new("VK_QCOM_render_pass_store_ops").unwrap());
        }
        if x.qcom_render_pass_transform {
            data.push(std::ffi::CString::new("VK_QCOM_render_pass_transform").unwrap());
        }
        if x.qcom_rotated_copy_commands {
            data.push(std::ffi::CString::new("VK_QCOM_rotated_copy_commands").unwrap());
        }
        if x.qcom_tile_properties {
            data.push(std::ffi::CString::new("VK_QCOM_tile_properties").unwrap());
        }
        if x.qcom_ycbcr_degamma {
            data.push(std::ffi::CString::new("VK_QCOM_ycbcr_degamma").unwrap());
        }
        if x.qnx_external_memory_screen_buffer {
            data.push(
                std::ffi::CString::new("VK_QNX_external_memory_screen_buffer").unwrap(),
            );
        }
        if x.sec_amigo_profiling {
            data.push(std::ffi::CString::new("VK_SEC_amigo_profiling").unwrap());
        }
        if x.valve_descriptor_set_host_mapping {
            data.push(
                std::ffi::CString::new("VK_VALVE_descriptor_set_host_mapping").unwrap(),
            );
        }
        if x.valve_mutable_descriptor_type {
            data.push(
                std::ffi::CString::new("VK_VALVE_mutable_descriptor_type").unwrap(),
            );
        }
        data
    }
}
impl IntoIterator for DeviceExtensions {
    type Item = (&'static str, bool);
    type IntoIter = std::array::IntoIter<Self::Item, 330usize>;
    #[inline]
    fn into_iter(self) -> Self::IntoIter {
        [
            ("VK_KHR_16bit_storage", self.khr_16bit_storage),
            ("VK_KHR_8bit_storage", self.khr_8bit_storage),
            ("VK_KHR_acceleration_structure", self.khr_acceleration_structure),
            ("VK_KHR_bind_memory2", self.khr_bind_memory2),
            ("VK_KHR_buffer_device_address", self.khr_buffer_device_address),
            ("VK_KHR_calibrated_timestamps", self.khr_calibrated_timestamps),
            ("VK_KHR_cooperative_matrix", self.khr_cooperative_matrix),
            ("VK_KHR_copy_commands2", self.khr_copy_commands2),
            ("VK_KHR_create_renderpass2", self.khr_create_renderpass2),
            ("VK_KHR_dedicated_allocation", self.khr_dedicated_allocation),
            ("VK_KHR_deferred_host_operations", self.khr_deferred_host_operations),
            ("VK_KHR_depth_stencil_resolve", self.khr_depth_stencil_resolve),
            ("VK_KHR_descriptor_update_template", self.khr_descriptor_update_template),
            ("VK_KHR_device_group", self.khr_device_group),
            ("VK_KHR_display_swapchain", self.khr_display_swapchain),
            ("VK_KHR_draw_indirect_count", self.khr_draw_indirect_count),
            ("VK_KHR_driver_properties", self.khr_driver_properties),
            ("VK_KHR_dynamic_rendering", self.khr_dynamic_rendering),
            (
                "VK_KHR_dynamic_rendering_local_read",
                self.khr_dynamic_rendering_local_read,
            ),
            ("VK_KHR_external_fence", self.khr_external_fence),
            ("VK_KHR_external_fence_fd", self.khr_external_fence_fd),
            ("VK_KHR_external_fence_win32", self.khr_external_fence_win32),
            ("VK_KHR_external_memory", self.khr_external_memory),
            ("VK_KHR_external_memory_fd", self.khr_external_memory_fd),
            ("VK_KHR_external_memory_win32", self.khr_external_memory_win32),
            ("VK_KHR_external_semaphore", self.khr_external_semaphore),
            ("VK_KHR_external_semaphore_fd", self.khr_external_semaphore_fd),
            ("VK_KHR_external_semaphore_win32", self.khr_external_semaphore_win32),
            ("VK_KHR_format_feature_flags2", self.khr_format_feature_flags2),
            ("VK_KHR_fragment_shader_barycentric", self.khr_fragment_shader_barycentric),
            ("VK_KHR_fragment_shading_rate", self.khr_fragment_shading_rate),
            ("VK_KHR_get_memory_requirements2", self.khr_get_memory_requirements2),
            ("VK_KHR_global_priority", self.khr_global_priority),
            ("VK_KHR_image_format_list", self.khr_image_format_list),
            ("VK_KHR_imageless_framebuffer", self.khr_imageless_framebuffer),
            ("VK_KHR_incremental_present", self.khr_incremental_present),
            ("VK_KHR_index_type_uint8", self.khr_index_type_uint8),
            ("VK_KHR_line_rasterization", self.khr_line_rasterization),
            ("VK_KHR_load_store_op_none", self.khr_load_store_op_none),
            ("VK_KHR_maintenance1", self.khr_maintenance1),
            ("VK_KHR_maintenance2", self.khr_maintenance2),
            ("VK_KHR_maintenance3", self.khr_maintenance3),
            ("VK_KHR_maintenance4", self.khr_maintenance4),
            ("VK_KHR_maintenance5", self.khr_maintenance5),
            ("VK_KHR_maintenance6", self.khr_maintenance6),
            ("VK_KHR_map_memory2", self.khr_map_memory2),
            ("VK_KHR_multiview", self.khr_multiview),
            ("VK_KHR_performance_query", self.khr_performance_query),
            (
                "VK_KHR_pipeline_executable_properties",
                self.khr_pipeline_executable_properties,
            ),
            ("VK_KHR_pipeline_library", self.khr_pipeline_library),
            ("VK_KHR_portability_subset", self.khr_portability_subset),
            ("VK_KHR_present_id", self.khr_present_id),
            ("VK_KHR_present_wait", self.khr_present_wait),
            ("VK_KHR_push_descriptor", self.khr_push_descriptor),
            ("VK_KHR_ray_query", self.khr_ray_query),
            ("VK_KHR_ray_tracing_maintenance1", self.khr_ray_tracing_maintenance1),
            ("VK_KHR_ray_tracing_pipeline", self.khr_ray_tracing_pipeline),
            ("VK_KHR_ray_tracing_position_fetch", self.khr_ray_tracing_position_fetch),
            ("VK_KHR_relaxed_block_layout", self.khr_relaxed_block_layout),
            (
                "VK_KHR_sampler_mirror_clamp_to_edge",
                self.khr_sampler_mirror_clamp_to_edge,
            ),
            ("VK_KHR_sampler_ycbcr_conversion", self.khr_sampler_ycbcr_conversion),
            (
                "VK_KHR_separate_depth_stencil_layouts",
                self.khr_separate_depth_stencil_layouts,
            ),
            ("VK_KHR_shader_atomic_int64", self.khr_shader_atomic_int64),
            ("VK_KHR_shader_clock", self.khr_shader_clock),
            ("VK_KHR_shader_draw_parameters", self.khr_shader_draw_parameters),
            ("VK_KHR_shader_expect_assume", self.khr_shader_expect_assume),
            ("VK_KHR_shader_float16_int8", self.khr_shader_float16_int8),
            ("VK_KHR_shader_float_controls", self.khr_shader_float_controls),
            ("VK_KHR_shader_float_controls2", self.khr_shader_float_controls2),
            ("VK_KHR_shader_integer_dot_product", self.khr_shader_integer_dot_product),
            (
                "VK_KHR_shader_maximal_reconvergence",
                self.khr_shader_maximal_reconvergence,
            ),
            ("VK_KHR_shader_non_semantic_info", self.khr_shader_non_semantic_info),
            ("VK_KHR_shader_quad_control", self.khr_shader_quad_control),
            (
                "VK_KHR_shader_subgroup_extended_types",
                self.khr_shader_subgroup_extended_types,
            ),
            ("VK_KHR_shader_subgroup_rotate", self.khr_shader_subgroup_rotate),
            (
                "VK_KHR_shader_subgroup_uniform_control_flow",
                self.khr_shader_subgroup_uniform_control_flow,
            ),
            ("VK_KHR_shader_terminate_invocation", self.khr_shader_terminate_invocation),
            ("VK_KHR_shared_presentable_image", self.khr_shared_presentable_image),
            ("VK_KHR_spirv_1_4", self.khr_spirv_1_4),
            (
                "VK_KHR_storage_buffer_storage_class",
                self.khr_storage_buffer_storage_class,
            ),
            ("VK_KHR_swapchain", self.khr_swapchain),
            ("VK_KHR_swapchain_mutable_format", self.khr_swapchain_mutable_format),
            ("VK_KHR_synchronization2", self.khr_synchronization2),
            ("VK_KHR_timeline_semaphore", self.khr_timeline_semaphore),
            (
                "VK_KHR_uniform_buffer_standard_layout",
                self.khr_uniform_buffer_standard_layout,
            ),
            ("VK_KHR_variable_pointers", self.khr_variable_pointers),
            ("VK_KHR_vertex_attribute_divisor", self.khr_vertex_attribute_divisor),
            ("VK_KHR_video_decode_av1", self.khr_video_decode_av1),
            ("VK_KHR_video_decode_h264", self.khr_video_decode_h264),
            ("VK_KHR_video_decode_h265", self.khr_video_decode_h265),
            ("VK_KHR_video_decode_queue", self.khr_video_decode_queue),
            ("VK_KHR_video_encode_h264", self.khr_video_encode_h264),
            ("VK_KHR_video_encode_h265", self.khr_video_encode_h265),
            ("VK_KHR_video_encode_queue", self.khr_video_encode_queue),
            ("VK_KHR_video_maintenance1", self.khr_video_maintenance1),
            ("VK_KHR_video_queue", self.khr_video_queue),
            ("VK_KHR_vulkan_memory_model", self.khr_vulkan_memory_model),
            ("VK_KHR_win32_keyed_mutex", self.khr_win32_keyed_mutex),
            (
                "VK_KHR_workgroup_memory_explicit_layout",
                self.khr_workgroup_memory_explicit_layout,
            ),
            (
                "VK_KHR_zero_initialize_workgroup_memory",
                self.khr_zero_initialize_workgroup_memory,
            ),
            ("VK_EXT_4444_formats", self.ext_4444_formats),
            ("VK_EXT_astc_decode_mode", self.ext_astc_decode_mode),
            (
                "VK_EXT_attachment_feedback_loop_dynamic_state",
                self.ext_attachment_feedback_loop_dynamic_state,
            ),
            (
                "VK_EXT_attachment_feedback_loop_layout",
                self.ext_attachment_feedback_loop_layout,
            ),
            ("VK_EXT_blend_operation_advanced", self.ext_blend_operation_advanced),
            ("VK_EXT_border_color_swizzle", self.ext_border_color_swizzle),
            ("VK_EXT_buffer_device_address", self.ext_buffer_device_address),
            ("VK_EXT_calibrated_timestamps", self.ext_calibrated_timestamps),
            ("VK_EXT_color_write_enable", self.ext_color_write_enable),
            ("VK_EXT_conditional_rendering", self.ext_conditional_rendering),
            ("VK_EXT_conservative_rasterization", self.ext_conservative_rasterization),
            ("VK_EXT_custom_border_color", self.ext_custom_border_color),
            ("VK_EXT_debug_marker", self.ext_debug_marker),
            ("VK_EXT_depth_bias_control", self.ext_depth_bias_control),
            ("VK_EXT_depth_clamp_zero_one", self.ext_depth_clamp_zero_one),
            ("VK_EXT_depth_clip_control", self.ext_depth_clip_control),
            ("VK_EXT_depth_clip_enable", self.ext_depth_clip_enable),
            ("VK_EXT_depth_range_unrestricted", self.ext_depth_range_unrestricted),
            ("VK_EXT_descriptor_buffer", self.ext_descriptor_buffer),
            ("VK_EXT_descriptor_indexing", self.ext_descriptor_indexing),
            (
                "VK_EXT_device_address_binding_report",
                self.ext_device_address_binding_report,
            ),
            ("VK_EXT_device_fault", self.ext_device_fault),
            ("VK_EXT_device_memory_report", self.ext_device_memory_report),
            ("VK_EXT_discard_rectangles", self.ext_discard_rectangles),
            ("VK_EXT_display_control", self.ext_display_control),
            (
                "VK_EXT_dynamic_rendering_unused_attachments",
                self.ext_dynamic_rendering_unused_attachments,
            ),
            ("VK_EXT_extended_dynamic_state", self.ext_extended_dynamic_state),
            ("VK_EXT_extended_dynamic_state2", self.ext_extended_dynamic_state2),
            ("VK_EXT_extended_dynamic_state3", self.ext_extended_dynamic_state3),
            (
                "VK_EXT_external_memory_acquire_unmodified",
                self.ext_external_memory_acquire_unmodified,
            ),
            ("VK_EXT_external_memory_dma_buf", self.ext_external_memory_dma_buf),
            ("VK_EXT_external_memory_host", self.ext_external_memory_host),
            ("VK_EXT_filter_cubic", self.ext_filter_cubic),
            ("VK_EXT_fragment_density_map", self.ext_fragment_density_map),
            ("VK_EXT_fragment_density_map2", self.ext_fragment_density_map2),
            ("VK_EXT_fragment_shader_interlock", self.ext_fragment_shader_interlock),
            ("VK_EXT_frame_boundary", self.ext_frame_boundary),
            ("VK_EXT_full_screen_exclusive", self.ext_full_screen_exclusive),
            ("VK_EXT_global_priority", self.ext_global_priority),
            ("VK_EXT_global_priority_query", self.ext_global_priority_query),
            ("VK_EXT_graphics_pipeline_library", self.ext_graphics_pipeline_library),
            ("VK_EXT_hdr_metadata", self.ext_hdr_metadata),
            ("VK_EXT_host_image_copy", self.ext_host_image_copy),
            ("VK_EXT_host_query_reset", self.ext_host_query_reset),
            ("VK_EXT_image_2d_view_of_3d", self.ext_image_2d_view_of_3d),
            ("VK_EXT_image_compression_control", self.ext_image_compression_control),
            (
                "VK_EXT_image_compression_control_swapchain",
                self.ext_image_compression_control_swapchain,
            ),
            ("VK_EXT_image_drm_format_modifier", self.ext_image_drm_format_modifier),
            ("VK_EXT_image_robustness", self.ext_image_robustness),
            ("VK_EXT_image_sliced_view_of_3d", self.ext_image_sliced_view_of_3d),
            ("VK_EXT_image_view_min_lod", self.ext_image_view_min_lod),
            ("VK_EXT_index_type_uint8", self.ext_index_type_uint8),
            ("VK_EXT_inline_uniform_block", self.ext_inline_uniform_block),
            ("VK_EXT_legacy_dithering", self.ext_legacy_dithering),
            ("VK_EXT_line_rasterization", self.ext_line_rasterization),
            ("VK_EXT_load_store_op_none", self.ext_load_store_op_none),
            ("VK_EXT_map_memory_placed", self.ext_map_memory_placed),
            ("VK_EXT_memory_budget", self.ext_memory_budget),
            ("VK_EXT_memory_priority", self.ext_memory_priority),
            ("VK_EXT_mesh_shader", self.ext_mesh_shader),
            ("VK_EXT_metal_objects", self.ext_metal_objects),
            ("VK_EXT_multi_draw", self.ext_multi_draw),
            (
                "VK_EXT_multisampled_render_to_single_sampled",
                self.ext_multisampled_render_to_single_sampled,
            ),
            ("VK_EXT_mutable_descriptor_type", self.ext_mutable_descriptor_type),
            ("VK_EXT_nested_command_buffer", self.ext_nested_command_buffer),
            ("VK_EXT_non_seamless_cube_map", self.ext_non_seamless_cube_map),
            ("VK_EXT_opacity_micromap", self.ext_opacity_micromap),
            (
                "VK_EXT_pageable_device_local_memory",
                self.ext_pageable_device_local_memory,
            ),
            ("VK_EXT_pci_bus_info", self.ext_pci_bus_info),
            ("VK_EXT_physical_device_drm", self.ext_physical_device_drm),
            (
                "VK_EXT_pipeline_creation_cache_control",
                self.ext_pipeline_creation_cache_control,
            ),
            ("VK_EXT_pipeline_creation_feedback", self.ext_pipeline_creation_feedback),
            (
                "VK_EXT_pipeline_library_group_handles",
                self.ext_pipeline_library_group_handles,
            ),
            ("VK_EXT_pipeline_properties", self.ext_pipeline_properties),
            ("VK_EXT_pipeline_protected_access", self.ext_pipeline_protected_access),
            ("VK_EXT_pipeline_robustness", self.ext_pipeline_robustness),
            ("VK_EXT_post_depth_coverage", self.ext_post_depth_coverage),
            (
                "VK_EXT_primitive_topology_list_restart",
                self.ext_primitive_topology_list_restart,
            ),
            ("VK_EXT_primitives_generated_query", self.ext_primitives_generated_query),
            ("VK_EXT_private_data", self.ext_private_data),
            ("VK_EXT_provoking_vertex", self.ext_provoking_vertex),
            ("VK_EXT_queue_family_foreign", self.ext_queue_family_foreign),
            (
                "VK_EXT_rasterization_order_attachment_access",
                self.ext_rasterization_order_attachment_access,
            ),
            ("VK_EXT_rgba10x6_formats", self.ext_rgba10x6_formats),
            ("VK_EXT_robustness2", self.ext_robustness2),
            ("VK_EXT_sample_locations", self.ext_sample_locations),
            ("VK_EXT_sampler_filter_minmax", self.ext_sampler_filter_minmax),
            ("VK_EXT_scalar_block_layout", self.ext_scalar_block_layout),
            ("VK_EXT_separate_stencil_usage", self.ext_separate_stencil_usage),
            ("VK_EXT_shader_atomic_float", self.ext_shader_atomic_float),
            ("VK_EXT_shader_atomic_float2", self.ext_shader_atomic_float2),
            (
                "VK_EXT_shader_demote_to_helper_invocation",
                self.ext_shader_demote_to_helper_invocation,
            ),
            ("VK_EXT_shader_image_atomic_int64", self.ext_shader_image_atomic_int64),
            ("VK_EXT_shader_module_identifier", self.ext_shader_module_identifier),
            ("VK_EXT_shader_object", self.ext_shader_object),
            ("VK_EXT_shader_stencil_export", self.ext_shader_stencil_export),
            ("VK_EXT_shader_subgroup_ballot", self.ext_shader_subgroup_ballot),
            ("VK_EXT_shader_subgroup_vote", self.ext_shader_subgroup_vote),
            ("VK_EXT_shader_tile_image", self.ext_shader_tile_image),
            ("VK_EXT_shader_viewport_index_layer", self.ext_shader_viewport_index_layer),
            ("VK_EXT_subgroup_size_control", self.ext_subgroup_size_control),
            ("VK_EXT_subpass_merge_feedback", self.ext_subpass_merge_feedback),
            ("VK_EXT_swapchain_maintenance1", self.ext_swapchain_maintenance1),
            ("VK_EXT_texel_buffer_alignment", self.ext_texel_buffer_alignment),
            (
                "VK_EXT_texture_compression_astc_hdr",
                self.ext_texture_compression_astc_hdr,
            ),
            ("VK_EXT_tooling_info", self.ext_tooling_info),
            ("VK_EXT_transform_feedback", self.ext_transform_feedback),
            ("VK_EXT_validation_cache", self.ext_validation_cache),
            ("VK_EXT_vertex_attribute_divisor", self.ext_vertex_attribute_divisor),
            ("VK_EXT_vertex_input_dynamic_state", self.ext_vertex_input_dynamic_state),
            ("VK_EXT_ycbcr_2plane_444_formats", self.ext_ycbcr_2plane_444_formats),
            ("VK_EXT_ycbcr_image_arrays", self.ext_ycbcr_image_arrays),
            ("VK_AMDX_shader_enqueue", self.amdx_shader_enqueue),
            ("VK_AMD_buffer_marker", self.amd_buffer_marker),
            ("VK_AMD_device_coherent_memory", self.amd_device_coherent_memory),
            ("VK_AMD_display_native_hdr", self.amd_display_native_hdr),
            ("VK_AMD_draw_indirect_count", self.amd_draw_indirect_count),
            ("VK_AMD_gcn_shader", self.amd_gcn_shader),
            ("VK_AMD_gpu_shader_half_float", self.amd_gpu_shader_half_float),
            ("VK_AMD_gpu_shader_int16", self.amd_gpu_shader_int16),
            (
                "VK_AMD_memory_overallocation_behavior",
                self.amd_memory_overallocation_behavior,
            ),
            ("VK_AMD_mixed_attachment_samples", self.amd_mixed_attachment_samples),
            ("VK_AMD_pipeline_compiler_control", self.amd_pipeline_compiler_control),
            ("VK_AMD_rasterization_order", self.amd_rasterization_order),
            ("VK_AMD_shader_ballot", self.amd_shader_ballot),
            ("VK_AMD_shader_core_properties", self.amd_shader_core_properties),
            ("VK_AMD_shader_core_properties2", self.amd_shader_core_properties2),
            (
                "VK_AMD_shader_early_and_late_fragment_tests",
                self.amd_shader_early_and_late_fragment_tests,
            ),
            (
                "VK_AMD_shader_explicit_vertex_parameter",
                self.amd_shader_explicit_vertex_parameter,
            ),
            ("VK_AMD_shader_fragment_mask", self.amd_shader_fragment_mask),
            ("VK_AMD_shader_image_load_store_lod", self.amd_shader_image_load_store_lod),
            ("VK_AMD_shader_info", self.amd_shader_info),
            ("VK_AMD_shader_trinary_minmax", self.amd_shader_trinary_minmax),
            ("VK_AMD_texture_gather_bias_lod", self.amd_texture_gather_bias_lod),
            ("VK_ANDROID_external_format_resolve", self.android_external_format_resolve),
            (
                "VK_ANDROID_external_memory_android_hardware_buffer",
                self.android_external_memory_android_hardware_buffer,
            ),
            (
                "VK_ARM_rasterization_order_attachment_access",
                self.arm_rasterization_order_attachment_access,
            ),
            ("VK_ARM_render_pass_striped", self.arm_render_pass_striped),
            ("VK_ARM_scheduling_controls", self.arm_scheduling_controls),
            ("VK_ARM_shader_core_builtins", self.arm_shader_core_builtins),
            ("VK_ARM_shader_core_properties", self.arm_shader_core_properties),
            ("VK_FUCHSIA_buffer_collection", self.fuchsia_buffer_collection),
            ("VK_FUCHSIA_external_memory", self.fuchsia_external_memory),
            ("VK_FUCHSIA_external_semaphore", self.fuchsia_external_semaphore),
            ("VK_GGP_frame_token", self.ggp_frame_token),
            ("VK_GOOGLE_decorate_string", self.google_decorate_string),
            ("VK_GOOGLE_display_timing", self.google_display_timing),
            ("VK_GOOGLE_hlsl_functionality1", self.google_hlsl_functionality1),
            ("VK_GOOGLE_user_type", self.google_user_type),
            ("VK_HUAWEI_cluster_culling_shader", self.huawei_cluster_culling_shader),
            ("VK_HUAWEI_invocation_mask", self.huawei_invocation_mask),
            ("VK_HUAWEI_subpass_shading", self.huawei_subpass_shading),
            ("VK_IMG_filter_cubic", self.img_filter_cubic),
            ("VK_IMG_format_pvrtc", self.img_format_pvrtc),
            ("VK_IMG_relaxed_line_rasterization", self.img_relaxed_line_rasterization),
            ("VK_INTEL_performance_query", self.intel_performance_query),
            ("VK_INTEL_shader_integer_functions2", self.intel_shader_integer_functions2),
            ("VK_MSFT_layered_driver", self.msft_layered_driver),
            ("VK_NVX_binary_import", self.nvx_binary_import),
            ("VK_NVX_image_view_handle", self.nvx_image_view_handle),
            (
                "VK_NVX_multiview_per_view_attributes",
                self.nvx_multiview_per_view_attributes,
            ),
            ("VK_NV_acquire_winrt_display", self.nv_acquire_winrt_display),
            ("VK_NV_clip_space_w_scaling", self.nv_clip_space_w_scaling),
            ("VK_NV_compute_shader_derivatives", self.nv_compute_shader_derivatives),
            ("VK_NV_cooperative_matrix", self.nv_cooperative_matrix),
            ("VK_NV_copy_memory_indirect", self.nv_copy_memory_indirect),
            ("VK_NV_corner_sampled_image", self.nv_corner_sampled_image),
            ("VK_NV_coverage_reduction_mode", self.nv_coverage_reduction_mode),
            ("VK_NV_cuda_kernel_launch", self.nv_cuda_kernel_launch),
            ("VK_NV_dedicated_allocation", self.nv_dedicated_allocation),
            (
                "VK_NV_dedicated_allocation_image_aliasing",
                self.nv_dedicated_allocation_image_aliasing,
            ),
            (
                "VK_NV_descriptor_pool_overallocation",
                self.nv_descriptor_pool_overallocation,
            ),
            (
                "VK_NV_device_diagnostic_checkpoints",
                self.nv_device_diagnostic_checkpoints,
            ),
            ("VK_NV_device_diagnostics_config", self.nv_device_diagnostics_config),
            ("VK_NV_device_generated_commands", self.nv_device_generated_commands),
            (
                "VK_NV_device_generated_commands_compute",
                self.nv_device_generated_commands_compute,
            ),
            ("VK_NV_displacement_micromap", self.nv_displacement_micromap),
            (
                "VK_NV_extended_sparse_address_space",
                self.nv_extended_sparse_address_space,
            ),
            ("VK_NV_external_memory", self.nv_external_memory),
            ("VK_NV_external_memory_rdma", self.nv_external_memory_rdma),
            ("VK_NV_external_memory_win32", self.nv_external_memory_win32),
            ("VK_NV_fill_rectangle", self.nv_fill_rectangle),
            ("VK_NV_fragment_coverage_to_color", self.nv_fragment_coverage_to_color),
            ("VK_NV_fragment_shader_barycentric", self.nv_fragment_shader_barycentric),
            ("VK_NV_fragment_shading_rate_enums", self.nv_fragment_shading_rate_enums),
            ("VK_NV_framebuffer_mixed_samples", self.nv_framebuffer_mixed_samples),
            ("VK_NV_geometry_shader_passthrough", self.nv_geometry_shader_passthrough),
            ("VK_NV_glsl_shader", self.nv_glsl_shader),
            ("VK_NV_inherited_viewport_scissor", self.nv_inherited_viewport_scissor),
            ("VK_NV_linear_color_attachment", self.nv_linear_color_attachment),
            ("VK_NV_low_latency", self.nv_low_latency),
            ("VK_NV_low_latency2", self.nv_low_latency2),
            ("VK_NV_memory_decompression", self.nv_memory_decompression),
            ("VK_NV_mesh_shader", self.nv_mesh_shader),
            ("VK_NV_optical_flow", self.nv_optical_flow),
            ("VK_NV_per_stage_descriptor_set", self.nv_per_stage_descriptor_set),
            ("VK_NV_present_barrier", self.nv_present_barrier),
            ("VK_NV_raw_access_chains", self.nv_raw_access_chains),
            ("VK_NV_ray_tracing", self.nv_ray_tracing),
            (
                "VK_NV_ray_tracing_invocation_reorder",
                self.nv_ray_tracing_invocation_reorder,
            ),
            ("VK_NV_ray_tracing_motion_blur", self.nv_ray_tracing_motion_blur),
            ("VK_NV_ray_tracing_validation", self.nv_ray_tracing_validation),
            ("VK_NV_representative_fragment_test", self.nv_representative_fragment_test),
            (
                "VK_NV_sample_mask_override_coverage",
                self.nv_sample_mask_override_coverage,
            ),
            ("VK_NV_scissor_exclusive", self.nv_scissor_exclusive),
            ("VK_NV_shader_atomic_float16_vector", self.nv_shader_atomic_float16_vector),
            ("VK_NV_shader_image_footprint", self.nv_shader_image_footprint),
            ("VK_NV_shader_sm_builtins", self.nv_shader_sm_builtins),
            ("VK_NV_shader_subgroup_partitioned", self.nv_shader_subgroup_partitioned),
            ("VK_NV_shading_rate_image", self.nv_shading_rate_image),
            ("VK_NV_viewport_array2", self.nv_viewport_array2),
            ("VK_NV_viewport_swizzle", self.nv_viewport_swizzle),
            ("VK_NV_win32_keyed_mutex", self.nv_win32_keyed_mutex),
            ("VK_QCOM_filter_cubic_clamp", self.qcom_filter_cubic_clamp),
            ("VK_QCOM_filter_cubic_weights", self.qcom_filter_cubic_weights),
            (
                "VK_QCOM_fragment_density_map_offset",
                self.qcom_fragment_density_map_offset,
            ),
            ("VK_QCOM_image_processing", self.qcom_image_processing),
            ("VK_QCOM_image_processing2", self.qcom_image_processing2),
            (
                "VK_QCOM_multiview_per_view_render_areas",
                self.qcom_multiview_per_view_render_areas,
            ),
            (
                "VK_QCOM_multiview_per_view_viewports",
                self.qcom_multiview_per_view_viewports,
            ),
            ("VK_QCOM_render_pass_shader_resolve", self.qcom_render_pass_shader_resolve),
            ("VK_QCOM_render_pass_store_ops", self.qcom_render_pass_store_ops),
            ("VK_QCOM_render_pass_transform", self.qcom_render_pass_transform),
            ("VK_QCOM_rotated_copy_commands", self.qcom_rotated_copy_commands),
            ("VK_QCOM_tile_properties", self.qcom_tile_properties),
            ("VK_QCOM_ycbcr_degamma", self.qcom_ycbcr_degamma),
            (
                "VK_QNX_external_memory_screen_buffer",
                self.qnx_external_memory_screen_buffer,
            ),
            ("VK_SEC_amigo_profiling", self.sec_amigo_profiling),
            (
                "VK_VALVE_descriptor_set_host_mapping",
                self.valve_descriptor_set_host_mapping,
            ),
            ("VK_VALVE_mutable_descriptor_type", self.valve_mutable_descriptor_type),
        ]
            .into_iter()
    }
}
impl DeviceExtensions {
    /// Checks enabled extensions against the physical device support,
    /// and checks for required API version and instance extensions.
    pub(super) fn check_requirements(
        &self,
        supported: &DeviceExtensions,
        api_version: crate::Version,
        instance_extensions: &crate::instance::InstanceExtensions,
    ) -> Result<(), Box<crate::ValidationError>> {
        if self.khr_16bit_storage {
            if !supported.khr_16bit_storage {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_16bit_storage`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_get_physical_device_properties2)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_16bit_storage`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_physical_device_properties2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.khr_8bit_storage {
            if !supported.khr_8bit_storage {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_8bit_storage`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_get_physical_device_properties2)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_8bit_storage`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_physical_device_properties2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.khr_acceleration_structure {
            if !supported.khr_acceleration_structure {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_acceleration_structure`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1) {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_acceleration_structure`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.khr_bind_memory2 {
            if !supported.khr_bind_memory2 {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_bind_memory2`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.khr_buffer_device_address {
            if !supported.khr_buffer_device_address {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_buffer_device_address`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_get_physical_device_properties2)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_buffer_device_address`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_physical_device_properties2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.khr_calibrated_timestamps {
            if !supported.khr_calibrated_timestamps {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_calibrated_timestamps`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_get_physical_device_properties2)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_calibrated_timestamps`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_physical_device_properties2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.khr_cooperative_matrix {
            if !supported.khr_cooperative_matrix {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_cooperative_matrix`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_get_physical_device_properties2)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_cooperative_matrix`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_physical_device_properties2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.khr_copy_commands2 {
            if !supported.khr_copy_commands2 {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_copy_commands2`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_get_physical_device_properties2)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_copy_commands2`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_physical_device_properties2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.khr_create_renderpass2 {
            if !supported.khr_create_renderpass2 {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_create_renderpass2`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.khr_dedicated_allocation {
            if !supported.khr_dedicated_allocation {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_dedicated_allocation`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.khr_deferred_host_operations {
            if !supported.khr_deferred_host_operations {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_deferred_host_operations`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.khr_depth_stencil_resolve {
            if !supported.khr_depth_stencil_resolve {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_depth_stencil_resolve`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.khr_descriptor_update_template {
            if !supported.khr_descriptor_update_template {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_descriptor_update_template`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.khr_device_group {
            if !supported.khr_device_group {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_device_group`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_device_group_creation)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_device_group`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_device_group_creation",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.khr_display_swapchain {
            if !supported.khr_display_swapchain {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_display_swapchain`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(instance_extensions.khr_display) {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_display_swapchain`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::InstanceExtension("khr_display")],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.khr_draw_indirect_count {
            if !supported.khr_draw_indirect_count {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_draw_indirect_count`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.khr_driver_properties {
            if !supported.khr_driver_properties {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_driver_properties`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_get_physical_device_properties2)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_driver_properties`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_physical_device_properties2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.khr_dynamic_rendering {
            if !supported.khr_dynamic_rendering {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_dynamic_rendering`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_get_physical_device_properties2)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_dynamic_rendering`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_physical_device_properties2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.khr_dynamic_rendering_local_read {
            if !supported.khr_dynamic_rendering_local_read {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_dynamic_rendering_local_read`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.khr_external_fence {
            if !supported.khr_external_fence {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_external_fence`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_external_fence_capabilities)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_external_fence`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_external_fence_capabilities",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.khr_external_fence_fd {
            if !supported.khr_external_fence_fd {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_external_fence_fd`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.khr_external_fence_win32 {
            if !supported.khr_external_fence_win32 {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_external_fence_win32`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.khr_external_memory {
            if !supported.khr_external_memory {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_external_memory`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_external_memory_capabilities)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_external_memory`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_external_memory_capabilities",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.khr_external_memory_fd {
            if !supported.khr_external_memory_fd {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_external_memory_fd`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.khr_external_memory_win32 {
            if !supported.khr_external_memory_win32 {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_external_memory_win32`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.khr_external_semaphore {
            if !supported.khr_external_semaphore {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_external_semaphore`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_external_semaphore_capabilities)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_external_semaphore`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_external_semaphore_capabilities",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.khr_external_semaphore_fd {
            if !supported.khr_external_semaphore_fd {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_external_semaphore_fd`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.khr_external_semaphore_win32 {
            if !supported.khr_external_semaphore_win32 {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_external_semaphore_win32`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.khr_format_feature_flags2 {
            if !supported.khr_format_feature_flags2 {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_format_feature_flags2`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_get_physical_device_properties2)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_format_feature_flags2`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_physical_device_properties2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.khr_fragment_shader_barycentric {
            if !supported.khr_fragment_shader_barycentric {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_fragment_shader_barycentric`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_get_physical_device_properties2)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_fragment_shader_barycentric`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_physical_device_properties2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.khr_fragment_shading_rate {
            if !supported.khr_fragment_shading_rate {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_fragment_shading_rate`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_get_physical_device_properties2)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_fragment_shading_rate`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_physical_device_properties2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.khr_get_memory_requirements2 {
            if !supported.khr_get_memory_requirements2 {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_get_memory_requirements2`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.khr_global_priority {
            if !supported.khr_global_priority {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_global_priority`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_get_physical_device_properties2)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_global_priority`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_physical_device_properties2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.khr_image_format_list {
            if !supported.khr_image_format_list {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_image_format_list`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.khr_imageless_framebuffer {
            if !supported.khr_imageless_framebuffer {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_imageless_framebuffer`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_get_physical_device_properties2)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_imageless_framebuffer`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_physical_device_properties2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.khr_incremental_present {
            if !supported.khr_incremental_present {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_incremental_present`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.khr_index_type_uint8 {
            if !supported.khr_index_type_uint8 {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_index_type_uint8`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_get_physical_device_properties2)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_index_type_uint8`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_physical_device_properties2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.khr_line_rasterization {
            if !supported.khr_line_rasterization {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_line_rasterization`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_get_physical_device_properties2)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_line_rasterization`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_physical_device_properties2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.khr_load_store_op_none {
            if !supported.khr_load_store_op_none {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_load_store_op_none`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.khr_maintenance1 {
            if !supported.khr_maintenance1 {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_maintenance1`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.khr_maintenance2 {
            if !supported.khr_maintenance2 {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_maintenance2`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.khr_maintenance3 {
            if !supported.khr_maintenance3 {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_maintenance3`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_get_physical_device_properties2)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_maintenance3`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_physical_device_properties2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.khr_maintenance4 {
            if !supported.khr_maintenance4 {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_maintenance4`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1) {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_maintenance4`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.khr_maintenance5 {
            if !supported.khr_maintenance5 {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_maintenance5`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1) {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_maintenance5`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.khr_maintenance6 {
            if !supported.khr_maintenance6 {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_maintenance6`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1) {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_maintenance6`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.khr_map_memory2 {
            if !supported.khr_map_memory2 {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_map_memory2`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.khr_multiview {
            if !supported.khr_multiview {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_multiview`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_get_physical_device_properties2)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_multiview`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_physical_device_properties2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.khr_performance_query {
            if !supported.khr_performance_query {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_performance_query`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_get_physical_device_properties2)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_performance_query`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_physical_device_properties2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.khr_pipeline_executable_properties {
            if !supported.khr_pipeline_executable_properties {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_pipeline_executable_properties`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_get_physical_device_properties2)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_pipeline_executable_properties`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_physical_device_properties2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.khr_pipeline_library {
            if !supported.khr_pipeline_library {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_pipeline_library`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.khr_portability_subset {
            if !supported.khr_portability_subset {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_portability_subset`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_get_physical_device_properties2)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_portability_subset`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_physical_device_properties2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.khr_present_id {
            if !supported.khr_present_id {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_present_id`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_get_physical_device_properties2)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_present_id`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_physical_device_properties2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.khr_present_wait {
            if !supported.khr_present_wait {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_present_wait`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.khr_push_descriptor {
            if !supported.khr_push_descriptor {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_push_descriptor`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_get_physical_device_properties2)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_push_descriptor`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_physical_device_properties2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.khr_ray_query {
            if !supported.khr_ray_query {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_ray_query`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.khr_ray_tracing_maintenance1 {
            if !supported.khr_ray_tracing_maintenance1 {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_ray_tracing_maintenance1`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.khr_ray_tracing_pipeline {
            if !supported.khr_ray_tracing_pipeline {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_ray_tracing_pipeline`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.khr_ray_tracing_position_fetch {
            if !supported.khr_ray_tracing_position_fetch {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_ray_tracing_position_fetch`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.khr_relaxed_block_layout {
            if !supported.khr_relaxed_block_layout {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_relaxed_block_layout`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.khr_sampler_mirror_clamp_to_edge {
            if !supported.khr_sampler_mirror_clamp_to_edge {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_sampler_mirror_clamp_to_edge`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.khr_sampler_ycbcr_conversion {
            if !supported.khr_sampler_ycbcr_conversion {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_sampler_ycbcr_conversion`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_get_physical_device_properties2)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_sampler_ycbcr_conversion`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_physical_device_properties2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.khr_separate_depth_stencil_layouts {
            if !supported.khr_separate_depth_stencil_layouts {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_separate_depth_stencil_layouts`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_get_physical_device_properties2)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_separate_depth_stencil_layouts`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_physical_device_properties2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.khr_shader_atomic_int64 {
            if !supported.khr_shader_atomic_int64 {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_shader_atomic_int64`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_get_physical_device_properties2)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_shader_atomic_int64`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_physical_device_properties2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.khr_shader_clock {
            if !supported.khr_shader_clock {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_shader_clock`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_get_physical_device_properties2)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_shader_clock`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_physical_device_properties2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.khr_shader_draw_parameters {
            if !supported.khr_shader_draw_parameters {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_shader_draw_parameters`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.khr_shader_expect_assume {
            if !supported.khr_shader_expect_assume {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_shader_expect_assume`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_get_physical_device_properties2)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_shader_expect_assume`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_physical_device_properties2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.khr_shader_float16_int8 {
            if !supported.khr_shader_float16_int8 {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_shader_float16_int8`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_get_physical_device_properties2)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_shader_float16_int8`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_physical_device_properties2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.khr_shader_float_controls {
            if !supported.khr_shader_float_controls {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_shader_float_controls`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_get_physical_device_properties2)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_shader_float_controls`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_physical_device_properties2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.khr_shader_float_controls2 {
            if !supported.khr_shader_float_controls2 {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_shader_float_controls2`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1) {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_shader_float_controls2`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.khr_shader_integer_dot_product {
            if !supported.khr_shader_integer_dot_product {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_shader_integer_dot_product`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_get_physical_device_properties2)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_shader_integer_dot_product`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_physical_device_properties2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.khr_shader_maximal_reconvergence {
            if !supported.khr_shader_maximal_reconvergence {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_shader_maximal_reconvergence`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1) {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_shader_maximal_reconvergence`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.khr_shader_non_semantic_info {
            if !supported.khr_shader_non_semantic_info {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_shader_non_semantic_info`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.khr_shader_quad_control {
            if !supported.khr_shader_quad_control {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_shader_quad_control`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1) {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_shader_quad_control`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.khr_shader_subgroup_extended_types {
            if !supported.khr_shader_subgroup_extended_types {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_shader_subgroup_extended_types`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1) {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_shader_subgroup_extended_types`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.khr_shader_subgroup_rotate {
            if !supported.khr_shader_subgroup_rotate {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_shader_subgroup_rotate`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.khr_shader_subgroup_uniform_control_flow {
            if !supported.khr_shader_subgroup_uniform_control_flow {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_shader_subgroup_uniform_control_flow`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1) {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_shader_subgroup_uniform_control_flow`"
                            .into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.khr_shader_terminate_invocation {
            if !supported.khr_shader_terminate_invocation {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_shader_terminate_invocation`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_get_physical_device_properties2)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_shader_terminate_invocation`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_physical_device_properties2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.khr_shared_presentable_image {
            if !supported.khr_shared_presentable_image {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_shared_presentable_image`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(instance_extensions.khr_get_surface_capabilities2) {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_shared_presentable_image`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_surface_capabilities2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_get_physical_device_properties2)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_shared_presentable_image`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_physical_device_properties2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.khr_spirv_1_4 {
            if !supported.khr_spirv_1_4 {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_spirv_1_4`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1) {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_spirv_1_4`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.khr_storage_buffer_storage_class {
            if !supported.khr_storage_buffer_storage_class {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_storage_buffer_storage_class`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.khr_swapchain {
            if !supported.khr_swapchain {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_swapchain`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(instance_extensions.khr_surface) {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_swapchain`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::InstanceExtension("khr_surface")],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.khr_swapchain_mutable_format {
            if !supported.khr_swapchain_mutable_format {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_swapchain_mutable_format`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.khr_synchronization2 {
            if !supported.khr_synchronization2 {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_synchronization2`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_get_physical_device_properties2)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_synchronization2`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_physical_device_properties2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.khr_timeline_semaphore {
            if !supported.khr_timeline_semaphore {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_timeline_semaphore`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_get_physical_device_properties2)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_timeline_semaphore`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_physical_device_properties2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.khr_uniform_buffer_standard_layout {
            if !supported.khr_uniform_buffer_standard_layout {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_uniform_buffer_standard_layout`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_get_physical_device_properties2)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_uniform_buffer_standard_layout`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_physical_device_properties2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.khr_variable_pointers {
            if !supported.khr_variable_pointers {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_variable_pointers`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_get_physical_device_properties2)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_variable_pointers`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_physical_device_properties2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.khr_vertex_attribute_divisor {
            if !supported.khr_vertex_attribute_divisor {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_vertex_attribute_divisor`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_get_physical_device_properties2)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_vertex_attribute_divisor`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_physical_device_properties2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.khr_video_decode_av1 {
            if !supported.khr_video_decode_av1 {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_video_decode_av1`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.khr_video_decode_h264 {
            if !supported.khr_video_decode_h264 {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_video_decode_h264`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.khr_video_decode_h265 {
            if !supported.khr_video_decode_h265 {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_video_decode_h265`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.khr_video_decode_queue {
            if !supported.khr_video_decode_queue {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_video_decode_queue`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.khr_video_encode_h264 {
            if !supported.khr_video_encode_h264 {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_video_encode_h264`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.khr_video_encode_h265 {
            if !supported.khr_video_encode_h265 {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_video_encode_h265`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.khr_video_encode_queue {
            if !supported.khr_video_encode_queue {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_video_encode_queue`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.khr_video_maintenance1 {
            if !supported.khr_video_maintenance1 {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_video_maintenance1`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.khr_video_queue {
            if !supported.khr_video_queue {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_video_queue`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1) {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_video_queue`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.khr_vulkan_memory_model {
            if !supported.khr_vulkan_memory_model {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_vulkan_memory_model`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_get_physical_device_properties2)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_vulkan_memory_model`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_physical_device_properties2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.khr_win32_keyed_mutex {
            if !supported.khr_win32_keyed_mutex {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_win32_keyed_mutex`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.khr_workgroup_memory_explicit_layout {
            if !supported.khr_workgroup_memory_explicit_layout {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_workgroup_memory_explicit_layout`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_get_physical_device_properties2)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_workgroup_memory_explicit_layout`"
                            .into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_physical_device_properties2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.khr_zero_initialize_workgroup_memory {
            if !supported.khr_zero_initialize_workgroup_memory {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_zero_initialize_workgroup_memory`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_get_physical_device_properties2)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `khr_zero_initialize_workgroup_memory`"
                            .into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_physical_device_properties2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.ext_4444_formats {
            if !supported.ext_4444_formats {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_4444_formats`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_get_physical_device_properties2)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_4444_formats`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_physical_device_properties2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.ext_astc_decode_mode {
            if !supported.ext_astc_decode_mode {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_astc_decode_mode`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_get_physical_device_properties2)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_astc_decode_mode`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_physical_device_properties2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.ext_attachment_feedback_loop_dynamic_state {
            if !supported.ext_attachment_feedback_loop_dynamic_state {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_attachment_feedback_loop_dynamic_state`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_get_physical_device_properties2)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_attachment_feedback_loop_dynamic_state`"
                            .into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_physical_device_properties2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.ext_attachment_feedback_loop_layout {
            if !supported.ext_attachment_feedback_loop_layout {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_attachment_feedback_loop_layout`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_get_physical_device_properties2)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_attachment_feedback_loop_layout`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_physical_device_properties2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.ext_blend_operation_advanced {
            if !supported.ext_blend_operation_advanced {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_blend_operation_advanced`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_get_physical_device_properties2)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_blend_operation_advanced`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_physical_device_properties2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.ext_border_color_swizzle {
            if !supported.ext_border_color_swizzle {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_border_color_swizzle`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.ext_buffer_device_address {
            if !supported.ext_buffer_device_address {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_buffer_device_address`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_get_physical_device_properties2)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_buffer_device_address`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_physical_device_properties2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.ext_calibrated_timestamps {
            if !supported.ext_calibrated_timestamps {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_calibrated_timestamps`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_get_physical_device_properties2)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_calibrated_timestamps`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_physical_device_properties2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.ext_color_write_enable {
            if !supported.ext_color_write_enable {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_color_write_enable`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_get_physical_device_properties2)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_color_write_enable`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_physical_device_properties2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.ext_conditional_rendering {
            if !supported.ext_conditional_rendering {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_conditional_rendering`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_get_physical_device_properties2)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_conditional_rendering`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_physical_device_properties2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.ext_conservative_rasterization {
            if !supported.ext_conservative_rasterization {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_conservative_rasterization`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_get_physical_device_properties2)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_conservative_rasterization`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_physical_device_properties2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.ext_custom_border_color {
            if !supported.ext_custom_border_color {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_custom_border_color`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_get_physical_device_properties2)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_custom_border_color`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_physical_device_properties2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.ext_debug_marker {
            if !supported.ext_debug_marker {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_debug_marker`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(instance_extensions.ext_debug_report) {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_debug_marker`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::InstanceExtension("ext_debug_report")],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.ext_depth_bias_control {
            if !supported.ext_depth_bias_control {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_depth_bias_control`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_get_physical_device_properties2)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_depth_bias_control`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_physical_device_properties2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.ext_depth_clamp_zero_one {
            if !supported.ext_depth_clamp_zero_one {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_depth_clamp_zero_one`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_get_physical_device_properties2)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_depth_clamp_zero_one`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_physical_device_properties2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.ext_depth_clip_control {
            if !supported.ext_depth_clip_control {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_depth_clip_control`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_get_physical_device_properties2)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_depth_clip_control`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_physical_device_properties2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.ext_depth_clip_enable {
            if !supported.ext_depth_clip_enable {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_depth_clip_enable`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_get_physical_device_properties2)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_depth_clip_enable`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_physical_device_properties2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.ext_depth_range_unrestricted {
            if !supported.ext_depth_range_unrestricted {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_depth_range_unrestricted`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.ext_descriptor_buffer {
            if !supported.ext_descriptor_buffer {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_descriptor_buffer`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_get_physical_device_properties2)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_descriptor_buffer`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_physical_device_properties2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.ext_descriptor_indexing {
            if !supported.ext_descriptor_indexing {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_descriptor_indexing`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_get_physical_device_properties2)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_descriptor_indexing`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_physical_device_properties2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.ext_device_address_binding_report {
            if !supported.ext_device_address_binding_report {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_device_address_binding_report`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_get_physical_device_properties2)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_device_address_binding_report`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_physical_device_properties2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
            if !(instance_extensions.ext_debug_utils) {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_device_address_binding_report`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::InstanceExtension("ext_debug_utils")],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.ext_device_fault {
            if !supported.ext_device_fault {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_device_fault`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_get_physical_device_properties2)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_device_fault`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_physical_device_properties2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.ext_device_memory_report {
            if !supported.ext_device_memory_report {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_device_memory_report`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_get_physical_device_properties2)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_device_memory_report`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_physical_device_properties2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.ext_discard_rectangles {
            if !supported.ext_discard_rectangles {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_discard_rectangles`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_get_physical_device_properties2)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_discard_rectangles`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_physical_device_properties2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.ext_display_control {
            if !supported.ext_display_control {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_display_control`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(instance_extensions.ext_display_surface_counter) {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_display_control`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "ext_display_surface_counter",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.ext_dynamic_rendering_unused_attachments {
            if !supported.ext_dynamic_rendering_unused_attachments {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_dynamic_rendering_unused_attachments`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_get_physical_device_properties2)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_dynamic_rendering_unused_attachments`"
                            .into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_physical_device_properties2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.ext_extended_dynamic_state {
            if !supported.ext_extended_dynamic_state {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_extended_dynamic_state`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_get_physical_device_properties2)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_extended_dynamic_state`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_physical_device_properties2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.ext_extended_dynamic_state2 {
            if !supported.ext_extended_dynamic_state2 {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_extended_dynamic_state2`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_get_physical_device_properties2)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_extended_dynamic_state2`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_physical_device_properties2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.ext_extended_dynamic_state3 {
            if !supported.ext_extended_dynamic_state3 {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_extended_dynamic_state3`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_get_physical_device_properties2)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_extended_dynamic_state3`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_physical_device_properties2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.ext_external_memory_acquire_unmodified {
            if !supported.ext_external_memory_acquire_unmodified {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_external_memory_acquire_unmodified`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.ext_external_memory_dma_buf {
            if !supported.ext_external_memory_dma_buf {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_external_memory_dma_buf`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.ext_external_memory_host {
            if !supported.ext_external_memory_host {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_external_memory_host`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.ext_filter_cubic {
            if !supported.ext_filter_cubic {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_filter_cubic`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.ext_fragment_density_map {
            if !supported.ext_fragment_density_map {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_fragment_density_map`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_get_physical_device_properties2)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_fragment_density_map`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_physical_device_properties2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.ext_fragment_density_map2 {
            if !supported.ext_fragment_density_map2 {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_fragment_density_map2`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.ext_fragment_shader_interlock {
            if !supported.ext_fragment_shader_interlock {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_fragment_shader_interlock`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_get_physical_device_properties2)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_fragment_shader_interlock`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_physical_device_properties2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.ext_frame_boundary {
            if !supported.ext_frame_boundary {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_frame_boundary`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.ext_full_screen_exclusive {
            if !supported.ext_full_screen_exclusive {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_full_screen_exclusive`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_get_physical_device_properties2)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_full_screen_exclusive`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_physical_device_properties2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
            if !(instance_extensions.khr_surface) {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_full_screen_exclusive`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::InstanceExtension("khr_surface")],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
            if !(instance_extensions.khr_get_surface_capabilities2) {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_full_screen_exclusive`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_surface_capabilities2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.ext_global_priority {
            if !supported.ext_global_priority {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_global_priority`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.ext_global_priority_query {
            if !supported.ext_global_priority_query {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_global_priority_query`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_get_physical_device_properties2)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_global_priority_query`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_physical_device_properties2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.ext_graphics_pipeline_library {
            if !supported.ext_graphics_pipeline_library {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_graphics_pipeline_library`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_get_physical_device_properties2)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_graphics_pipeline_library`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_physical_device_properties2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.ext_hdr_metadata {
            if !supported.ext_hdr_metadata {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_hdr_metadata`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.ext_host_image_copy {
            if !supported.ext_host_image_copy {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_host_image_copy`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_get_physical_device_properties2)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_host_image_copy`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_physical_device_properties2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.ext_host_query_reset {
            if !supported.ext_host_query_reset {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_host_query_reset`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_get_physical_device_properties2)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_host_query_reset`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_physical_device_properties2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.ext_image_2d_view_of_3d {
            if !supported.ext_image_2d_view_of_3d {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_image_2d_view_of_3d`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_get_physical_device_properties2)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_image_2d_view_of_3d`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_physical_device_properties2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.ext_image_compression_control {
            if !supported.ext_image_compression_control {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_image_compression_control`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_get_physical_device_properties2)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_image_compression_control`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_physical_device_properties2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.ext_image_compression_control_swapchain {
            if !supported.ext_image_compression_control_swapchain {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_image_compression_control_swapchain`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.ext_image_drm_format_modifier {
            if !supported.ext_image_drm_format_modifier {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_image_drm_format_modifier`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_get_physical_device_properties2)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_image_drm_format_modifier`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_physical_device_properties2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.ext_image_robustness {
            if !supported.ext_image_robustness {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_image_robustness`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_get_physical_device_properties2)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_image_robustness`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_physical_device_properties2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.ext_image_sliced_view_of_3d {
            if !supported.ext_image_sliced_view_of_3d {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_image_sliced_view_of_3d`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_get_physical_device_properties2)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_image_sliced_view_of_3d`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_physical_device_properties2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.ext_image_view_min_lod {
            if !supported.ext_image_view_min_lod {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_image_view_min_lod`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_get_physical_device_properties2)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_image_view_min_lod`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_physical_device_properties2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.ext_index_type_uint8 {
            if !supported.ext_index_type_uint8 {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_index_type_uint8`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_get_physical_device_properties2)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_index_type_uint8`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_physical_device_properties2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.ext_inline_uniform_block {
            if !supported.ext_inline_uniform_block {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_inline_uniform_block`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_get_physical_device_properties2)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_inline_uniform_block`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_physical_device_properties2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.ext_legacy_dithering {
            if !supported.ext_legacy_dithering {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_legacy_dithering`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_get_physical_device_properties2)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_legacy_dithering`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_physical_device_properties2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.ext_line_rasterization {
            if !supported.ext_line_rasterization {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_line_rasterization`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_get_physical_device_properties2)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_line_rasterization`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_physical_device_properties2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.ext_load_store_op_none {
            if !supported.ext_load_store_op_none {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_load_store_op_none`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.ext_map_memory_placed {
            if !supported.ext_map_memory_placed {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_map_memory_placed`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.ext_memory_budget {
            if !supported.ext_memory_budget {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_memory_budget`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_get_physical_device_properties2)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_memory_budget`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_physical_device_properties2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.ext_memory_priority {
            if !supported.ext_memory_priority {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_memory_priority`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_get_physical_device_properties2)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_memory_priority`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_physical_device_properties2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.ext_mesh_shader {
            if !supported.ext_mesh_shader {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_mesh_shader`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.ext_metal_objects {
            if !supported.ext_metal_objects {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_metal_objects`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.ext_multi_draw {
            if !supported.ext_multi_draw {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_multi_draw`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_get_physical_device_properties2)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_multi_draw`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_physical_device_properties2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.ext_multisampled_render_to_single_sampled {
            if !supported.ext_multisampled_render_to_single_sampled {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_multisampled_render_to_single_sampled`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.ext_mutable_descriptor_type {
            if !supported.ext_mutable_descriptor_type {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_mutable_descriptor_type`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.ext_nested_command_buffer {
            if !supported.ext_nested_command_buffer {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_nested_command_buffer`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_get_physical_device_properties2)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_nested_command_buffer`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_physical_device_properties2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.ext_non_seamless_cube_map {
            if !supported.ext_non_seamless_cube_map {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_non_seamless_cube_map`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_get_physical_device_properties2)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_non_seamless_cube_map`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_physical_device_properties2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.ext_opacity_micromap {
            if !supported.ext_opacity_micromap {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_opacity_micromap`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.ext_pageable_device_local_memory {
            if !supported.ext_pageable_device_local_memory {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_pageable_device_local_memory`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.ext_pci_bus_info {
            if !supported.ext_pci_bus_info {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_pci_bus_info`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_get_physical_device_properties2)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_pci_bus_info`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_physical_device_properties2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.ext_physical_device_drm {
            if !supported.ext_physical_device_drm {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_physical_device_drm`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_get_physical_device_properties2)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_physical_device_drm`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_physical_device_properties2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.ext_pipeline_creation_cache_control {
            if !supported.ext_pipeline_creation_cache_control {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_pipeline_creation_cache_control`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_get_physical_device_properties2)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_pipeline_creation_cache_control`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_physical_device_properties2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.ext_pipeline_creation_feedback {
            if !supported.ext_pipeline_creation_feedback {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_pipeline_creation_feedback`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.ext_pipeline_library_group_handles {
            if !supported.ext_pipeline_library_group_handles {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_pipeline_library_group_handles`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.ext_pipeline_properties {
            if !supported.ext_pipeline_properties {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_pipeline_properties`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_get_physical_device_properties2)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_pipeline_properties`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_physical_device_properties2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.ext_pipeline_protected_access {
            if !supported.ext_pipeline_protected_access {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_pipeline_protected_access`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_get_physical_device_properties2)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_pipeline_protected_access`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_physical_device_properties2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.ext_pipeline_robustness {
            if !supported.ext_pipeline_robustness {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_pipeline_robustness`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_get_physical_device_properties2)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_pipeline_robustness`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_physical_device_properties2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.ext_post_depth_coverage {
            if !supported.ext_post_depth_coverage {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_post_depth_coverage`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.ext_primitive_topology_list_restart {
            if !supported.ext_primitive_topology_list_restart {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_primitive_topology_list_restart`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_get_physical_device_properties2)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_primitive_topology_list_restart`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_physical_device_properties2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.ext_primitives_generated_query {
            if !supported.ext_primitives_generated_query {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_primitives_generated_query`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.ext_private_data {
            if !supported.ext_private_data {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_private_data`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_get_physical_device_properties2)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_private_data`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_physical_device_properties2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.ext_provoking_vertex {
            if !supported.ext_provoking_vertex {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_provoking_vertex`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_get_physical_device_properties2)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_provoking_vertex`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_physical_device_properties2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.ext_queue_family_foreign {
            if !supported.ext_queue_family_foreign {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_queue_family_foreign`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.ext_rasterization_order_attachment_access {
            if !supported.ext_rasterization_order_attachment_access {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_rasterization_order_attachment_access`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_get_physical_device_properties2)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_rasterization_order_attachment_access`"
                            .into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_physical_device_properties2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.ext_rgba10x6_formats {
            if !supported.ext_rgba10x6_formats {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_rgba10x6_formats`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.ext_robustness2 {
            if !supported.ext_robustness2 {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_robustness2`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_get_physical_device_properties2)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_robustness2`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_physical_device_properties2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.ext_sample_locations {
            if !supported.ext_sample_locations {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_sample_locations`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_get_physical_device_properties2)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_sample_locations`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_physical_device_properties2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.ext_sampler_filter_minmax {
            if !supported.ext_sampler_filter_minmax {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_sampler_filter_minmax`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_get_physical_device_properties2)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_sampler_filter_minmax`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_physical_device_properties2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.ext_scalar_block_layout {
            if !supported.ext_scalar_block_layout {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_scalar_block_layout`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_get_physical_device_properties2)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_scalar_block_layout`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_physical_device_properties2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.ext_separate_stencil_usage {
            if !supported.ext_separate_stencil_usage {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_separate_stencil_usage`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.ext_shader_atomic_float {
            if !supported.ext_shader_atomic_float {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_shader_atomic_float`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_get_physical_device_properties2)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_shader_atomic_float`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_physical_device_properties2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.ext_shader_atomic_float2 {
            if !supported.ext_shader_atomic_float2 {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_shader_atomic_float2`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.ext_shader_demote_to_helper_invocation {
            if !supported.ext_shader_demote_to_helper_invocation {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_shader_demote_to_helper_invocation`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_get_physical_device_properties2)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_shader_demote_to_helper_invocation`"
                            .into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_physical_device_properties2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.ext_shader_image_atomic_int64 {
            if !supported.ext_shader_image_atomic_int64 {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_shader_image_atomic_int64`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_get_physical_device_properties2)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_shader_image_atomic_int64`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_physical_device_properties2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.ext_shader_module_identifier {
            if !supported.ext_shader_module_identifier {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_shader_module_identifier`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_get_physical_device_properties2)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_shader_module_identifier`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_physical_device_properties2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.ext_shader_object {
            if !supported.ext_shader_object {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_shader_object`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_get_physical_device_properties2)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_shader_object`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_physical_device_properties2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.ext_shader_stencil_export {
            if !supported.ext_shader_stencil_export {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_shader_stencil_export`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.ext_shader_subgroup_ballot {
            if !supported.ext_shader_subgroup_ballot {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_shader_subgroup_ballot`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.ext_shader_subgroup_vote {
            if !supported.ext_shader_subgroup_vote {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_shader_subgroup_vote`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.ext_shader_tile_image {
            if !supported.ext_shader_tile_image {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_shader_tile_image`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_3) {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_shader_tile_image`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_3)],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.ext_shader_viewport_index_layer {
            if !supported.ext_shader_viewport_index_layer {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_shader_viewport_index_layer`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.ext_subgroup_size_control {
            if !supported.ext_subgroup_size_control {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_subgroup_size_control`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1) {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_subgroup_size_control`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.ext_subpass_merge_feedback {
            if !supported.ext_subpass_merge_feedback {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_subpass_merge_feedback`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_get_physical_device_properties2)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_subpass_merge_feedback`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_physical_device_properties2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.ext_swapchain_maintenance1 {
            if !supported.ext_swapchain_maintenance1 {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_swapchain_maintenance1`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(instance_extensions.ext_surface_maintenance1) {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_swapchain_maintenance1`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "ext_surface_maintenance1",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_get_physical_device_properties2)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_swapchain_maintenance1`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_physical_device_properties2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.ext_texel_buffer_alignment {
            if !supported.ext_texel_buffer_alignment {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_texel_buffer_alignment`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_get_physical_device_properties2)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_texel_buffer_alignment`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_physical_device_properties2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.ext_texture_compression_astc_hdr {
            if !supported.ext_texture_compression_astc_hdr {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_texture_compression_astc_hdr`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_get_physical_device_properties2)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_texture_compression_astc_hdr`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_physical_device_properties2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.ext_tooling_info {
            if !supported.ext_tooling_info {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_tooling_info`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.ext_transform_feedback {
            if !supported.ext_transform_feedback {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_transform_feedback`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_get_physical_device_properties2)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_transform_feedback`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_physical_device_properties2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.ext_validation_cache {
            if !supported.ext_validation_cache {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_validation_cache`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.ext_vertex_attribute_divisor {
            if !supported.ext_vertex_attribute_divisor {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_vertex_attribute_divisor`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_get_physical_device_properties2)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_vertex_attribute_divisor`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_physical_device_properties2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.ext_vertex_input_dynamic_state {
            if !supported.ext_vertex_input_dynamic_state {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_vertex_input_dynamic_state`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_get_physical_device_properties2)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_vertex_input_dynamic_state`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_physical_device_properties2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.ext_ycbcr_2plane_444_formats {
            if !supported.ext_ycbcr_2plane_444_formats {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_ycbcr_2plane_444_formats`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.ext_ycbcr_image_arrays {
            if !supported.ext_ycbcr_image_arrays {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ext_ycbcr_image_arrays`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.amdx_shader_enqueue {
            if !supported.amdx_shader_enqueue {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `amdx_shader_enqueue`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_get_physical_device_properties2)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `amdx_shader_enqueue`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_physical_device_properties2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.amd_buffer_marker {
            if !supported.amd_buffer_marker {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `amd_buffer_marker`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.amd_device_coherent_memory {
            if !supported.amd_device_coherent_memory {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `amd_device_coherent_memory`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_get_physical_device_properties2)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `amd_device_coherent_memory`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_physical_device_properties2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.amd_display_native_hdr {
            if !supported.amd_display_native_hdr {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `amd_display_native_hdr`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_get_physical_device_properties2)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `amd_display_native_hdr`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_physical_device_properties2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
            if !(instance_extensions.khr_get_surface_capabilities2) {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `amd_display_native_hdr`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_surface_capabilities2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.amd_draw_indirect_count {
            if !supported.amd_draw_indirect_count {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `amd_draw_indirect_count`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.amd_gcn_shader {
            if !supported.amd_gcn_shader {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `amd_gcn_shader`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.amd_gpu_shader_half_float {
            if !supported.amd_gpu_shader_half_float {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `amd_gpu_shader_half_float`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.amd_gpu_shader_int16 {
            if !supported.amd_gpu_shader_int16 {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `amd_gpu_shader_int16`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.amd_memory_overallocation_behavior {
            if !supported.amd_memory_overallocation_behavior {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `amd_memory_overallocation_behavior`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.amd_mixed_attachment_samples {
            if !supported.amd_mixed_attachment_samples {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `amd_mixed_attachment_samples`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.amd_pipeline_compiler_control {
            if !supported.amd_pipeline_compiler_control {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `amd_pipeline_compiler_control`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.amd_rasterization_order {
            if !supported.amd_rasterization_order {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `amd_rasterization_order`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.amd_shader_ballot {
            if !supported.amd_shader_ballot {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `amd_shader_ballot`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.amd_shader_core_properties {
            if !supported.amd_shader_core_properties {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `amd_shader_core_properties`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_get_physical_device_properties2)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `amd_shader_core_properties`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_physical_device_properties2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.amd_shader_core_properties2 {
            if !supported.amd_shader_core_properties2 {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `amd_shader_core_properties2`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.amd_shader_early_and_late_fragment_tests {
            if !supported.amd_shader_early_and_late_fragment_tests {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `amd_shader_early_and_late_fragment_tests`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_get_physical_device_properties2)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `amd_shader_early_and_late_fragment_tests`"
                            .into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_physical_device_properties2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.amd_shader_explicit_vertex_parameter {
            if !supported.amd_shader_explicit_vertex_parameter {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `amd_shader_explicit_vertex_parameter`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.amd_shader_fragment_mask {
            if !supported.amd_shader_fragment_mask {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `amd_shader_fragment_mask`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.amd_shader_image_load_store_lod {
            if !supported.amd_shader_image_load_store_lod {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `amd_shader_image_load_store_lod`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.amd_shader_info {
            if !supported.amd_shader_info {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `amd_shader_info`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.amd_shader_trinary_minmax {
            if !supported.amd_shader_trinary_minmax {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `amd_shader_trinary_minmax`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.amd_texture_gather_bias_lod {
            if !supported.amd_texture_gather_bias_lod {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `amd_texture_gather_bias_lod`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_get_physical_device_properties2)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `amd_texture_gather_bias_lod`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_physical_device_properties2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.android_external_format_resolve {
            if !supported.android_external_format_resolve {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `android_external_format_resolve`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.android_external_memory_android_hardware_buffer {
            if !supported.android_external_memory_android_hardware_buffer {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `android_external_memory_android_hardware_buffer`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.arm_rasterization_order_attachment_access {
            if !supported.arm_rasterization_order_attachment_access {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `arm_rasterization_order_attachment_access`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_get_physical_device_properties2)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `arm_rasterization_order_attachment_access`"
                            .into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_physical_device_properties2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.arm_render_pass_striped {
            if !supported.arm_render_pass_striped {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `arm_render_pass_striped`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_get_physical_device_properties2)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `arm_render_pass_striped`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_physical_device_properties2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.arm_scheduling_controls {
            if !supported.arm_scheduling_controls {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `arm_scheduling_controls`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.arm_shader_core_builtins {
            if !supported.arm_shader_core_builtins {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `arm_shader_core_builtins`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_get_physical_device_properties2)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `arm_shader_core_builtins`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_physical_device_properties2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.arm_shader_core_properties {
            if !supported.arm_shader_core_properties {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `arm_shader_core_properties`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1) {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `arm_shader_core_properties`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.fuchsia_buffer_collection {
            if !supported.fuchsia_buffer_collection {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `fuchsia_buffer_collection`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.fuchsia_external_memory {
            if !supported.fuchsia_external_memory {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `fuchsia_external_memory`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_external_memory_capabilities)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `fuchsia_external_memory`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_external_memory_capabilities",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.fuchsia_external_semaphore {
            if !supported.fuchsia_external_semaphore {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `fuchsia_external_semaphore`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_external_semaphore_capabilities)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `fuchsia_external_semaphore`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_external_semaphore_capabilities",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.ggp_frame_token {
            if !supported.ggp_frame_token {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ggp_frame_token`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(instance_extensions.ggp_stream_descriptor_surface) {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `ggp_frame_token`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "ggp_stream_descriptor_surface",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.google_decorate_string {
            if !supported.google_decorate_string {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `google_decorate_string`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.google_display_timing {
            if !supported.google_display_timing {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `google_display_timing`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.google_hlsl_functionality1 {
            if !supported.google_hlsl_functionality1 {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `google_hlsl_functionality1`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.google_user_type {
            if !supported.google_user_type {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `google_user_type`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.huawei_cluster_culling_shader {
            if !supported.huawei_cluster_culling_shader {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `huawei_cluster_culling_shader`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_get_physical_device_properties2)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `huawei_cluster_culling_shader`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_physical_device_properties2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.huawei_invocation_mask {
            if !supported.huawei_invocation_mask {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `huawei_invocation_mask`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.huawei_subpass_shading {
            if !supported.huawei_subpass_shading {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `huawei_subpass_shading`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.img_filter_cubic {
            if !supported.img_filter_cubic {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `img_filter_cubic`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.img_format_pvrtc {
            if !supported.img_format_pvrtc {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `img_format_pvrtc`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.img_relaxed_line_rasterization {
            if !supported.img_relaxed_line_rasterization {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `img_relaxed_line_rasterization`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_get_physical_device_properties2)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `img_relaxed_line_rasterization`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_physical_device_properties2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.intel_performance_query {
            if !supported.intel_performance_query {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `intel_performance_query`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.intel_shader_integer_functions2 {
            if !supported.intel_shader_integer_functions2 {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `intel_shader_integer_functions2`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_get_physical_device_properties2)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `intel_shader_integer_functions2`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_physical_device_properties2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.msft_layered_driver {
            if !supported.msft_layered_driver {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `msft_layered_driver`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_get_physical_device_properties2)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `msft_layered_driver`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_physical_device_properties2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.nvx_binary_import {
            if !supported.nvx_binary_import {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `nvx_binary_import`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.nvx_image_view_handle {
            if !supported.nvx_image_view_handle {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `nvx_image_view_handle`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.nvx_multiview_per_view_attributes {
            if !supported.nvx_multiview_per_view_attributes {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `nvx_multiview_per_view_attributes`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.nv_acquire_winrt_display {
            if !supported.nv_acquire_winrt_display {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `nv_acquire_winrt_display`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(instance_extensions.ext_direct_mode_display) {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `nv_acquire_winrt_display`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "ext_direct_mode_display",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.nv_clip_space_w_scaling {
            if !supported.nv_clip_space_w_scaling {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `nv_clip_space_w_scaling`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.nv_compute_shader_derivatives {
            if !supported.nv_compute_shader_derivatives {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `nv_compute_shader_derivatives`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_get_physical_device_properties2)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `nv_compute_shader_derivatives`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_physical_device_properties2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.nv_cooperative_matrix {
            if !supported.nv_cooperative_matrix {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `nv_cooperative_matrix`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_get_physical_device_properties2)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `nv_cooperative_matrix`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_physical_device_properties2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.nv_copy_memory_indirect {
            if !supported.nv_copy_memory_indirect {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `nv_copy_memory_indirect`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_get_physical_device_properties2)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `nv_copy_memory_indirect`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_physical_device_properties2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.nv_corner_sampled_image {
            if !supported.nv_corner_sampled_image {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `nv_corner_sampled_image`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_get_physical_device_properties2)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `nv_corner_sampled_image`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_physical_device_properties2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.nv_coverage_reduction_mode {
            if !supported.nv_coverage_reduction_mode {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `nv_coverage_reduction_mode`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_get_physical_device_properties2)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `nv_coverage_reduction_mode`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_physical_device_properties2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.nv_cuda_kernel_launch {
            if !supported.nv_cuda_kernel_launch {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `nv_cuda_kernel_launch`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.nv_dedicated_allocation {
            if !supported.nv_dedicated_allocation {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `nv_dedicated_allocation`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.nv_dedicated_allocation_image_aliasing {
            if !supported.nv_dedicated_allocation_image_aliasing {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `nv_dedicated_allocation_image_aliasing`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_get_physical_device_properties2)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `nv_dedicated_allocation_image_aliasing`"
                            .into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_physical_device_properties2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.nv_descriptor_pool_overallocation {
            if !supported.nv_descriptor_pool_overallocation {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `nv_descriptor_pool_overallocation`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1) {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `nv_descriptor_pool_overallocation`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.nv_device_diagnostic_checkpoints {
            if !supported.nv_device_diagnostic_checkpoints {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `nv_device_diagnostic_checkpoints`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_get_physical_device_properties2)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `nv_device_diagnostic_checkpoints`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_physical_device_properties2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.nv_device_diagnostics_config {
            if !supported.nv_device_diagnostics_config {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `nv_device_diagnostics_config`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_get_physical_device_properties2)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `nv_device_diagnostics_config`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_physical_device_properties2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.nv_device_generated_commands {
            if !supported.nv_device_generated_commands {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `nv_device_generated_commands`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1) {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `nv_device_generated_commands`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.nv_device_generated_commands_compute {
            if !supported.nv_device_generated_commands_compute {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `nv_device_generated_commands_compute`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.nv_displacement_micromap {
            if !supported.nv_displacement_micromap {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `nv_displacement_micromap`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.nv_extended_sparse_address_space {
            if !supported.nv_extended_sparse_address_space {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `nv_extended_sparse_address_space`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.nv_external_memory {
            if !supported.nv_external_memory {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `nv_external_memory`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(instance_extensions.nv_external_memory_capabilities) {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `nv_external_memory`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "nv_external_memory_capabilities",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.nv_external_memory_rdma {
            if !supported.nv_external_memory_rdma {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `nv_external_memory_rdma`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.nv_external_memory_win32 {
            if !supported.nv_external_memory_win32 {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `nv_external_memory_win32`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.nv_fill_rectangle {
            if !supported.nv_fill_rectangle {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `nv_fill_rectangle`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.nv_fragment_coverage_to_color {
            if !supported.nv_fragment_coverage_to_color {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `nv_fragment_coverage_to_color`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.nv_fragment_shader_barycentric {
            if !supported.nv_fragment_shader_barycentric {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `nv_fragment_shader_barycentric`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_get_physical_device_properties2)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `nv_fragment_shader_barycentric`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_physical_device_properties2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.nv_fragment_shading_rate_enums {
            if !supported.nv_fragment_shading_rate_enums {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `nv_fragment_shading_rate_enums`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.nv_framebuffer_mixed_samples {
            if !supported.nv_framebuffer_mixed_samples {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `nv_framebuffer_mixed_samples`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.nv_geometry_shader_passthrough {
            if !supported.nv_geometry_shader_passthrough {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `nv_geometry_shader_passthrough`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.nv_glsl_shader {
            if !supported.nv_glsl_shader {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `nv_glsl_shader`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.nv_inherited_viewport_scissor {
            if !supported.nv_inherited_viewport_scissor {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `nv_inherited_viewport_scissor`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_get_physical_device_properties2)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `nv_inherited_viewport_scissor`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_physical_device_properties2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.nv_linear_color_attachment {
            if !supported.nv_linear_color_attachment {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `nv_linear_color_attachment`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_get_physical_device_properties2)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `nv_linear_color_attachment`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_physical_device_properties2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.nv_low_latency {
            if !supported.nv_low_latency {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `nv_low_latency`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.nv_low_latency2 {
            if !supported.nv_low_latency2 {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `nv_low_latency2`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.nv_memory_decompression {
            if !supported.nv_memory_decompression {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `nv_memory_decompression`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_get_physical_device_properties2)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `nv_memory_decompression`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_physical_device_properties2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.nv_mesh_shader {
            if !supported.nv_mesh_shader {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `nv_mesh_shader`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_get_physical_device_properties2)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `nv_mesh_shader`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_physical_device_properties2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.nv_optical_flow {
            if !supported.nv_optical_flow {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `nv_optical_flow`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_get_physical_device_properties2)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `nv_optical_flow`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_physical_device_properties2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.nv_per_stage_descriptor_set {
            if !supported.nv_per_stage_descriptor_set {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `nv_per_stage_descriptor_set`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.nv_present_barrier {
            if !supported.nv_present_barrier {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `nv_present_barrier`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_get_physical_device_properties2)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `nv_present_barrier`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_physical_device_properties2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
            if !(instance_extensions.khr_surface) {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `nv_present_barrier`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::InstanceExtension("khr_surface")],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
            if !(instance_extensions.khr_get_surface_capabilities2) {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `nv_present_barrier`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_surface_capabilities2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.nv_raw_access_chains {
            if !supported.nv_raw_access_chains {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `nv_raw_access_chains`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.nv_ray_tracing {
            if !supported.nv_ray_tracing {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `nv_ray_tracing`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_get_physical_device_properties2)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `nv_ray_tracing`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_physical_device_properties2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.nv_ray_tracing_invocation_reorder {
            if !supported.nv_ray_tracing_invocation_reorder {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `nv_ray_tracing_invocation_reorder`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.nv_ray_tracing_motion_blur {
            if !supported.nv_ray_tracing_motion_blur {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `nv_ray_tracing_motion_blur`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.nv_ray_tracing_validation {
            if !supported.nv_ray_tracing_validation {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `nv_ray_tracing_validation`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.nv_representative_fragment_test {
            if !supported.nv_representative_fragment_test {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `nv_representative_fragment_test`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_get_physical_device_properties2)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `nv_representative_fragment_test`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_physical_device_properties2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.nv_sample_mask_override_coverage {
            if !supported.nv_sample_mask_override_coverage {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `nv_sample_mask_override_coverage`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.nv_scissor_exclusive {
            if !supported.nv_scissor_exclusive {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `nv_scissor_exclusive`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_get_physical_device_properties2)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `nv_scissor_exclusive`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_physical_device_properties2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.nv_shader_atomic_float16_vector {
            if !supported.nv_shader_atomic_float16_vector {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `nv_shader_atomic_float16_vector`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.nv_shader_image_footprint {
            if !supported.nv_shader_image_footprint {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `nv_shader_image_footprint`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_get_physical_device_properties2)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `nv_shader_image_footprint`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_physical_device_properties2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.nv_shader_sm_builtins {
            if !supported.nv_shader_sm_builtins {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `nv_shader_sm_builtins`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1) {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `nv_shader_sm_builtins`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.nv_shader_subgroup_partitioned {
            if !supported.nv_shader_subgroup_partitioned {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `nv_shader_subgroup_partitioned`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1) {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `nv_shader_subgroup_partitioned`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.nv_shading_rate_image {
            if !supported.nv_shading_rate_image {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `nv_shading_rate_image`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_get_physical_device_properties2)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `nv_shading_rate_image`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_physical_device_properties2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.nv_viewport_array2 {
            if !supported.nv_viewport_array2 {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `nv_viewport_array2`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.nv_viewport_swizzle {
            if !supported.nv_viewport_swizzle {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `nv_viewport_swizzle`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.nv_win32_keyed_mutex {
            if !supported.nv_win32_keyed_mutex {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `nv_win32_keyed_mutex`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.qcom_filter_cubic_clamp {
            if !supported.qcom_filter_cubic_clamp {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `qcom_filter_cubic_clamp`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.qcom_filter_cubic_weights {
            if !supported.qcom_filter_cubic_weights {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `qcom_filter_cubic_weights`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.qcom_fragment_density_map_offset {
            if !supported.qcom_fragment_density_map_offset {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `qcom_fragment_density_map_offset`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_get_physical_device_properties2)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `qcom_fragment_density_map_offset`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_physical_device_properties2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.qcom_image_processing {
            if !supported.qcom_image_processing {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `qcom_image_processing`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.qcom_image_processing2 {
            if !supported.qcom_image_processing2 {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `qcom_image_processing2`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.qcom_multiview_per_view_render_areas {
            if !supported.qcom_multiview_per_view_render_areas {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `qcom_multiview_per_view_render_areas`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.qcom_multiview_per_view_viewports {
            if !supported.qcom_multiview_per_view_viewports {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `qcom_multiview_per_view_viewports`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_get_physical_device_properties2)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `qcom_multiview_per_view_viewports`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_physical_device_properties2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.qcom_render_pass_shader_resolve {
            if !supported.qcom_render_pass_shader_resolve {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `qcom_render_pass_shader_resolve`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.qcom_render_pass_store_ops {
            if !supported.qcom_render_pass_store_ops {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `qcom_render_pass_store_ops`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.qcom_render_pass_transform {
            if !supported.qcom_render_pass_transform {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `qcom_render_pass_transform`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.qcom_rotated_copy_commands {
            if !supported.qcom_rotated_copy_commands {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `qcom_rotated_copy_commands`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.qcom_tile_properties {
            if !supported.qcom_tile_properties {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `qcom_tile_properties`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_get_physical_device_properties2)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `qcom_tile_properties`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_physical_device_properties2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.qcom_ycbcr_degamma {
            if !supported.qcom_ycbcr_degamma {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `qcom_ycbcr_degamma`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.qnx_external_memory_screen_buffer {
            if !supported.qnx_external_memory_screen_buffer {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `qnx_external_memory_screen_buffer`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.sec_amigo_profiling {
            if !supported.sec_amigo_profiling {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `sec_amigo_profiling`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_get_physical_device_properties2)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `sec_amigo_profiling`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_physical_device_properties2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.valve_descriptor_set_host_mapping {
            if !supported.valve_descriptor_set_host_mapping {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `valve_descriptor_set_host_mapping`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
            if !(api_version >= crate::Version::V1_1
                || instance_extensions.khr_get_physical_device_properties2)
            {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `valve_descriptor_set_host_mapping`".into(),
                        requires_one_of: crate::RequiresOneOf(
                            &[
                                crate::RequiresAllOf(
                                    &[crate::Requires::APIVersion(crate::Version::V1_1)],
                                ),
                                crate::RequiresAllOf(
                                    &[
                                        crate::Requires::InstanceExtension(
                                            "khr_get_physical_device_properties2",
                                        ),
                                    ],
                                ),
                            ],
                        ),
                        ..Default::default()
                    }),
                );
            }
        }
        if self.valve_mutable_descriptor_type {
            if !supported.valve_mutable_descriptor_type {
                return Err(
                    Box::new(crate::ValidationError {
                        problem: "contains `valve_mutable_descriptor_type`, but this extension is not supported by the physical device"
                            .into(),
                        ..Default::default()
                    }),
                );
            }
        }
        Ok(())
    }
    /// Enables all the extensions that the extensions in `self` currently depend on.
    pub(super) fn enable_dependencies(
        &mut self,
        api_version: crate::Version,
        supported: &DeviceExtensions,
    ) {
        if self.khr_16bit_storage {
            if !(api_version >= crate::Version::V1_1
                || self.khr_storage_buffer_storage_class)
            {
                assert!(
                    supported.khr_storage_buffer_storage_class,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "khr_16bit_storage", "khr_storage_buffer_storage_class",
                );
                self.khr_storage_buffer_storage_class = true;
            }
        }
        if self.khr_8bit_storage {
            if !(api_version >= crate::Version::V1_1
                || self.khr_storage_buffer_storage_class)
            {
                assert!(
                    supported.khr_storage_buffer_storage_class,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "khr_8bit_storage", "khr_storage_buffer_storage_class",
                );
                self.khr_storage_buffer_storage_class = true;
            }
        }
        if self.khr_acceleration_structure {
            if !(api_version >= crate::Version::V1_2 || self.ext_descriptor_indexing) {
                assert!(
                    supported.ext_descriptor_indexing,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "khr_acceleration_structure", "ext_descriptor_indexing",
                );
                self.ext_descriptor_indexing = true;
            }
            if !(api_version >= crate::Version::V1_2 || self.khr_buffer_device_address) {
                assert!(
                    supported.khr_buffer_device_address,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "khr_acceleration_structure", "khr_buffer_device_address",
                );
                self.khr_buffer_device_address = true;
            }
            if !(self.khr_deferred_host_operations) {
                assert!(
                    supported.khr_deferred_host_operations,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "khr_acceleration_structure", "khr_deferred_host_operations",
                );
                self.khr_deferred_host_operations = true;
            }
        }
        if self.khr_buffer_device_address {
            if !(api_version >= crate::Version::V1_1 || self.khr_device_group) {
                assert!(
                    supported.khr_device_group,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "khr_buffer_device_address", "khr_device_group",
                );
                self.khr_device_group = true;
            }
        }
        if self.khr_create_renderpass2 {
            if !(api_version >= crate::Version::V1_1 || self.khr_multiview) {
                assert!(
                    supported.khr_multiview,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "khr_create_renderpass2", "khr_multiview",
                );
                self.khr_multiview = true;
            }
            if !(api_version >= crate::Version::V1_1 || self.khr_maintenance2) {
                assert!(
                    supported.khr_maintenance2,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "khr_create_renderpass2", "khr_maintenance2",
                );
                self.khr_maintenance2 = true;
            }
        }
        if self.khr_dedicated_allocation {
            if !(api_version >= crate::Version::V1_1
                || self.khr_get_memory_requirements2)
            {
                assert!(
                    supported.khr_get_memory_requirements2,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "khr_dedicated_allocation", "khr_get_memory_requirements2",
                );
                self.khr_get_memory_requirements2 = true;
            }
        }
        if self.khr_depth_stencil_resolve {
            if !(api_version >= crate::Version::V1_2 || self.khr_create_renderpass2) {
                assert!(
                    supported.khr_create_renderpass2,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "khr_depth_stencil_resolve", "khr_create_renderpass2",
                );
                self.khr_create_renderpass2 = true;
            }
        }
        if self.khr_display_swapchain {
            if !(self.khr_swapchain) {
                assert!(
                    supported.khr_swapchain,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "khr_display_swapchain", "khr_swapchain",
                );
                self.khr_swapchain = true;
            }
        }
        if self.khr_dynamic_rendering {
            if !(api_version >= crate::Version::V1_2 || self.khr_depth_stencil_resolve) {
                assert!(
                    supported.khr_depth_stencil_resolve,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "khr_dynamic_rendering", "khr_depth_stencil_resolve",
                );
                self.khr_depth_stencil_resolve = true;
            }
        }
        if self.khr_dynamic_rendering_local_read {
            if !(api_version >= crate::Version::V1_3 || self.khr_dynamic_rendering) {
                assert!(
                    supported.khr_dynamic_rendering,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "khr_dynamic_rendering_local_read", "khr_dynamic_rendering",
                );
                self.khr_dynamic_rendering = true;
            }
        }
        if self.khr_external_fence_fd {
            if !(api_version >= crate::Version::V1_1 || self.khr_external_fence) {
                assert!(
                    supported.khr_external_fence,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "khr_external_fence_fd", "khr_external_fence",
                );
                self.khr_external_fence = true;
            }
        }
        if self.khr_external_fence_win32 {
            if !(api_version >= crate::Version::V1_1 || self.khr_external_fence) {
                assert!(
                    supported.khr_external_fence,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "khr_external_fence_win32", "khr_external_fence",
                );
                self.khr_external_fence = true;
            }
        }
        if self.khr_external_memory_fd {
            if !(api_version >= crate::Version::V1_1 || self.khr_external_memory) {
                assert!(
                    supported.khr_external_memory,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "khr_external_memory_fd", "khr_external_memory",
                );
                self.khr_external_memory = true;
            }
        }
        if self.khr_external_memory_win32 {
            if !(api_version >= crate::Version::V1_1 || self.khr_external_memory) {
                assert!(
                    supported.khr_external_memory,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "khr_external_memory_win32", "khr_external_memory",
                );
                self.khr_external_memory = true;
            }
        }
        if self.khr_external_semaphore_fd {
            if !(api_version >= crate::Version::V1_1 || self.khr_external_semaphore) {
                assert!(
                    supported.khr_external_semaphore,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "khr_external_semaphore_fd", "khr_external_semaphore",
                );
                self.khr_external_semaphore = true;
            }
        }
        if self.khr_external_semaphore_win32 {
            if !(api_version >= crate::Version::V1_1 || self.khr_external_semaphore) {
                assert!(
                    supported.khr_external_semaphore,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "khr_external_semaphore_win32", "khr_external_semaphore",
                );
                self.khr_external_semaphore = true;
            }
        }
        if self.khr_fragment_shading_rate {
            if !(api_version >= crate::Version::V1_2 || self.khr_create_renderpass2) {
                assert!(
                    supported.khr_create_renderpass2,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "khr_fragment_shading_rate", "khr_create_renderpass2",
                );
                self.khr_create_renderpass2 = true;
            }
        }
        if self.khr_imageless_framebuffer {
            if !(api_version >= crate::Version::V1_1 || self.khr_maintenance2) {
                assert!(
                    supported.khr_maintenance2,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "khr_imageless_framebuffer", "khr_maintenance2",
                );
                self.khr_maintenance2 = true;
            }
            if !(api_version >= crate::Version::V1_2 || self.khr_image_format_list) {
                assert!(
                    supported.khr_image_format_list,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "khr_imageless_framebuffer", "khr_image_format_list",
                );
                self.khr_image_format_list = true;
            }
        }
        if self.khr_incremental_present {
            if !(self.khr_swapchain) {
                assert!(
                    supported.khr_swapchain,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "khr_incremental_present", "khr_swapchain",
                );
                self.khr_swapchain = true;
            }
        }
        if self.khr_maintenance5 {
            if !(api_version >= crate::Version::V1_3 || self.khr_dynamic_rendering) {
                assert!(
                    supported.khr_dynamic_rendering,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "khr_maintenance5", "khr_dynamic_rendering",
                );
                self.khr_dynamic_rendering = true;
            }
        }
        if self.khr_present_id {
            if !(api_version >= crate::Version::V1_1 || self.khr_swapchain) {
                assert!(
                    supported.khr_swapchain,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "khr_present_id", "khr_swapchain",
                );
                self.khr_swapchain = true;
            }
        }
        if self.khr_present_wait {
            if !(self.khr_swapchain) {
                assert!(
                    supported.khr_swapchain,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "khr_present_wait", "khr_swapchain",
                );
                self.khr_swapchain = true;
            }
            if !(self.khr_present_id) {
                assert!(
                    supported.khr_present_id,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "khr_present_wait", "khr_present_id",
                );
                self.khr_present_id = true;
            }
        }
        if self.khr_ray_query {
            if !(api_version >= crate::Version::V1_2 || self.khr_spirv_1_4) {
                assert!(
                    supported.khr_spirv_1_4,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "khr_ray_query", "khr_spirv_1_4",
                );
                self.khr_spirv_1_4 = true;
            }
            if !(self.khr_acceleration_structure) {
                assert!(
                    supported.khr_acceleration_structure,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "khr_ray_query", "khr_acceleration_structure",
                );
                self.khr_acceleration_structure = true;
            }
        }
        if self.khr_ray_tracing_maintenance1 {
            if !(self.khr_acceleration_structure) {
                assert!(
                    supported.khr_acceleration_structure,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "khr_ray_tracing_maintenance1", "khr_acceleration_structure",
                );
                self.khr_acceleration_structure = true;
            }
        }
        if self.khr_ray_tracing_pipeline {
            if !(api_version >= crate::Version::V1_2 || self.khr_spirv_1_4) {
                assert!(
                    supported.khr_spirv_1_4,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "khr_ray_tracing_pipeline", "khr_spirv_1_4",
                );
                self.khr_spirv_1_4 = true;
            }
            if !(self.khr_acceleration_structure) {
                assert!(
                    supported.khr_acceleration_structure,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "khr_ray_tracing_pipeline", "khr_acceleration_structure",
                );
                self.khr_acceleration_structure = true;
            }
        }
        if self.khr_ray_tracing_position_fetch {
            if !(self.khr_acceleration_structure) {
                assert!(
                    supported.khr_acceleration_structure,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "khr_ray_tracing_position_fetch", "khr_acceleration_structure",
                );
                self.khr_acceleration_structure = true;
            }
        }
        if self.khr_sampler_ycbcr_conversion {
            if !(api_version >= crate::Version::V1_1 || self.khr_maintenance1) {
                assert!(
                    supported.khr_maintenance1,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "khr_sampler_ycbcr_conversion", "khr_maintenance1",
                );
                self.khr_maintenance1 = true;
            }
            if !(api_version >= crate::Version::V1_1 || self.khr_bind_memory2) {
                assert!(
                    supported.khr_bind_memory2,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "khr_sampler_ycbcr_conversion", "khr_bind_memory2",
                );
                self.khr_bind_memory2 = true;
            }
            if !(api_version >= crate::Version::V1_1
                || self.khr_get_memory_requirements2)
            {
                assert!(
                    supported.khr_get_memory_requirements2,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "khr_sampler_ycbcr_conversion", "khr_get_memory_requirements2",
                );
                self.khr_get_memory_requirements2 = true;
            }
        }
        if self.khr_separate_depth_stencil_layouts {
            if !(api_version >= crate::Version::V1_2 || self.khr_create_renderpass2) {
                assert!(
                    supported.khr_create_renderpass2,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "khr_separate_depth_stencil_layouts", "khr_create_renderpass2",
                );
                self.khr_create_renderpass2 = true;
            }
        }
        if self.khr_shader_float_controls2 {
            if !(api_version >= crate::Version::V1_2 || self.khr_shader_float_controls) {
                assert!(
                    supported.khr_shader_float_controls,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "khr_shader_float_controls2", "khr_shader_float_controls",
                );
                self.khr_shader_float_controls = true;
            }
        }
        if self.khr_shader_quad_control {
            if !(api_version >= crate::Version::V1_2 || self.khr_vulkan_memory_model) {
                assert!(
                    supported.khr_vulkan_memory_model,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "khr_shader_quad_control", "khr_vulkan_memory_model",
                );
                self.khr_vulkan_memory_model = true;
            }
            if !(self.khr_shader_maximal_reconvergence) {
                assert!(
                    supported.khr_shader_maximal_reconvergence,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "khr_shader_quad_control", "khr_shader_maximal_reconvergence",
                );
                self.khr_shader_maximal_reconvergence = true;
            }
        }
        if self.khr_shared_presentable_image {
            if !(self.khr_swapchain) {
                assert!(
                    supported.khr_swapchain,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "khr_shared_presentable_image", "khr_swapchain",
                );
                self.khr_swapchain = true;
            }
        }
        if self.khr_spirv_1_4 {
            if !(api_version >= crate::Version::V1_2 || self.khr_shader_float_controls) {
                assert!(
                    supported.khr_shader_float_controls,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "khr_spirv_1_4", "khr_shader_float_controls",
                );
                self.khr_shader_float_controls = true;
            }
        }
        if self.khr_swapchain_mutable_format {
            if !(self.khr_swapchain) {
                assert!(
                    supported.khr_swapchain,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "khr_swapchain_mutable_format", "khr_swapchain",
                );
                self.khr_swapchain = true;
            }
            if !(api_version >= crate::Version::V1_1 || self.khr_maintenance2) {
                assert!(
                    supported.khr_maintenance2,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "khr_swapchain_mutable_format", "khr_maintenance2",
                );
                self.khr_maintenance2 = true;
            }
            if !(api_version >= crate::Version::V1_2 || self.khr_image_format_list) {
                assert!(
                    supported.khr_image_format_list,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "khr_swapchain_mutable_format", "khr_image_format_list",
                );
                self.khr_image_format_list = true;
            }
        }
        if self.khr_variable_pointers {
            if !(api_version >= crate::Version::V1_1
                || self.khr_storage_buffer_storage_class)
            {
                assert!(
                    supported.khr_storage_buffer_storage_class,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "khr_variable_pointers", "khr_storage_buffer_storage_class",
                );
                self.khr_storage_buffer_storage_class = true;
            }
        }
        if self.khr_video_decode_av1 {
            if !(self.khr_video_decode_queue) {
                assert!(
                    supported.khr_video_decode_queue,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "khr_video_decode_av1", "khr_video_decode_queue",
                );
                self.khr_video_decode_queue = true;
            }
        }
        if self.khr_video_decode_h264 {
            if !(self.khr_video_decode_queue) {
                assert!(
                    supported.khr_video_decode_queue,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "khr_video_decode_h264", "khr_video_decode_queue",
                );
                self.khr_video_decode_queue = true;
            }
        }
        if self.khr_video_decode_h265 {
            if !(self.khr_video_decode_queue) {
                assert!(
                    supported.khr_video_decode_queue,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "khr_video_decode_h265", "khr_video_decode_queue",
                );
                self.khr_video_decode_queue = true;
            }
        }
        if self.khr_video_decode_queue {
            if !(self.khr_video_queue) {
                assert!(
                    supported.khr_video_queue,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "khr_video_decode_queue", "khr_video_queue",
                );
                self.khr_video_queue = true;
            }
            if !(api_version >= crate::Version::V1_3 || self.khr_synchronization2) {
                assert!(
                    supported.khr_synchronization2,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "khr_video_decode_queue", "khr_synchronization2",
                );
                self.khr_synchronization2 = true;
            }
        }
        if self.khr_video_encode_h264 {
            if !(self.khr_video_encode_queue) {
                assert!(
                    supported.khr_video_encode_queue,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "khr_video_encode_h264", "khr_video_encode_queue",
                );
                self.khr_video_encode_queue = true;
            }
        }
        if self.khr_video_encode_h265 {
            if !(self.khr_video_encode_queue) {
                assert!(
                    supported.khr_video_encode_queue,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "khr_video_encode_h265", "khr_video_encode_queue",
                );
                self.khr_video_encode_queue = true;
            }
        }
        if self.khr_video_encode_queue {
            if !(self.khr_video_queue) {
                assert!(
                    supported.khr_video_queue,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "khr_video_encode_queue", "khr_video_queue",
                );
                self.khr_video_queue = true;
            }
            if !(api_version >= crate::Version::V1_3 || self.khr_synchronization2) {
                assert!(
                    supported.khr_synchronization2,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "khr_video_encode_queue", "khr_synchronization2",
                );
                self.khr_synchronization2 = true;
            }
        }
        if self.khr_video_maintenance1 {
            if !(self.khr_video_queue) {
                assert!(
                    supported.khr_video_queue,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "khr_video_maintenance1", "khr_video_queue",
                );
                self.khr_video_queue = true;
            }
        }
        if self.khr_video_queue {
            if !(api_version >= crate::Version::V1_3 || self.khr_synchronization2) {
                assert!(
                    supported.khr_synchronization2,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "khr_video_queue", "khr_synchronization2",
                );
                self.khr_synchronization2 = true;
            }
        }
        if self.khr_win32_keyed_mutex {
            if !(self.khr_external_memory_win32) {
                assert!(
                    supported.khr_external_memory_win32,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "khr_win32_keyed_mutex", "khr_external_memory_win32",
                );
                self.khr_external_memory_win32 = true;
            }
        }
        if self.ext_attachment_feedback_loop_dynamic_state {
            if !(self.ext_attachment_feedback_loop_layout) {
                assert!(
                    supported.ext_attachment_feedback_loop_layout,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "ext_attachment_feedback_loop_dynamic_state",
                    "ext_attachment_feedback_loop_layout",
                );
                self.ext_attachment_feedback_loop_layout = true;
            }
        }
        if self.ext_border_color_swizzle {
            if !(self.ext_custom_border_color) {
                assert!(
                    supported.ext_custom_border_color,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "ext_border_color_swizzle", "ext_custom_border_color",
                );
                self.ext_custom_border_color = true;
            }
        }
        if self.ext_descriptor_buffer {
            if !(api_version >= crate::Version::V1_2 || self.khr_buffer_device_address) {
                assert!(
                    supported.khr_buffer_device_address,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "ext_descriptor_buffer", "khr_buffer_device_address",
                );
                self.khr_buffer_device_address = true;
            }
            if !(api_version >= crate::Version::V1_2 || self.ext_descriptor_indexing) {
                assert!(
                    supported.ext_descriptor_indexing,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "ext_descriptor_buffer", "ext_descriptor_indexing",
                );
                self.ext_descriptor_indexing = true;
            }
            if !(api_version >= crate::Version::V1_3 || self.khr_synchronization2) {
                assert!(
                    supported.khr_synchronization2,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "ext_descriptor_buffer", "khr_synchronization2",
                );
                self.khr_synchronization2 = true;
            }
        }
        if self.ext_descriptor_indexing {
            if !(api_version >= crate::Version::V1_1 || self.khr_maintenance3) {
                assert!(
                    supported.khr_maintenance3,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "ext_descriptor_indexing", "khr_maintenance3",
                );
                self.khr_maintenance3 = true;
            }
        }
        if self.ext_display_control {
            if !(self.khr_swapchain) {
                assert!(
                    supported.khr_swapchain,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "ext_display_control", "khr_swapchain",
                );
                self.khr_swapchain = true;
            }
        }
        if self.ext_dynamic_rendering_unused_attachments {
            if !(api_version >= crate::Version::V1_3 || self.khr_dynamic_rendering) {
                assert!(
                    supported.khr_dynamic_rendering,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "ext_dynamic_rendering_unused_attachments", "khr_dynamic_rendering",
                );
                self.khr_dynamic_rendering = true;
            }
        }
        if self.ext_external_memory_acquire_unmodified {
            if !(api_version >= crate::Version::V1_1 || self.khr_external_memory) {
                assert!(
                    supported.khr_external_memory,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "ext_external_memory_acquire_unmodified", "khr_external_memory",
                );
                self.khr_external_memory = true;
            }
        }
        if self.ext_external_memory_dma_buf {
            if !(self.khr_external_memory_fd) {
                assert!(
                    supported.khr_external_memory_fd,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "ext_external_memory_dma_buf", "khr_external_memory_fd",
                );
                self.khr_external_memory_fd = true;
            }
        }
        if self.ext_external_memory_host {
            if !(api_version >= crate::Version::V1_1 || self.khr_external_memory) {
                assert!(
                    supported.khr_external_memory,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "ext_external_memory_host", "khr_external_memory",
                );
                self.khr_external_memory = true;
            }
        }
        if self.ext_fragment_density_map2 {
            if !(self.ext_fragment_density_map) {
                assert!(
                    supported.ext_fragment_density_map,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "ext_fragment_density_map2", "ext_fragment_density_map",
                );
                self.ext_fragment_density_map = true;
            }
        }
        if self.ext_full_screen_exclusive {
            if !(self.khr_swapchain) {
                assert!(
                    supported.khr_swapchain,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "ext_full_screen_exclusive", "khr_swapchain",
                );
                self.khr_swapchain = true;
            }
        }
        if self.ext_global_priority_query {
            if !(self.khr_global_priority || self.ext_global_priority) {
                if supported.khr_global_priority {
                    self.khr_global_priority = true;
                } else {
                    assert!(
                        supported.ext_global_priority,
                        "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                        "ext_global_priority_query", "ext_global_priority",
                    );
                    self.ext_global_priority = true;
                }
            }
        }
        if self.ext_graphics_pipeline_library {
            if !(self.khr_pipeline_library) {
                assert!(
                    supported.khr_pipeline_library,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "ext_graphics_pipeline_library", "khr_pipeline_library",
                );
                self.khr_pipeline_library = true;
            }
        }
        if self.ext_hdr_metadata {
            if !(self.khr_swapchain) {
                assert!(
                    supported.khr_swapchain,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "ext_hdr_metadata", "khr_swapchain",
                );
                self.khr_swapchain = true;
            }
        }
        if self.ext_host_image_copy {
            if !(api_version >= crate::Version::V1_3 || self.khr_copy_commands2) {
                assert!(
                    supported.khr_copy_commands2,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "ext_host_image_copy", "khr_copy_commands2",
                );
                self.khr_copy_commands2 = true;
            }
            if !(api_version >= crate::Version::V1_3 || self.khr_format_feature_flags2) {
                assert!(
                    supported.khr_format_feature_flags2,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "ext_host_image_copy", "khr_format_feature_flags2",
                );
                self.khr_format_feature_flags2 = true;
            }
        }
        if self.ext_image_2d_view_of_3d {
            if !(api_version >= crate::Version::V1_1 || self.khr_maintenance1) {
                assert!(
                    supported.khr_maintenance1,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "ext_image_2d_view_of_3d", "khr_maintenance1",
                );
                self.khr_maintenance1 = true;
            }
        }
        if self.ext_image_compression_control_swapchain {
            if !(self.ext_image_compression_control) {
                assert!(
                    supported.ext_image_compression_control,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "ext_image_compression_control_swapchain",
                    "ext_image_compression_control",
                );
                self.ext_image_compression_control = true;
            }
        }
        if self.ext_image_drm_format_modifier {
            if !(api_version >= crate::Version::V1_1 || self.khr_bind_memory2) {
                assert!(
                    supported.khr_bind_memory2,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "ext_image_drm_format_modifier", "khr_bind_memory2",
                );
                self.khr_bind_memory2 = true;
            }
            if !(api_version >= crate::Version::V1_1
                || self.khr_sampler_ycbcr_conversion)
            {
                assert!(
                    supported.khr_sampler_ycbcr_conversion,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "ext_image_drm_format_modifier", "khr_sampler_ycbcr_conversion",
                );
                self.khr_sampler_ycbcr_conversion = true;
            }
            if !(api_version >= crate::Version::V1_2 || self.khr_image_format_list) {
                assert!(
                    supported.khr_image_format_list,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "ext_image_drm_format_modifier", "khr_image_format_list",
                );
                self.khr_image_format_list = true;
            }
        }
        if self.ext_image_sliced_view_of_3d {
            if !(api_version >= crate::Version::V1_1 || self.khr_maintenance1) {
                assert!(
                    supported.khr_maintenance1,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "ext_image_sliced_view_of_3d", "khr_maintenance1",
                );
                self.khr_maintenance1 = true;
            }
        }
        if self.ext_inline_uniform_block {
            if !(api_version >= crate::Version::V1_1 || self.khr_maintenance1) {
                assert!(
                    supported.khr_maintenance1,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "ext_inline_uniform_block", "khr_maintenance1",
                );
                self.khr_maintenance1 = true;
            }
        }
        if self.ext_map_memory_placed {
            if !(self.khr_map_memory2) {
                assert!(
                    supported.khr_map_memory2,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "ext_map_memory_placed", "khr_map_memory2",
                );
                self.khr_map_memory2 = true;
            }
        }
        if self.ext_mesh_shader {
            if !(api_version >= crate::Version::V1_2 || self.khr_spirv_1_4) {
                assert!(
                    supported.khr_spirv_1_4,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "ext_mesh_shader", "khr_spirv_1_4",
                );
                self.khr_spirv_1_4 = true;
            }
        }
        if self.ext_multisampled_render_to_single_sampled {
            if !(api_version >= crate::Version::V1_2 || self.khr_create_renderpass2) {
                assert!(
                    supported.khr_create_renderpass2,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "ext_multisampled_render_to_single_sampled",
                    "khr_create_renderpass2",
                );
                self.khr_create_renderpass2 = true;
            }
            if !(api_version >= crate::Version::V1_2 || self.khr_depth_stencil_resolve) {
                assert!(
                    supported.khr_depth_stencil_resolve,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "ext_multisampled_render_to_single_sampled",
                    "khr_depth_stencil_resolve",
                );
                self.khr_depth_stencil_resolve = true;
            }
        }
        if self.ext_mutable_descriptor_type {
            if !(api_version >= crate::Version::V1_1 || self.khr_maintenance3) {
                assert!(
                    supported.khr_maintenance3,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "ext_mutable_descriptor_type", "khr_maintenance3",
                );
                self.khr_maintenance3 = true;
            }
        }
        if self.ext_opacity_micromap {
            if !(self.khr_acceleration_structure) {
                assert!(
                    supported.khr_acceleration_structure,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "ext_opacity_micromap", "khr_acceleration_structure",
                );
                self.khr_acceleration_structure = true;
            }
            if !(api_version >= crate::Version::V1_3 || self.khr_synchronization2) {
                assert!(
                    supported.khr_synchronization2,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "ext_opacity_micromap", "khr_synchronization2",
                );
                self.khr_synchronization2 = true;
            }
        }
        if self.ext_pageable_device_local_memory {
            if !(self.ext_memory_priority) {
                assert!(
                    supported.ext_memory_priority,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "ext_pageable_device_local_memory", "ext_memory_priority",
                );
                self.ext_memory_priority = true;
            }
        }
        if self.ext_pipeline_library_group_handles {
            if !(self.khr_ray_tracing_pipeline) {
                assert!(
                    supported.khr_ray_tracing_pipeline,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "ext_pipeline_library_group_handles", "khr_ray_tracing_pipeline",
                );
                self.khr_ray_tracing_pipeline = true;
            }
            if !(self.khr_pipeline_library) {
                assert!(
                    supported.khr_pipeline_library,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "ext_pipeline_library_group_handles", "khr_pipeline_library",
                );
                self.khr_pipeline_library = true;
            }
        }
        if self.ext_primitives_generated_query {
            if !(self.ext_transform_feedback) {
                assert!(
                    supported.ext_transform_feedback,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "ext_primitives_generated_query", "ext_transform_feedback",
                );
                self.ext_transform_feedback = true;
            }
        }
        if self.ext_queue_family_foreign {
            if !(api_version >= crate::Version::V1_1 || self.khr_external_memory) {
                assert!(
                    supported.khr_external_memory,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "ext_queue_family_foreign", "khr_external_memory",
                );
                self.khr_external_memory = true;
            }
        }
        if self.ext_rgba10x6_formats {
            if !(api_version >= crate::Version::V1_1
                || self.khr_sampler_ycbcr_conversion)
            {
                assert!(
                    supported.khr_sampler_ycbcr_conversion,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "ext_rgba10x6_formats", "khr_sampler_ycbcr_conversion",
                );
                self.khr_sampler_ycbcr_conversion = true;
            }
        }
        if self.ext_shader_atomic_float2 {
            if !(self.ext_shader_atomic_float) {
                assert!(
                    supported.ext_shader_atomic_float,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "ext_shader_atomic_float2", "ext_shader_atomic_float",
                );
                self.ext_shader_atomic_float = true;
            }
        }
        if self.ext_shader_module_identifier {
            if !(api_version >= crate::Version::V1_3
                || self.ext_pipeline_creation_cache_control)
            {
                assert!(
                    supported.ext_pipeline_creation_cache_control,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "ext_shader_module_identifier",
                    "ext_pipeline_creation_cache_control",
                );
                self.ext_pipeline_creation_cache_control = true;
            }
        }
        if self.ext_shader_object {
            if !(api_version >= crate::Version::V1_3 || self.khr_dynamic_rendering) {
                assert!(
                    supported.khr_dynamic_rendering,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "ext_shader_object", "khr_dynamic_rendering",
                );
                self.khr_dynamic_rendering = true;
            }
        }
        if self.ext_swapchain_maintenance1 {
            if !(self.khr_swapchain) {
                assert!(
                    supported.khr_swapchain,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "ext_swapchain_maintenance1", "khr_swapchain",
                );
                self.khr_swapchain = true;
            }
        }
        if self.ext_ycbcr_2plane_444_formats {
            if !(api_version >= crate::Version::V1_1
                || self.khr_sampler_ycbcr_conversion)
            {
                assert!(
                    supported.khr_sampler_ycbcr_conversion,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "ext_ycbcr_2plane_444_formats", "khr_sampler_ycbcr_conversion",
                );
                self.khr_sampler_ycbcr_conversion = true;
            }
        }
        if self.ext_ycbcr_image_arrays {
            if !(api_version >= crate::Version::V1_1
                || self.khr_sampler_ycbcr_conversion)
            {
                assert!(
                    supported.khr_sampler_ycbcr_conversion,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "ext_ycbcr_image_arrays", "khr_sampler_ycbcr_conversion",
                );
                self.khr_sampler_ycbcr_conversion = true;
            }
        }
        if self.amdx_shader_enqueue {
            if !(api_version >= crate::Version::V1_3 || self.khr_synchronization2) {
                assert!(
                    supported.khr_synchronization2,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "amdx_shader_enqueue", "khr_synchronization2",
                );
                self.khr_synchronization2 = true;
            }
            if !(self.khr_pipeline_library) {
                assert!(
                    supported.khr_pipeline_library,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "amdx_shader_enqueue", "khr_pipeline_library",
                );
                self.khr_pipeline_library = true;
            }
            if !(api_version >= crate::Version::V1_2 || self.khr_spirv_1_4) {
                assert!(
                    supported.khr_spirv_1_4,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "amdx_shader_enqueue", "khr_spirv_1_4",
                );
                self.khr_spirv_1_4 = true;
            }
        }
        if self.amd_display_native_hdr {
            if !(self.khr_swapchain) {
                assert!(
                    supported.khr_swapchain,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "amd_display_native_hdr", "khr_swapchain",
                );
                self.khr_swapchain = true;
            }
        }
        if self.amd_shader_core_properties2 {
            if !(self.amd_shader_core_properties) {
                assert!(
                    supported.amd_shader_core_properties,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "amd_shader_core_properties2", "amd_shader_core_properties",
                );
                self.amd_shader_core_properties = true;
            }
        }
        if self.android_external_format_resolve {
            if !(self.android_external_memory_android_hardware_buffer) {
                assert!(
                    supported.android_external_memory_android_hardware_buffer,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "android_external_format_resolve",
                    "android_external_memory_android_hardware_buffer",
                );
                self.android_external_memory_android_hardware_buffer = true;
            }
        }
        if self.android_external_memory_android_hardware_buffer {
            if !(api_version >= crate::Version::V1_1
                || self.khr_sampler_ycbcr_conversion)
            {
                assert!(
                    supported.khr_sampler_ycbcr_conversion,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "android_external_memory_android_hardware_buffer",
                    "khr_sampler_ycbcr_conversion",
                );
                self.khr_sampler_ycbcr_conversion = true;
            }
            if !(api_version >= crate::Version::V1_1 || self.khr_external_memory) {
                assert!(
                    supported.khr_external_memory,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "android_external_memory_android_hardware_buffer",
                    "khr_external_memory",
                );
                self.khr_external_memory = true;
            }
            if !(api_version >= crate::Version::V1_1 || self.khr_dedicated_allocation) {
                assert!(
                    supported.khr_dedicated_allocation,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "android_external_memory_android_hardware_buffer",
                    "khr_dedicated_allocation",
                );
                self.khr_dedicated_allocation = true;
            }
            if !(self.ext_queue_family_foreign) {
                assert!(
                    supported.ext_queue_family_foreign,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "android_external_memory_android_hardware_buffer",
                    "ext_queue_family_foreign",
                );
                self.ext_queue_family_foreign = true;
            }
        }
        if self.arm_render_pass_striped {
            if !(api_version >= crate::Version::V1_3 || self.khr_synchronization2) {
                assert!(
                    supported.khr_synchronization2,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "arm_render_pass_striped", "khr_synchronization2",
                );
                self.khr_synchronization2 = true;
            }
        }
        if self.arm_scheduling_controls {
            if !(self.arm_shader_core_builtins) {
                assert!(
                    supported.arm_shader_core_builtins,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "arm_scheduling_controls", "arm_shader_core_builtins",
                );
                self.arm_shader_core_builtins = true;
            }
        }
        if self.fuchsia_buffer_collection {
            if !(self.fuchsia_external_memory) {
                assert!(
                    supported.fuchsia_external_memory,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "fuchsia_buffer_collection", "fuchsia_external_memory",
                );
                self.fuchsia_external_memory = true;
            }
            if !(api_version >= crate::Version::V1_1
                || self.khr_sampler_ycbcr_conversion)
            {
                assert!(
                    supported.khr_sampler_ycbcr_conversion,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "fuchsia_buffer_collection", "khr_sampler_ycbcr_conversion",
                );
                self.khr_sampler_ycbcr_conversion = true;
            }
        }
        if self.fuchsia_external_memory {
            if !(api_version >= crate::Version::V1_1 || self.khr_external_memory) {
                assert!(
                    supported.khr_external_memory,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "fuchsia_external_memory", "khr_external_memory",
                );
                self.khr_external_memory = true;
            }
        }
        if self.fuchsia_external_semaphore {
            if !(api_version >= crate::Version::V1_1 || self.khr_external_semaphore) {
                assert!(
                    supported.khr_external_semaphore,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "fuchsia_external_semaphore", "khr_external_semaphore",
                );
                self.khr_external_semaphore = true;
            }
        }
        if self.ggp_frame_token {
            if !(self.khr_swapchain) {
                assert!(
                    supported.khr_swapchain,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "ggp_frame_token", "khr_swapchain",
                );
                self.khr_swapchain = true;
            }
        }
        if self.google_display_timing {
            if !(self.khr_swapchain) {
                assert!(
                    supported.khr_swapchain,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "google_display_timing", "khr_swapchain",
                );
                self.khr_swapchain = true;
            }
        }
        if self.huawei_invocation_mask {
            if !(self.khr_ray_tracing_pipeline) {
                assert!(
                    supported.khr_ray_tracing_pipeline,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "huawei_invocation_mask", "khr_ray_tracing_pipeline",
                );
                self.khr_ray_tracing_pipeline = true;
            }
            if !(api_version >= crate::Version::V1_3 || self.khr_synchronization2) {
                assert!(
                    supported.khr_synchronization2,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "huawei_invocation_mask", "khr_synchronization2",
                );
                self.khr_synchronization2 = true;
            }
        }
        if self.huawei_subpass_shading {
            if !(api_version >= crate::Version::V1_2 || self.khr_create_renderpass2) {
                assert!(
                    supported.khr_create_renderpass2,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "huawei_subpass_shading", "khr_create_renderpass2",
                );
                self.khr_create_renderpass2 = true;
            }
            if !(api_version >= crate::Version::V1_3 || self.khr_synchronization2) {
                assert!(
                    supported.khr_synchronization2,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "huawei_subpass_shading", "khr_synchronization2",
                );
                self.khr_synchronization2 = true;
            }
        }
        if self.nvx_multiview_per_view_attributes {
            if !(api_version >= crate::Version::V1_1 || self.khr_multiview) {
                assert!(
                    supported.khr_multiview,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "nvx_multiview_per_view_attributes", "khr_multiview",
                );
                self.khr_multiview = true;
            }
        }
        if self.nv_copy_memory_indirect {
            if !(api_version >= crate::Version::V1_2 || self.khr_buffer_device_address) {
                assert!(
                    supported.khr_buffer_device_address,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "nv_copy_memory_indirect", "khr_buffer_device_address",
                );
                self.khr_buffer_device_address = true;
            }
        }
        if self.nv_coverage_reduction_mode {
            if !(self.nv_framebuffer_mixed_samples) {
                assert!(
                    supported.nv_framebuffer_mixed_samples,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "nv_coverage_reduction_mode", "nv_framebuffer_mixed_samples",
                );
                self.nv_framebuffer_mixed_samples = true;
            }
        }
        if self.nv_dedicated_allocation_image_aliasing {
            if !(api_version >= crate::Version::V1_1 || self.khr_dedicated_allocation) {
                assert!(
                    supported.khr_dedicated_allocation,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "nv_dedicated_allocation_image_aliasing", "khr_dedicated_allocation",
                );
                self.khr_dedicated_allocation = true;
            }
        }
        if self.nv_device_generated_commands {
            if !(api_version >= crate::Version::V1_2 || self.khr_buffer_device_address) {
                assert!(
                    supported.khr_buffer_device_address,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "nv_device_generated_commands", "khr_buffer_device_address",
                );
                self.khr_buffer_device_address = true;
            }
        }
        if self.nv_device_generated_commands_compute {
            if !(self.nv_device_generated_commands) {
                assert!(
                    supported.nv_device_generated_commands,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "nv_device_generated_commands_compute",
                    "nv_device_generated_commands",
                );
                self.nv_device_generated_commands = true;
            }
        }
        if self.nv_displacement_micromap {
            if !(self.ext_opacity_micromap) {
                assert!(
                    supported.ext_opacity_micromap,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "nv_displacement_micromap", "ext_opacity_micromap",
                );
                self.ext_opacity_micromap = true;
            }
        }
        if self.nv_external_memory_rdma {
            if !(api_version >= crate::Version::V1_1 || self.khr_external_memory) {
                assert!(
                    supported.khr_external_memory,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "nv_external_memory_rdma", "khr_external_memory",
                );
                self.khr_external_memory = true;
            }
        }
        if self.nv_external_memory_win32 {
            if !(self.nv_external_memory) {
                assert!(
                    supported.nv_external_memory,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "nv_external_memory_win32", "nv_external_memory",
                );
                self.nv_external_memory = true;
            }
        }
        if self.nv_fragment_shading_rate_enums {
            if !(self.khr_fragment_shading_rate) {
                assert!(
                    supported.khr_fragment_shading_rate,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "nv_fragment_shading_rate_enums", "khr_fragment_shading_rate",
                );
                self.khr_fragment_shading_rate = true;
            }
        }
        if self.nv_low_latency2 {
            if !(api_version >= crate::Version::V1_2 || self.khr_timeline_semaphore) {
                assert!(
                    supported.khr_timeline_semaphore,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "nv_low_latency2", "khr_timeline_semaphore",
                );
                self.khr_timeline_semaphore = true;
            }
        }
        if self.nv_memory_decompression {
            if !(api_version >= crate::Version::V1_2 || self.khr_buffer_device_address) {
                assert!(
                    supported.khr_buffer_device_address,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "nv_memory_decompression", "khr_buffer_device_address",
                );
                self.khr_buffer_device_address = true;
            }
        }
        if self.nv_optical_flow {
            if !(api_version >= crate::Version::V1_3 || self.khr_format_feature_flags2) {
                assert!(
                    supported.khr_format_feature_flags2,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "nv_optical_flow", "khr_format_feature_flags2",
                );
                self.khr_format_feature_flags2 = true;
            }
            if !(api_version >= crate::Version::V1_3 || self.khr_synchronization2) {
                assert!(
                    supported.khr_synchronization2,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "nv_optical_flow", "khr_synchronization2",
                );
                self.khr_synchronization2 = true;
            }
        }
        if self.nv_per_stage_descriptor_set {
            if !(self.khr_maintenance6) {
                assert!(
                    supported.khr_maintenance6,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "nv_per_stage_descriptor_set", "khr_maintenance6",
                );
                self.khr_maintenance6 = true;
            }
        }
        if self.nv_present_barrier {
            if !(self.khr_swapchain) {
                assert!(
                    supported.khr_swapchain,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "nv_present_barrier", "khr_swapchain",
                );
                self.khr_swapchain = true;
            }
        }
        if self.nv_ray_tracing {
            if !(api_version >= crate::Version::V1_1
                || self.khr_get_memory_requirements2)
            {
                assert!(
                    supported.khr_get_memory_requirements2,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "nv_ray_tracing", "khr_get_memory_requirements2",
                );
                self.khr_get_memory_requirements2 = true;
            }
        }
        if self.nv_ray_tracing_invocation_reorder {
            if !(self.khr_ray_tracing_pipeline) {
                assert!(
                    supported.khr_ray_tracing_pipeline,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "nv_ray_tracing_invocation_reorder", "khr_ray_tracing_pipeline",
                );
                self.khr_ray_tracing_pipeline = true;
            }
        }
        if self.nv_ray_tracing_motion_blur {
            if !(self.khr_ray_tracing_pipeline) {
                assert!(
                    supported.khr_ray_tracing_pipeline,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "nv_ray_tracing_motion_blur", "khr_ray_tracing_pipeline",
                );
                self.khr_ray_tracing_pipeline = true;
            }
        }
        if self.nv_win32_keyed_mutex {
            if !(self.nv_external_memory_win32) {
                assert!(
                    supported.nv_external_memory_win32,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "nv_win32_keyed_mutex", "nv_external_memory_win32",
                );
                self.nv_external_memory_win32 = true;
            }
        }
        if self.qcom_filter_cubic_clamp {
            if !(self.ext_filter_cubic) {
                assert!(
                    supported.ext_filter_cubic,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "qcom_filter_cubic_clamp", "ext_filter_cubic",
                );
                self.ext_filter_cubic = true;
            }
            if !(api_version >= crate::Version::V1_2 || self.ext_sampler_filter_minmax) {
                assert!(
                    supported.ext_sampler_filter_minmax,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "qcom_filter_cubic_clamp", "ext_sampler_filter_minmax",
                );
                self.ext_sampler_filter_minmax = true;
            }
        }
        if self.qcom_filter_cubic_weights {
            if !(self.ext_filter_cubic) {
                assert!(
                    supported.ext_filter_cubic,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "qcom_filter_cubic_weights", "ext_filter_cubic",
                );
                self.ext_filter_cubic = true;
            }
        }
        if self.qcom_fragment_density_map_offset {
            if !(self.ext_fragment_density_map) {
                assert!(
                    supported.ext_fragment_density_map,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "qcom_fragment_density_map_offset", "ext_fragment_density_map",
                );
                self.ext_fragment_density_map = true;
            }
        }
        if self.qcom_image_processing {
            if !(api_version >= crate::Version::V1_3 || self.khr_format_feature_flags2) {
                assert!(
                    supported.khr_format_feature_flags2,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "qcom_image_processing", "khr_format_feature_flags2",
                );
                self.khr_format_feature_flags2 = true;
            }
        }
        if self.qcom_image_processing2 {
            if !(self.qcom_image_processing) {
                assert!(
                    supported.qcom_image_processing,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "qcom_image_processing2", "qcom_image_processing",
                );
                self.qcom_image_processing = true;
            }
        }
        if self.qcom_rotated_copy_commands {
            if !(api_version >= crate::Version::V1_3 || self.khr_copy_commands2) {
                assert!(
                    supported.khr_copy_commands2,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "qcom_rotated_copy_commands", "khr_copy_commands2",
                );
                self.khr_copy_commands2 = true;
            }
        }
        if self.qnx_external_memory_screen_buffer {
            if !(api_version >= crate::Version::V1_1
                || self.khr_sampler_ycbcr_conversion)
            {
                assert!(
                    supported.khr_sampler_ycbcr_conversion,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "qnx_external_memory_screen_buffer", "khr_sampler_ycbcr_conversion",
                );
                self.khr_sampler_ycbcr_conversion = true;
            }
            if !(api_version >= crate::Version::V1_1 || self.khr_external_memory) {
                assert!(
                    supported.khr_external_memory,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "qnx_external_memory_screen_buffer", "khr_external_memory",
                );
                self.khr_external_memory = true;
            }
            if !(api_version >= crate::Version::V1_1 || self.khr_dedicated_allocation) {
                assert!(
                    supported.khr_dedicated_allocation,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "qnx_external_memory_screen_buffer", "khr_dedicated_allocation",
                );
                self.khr_dedicated_allocation = true;
            }
            if !(self.ext_queue_family_foreign) {
                assert!(
                    supported.ext_queue_family_foreign,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "qnx_external_memory_screen_buffer", "ext_queue_family_foreign",
                );
                self.ext_queue_family_foreign = true;
            }
        }
        if self.valve_mutable_descriptor_type {
            if !(api_version >= crate::Version::V1_1 || self.khr_maintenance3) {
                assert!(
                    supported.khr_maintenance3,
                    "The device extension `{}` is enabled, and it requires \
                                        the `{}` extension to be also enabled, but the device \
                                        does not support the required extension. \
                                        This is a bug in the Vulkan driver for this device.",
                    "valve_mutable_descriptor_type", "khr_maintenance3",
                );
                self.khr_maintenance3 = true;
            }
        }
    }
}
