// This file is auto-generated by vulkano autogen from vk.xml header version 1.3.281.
// It should not be edited manually. Changes should be made by editing autogen.


/// Represents all the features that are available on a physical device or enabled on
/// a logical device.
///
/// Note that the `robust_buffer_access` is guaranteed to be supported by all Vulkan
/// implementations.
///
/// # Examples
///
/// ```
/// use vulkano::device::DeviceFeatures;
/// # let physical_device: vulkano::device::physical::PhysicalDevice = return;
/// let minimal_features = DeviceFeatures {
///     geometry_shader: true,
///     ..DeviceFeatures::empty()
/// };
///
/// let optimal_features = vulkano::device::DeviceFeatures {
///     geometry_shader: true,
///     tessellation_shader: true,
///     ..DeviceFeatures::empty()
/// };
///
/// if !physical_device.supported_features().contains(&minimal_features) {
///     panic!("The physical device is not good enough for this application.");
/// }
///
/// assert!(optimal_features.contains(&minimal_features));
/// let features_to_request = optimal_features.intersection(physical_device.supported_features());
/// ```
#[derive(Copy, Clone, PartialEq, Eq, Hash)]
pub struct DeviceFeatures {
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceAccelerationStructureFeaturesKHR.html#features-accelerationStructure)
    pub acceleration_structure: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceAccelerationStructureFeaturesKHR.html#features-accelerationStructureCaptureReplay)
    pub acceleration_structure_capture_replay: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceAccelerationStructureFeaturesKHR.html#features-accelerationStructureHostCommands)
    pub acceleration_structure_host_commands: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceAccelerationStructureFeaturesKHR.html#features-accelerationStructureIndirectBuild)
    pub acceleration_structure_indirect_build: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT.html#features-advancedBlendCoherentOperations)
    pub advanced_blend_coherent_operations: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFeatures.html#features-alphaToOne)
    pub alpha_to_one: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceAmigoProfilingFeaturesSEC.html#features-amigoProfiling)
    pub amigo_profiling: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT.html#features-attachmentFeedbackLoopDynamicState)
    pub attachment_feedback_loop_dynamic_state: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT.html#features-attachmentFeedbackLoopLayout)
    pub attachment_feedback_loop_layout: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFragmentShadingRateFeaturesKHR.html#features-attachmentFragmentShadingRate)
- Conflicts with features: [`shading_rate_image`](crate::device::DeviceFeatures::shading_rate_image), [`fragment_density_map`](crate::device::DeviceFeatures::fragment_density_map)*/
    pub attachment_fragment_shading_rate: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceBorderColorSwizzleFeaturesEXT.html#features-borderColorSwizzle)
    pub border_color_swizzle: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceBorderColorSwizzleFeaturesEXT.html#features-borderColorSwizzleFromImage)
    pub border_color_swizzle_from_image: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceLineRasterizationFeaturesKHR.html#features-bresenhamLines)
    pub bresenham_lines: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceVulkan12Features.html#features-bufferDeviceAddress)
    pub buffer_device_address: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceVulkan12Features.html#features-bufferDeviceAddressCaptureReplay)
    pub buffer_device_address_capture_replay: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceVulkan12Features.html#features-bufferDeviceAddressMultiDevice)
    pub buffer_device_address_multi_device: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI.html#features-clustercullingShader)
    pub clusterculling_shader: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceColorWriteEnableFeaturesEXT.html#features-colorWriteEnable)
    pub color_write_enable: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceComputeShaderDerivativesFeaturesNV.html#features-computeDerivativeGroupLinear)
    pub compute_derivative_group_linear: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceComputeShaderDerivativesFeaturesNV.html#features-computeDerivativeGroupQuads)
    pub compute_derivative_group_quads: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceVulkan13Features.html#features-computeFullSubgroups)
    pub compute_full_subgroups: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceConditionalRenderingFeaturesEXT.html#features-conditionalRendering)
    pub conditional_rendering: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevicePortabilitySubsetFeaturesKHR.html#features-constantAlphaColorBlendFactors)
    pub constant_alpha_color_blend_factors: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceCooperativeMatrixFeaturesKHR.html#features-cooperativeMatrix)
    pub cooperative_matrix: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceCooperativeMatrixFeaturesKHR.html#features-cooperativeMatrixRobustBufferAccess)
    pub cooperative_matrix_robust_buffer_access: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceCornerSampledImageFeaturesNV.html#features-cornerSampledImage)
    pub corner_sampled_image: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceCoverageReductionModeFeaturesNV.html#features-coverageReductionMode)
    pub coverage_reduction_mode: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceCubicClampFeaturesQCOM.html#features-cubicRangeClamp)
    pub cubic_range_clamp: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceCudaKernelLaunchFeaturesNV.html#features-cudaKernelLaunchFeatures)
    pub cuda_kernel_launch_features: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceCustomBorderColorFeaturesEXT.html#features-customBorderColorWithoutFormat)
    pub custom_border_color_without_format: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceCustomBorderColorFeaturesEXT.html#features-customBorderColors)
    pub custom_border_colors: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceASTCDecodeFeaturesEXT.html#features-decodeModeSharedExponent)
    pub decode_mode_shared_exponent: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV.html#features-dedicatedAllocationImageAliasing)
    pub dedicated_allocation_image_aliasing: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFeatures.html#features-depthBiasClamp)
    pub depth_bias_clamp: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceDepthBiasControlFeaturesEXT.html#features-depthBiasControl)
    pub depth_bias_control: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceDepthBiasControlFeaturesEXT.html#features-depthBiasExact)
    pub depth_bias_exact: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFeatures.html#features-depthBounds)
    pub depth_bounds: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFeatures.html#features-depthClamp)
    pub depth_clamp: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceDepthClampZeroOneFeaturesEXT.html#features-depthClampZeroOne)
    pub depth_clamp_zero_one: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceDepthClipControlFeaturesEXT.html#features-depthClipControl)
    pub depth_clip_control: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceDepthClipEnableFeaturesEXT.html#features-depthClipEnable)
    pub depth_clip_enable: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceAccelerationStructureFeaturesKHR.html#features-descriptorBindingAccelerationStructureUpdateAfterBind)
    pub descriptor_binding_acceleration_structure_update_after_bind: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceVulkan13Features.html#features-descriptorBindingInlineUniformBlockUpdateAfterBind)
    pub descriptor_binding_inline_uniform_block_update_after_bind: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceVulkan12Features.html#features-descriptorBindingPartiallyBound)
    pub descriptor_binding_partially_bound: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceVulkan12Features.html#features-descriptorBindingSampledImageUpdateAfterBind)
    pub descriptor_binding_sampled_image_update_after_bind: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceVulkan12Features.html#features-descriptorBindingStorageBufferUpdateAfterBind)
    pub descriptor_binding_storage_buffer_update_after_bind: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceVulkan12Features.html#features-descriptorBindingStorageImageUpdateAfterBind)
    pub descriptor_binding_storage_image_update_after_bind: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceVulkan12Features.html#features-descriptorBindingStorageTexelBufferUpdateAfterBind)
    pub descriptor_binding_storage_texel_buffer_update_after_bind: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceVulkan12Features.html#features-descriptorBindingUniformBufferUpdateAfterBind)
    pub descriptor_binding_uniform_buffer_update_after_bind: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceVulkan12Features.html#features-descriptorBindingUniformTexelBufferUpdateAfterBind)
    pub descriptor_binding_uniform_texel_buffer_update_after_bind: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceVulkan12Features.html#features-descriptorBindingUpdateUnusedWhilePending)
    pub descriptor_binding_update_unused_while_pending: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceVulkan12Features.html#features-descriptorBindingVariableDescriptorCount)
    pub descriptor_binding_variable_descriptor_count: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceDescriptorBufferFeaturesEXT.html#features-descriptorBuffer)
    pub descriptor_buffer: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceDescriptorBufferFeaturesEXT.html#features-descriptorBufferCaptureReplay)
    pub descriptor_buffer_capture_replay: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceDescriptorBufferFeaturesEXT.html#features-descriptorBufferImageLayoutIgnored)
    pub descriptor_buffer_image_layout_ignored: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceDescriptorBufferFeaturesEXT.html#features-descriptorBufferPushDescriptors)
    pub descriptor_buffer_push_descriptors: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceVulkan12Features.html#features-descriptorIndexing)
- Required by device extension: [`ext_descriptor_indexing`](crate::device::DeviceExtensions::ext_descriptor_indexing)*/
    pub descriptor_indexing: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV.html#features-descriptorPoolOverallocation)
    pub descriptor_pool_overallocation: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE.html#features-descriptorSetHostMapping)
    pub descriptor_set_host_mapping: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceCoherentMemoryFeaturesAMD.html#features-deviceCoherentMemory)
    pub device_coherent_memory: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFaultFeaturesEXT.html#features-deviceFault)
    pub device_fault: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFaultFeaturesEXT.html#features-deviceFaultVendorBinary)
    pub device_fault_vendor_binary: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV.html#features-deviceGeneratedCommands)
    pub device_generated_commands: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV.html#features-deviceGeneratedCompute)
    pub device_generated_compute: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV.html#features-deviceGeneratedComputeCaptureReplay)
    pub device_generated_compute_capture_replay: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV.html#features-deviceGeneratedComputePipelines)
    pub device_generated_compute_pipelines: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceDeviceMemoryReportFeaturesEXT.html#features-deviceMemoryReport)
    pub device_memory_report: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceDiagnosticsConfigFeaturesNV.html#features-diagnosticsConfig)
    pub diagnostics_config: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceDisplacementMicromapFeaturesNV.html#features-displacementMicromap)
    pub displacement_micromap: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceVulkan12Features.html#features-drawIndirectCount)
- Required by device extension: [`khr_draw_indirect_count`](crate::device::DeviceExtensions::khr_draw_indirect_count)*/
    pub draw_indirect_count: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFeatures.html#features-drawIndirectFirstInstance)
    pub draw_indirect_first_instance: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFeatures.html#features-dualSrcBlend)
    pub dual_src_blend: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevicePerStageDescriptorSetFeaturesNV.html#features-dynamicPipelineLayout)
    pub dynamic_pipeline_layout: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceVulkan13Features.html#features-dynamicRendering)
    pub dynamic_rendering: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceDynamicRenderingLocalReadFeaturesKHR.html#features-dynamicRenderingLocalRead)
    pub dynamic_rendering_local_read: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT.html#features-dynamicRenderingUnusedAttachments)
    pub dynamic_rendering_unused_attachments: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevicePortabilitySubsetFeaturesKHR.html#features-events)
    pub events: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceExclusiveScissorFeaturesNV.html#features-exclusiveScissor)
    pub exclusive_scissor: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceExtendedDynamicStateFeaturesEXT.html#features-extendedDynamicState)
    pub extended_dynamic_state: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceExtendedDynamicState2FeaturesEXT.html#features-extendedDynamicState2)
    pub extended_dynamic_state2: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceExtendedDynamicState2FeaturesEXT.html#features-extendedDynamicState2LogicOp)
    pub extended_dynamic_state2_logic_op: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceExtendedDynamicState2FeaturesEXT.html#features-extendedDynamicState2PatchControlPoints)
    pub extended_dynamic_state2_patch_control_points: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceExtendedDynamicState3FeaturesEXT.html#features-extendedDynamicState3AlphaToCoverageEnable)
    pub extended_dynamic_state3_alpha_to_coverage_enable: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceExtendedDynamicState3FeaturesEXT.html#features-extendedDynamicState3AlphaToOneEnable)
    pub extended_dynamic_state3_alpha_to_one_enable: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceExtendedDynamicState3FeaturesEXT.html#features-extendedDynamicState3ColorBlendAdvanced)
    pub extended_dynamic_state3_color_blend_advanced: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceExtendedDynamicState3FeaturesEXT.html#features-extendedDynamicState3ColorBlendEnable)
    pub extended_dynamic_state3_color_blend_enable: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceExtendedDynamicState3FeaturesEXT.html#features-extendedDynamicState3ColorBlendEquation)
    pub extended_dynamic_state3_color_blend_equation: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceExtendedDynamicState3FeaturesEXT.html#features-extendedDynamicState3ColorWriteMask)
    pub extended_dynamic_state3_color_write_mask: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceExtendedDynamicState3FeaturesEXT.html#features-extendedDynamicState3ConservativeRasterizationMode)
    pub extended_dynamic_state3_conservative_rasterization_mode: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceExtendedDynamicState3FeaturesEXT.html#features-extendedDynamicState3CoverageModulationMode)
    pub extended_dynamic_state3_coverage_modulation_mode: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceExtendedDynamicState3FeaturesEXT.html#features-extendedDynamicState3CoverageModulationTable)
    pub extended_dynamic_state3_coverage_modulation_table: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceExtendedDynamicState3FeaturesEXT.html#features-extendedDynamicState3CoverageModulationTableEnable)
    pub extended_dynamic_state3_coverage_modulation_table_enable: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceExtendedDynamicState3FeaturesEXT.html#features-extendedDynamicState3CoverageReductionMode)
    pub extended_dynamic_state3_coverage_reduction_mode: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceExtendedDynamicState3FeaturesEXT.html#features-extendedDynamicState3CoverageToColorEnable)
    pub extended_dynamic_state3_coverage_to_color_enable: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceExtendedDynamicState3FeaturesEXT.html#features-extendedDynamicState3CoverageToColorLocation)
    pub extended_dynamic_state3_coverage_to_color_location: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceExtendedDynamicState3FeaturesEXT.html#features-extendedDynamicState3DepthClampEnable)
    pub extended_dynamic_state3_depth_clamp_enable: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceExtendedDynamicState3FeaturesEXT.html#features-extendedDynamicState3DepthClipEnable)
    pub extended_dynamic_state3_depth_clip_enable: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceExtendedDynamicState3FeaturesEXT.html#features-extendedDynamicState3DepthClipNegativeOneToOne)
    pub extended_dynamic_state3_depth_clip_negative_one_to_one: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceExtendedDynamicState3FeaturesEXT.html#features-extendedDynamicState3ExtraPrimitiveOverestimationSize)
    pub extended_dynamic_state3_extra_primitive_overestimation_size: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceExtendedDynamicState3FeaturesEXT.html#features-extendedDynamicState3LineRasterizationMode)
    pub extended_dynamic_state3_line_rasterization_mode: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceExtendedDynamicState3FeaturesEXT.html#features-extendedDynamicState3LineStippleEnable)
    pub extended_dynamic_state3_line_stipple_enable: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceExtendedDynamicState3FeaturesEXT.html#features-extendedDynamicState3LogicOpEnable)
    pub extended_dynamic_state3_logic_op_enable: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceExtendedDynamicState3FeaturesEXT.html#features-extendedDynamicState3PolygonMode)
    pub extended_dynamic_state3_polygon_mode: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceExtendedDynamicState3FeaturesEXT.html#features-extendedDynamicState3ProvokingVertexMode)
    pub extended_dynamic_state3_provoking_vertex_mode: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceExtendedDynamicState3FeaturesEXT.html#features-extendedDynamicState3RasterizationSamples)
    pub extended_dynamic_state3_rasterization_samples: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceExtendedDynamicState3FeaturesEXT.html#features-extendedDynamicState3RasterizationStream)
    pub extended_dynamic_state3_rasterization_stream: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceExtendedDynamicState3FeaturesEXT.html#features-extendedDynamicState3RepresentativeFragmentTestEnable)
    pub extended_dynamic_state3_representative_fragment_test_enable: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceExtendedDynamicState3FeaturesEXT.html#features-extendedDynamicState3SampleLocationsEnable)
    pub extended_dynamic_state3_sample_locations_enable: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceExtendedDynamicState3FeaturesEXT.html#features-extendedDynamicState3SampleMask)
    pub extended_dynamic_state3_sample_mask: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceExtendedDynamicState3FeaturesEXT.html#features-extendedDynamicState3ShadingRateImageEnable)
    pub extended_dynamic_state3_shading_rate_image_enable: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceExtendedDynamicState3FeaturesEXT.html#features-extendedDynamicState3TessellationDomainOrigin)
    pub extended_dynamic_state3_tessellation_domain_origin: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceExtendedDynamicState3FeaturesEXT.html#features-extendedDynamicState3ViewportSwizzle)
    pub extended_dynamic_state3_viewport_swizzle: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceExtendedDynamicState3FeaturesEXT.html#features-extendedDynamicState3ViewportWScalingEnable)
    pub extended_dynamic_state3_viewport_w_scaling_enable: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV.html#features-extendedSparseAddressSpace)
    pub extended_sparse_address_space: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceExternalFormatResolveFeaturesANDROID.html#features-externalFormatResolve)
    pub external_format_resolve: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceExternalMemoryRDMAFeaturesNV.html#features-externalMemoryRDMA)
    pub external_memory_rdma: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFeatures.html#features-fillModeNonSolid)
    pub fill_mode_non_solid: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceDepthBiasControlFeaturesEXT.html#features-floatRepresentation)
    pub float_representation: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevice4444FormatsFeaturesEXT.html#features-formatA4B4G4R4)
    pub format_a4b4g4r4: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevice4444FormatsFeaturesEXT.html#features-formatA4R4G4B4)
    pub format_a4r4g4b4: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT.html#features-formatRgba10x6WithoutYCbCrSampler)
    pub format_rgba10x6_without_y_cb_cr_sampler: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFragmentDensityMapFeaturesEXT.html#features-fragmentDensityMap)
- Conflicts with features: [`pipeline_fragment_shading_rate`](crate::device::DeviceFeatures::pipeline_fragment_shading_rate), [`primitive_fragment_shading_rate`](crate::device::DeviceFeatures::primitive_fragment_shading_rate), [`attachment_fragment_shading_rate`](crate::device::DeviceFeatures::attachment_fragment_shading_rate)*/
    pub fragment_density_map: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFragmentDensityMap2FeaturesEXT.html#features-fragmentDensityMapDeferred)
    pub fragment_density_map_deferred: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFragmentDensityMapFeaturesEXT.html#features-fragmentDensityMapDynamic)
    pub fragment_density_map_dynamic: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFragmentDensityMapFeaturesEXT.html#features-fragmentDensityMapNonSubsampledImages)
    pub fragment_density_map_non_subsampled_images: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM.html#features-fragmentDensityMapOffset)
    pub fragment_density_map_offset: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR.html#features-fragmentShaderBarycentric)
    pub fragment_shader_barycentric: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT.html#features-fragmentShaderPixelInterlock)
    pub fragment_shader_pixel_interlock: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT.html#features-fragmentShaderSampleInterlock)
    pub fragment_shader_sample_interlock: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT.html#features-fragmentShaderShadingRateInterlock)
    pub fragment_shader_shading_rate_interlock: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV.html#features-fragmentShadingRateEnums)
    pub fragment_shading_rate_enums: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFeatures.html#features-fragmentStoresAndAtomics)
    pub fragment_stores_and_atomics: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFrameBoundaryFeaturesEXT.html#features-frameBoundary)
    pub frame_boundary: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFeatures.html#features-fullDrawIndexUint32)
    pub full_draw_index_uint32: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFeatures.html#features-geometryShader)
    pub geometry_shader: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceTransformFeedbackFeaturesEXT.html#features-geometryStreams)
    pub geometry_streams: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR.html#features-globalPriorityQuery)
    pub global_priority_query: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT.html#features-graphicsPipelineLibrary)
    pub graphics_pipeline_library: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceHostImageCopyFeaturesEXT.html#features-hostImageCopy)
    pub host_image_copy: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceVulkan12Features.html#features-hostQueryReset)
    pub host_query_reset: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceImage2DViewOf3DFeaturesEXT.html#features-image2DViewOf3D)
    pub image2_d_view_of3_d: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceImageCompressionControlFeaturesEXT.html#features-imageCompressionControl)
    pub image_compression_control: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT.html#features-imageCompressionControlSwapchain)
    pub image_compression_control_swapchain: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFeatures.html#features-imageCubeArray)
    pub image_cube_array: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderImageFootprintFeaturesNV.html#features-imageFootprint)
    pub image_footprint: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT.html#features-imageSlicedViewOf3D)
    pub image_sliced_view_of3_d: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevicePortabilitySubsetFeaturesKHR.html#features-imageView2DOn3DImage)
    pub image_view2_d_on3_d_image: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevicePortabilitySubsetFeaturesKHR.html#features-imageViewFormatReinterpretation)
    pub image_view_format_reinterpretation: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevicePortabilitySubsetFeaturesKHR.html#features-imageViewFormatSwizzle)
    pub image_view_format_swizzle: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceVulkan12Features.html#features-imagelessFramebuffer)
    pub imageless_framebuffer: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFeatures.html#features-independentBlend)
    pub independent_blend: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceIndexTypeUint8FeaturesKHR.html#features-indexTypeUint8)
    pub index_type_uint8: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceCopyMemoryIndirectFeaturesNV.html#features-indirectCopy)
    pub indirect_copy: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceConditionalRenderingFeaturesEXT.html#features-inheritedConditionalRendering)
    pub inherited_conditional_rendering: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFeatures.html#features-inheritedQueries)
    pub inherited_queries: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceInheritedViewportScissorFeaturesNV.html#features-inheritedViewportScissor2D)
    pub inherited_viewport_scissor2_d: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceVulkan13Features.html#features-inlineUniformBlock)
    pub inline_uniform_block: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceInvocationMaskFeaturesHUAWEI.html#features-invocationMask)
    pub invocation_mask: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFeatures.html#features-largePoints)
    pub large_points: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceDepthBiasControlFeaturesEXT.html#features-leastRepresentableValueForceUnormRepresentation)
    pub least_representable_value_force_unorm_representation: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceLegacyDitheringFeaturesEXT.html#features-legacyDithering)
    pub legacy_dithering: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceLinearColorAttachmentFeaturesNV.html#features-linearColorAttachment)
    pub linear_color_attachment: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFeatures.html#features-logicOp)
    pub logic_op: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceVulkan13Features.html#features-maintenance4)
    pub maintenance4: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceMaintenance5FeaturesKHR.html#features-maintenance5)
    pub maintenance5: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceMaintenance6FeaturesKHR.html#features-maintenance6)
    pub maintenance6: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceMemoryDecompressionFeaturesNV.html#features-memoryDecompression)
    pub memory_decompression: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceMapMemoryPlacedFeaturesEXT.html#features-memoryMapPlaced)
    pub memory_map_placed: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceMapMemoryPlacedFeaturesEXT.html#features-memoryMapRangePlaced)
    pub memory_map_range_placed: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceMemoryPriorityFeaturesEXT.html#features-memoryPriority)
    pub memory_priority: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceMapMemoryPlacedFeaturesEXT.html#features-memoryUnmapReserve)
    pub memory_unmap_reserve: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceMeshShaderFeaturesEXT.html#features-meshShader)
    pub mesh_shader: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceMeshShaderFeaturesEXT.html#features-meshShaderQueries)
    pub mesh_shader_queries: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceOpacityMicromapFeaturesEXT.html#features-micromap)
    pub micromap: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceOpacityMicromapFeaturesEXT.html#features-micromapCaptureReplay)
    pub micromap_capture_replay: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceOpacityMicromapFeaturesEXT.html#features-micromapHostCommands)
    pub micromap_host_commands: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceImageViewMinLodFeaturesEXT.html#features-minLod)
    pub min_lod: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceMultiDrawFeaturesEXT.html#features-multiDraw)
    pub multi_draw: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFeatures.html#features-multiDrawIndirect)
    pub multi_draw_indirect: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFeatures.html#features-multiViewport)
    pub multi_viewport: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevicePortabilitySubsetFeaturesKHR.html#features-multisampleArrayImage)
    pub multisample_array_image: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT.html#features-multisampledRenderToSingleSampled)
    pub multisampled_render_to_single_sampled: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceVulkan11Features.html#features-multiview)
    pub multiview: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI.html#features-multiviewClusterCullingShader)
    pub multiview_cluster_culling_shader: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceVulkan11Features.html#features-multiviewGeometryShader)
    pub multiview_geometry_shader: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceMeshShaderFeaturesEXT.html#features-multiviewMeshShader)
    pub multiview_mesh_shader: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM.html#features-multiviewPerViewRenderAreas)
    pub multiview_per_view_render_areas: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM.html#features-multiviewPerViewViewports)
    pub multiview_per_view_viewports: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceVulkan11Features.html#features-multiviewTessellationShader)
    pub multiview_tessellation_shader: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevicePortabilitySubsetFeaturesKHR.html#features-mutableComparisonSamplers)
    pub mutable_comparison_samplers: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT.html#features-mutableDescriptorType)
    pub mutable_descriptor_type: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceNestedCommandBufferFeaturesEXT.html#features-nestedCommandBuffer)
    pub nested_command_buffer: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceNestedCommandBufferFeaturesEXT.html#features-nestedCommandBufferRendering)
    pub nested_command_buffer_rendering: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceNestedCommandBufferFeaturesEXT.html#features-nestedCommandBufferSimultaneousUse)
    pub nested_command_buffer_simultaneous_use: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV.html#features-noInvocationFragmentShadingRates)
    pub no_invocation_fragment_shading_rates: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT.html#features-nonSeamlessCubeMap)
    pub non_seamless_cube_map: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceRobustness2FeaturesEXT.html#features-nullDescriptor)
    pub null_descriptor: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFeatures.html#features-occlusionQueryPrecise)
    pub occlusion_query_precise: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceOpticalFlowFeaturesNV.html#features-opticalFlow)
    pub optical_flow: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT.html#features-pageableDeviceLocalMemory)
    pub pageable_device_local_memory: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevicePerStageDescriptorSetFeaturesNV.html#features-perStageDescriptorSet)
    pub per_stage_descriptor_set: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevicePerformanceQueryFeaturesKHR.html#features-performanceCounterMultipleQueryPools)
    pub performance_counter_multiple_query_pools: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevicePerformanceQueryFeaturesKHR.html#features-performanceCounterQueryPools)
    pub performance_counter_query_pools: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceVulkan13Features.html#features-pipelineCreationCacheControl)
    pub pipeline_creation_cache_control: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR.html#features-pipelineExecutableInfo)
    pub pipeline_executable_info: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFragmentShadingRateFeaturesKHR.html#features-pipelineFragmentShadingRate)
- Conflicts with features: [`shading_rate_image`](crate::device::DeviceFeatures::shading_rate_image), [`fragment_density_map`](crate::device::DeviceFeatures::fragment_density_map)*/
    pub pipeline_fragment_shading_rate: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT.html#features-pipelineLibraryGroupHandles)
    pub pipeline_library_group_handles: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevicePipelinePropertiesFeaturesEXT.html#features-pipelinePropertiesIdentifier)
    pub pipeline_properties_identifier: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevicePipelineProtectedAccessFeaturesEXT.html#features-pipelineProtectedAccess)
    pub pipeline_protected_access: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevicePipelineRobustnessFeaturesEXT.html#features-pipelineRobustness)
    pub pipeline_robustness: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFeatures.html#features-pipelineStatisticsQuery)
    pub pipeline_statistics_query: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevicePortabilitySubsetFeaturesKHR.html#features-pointPolygons)
    pub point_polygons: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevicePresentBarrierFeaturesNV.html#features-presentBarrier)
    pub present_barrier: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevicePresentIdFeaturesKHR.html#features-presentId)
    pub present_id: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevicePresentWaitFeaturesKHR.html#features-presentWait)
    pub present_wait: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFragmentShadingRateFeaturesKHR.html#features-primitiveFragmentShadingRate)
- Conflicts with features: [`shading_rate_image`](crate::device::DeviceFeatures::shading_rate_image), [`fragment_density_map`](crate::device::DeviceFeatures::fragment_density_map)*/
    pub primitive_fragment_shading_rate: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceMeshShaderFeaturesEXT.html#features-primitiveFragmentShadingRateMeshShader)
    pub primitive_fragment_shading_rate_mesh_shader: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT.html#features-primitiveTopologyListRestart)
    pub primitive_topology_list_restart: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT.html#features-primitiveTopologyPatchListRestart)
    pub primitive_topology_patch_list_restart: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT.html#features-primitivesGeneratedQuery)
    pub primitives_generated_query: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT.html#features-primitivesGeneratedQueryWithNonZeroStreams)
    pub primitives_generated_query_with_non_zero_streams: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT.html#features-primitivesGeneratedQueryWithRasterizerDiscard)
    pub primitives_generated_query_with_rasterizer_discard: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceVulkan13Features.html#features-privateData)
    pub private_data: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceVulkan11Features.html#features-protectedMemory)
    pub protected_memory: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceProvokingVertexFeaturesEXT.html#features-provokingVertexLast)
    pub provoking_vertex_last: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT.html#features-rasterizationOrderColorAttachmentAccess)
    pub rasterization_order_color_attachment_access: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT.html#features-rasterizationOrderDepthAttachmentAccess)
    pub rasterization_order_depth_attachment_access: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT.html#features-rasterizationOrderStencilAttachmentAccess)
    pub rasterization_order_stencil_attachment_access: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceRayQueryFeaturesKHR.html#features-rayQuery)
    pub ray_query: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV.html#features-rayTracingInvocationReorder)
    pub ray_tracing_invocation_reorder: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR.html#features-rayTracingMaintenance1)
    pub ray_tracing_maintenance1: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceRayTracingMotionBlurFeaturesNV.html#features-rayTracingMotionBlur)
    pub ray_tracing_motion_blur: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceRayTracingMotionBlurFeaturesNV.html#features-rayTracingMotionBlurPipelineTraceRaysIndirect)
    pub ray_tracing_motion_blur_pipeline_trace_rays_indirect: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceRayTracingPipelineFeaturesKHR.html#features-rayTracingPipeline)
    pub ray_tracing_pipeline: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceRayTracingPipelineFeaturesKHR.html#features-rayTracingPipelineShaderGroupHandleCaptureReplay)
    pub ray_tracing_pipeline_shader_group_handle_capture_replay: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceRayTracingPipelineFeaturesKHR.html#features-rayTracingPipelineShaderGroupHandleCaptureReplayMixed)
    pub ray_tracing_pipeline_shader_group_handle_capture_replay_mixed: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceRayTracingPipelineFeaturesKHR.html#features-rayTracingPipelineTraceRaysIndirect)
    pub ray_tracing_pipeline_trace_rays_indirect: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR.html#features-rayTracingPipelineTraceRaysIndirect2)
    pub ray_tracing_pipeline_trace_rays_indirect2: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR.html#features-rayTracingPositionFetch)
    pub ray_tracing_position_fetch: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceRayTracingValidationFeaturesNV.html#features-rayTracingValidation)
    pub ray_tracing_validation: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceRayTracingPipelineFeaturesKHR.html#features-rayTraversalPrimitiveCulling)
    pub ray_traversal_primitive_culling: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceLineRasterizationFeaturesKHR.html#features-rectangularLines)
    pub rectangular_lines: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG.html#features-relaxedLineRasterization)
    pub relaxed_line_rasterization: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceRenderPassStripedFeaturesARM.html#features-renderPassStriped)
    pub render_pass_striped: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceAddressBindingReportFeaturesEXT.html#features-reportAddressBinding)
    pub report_address_binding: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV.html#features-representativeFragmentTest)
    pub representative_fragment_test: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFeatures.html#features-robustBufferAccess)
    pub robust_buffer_access: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceRobustness2FeaturesEXT.html#features-robustBufferAccess2)
    pub robust_buffer_access2: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceVulkan13Features.html#features-robustImageAccess)
    pub robust_image_access: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceRobustness2FeaturesEXT.html#features-robustImageAccess2)
    pub robust_image_access2: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceVulkan12Features.html#features-runtimeDescriptorArray)
    pub runtime_descriptor_array: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFeatures.html#features-sampleRateShading)
    pub sample_rate_shading: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceImage2DViewOf3DFeaturesEXT.html#features-sampler2DViewOf3D)
    pub sampler2_d_view_of3_d: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFeatures.html#features-samplerAnisotropy)
    pub sampler_anisotropy: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceVulkan12Features.html#features-samplerFilterMinmax)
- Required by device extension: [`ext_sampler_filter_minmax`](crate::device::DeviceExtensions::ext_sampler_filter_minmax)*/
    pub sampler_filter_minmax: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevicePortabilitySubsetFeaturesKHR.html#features-samplerMipLodBias)
    pub sampler_mip_lod_bias: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceVulkan12Features.html#features-samplerMirrorClampToEdge)
- Required by device extension: [`khr_sampler_mirror_clamp_to_edge`](crate::device::DeviceExtensions::khr_sampler_mirror_clamp_to_edge)*/
    pub sampler_mirror_clamp_to_edge: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceVulkan11Features.html#features-samplerYcbcrConversion)
    pub sampler_ycbcr_conversion: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceVulkan12Features.html#features-scalarBlockLayout)
    pub scalar_block_layout: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceSchedulingControlsFeaturesARM.html#features-schedulingControls)
    pub scheduling_controls: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceExternalMemoryScreenBufferFeaturesQNX.html#features-screenBufferImport)
    pub screen_buffer_import: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceCubicWeightsFeaturesQCOM.html#features-selectableCubicWeights)
    pub selectable_cubic_weights: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceVulkan12Features.html#features-separateDepthStencilLayouts)
    pub separate_depth_stencil_layouts: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevicePortabilitySubsetFeaturesKHR.html#features-separateStencilMaskRef)
    pub separate_stencil_mask_ref: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT.html#features-shaderBufferFloat16AtomicAdd)
    pub shader_buffer_float16_atomic_add: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT.html#features-shaderBufferFloat16AtomicMinMax)
    pub shader_buffer_float16_atomic_min_max: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT.html#features-shaderBufferFloat16Atomics)
    pub shader_buffer_float16_atomics: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderAtomicFloatFeaturesEXT.html#features-shaderBufferFloat32AtomicAdd)
    pub shader_buffer_float32_atomic_add: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT.html#features-shaderBufferFloat32AtomicMinMax)
    pub shader_buffer_float32_atomic_min_max: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderAtomicFloatFeaturesEXT.html#features-shaderBufferFloat32Atomics)
    pub shader_buffer_float32_atomics: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderAtomicFloatFeaturesEXT.html#features-shaderBufferFloat64AtomicAdd)
    pub shader_buffer_float64_atomic_add: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT.html#features-shaderBufferFloat64AtomicMinMax)
    pub shader_buffer_float64_atomic_min_max: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderAtomicFloatFeaturesEXT.html#features-shaderBufferFloat64Atomics)
    pub shader_buffer_float64_atomics: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceVulkan12Features.html#features-shaderBufferInt64Atomics)
    pub shader_buffer_int64_atomics: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFeatures.html#features-shaderClipDistance)
    pub shader_clip_distance: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM.html#features-shaderCoreBuiltins)
    pub shader_core_builtins: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFeatures.html#features-shaderCullDistance)
    pub shader_cull_distance: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceVulkan13Features.html#features-shaderDemoteToHelperInvocation)
    pub shader_demote_to_helper_invocation: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderClockFeaturesKHR.html#features-shaderDeviceClock)
    pub shader_device_clock: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceVulkan11Features.html#features-shaderDrawParameters)
- Required by device extension: [`khr_shader_draw_parameters`](crate::device::DeviceExtensions::khr_shader_draw_parameters)*/
    pub shader_draw_parameters: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD.html#features-shaderEarlyAndLateFragmentTests)
    pub shader_early_and_late_fragment_tests: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderEnqueueFeaturesAMDX.html#features-shaderEnqueue)
    pub shader_enqueue: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderExpectAssumeFeaturesKHR.html#features-shaderExpectAssume)
    pub shader_expect_assume: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceVulkan12Features.html#features-shaderFloat16)
    pub shader_float16: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderAtomicFloat16VectorFeaturesNV.html#features-shaderFloat16VectorAtomics)
    pub shader_float16_vector_atomics: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFeatures.html#features-shaderFloat64)
    pub shader_float64: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderFloatControls2FeaturesKHR.html#features-shaderFloatControls2)
    pub shader_float_controls2: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderAtomicFloatFeaturesEXT.html#features-shaderImageFloat32AtomicAdd)
    pub shader_image_float32_atomic_add: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT.html#features-shaderImageFloat32AtomicMinMax)
    pub shader_image_float32_atomic_min_max: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderAtomicFloatFeaturesEXT.html#features-shaderImageFloat32Atomics)
    pub shader_image_float32_atomics: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFeatures.html#features-shaderImageGatherExtended)
    pub shader_image_gather_extended: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT.html#features-shaderImageInt64Atomics)
    pub shader_image_int64_atomics: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceVulkan12Features.html#features-shaderInputAttachmentArrayDynamicIndexing)
    pub shader_input_attachment_array_dynamic_indexing: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceVulkan12Features.html#features-shaderInputAttachmentArrayNonUniformIndexing)
    pub shader_input_attachment_array_non_uniform_indexing: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFeatures.html#features-shaderInt16)
    pub shader_int16: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFeatures.html#features-shaderInt64)
    pub shader_int64: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceVulkan12Features.html#features-shaderInt8)
    pub shader_int8: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceVulkan13Features.html#features-shaderIntegerDotProduct)
    pub shader_integer_dot_product: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL.html#features-shaderIntegerFunctions2)
    pub shader_integer_functions2: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR.html#features-shaderMaximalReconvergence)
    pub shader_maximal_reconvergence: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT.html#features-shaderModuleIdentifier)
    pub shader_module_identifier: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderObjectFeaturesEXT.html#features-shaderObject)
    pub shader_object: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceVulkan12Features.html#features-shaderOutputLayer)
- Required by device extension: [`ext_shader_viewport_index_layer`](crate::device::DeviceExtensions::ext_shader_viewport_index_layer)*/
    pub shader_output_layer: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceVulkan12Features.html#features-shaderOutputViewportIndex)
- Required by device extension: [`ext_shader_viewport_index_layer`](crate::device::DeviceExtensions::ext_shader_viewport_index_layer)*/
    pub shader_output_viewport_index: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderQuadControlFeaturesKHR.html#features-shaderQuadControl)
    pub shader_quad_control: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceRawAccessChainsFeaturesNV.html#features-shaderRawAccessChains)
    pub shader_raw_access_chains: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFeatures.html#features-shaderResourceMinLod)
    pub shader_resource_min_lod: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFeatures.html#features-shaderResourceResidency)
    pub shader_resource_residency: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevicePortabilitySubsetFeaturesKHR.html#features-shaderSampleRateInterpolationFunctions)
    pub shader_sample_rate_interpolation_functions: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFeatures.html#features-shaderSampledImageArrayDynamicIndexing)
    pub shader_sampled_image_array_dynamic_indexing: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceVulkan12Features.html#features-shaderSampledImageArrayNonUniformIndexing)
    pub shader_sampled_image_array_non_uniform_indexing: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT.html#features-shaderSharedFloat16AtomicAdd)
    pub shader_shared_float16_atomic_add: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT.html#features-shaderSharedFloat16AtomicMinMax)
    pub shader_shared_float16_atomic_min_max: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT.html#features-shaderSharedFloat16Atomics)
    pub shader_shared_float16_atomics: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderAtomicFloatFeaturesEXT.html#features-shaderSharedFloat32AtomicAdd)
    pub shader_shared_float32_atomic_add: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT.html#features-shaderSharedFloat32AtomicMinMax)
    pub shader_shared_float32_atomic_min_max: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderAtomicFloatFeaturesEXT.html#features-shaderSharedFloat32Atomics)
    pub shader_shared_float32_atomics: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderAtomicFloatFeaturesEXT.html#features-shaderSharedFloat64AtomicAdd)
    pub shader_shared_float64_atomic_add: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT.html#features-shaderSharedFloat64AtomicMinMax)
    pub shader_shared_float64_atomic_min_max: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderAtomicFloatFeaturesEXT.html#features-shaderSharedFloat64Atomics)
    pub shader_shared_float64_atomics: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceVulkan12Features.html#features-shaderSharedInt64Atomics)
    pub shader_shared_int64_atomics: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderSMBuiltinsFeaturesNV.html#features-shaderSMBuiltins)
    pub shader_sm_builtins: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFeatures.html#features-shaderStorageBufferArrayDynamicIndexing)
    pub shader_storage_buffer_array_dynamic_indexing: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceVulkan12Features.html#features-shaderStorageBufferArrayNonUniformIndexing)
    pub shader_storage_buffer_array_non_uniform_indexing: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFeatures.html#features-shaderStorageImageArrayDynamicIndexing)
    pub shader_storage_image_array_dynamic_indexing: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceVulkan12Features.html#features-shaderStorageImageArrayNonUniformIndexing)
    pub shader_storage_image_array_non_uniform_indexing: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFeatures.html#features-shaderStorageImageExtendedFormats)
    pub shader_storage_image_extended_formats: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFeatures.html#features-shaderStorageImageMultisample)
    pub shader_storage_image_multisample: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFeatures.html#features-shaderStorageImageReadWithoutFormat)
    pub shader_storage_image_read_without_format: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFeatures.html#features-shaderStorageImageWriteWithoutFormat)
    pub shader_storage_image_write_without_format: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceVulkan12Features.html#features-shaderStorageTexelBufferArrayDynamicIndexing)
    pub shader_storage_texel_buffer_array_dynamic_indexing: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceVulkan12Features.html#features-shaderStorageTexelBufferArrayNonUniformIndexing)
    pub shader_storage_texel_buffer_array_non_uniform_indexing: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderClockFeaturesKHR.html#features-shaderSubgroupClock)
    pub shader_subgroup_clock: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceVulkan12Features.html#features-shaderSubgroupExtendedTypes)
    pub shader_subgroup_extended_types: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderSubgroupRotateFeaturesKHR.html#features-shaderSubgroupRotate)
    pub shader_subgroup_rotate: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderSubgroupRotateFeaturesKHR.html#features-shaderSubgroupRotateClustered)
    pub shader_subgroup_rotate_clustered: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR.html#features-shaderSubgroupUniformControlFlow)
    pub shader_subgroup_uniform_control_flow: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceVulkan13Features.html#features-shaderTerminateInvocation)
    pub shader_terminate_invocation: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFeatures.html#features-shaderTessellationAndGeometryPointSize)
    pub shader_tessellation_and_geometry_point_size: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderTileImageFeaturesEXT.html#features-shaderTileImageColorReadAccess)
    pub shader_tile_image_color_read_access: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderTileImageFeaturesEXT.html#features-shaderTileImageDepthReadAccess)
    pub shader_tile_image_depth_read_access: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderTileImageFeaturesEXT.html#features-shaderTileImageStencilReadAccess)
    pub shader_tile_image_stencil_read_access: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFeatures.html#features-shaderUniformBufferArrayDynamicIndexing)
    pub shader_uniform_buffer_array_dynamic_indexing: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceVulkan12Features.html#features-shaderUniformBufferArrayNonUniformIndexing)
    pub shader_uniform_buffer_array_non_uniform_indexing: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceVulkan12Features.html#features-shaderUniformTexelBufferArrayDynamicIndexing)
    pub shader_uniform_texel_buffer_array_dynamic_indexing: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceVulkan12Features.html#features-shaderUniformTexelBufferArrayNonUniformIndexing)
    pub shader_uniform_texel_buffer_array_non_uniform_indexing: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceVulkan13Features.html#features-shaderZeroInitializeWorkgroupMemory)
    pub shader_zero_initialize_workgroup_memory: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShadingRateImageFeaturesNV.html#features-shadingRateCoarseSampleOrder)
    pub shading_rate_coarse_sample_order: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShadingRateImageFeaturesNV.html#features-shadingRateImage)
- Conflicts with features: [`pipeline_fragment_shading_rate`](crate::device::DeviceFeatures::pipeline_fragment_shading_rate), [`primitive_fragment_shading_rate`](crate::device::DeviceFeatures::primitive_fragment_shading_rate), [`attachment_fragment_shading_rate`](crate::device::DeviceFeatures::attachment_fragment_shading_rate)*/
    pub shading_rate_image: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceLineRasterizationFeaturesKHR.html#features-smoothLines)
    pub smooth_lines: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFeatures.html#features-sparseBinding)
    pub sparse_binding: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderAtomicFloatFeaturesEXT.html#features-sparseImageFloat32AtomicAdd)
- Requires feature: [`shader_image_float32_atomic_add`](crate::device::DeviceFeatures::shader_image_float32_atomic_add)*/
    pub sparse_image_float32_atomic_add: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT.html#features-sparseImageFloat32AtomicMinMax)
- Requires feature: [`shader_image_float32_atomic_min_max`](crate::device::DeviceFeatures::shader_image_float32_atomic_min_max)*/
    pub sparse_image_float32_atomic_min_max: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderAtomicFloatFeaturesEXT.html#features-sparseImageFloat32Atomics)
- Requires feature: [`shader_image_float32_atomics`](crate::device::DeviceFeatures::shader_image_float32_atomics)*/
    pub sparse_image_float32_atomics: bool,
    /**- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT.html#features-sparseImageInt64Atomics)
- Requires feature: [`shader_image_int64_atomics`](crate::device::DeviceFeatures::shader_image_int64_atomics)*/
    pub sparse_image_int64_atomics: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFeatures.html#features-sparseResidency16Samples)
    pub sparse_residency16_samples: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFeatures.html#features-sparseResidency2Samples)
    pub sparse_residency2_samples: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFeatures.html#features-sparseResidency4Samples)
    pub sparse_residency4_samples: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFeatures.html#features-sparseResidency8Samples)
    pub sparse_residency8_samples: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFeatures.html#features-sparseResidencyAliased)
    pub sparse_residency_aliased: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFeatures.html#features-sparseResidencyBuffer)
    pub sparse_residency_buffer: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFeatures.html#features-sparseResidencyImage2D)
    pub sparse_residency_image2_d: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFeatures.html#features-sparseResidencyImage3D)
    pub sparse_residency_image3_d: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceLineRasterizationFeaturesKHR.html#features-stippledBresenhamLines)
    pub stippled_bresenham_lines: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceLineRasterizationFeaturesKHR.html#features-stippledRectangularLines)
    pub stippled_rectangular_lines: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceLineRasterizationFeaturesKHR.html#features-stippledSmoothLines)
    pub stippled_smooth_lines: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceVulkan11Features.html#features-storageBuffer16BitAccess)
    pub storage_buffer16_bit_access: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceVulkan12Features.html#features-storageBuffer8BitAccess)
    pub storage_buffer8_bit_access: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceVulkan11Features.html#features-storageInputOutput16)
    pub storage_input_output16: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceVulkan11Features.html#features-storagePushConstant16)
    pub storage_push_constant16: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceVulkan12Features.html#features-storagePushConstant8)
    pub storage_push_constant8: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceVulkan12Features.html#features-subgroupBroadcastDynamicId)
    pub subgroup_broadcast_dynamic_id: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceVulkan13Features.html#features-subgroupSizeControl)
    pub subgroup_size_control: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT.html#features-subpassMergeFeedback)
    pub subpass_merge_feedback: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceSubpassShadingFeaturesHUAWEI.html#features-subpassShading)
    pub subpass_shading: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV.html#features-supersampleFragmentShadingRates)
    pub supersample_fragment_shading_rates: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT.html#features-swapchainMaintenance1)
    pub swapchain_maintenance1: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceVulkan13Features.html#features-synchronization2)
    pub synchronization2: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceMeshShaderFeaturesEXT.html#features-taskShader)
    pub task_shader: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevicePortabilitySubsetFeaturesKHR.html#features-tessellationIsolines)
    pub tessellation_isolines: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevicePortabilitySubsetFeaturesKHR.html#features-tessellationPointMode)
    pub tessellation_point_mode: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFeatures.html#features-tessellationShader)
    pub tessellation_shader: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT.html#features-texelBufferAlignment)
    pub texel_buffer_alignment: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceImageProcessingFeaturesQCOM.html#features-textureBlockMatch)
    pub texture_block_match: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceImageProcessing2FeaturesQCOM.html#features-textureBlockMatch2)
    pub texture_block_match2: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceImageProcessingFeaturesQCOM.html#features-textureBoxFilter)
    pub texture_box_filter: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceVulkan13Features.html#features-textureCompressionASTC_HDR)
    pub texture_compression_astc_hdr: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFeatures.html#features-textureCompressionASTC_LDR)
    pub texture_compression_astc_ldr: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFeatures.html#features-textureCompressionBC)
    pub texture_compression_bc: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFeatures.html#features-textureCompressionETC2)
    pub texture_compression_etc2: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceImageProcessingFeaturesQCOM.html#features-textureSampleWeighted)
    pub texture_sample_weighted: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceTilePropertiesFeaturesQCOM.html#features-tileProperties)
    pub tile_properties: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceVulkan12Features.html#features-timelineSemaphore)
    pub timeline_semaphore: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceTransformFeedbackFeaturesEXT.html#features-transformFeedback)
    pub transform_feedback: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceProvokingVertexFeaturesEXT.html#features-transformFeedbackPreservesProvokingVertex)
    pub transform_feedback_preserves_provoking_vertex: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevicePortabilitySubsetFeaturesKHR.html#features-triangleFans)
    pub triangle_fans: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceVulkan11Features.html#features-uniformAndStorageBuffer16BitAccess)
    pub uniform_and_storage_buffer16_bit_access: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceVulkan12Features.html#features-uniformAndStorageBuffer8BitAccess)
    pub uniform_and_storage_buffer8_bit_access: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceVulkan12Features.html#features-uniformBufferStandardLayout)
    pub uniform_buffer_standard_layout: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFeatures.html#features-variableMultisampleRate)
    pub variable_multisample_rate: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceVulkan11Features.html#features-variablePointers)
    pub variable_pointers: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceVulkan11Features.html#features-variablePointersStorageBuffer)
    pub variable_pointers_storage_buffer: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDevicePortabilitySubsetFeaturesKHR.html#features-vertexAttributeAccessBeyondStride)
    pub vertex_attribute_access_beyond_stride: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceVertexAttributeDivisorFeaturesKHR.html#features-vertexAttributeInstanceRateDivisor)
    pub vertex_attribute_instance_rate_divisor: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceVertexAttributeDivisorFeaturesKHR.html#features-vertexAttributeInstanceRateZeroDivisor)
    pub vertex_attribute_instance_rate_zero_divisor: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT.html#features-vertexInputDynamicState)
    pub vertex_input_dynamic_state: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFeatures.html#features-vertexPipelineStoresAndAtomics)
    pub vertex_pipeline_stores_and_atomics: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceVideoMaintenance1FeaturesKHR.html#features-videoMaintenance1)
    pub video_maintenance1: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceVulkan12Features.html#features-vulkanMemoryModel)
    pub vulkan_memory_model: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceVulkan12Features.html#features-vulkanMemoryModelAvailabilityVisibilityChains)
    pub vulkan_memory_model_availability_visibility_chains: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceVulkan12Features.html#features-vulkanMemoryModelDeviceScope)
    pub vulkan_memory_model_device_scope: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceFeatures.html#features-wideLines)
    pub wide_lines: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR.html#features-workgroupMemoryExplicitLayout)
    pub workgroup_memory_explicit_layout: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR.html#features-workgroupMemoryExplicitLayout16BitAccess)
    pub workgroup_memory_explicit_layout16_bit_access: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR.html#features-workgroupMemoryExplicitLayout8BitAccess)
    pub workgroup_memory_explicit_layout8_bit_access: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR.html#features-workgroupMemoryExplicitLayoutScalarBlockLayout)
    pub workgroup_memory_explicit_layout_scalar_block_layout: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT.html#features-ycbcr2plane444Formats)
    pub ycbcr2plane444_formats: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceYcbcrDegammaFeaturesQCOM.html#features-ycbcrDegamma)
    pub ycbcr_degamma: bool,
    ///- [Vulkan documentation](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceYcbcrImageArraysFeaturesEXT.html#features-ycbcrImageArrays)
    pub ycbcr_image_arrays: bool,
    pub _ne: crate::NonExhaustive,
}
impl Default for DeviceFeatures {
    #[inline]
    fn default() -> Self {
        Self::empty()
    }
}
impl DeviceFeatures {
    /// Checks enabled features against the features supported by the physical device.
    pub(super) fn check_requirements(
        &self,
        supported: &DeviceFeatures,
    ) -> Result<(), Box<crate::ValidationError>> {
        if self.acceleration_structure && !supported.acceleration_structure {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "acceleration_structure",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.acceleration_structure_capture_replay
            && !supported.acceleration_structure_capture_replay
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "acceleration_structure_capture_replay",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.acceleration_structure_host_commands
            && !supported.acceleration_structure_host_commands
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "acceleration_structure_host_commands",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.acceleration_structure_indirect_build
            && !supported.acceleration_structure_indirect_build
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "acceleration_structure_indirect_build",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.advanced_blend_coherent_operations
            && !supported.advanced_blend_coherent_operations
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "advanced_blend_coherent_operations",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.alpha_to_one && !supported.alpha_to_one {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "alpha_to_one",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.amigo_profiling && !supported.amigo_profiling {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "amigo_profiling",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.attachment_feedback_loop_dynamic_state
            && !supported.attachment_feedback_loop_dynamic_state
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "attachment_feedback_loop_dynamic_state",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.attachment_feedback_loop_layout
            && !supported.attachment_feedback_loop_layout
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "attachment_feedback_loop_layout",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.attachment_fragment_shading_rate
            && !supported.attachment_fragment_shading_rate
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "attachment_fragment_shading_rate",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.border_color_swizzle && !supported.border_color_swizzle {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "border_color_swizzle",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.border_color_swizzle_from_image
            && !supported.border_color_swizzle_from_image
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "border_color_swizzle_from_image",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.bresenham_lines && !supported.bresenham_lines {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "bresenham_lines",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.buffer_device_address && !supported.buffer_device_address {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "buffer_device_address",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.buffer_device_address_capture_replay
            && !supported.buffer_device_address_capture_replay
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "buffer_device_address_capture_replay",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.buffer_device_address_multi_device
            && !supported.buffer_device_address_multi_device
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "buffer_device_address_multi_device",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.clusterculling_shader && !supported.clusterculling_shader {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "clusterculling_shader",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.color_write_enable && !supported.color_write_enable {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "color_write_enable",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.compute_derivative_group_linear
            && !supported.compute_derivative_group_linear
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "compute_derivative_group_linear",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.compute_derivative_group_quads
            && !supported.compute_derivative_group_quads
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "compute_derivative_group_quads",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.compute_full_subgroups && !supported.compute_full_subgroups {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "compute_full_subgroups",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.conditional_rendering && !supported.conditional_rendering {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "conditional_rendering",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.constant_alpha_color_blend_factors
            && !supported.constant_alpha_color_blend_factors
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "constant_alpha_color_blend_factors",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.cooperative_matrix && !supported.cooperative_matrix {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "cooperative_matrix",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.cooperative_matrix_robust_buffer_access
            && !supported.cooperative_matrix_robust_buffer_access
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "cooperative_matrix_robust_buffer_access",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.corner_sampled_image && !supported.corner_sampled_image {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "corner_sampled_image",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.coverage_reduction_mode && !supported.coverage_reduction_mode {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "coverage_reduction_mode",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.cubic_range_clamp && !supported.cubic_range_clamp {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "cubic_range_clamp",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.cuda_kernel_launch_features && !supported.cuda_kernel_launch_features {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "cuda_kernel_launch_features",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.custom_border_color_without_format
            && !supported.custom_border_color_without_format
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "custom_border_color_without_format",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.custom_border_colors && !supported.custom_border_colors {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "custom_border_colors",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.decode_mode_shared_exponent && !supported.decode_mode_shared_exponent {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "decode_mode_shared_exponent",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.dedicated_allocation_image_aliasing
            && !supported.dedicated_allocation_image_aliasing
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "dedicated_allocation_image_aliasing",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.depth_bias_clamp && !supported.depth_bias_clamp {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "depth_bias_clamp",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.depth_bias_control && !supported.depth_bias_control {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "depth_bias_control",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.depth_bias_exact && !supported.depth_bias_exact {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "depth_bias_exact",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.depth_bounds && !supported.depth_bounds {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "depth_bounds",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.depth_clamp && !supported.depth_clamp {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "depth_clamp",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.depth_clamp_zero_one && !supported.depth_clamp_zero_one {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "depth_clamp_zero_one",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.depth_clip_control && !supported.depth_clip_control {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "depth_clip_control",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.depth_clip_enable && !supported.depth_clip_enable {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "depth_clip_enable",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.descriptor_binding_acceleration_structure_update_after_bind
            && !supported.descriptor_binding_acceleration_structure_update_after_bind
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "descriptor_binding_acceleration_structure_update_after_bind",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.descriptor_binding_inline_uniform_block_update_after_bind
            && !supported.descriptor_binding_inline_uniform_block_update_after_bind
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "descriptor_binding_inline_uniform_block_update_after_bind",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.descriptor_binding_partially_bound
            && !supported.descriptor_binding_partially_bound
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "descriptor_binding_partially_bound",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.descriptor_binding_sampled_image_update_after_bind
            && !supported.descriptor_binding_sampled_image_update_after_bind
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "descriptor_binding_sampled_image_update_after_bind",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.descriptor_binding_storage_buffer_update_after_bind
            && !supported.descriptor_binding_storage_buffer_update_after_bind
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "descriptor_binding_storage_buffer_update_after_bind",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.descriptor_binding_storage_image_update_after_bind
            && !supported.descriptor_binding_storage_image_update_after_bind
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "descriptor_binding_storage_image_update_after_bind",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.descriptor_binding_storage_texel_buffer_update_after_bind
            && !supported.descriptor_binding_storage_texel_buffer_update_after_bind
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "descriptor_binding_storage_texel_buffer_update_after_bind",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.descriptor_binding_uniform_buffer_update_after_bind
            && !supported.descriptor_binding_uniform_buffer_update_after_bind
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "descriptor_binding_uniform_buffer_update_after_bind",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.descriptor_binding_uniform_texel_buffer_update_after_bind
            && !supported.descriptor_binding_uniform_texel_buffer_update_after_bind
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "descriptor_binding_uniform_texel_buffer_update_after_bind",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.descriptor_binding_update_unused_while_pending
            && !supported.descriptor_binding_update_unused_while_pending
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "descriptor_binding_update_unused_while_pending",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.descriptor_binding_variable_descriptor_count
            && !supported.descriptor_binding_variable_descriptor_count
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "descriptor_binding_variable_descriptor_count",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.descriptor_buffer && !supported.descriptor_buffer {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "descriptor_buffer",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.descriptor_buffer_capture_replay
            && !supported.descriptor_buffer_capture_replay
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "descriptor_buffer_capture_replay",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.descriptor_buffer_image_layout_ignored
            && !supported.descriptor_buffer_image_layout_ignored
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "descriptor_buffer_image_layout_ignored",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.descriptor_buffer_push_descriptors
            && !supported.descriptor_buffer_push_descriptors
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "descriptor_buffer_push_descriptors",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.descriptor_indexing && !supported.descriptor_indexing {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "descriptor_indexing",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.descriptor_pool_overallocation
            && !supported.descriptor_pool_overallocation
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "descriptor_pool_overallocation",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.descriptor_set_host_mapping && !supported.descriptor_set_host_mapping {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "descriptor_set_host_mapping",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.device_coherent_memory && !supported.device_coherent_memory {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "device_coherent_memory",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.device_fault && !supported.device_fault {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "device_fault",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.device_fault_vendor_binary && !supported.device_fault_vendor_binary {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "device_fault_vendor_binary",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.device_generated_commands && !supported.device_generated_commands {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "device_generated_commands",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.device_generated_compute && !supported.device_generated_compute {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "device_generated_compute",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.device_generated_compute_capture_replay
            && !supported.device_generated_compute_capture_replay
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "device_generated_compute_capture_replay",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.device_generated_compute_pipelines
            && !supported.device_generated_compute_pipelines
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "device_generated_compute_pipelines",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.device_memory_report && !supported.device_memory_report {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "device_memory_report",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.diagnostics_config && !supported.diagnostics_config {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "diagnostics_config",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.displacement_micromap && !supported.displacement_micromap {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "displacement_micromap",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.draw_indirect_count && !supported.draw_indirect_count {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "draw_indirect_count",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.draw_indirect_first_instance && !supported.draw_indirect_first_instance {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "draw_indirect_first_instance",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.dual_src_blend && !supported.dual_src_blend {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "dual_src_blend",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.dynamic_pipeline_layout && !supported.dynamic_pipeline_layout {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "dynamic_pipeline_layout",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.dynamic_rendering && !supported.dynamic_rendering {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "dynamic_rendering",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.dynamic_rendering_local_read && !supported.dynamic_rendering_local_read {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "dynamic_rendering_local_read",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.dynamic_rendering_unused_attachments
            && !supported.dynamic_rendering_unused_attachments
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "dynamic_rendering_unused_attachments",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.events && !supported.events {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "events",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.exclusive_scissor && !supported.exclusive_scissor {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "exclusive_scissor",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.extended_dynamic_state && !supported.extended_dynamic_state {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "extended_dynamic_state",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.extended_dynamic_state2 && !supported.extended_dynamic_state2 {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "extended_dynamic_state2",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.extended_dynamic_state2_logic_op
            && !supported.extended_dynamic_state2_logic_op
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "extended_dynamic_state2_logic_op",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.extended_dynamic_state2_patch_control_points
            && !supported.extended_dynamic_state2_patch_control_points
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "extended_dynamic_state2_patch_control_points",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.extended_dynamic_state3_alpha_to_coverage_enable
            && !supported.extended_dynamic_state3_alpha_to_coverage_enable
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "extended_dynamic_state3_alpha_to_coverage_enable",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.extended_dynamic_state3_alpha_to_one_enable
            && !supported.extended_dynamic_state3_alpha_to_one_enable
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "extended_dynamic_state3_alpha_to_one_enable",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.extended_dynamic_state3_color_blend_advanced
            && !supported.extended_dynamic_state3_color_blend_advanced
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "extended_dynamic_state3_color_blend_advanced",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.extended_dynamic_state3_color_blend_enable
            && !supported.extended_dynamic_state3_color_blend_enable
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "extended_dynamic_state3_color_blend_enable",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.extended_dynamic_state3_color_blend_equation
            && !supported.extended_dynamic_state3_color_blend_equation
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "extended_dynamic_state3_color_blend_equation",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.extended_dynamic_state3_color_write_mask
            && !supported.extended_dynamic_state3_color_write_mask
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "extended_dynamic_state3_color_write_mask",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.extended_dynamic_state3_conservative_rasterization_mode
            && !supported.extended_dynamic_state3_conservative_rasterization_mode
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "extended_dynamic_state3_conservative_rasterization_mode",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.extended_dynamic_state3_coverage_modulation_mode
            && !supported.extended_dynamic_state3_coverage_modulation_mode
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "extended_dynamic_state3_coverage_modulation_mode",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.extended_dynamic_state3_coverage_modulation_table
            && !supported.extended_dynamic_state3_coverage_modulation_table
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "extended_dynamic_state3_coverage_modulation_table",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.extended_dynamic_state3_coverage_modulation_table_enable
            && !supported.extended_dynamic_state3_coverage_modulation_table_enable
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "extended_dynamic_state3_coverage_modulation_table_enable",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.extended_dynamic_state3_coverage_reduction_mode
            && !supported.extended_dynamic_state3_coverage_reduction_mode
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "extended_dynamic_state3_coverage_reduction_mode",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.extended_dynamic_state3_coverage_to_color_enable
            && !supported.extended_dynamic_state3_coverage_to_color_enable
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "extended_dynamic_state3_coverage_to_color_enable",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.extended_dynamic_state3_coverage_to_color_location
            && !supported.extended_dynamic_state3_coverage_to_color_location
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "extended_dynamic_state3_coverage_to_color_location",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.extended_dynamic_state3_depth_clamp_enable
            && !supported.extended_dynamic_state3_depth_clamp_enable
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "extended_dynamic_state3_depth_clamp_enable",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.extended_dynamic_state3_depth_clip_enable
            && !supported.extended_dynamic_state3_depth_clip_enable
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "extended_dynamic_state3_depth_clip_enable",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.extended_dynamic_state3_depth_clip_negative_one_to_one
            && !supported.extended_dynamic_state3_depth_clip_negative_one_to_one
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "extended_dynamic_state3_depth_clip_negative_one_to_one",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.extended_dynamic_state3_extra_primitive_overestimation_size
            && !supported.extended_dynamic_state3_extra_primitive_overestimation_size
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "extended_dynamic_state3_extra_primitive_overestimation_size",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.extended_dynamic_state3_line_rasterization_mode
            && !supported.extended_dynamic_state3_line_rasterization_mode
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "extended_dynamic_state3_line_rasterization_mode",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.extended_dynamic_state3_line_stipple_enable
            && !supported.extended_dynamic_state3_line_stipple_enable
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "extended_dynamic_state3_line_stipple_enable",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.extended_dynamic_state3_logic_op_enable
            && !supported.extended_dynamic_state3_logic_op_enable
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "extended_dynamic_state3_logic_op_enable",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.extended_dynamic_state3_polygon_mode
            && !supported.extended_dynamic_state3_polygon_mode
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "extended_dynamic_state3_polygon_mode",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.extended_dynamic_state3_provoking_vertex_mode
            && !supported.extended_dynamic_state3_provoking_vertex_mode
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "extended_dynamic_state3_provoking_vertex_mode",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.extended_dynamic_state3_rasterization_samples
            && !supported.extended_dynamic_state3_rasterization_samples
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "extended_dynamic_state3_rasterization_samples",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.extended_dynamic_state3_rasterization_stream
            && !supported.extended_dynamic_state3_rasterization_stream
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "extended_dynamic_state3_rasterization_stream",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.extended_dynamic_state3_representative_fragment_test_enable
            && !supported.extended_dynamic_state3_representative_fragment_test_enable
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "extended_dynamic_state3_representative_fragment_test_enable",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.extended_dynamic_state3_sample_locations_enable
            && !supported.extended_dynamic_state3_sample_locations_enable
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "extended_dynamic_state3_sample_locations_enable",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.extended_dynamic_state3_sample_mask
            && !supported.extended_dynamic_state3_sample_mask
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "extended_dynamic_state3_sample_mask",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.extended_dynamic_state3_shading_rate_image_enable
            && !supported.extended_dynamic_state3_shading_rate_image_enable
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "extended_dynamic_state3_shading_rate_image_enable",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.extended_dynamic_state3_tessellation_domain_origin
            && !supported.extended_dynamic_state3_tessellation_domain_origin
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "extended_dynamic_state3_tessellation_domain_origin",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.extended_dynamic_state3_viewport_swizzle
            && !supported.extended_dynamic_state3_viewport_swizzle
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "extended_dynamic_state3_viewport_swizzle",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.extended_dynamic_state3_viewport_w_scaling_enable
            && !supported.extended_dynamic_state3_viewport_w_scaling_enable
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "extended_dynamic_state3_viewport_w_scaling_enable",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.extended_sparse_address_space && !supported.extended_sparse_address_space
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "extended_sparse_address_space",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.external_format_resolve && !supported.external_format_resolve {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "external_format_resolve",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.external_memory_rdma && !supported.external_memory_rdma {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "external_memory_rdma",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.fill_mode_non_solid && !supported.fill_mode_non_solid {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "fill_mode_non_solid",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.float_representation && !supported.float_representation {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "float_representation",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.format_a4b4g4r4 && !supported.format_a4b4g4r4 {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "format_a4b4g4r4",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.format_a4r4g4b4 && !supported.format_a4r4g4b4 {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "format_a4r4g4b4",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.format_rgba10x6_without_y_cb_cr_sampler
            && !supported.format_rgba10x6_without_y_cb_cr_sampler
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "format_rgba10x6_without_y_cb_cr_sampler",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.fragment_density_map && !supported.fragment_density_map {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "fragment_density_map",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.fragment_density_map_deferred && !supported.fragment_density_map_deferred
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "fragment_density_map_deferred",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.fragment_density_map_dynamic && !supported.fragment_density_map_dynamic {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "fragment_density_map_dynamic",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.fragment_density_map_non_subsampled_images
            && !supported.fragment_density_map_non_subsampled_images
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "fragment_density_map_non_subsampled_images",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.fragment_density_map_offset && !supported.fragment_density_map_offset {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "fragment_density_map_offset",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.fragment_shader_barycentric && !supported.fragment_shader_barycentric {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "fragment_shader_barycentric",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.fragment_shader_pixel_interlock
            && !supported.fragment_shader_pixel_interlock
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "fragment_shader_pixel_interlock",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.fragment_shader_sample_interlock
            && !supported.fragment_shader_sample_interlock
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "fragment_shader_sample_interlock",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.fragment_shader_shading_rate_interlock
            && !supported.fragment_shader_shading_rate_interlock
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "fragment_shader_shading_rate_interlock",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.fragment_shading_rate_enums && !supported.fragment_shading_rate_enums {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "fragment_shading_rate_enums",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.fragment_stores_and_atomics && !supported.fragment_stores_and_atomics {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "fragment_stores_and_atomics",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.frame_boundary && !supported.frame_boundary {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "frame_boundary",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.full_draw_index_uint32 && !supported.full_draw_index_uint32 {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "full_draw_index_uint32",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.geometry_shader && !supported.geometry_shader {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "geometry_shader",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.geometry_streams && !supported.geometry_streams {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "geometry_streams",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.global_priority_query && !supported.global_priority_query {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "global_priority_query",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.graphics_pipeline_library && !supported.graphics_pipeline_library {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "graphics_pipeline_library",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.host_image_copy && !supported.host_image_copy {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "host_image_copy",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.host_query_reset && !supported.host_query_reset {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "host_query_reset",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.image2_d_view_of3_d && !supported.image2_d_view_of3_d {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "image2_d_view_of3_d",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.image_compression_control && !supported.image_compression_control {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "image_compression_control",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.image_compression_control_swapchain
            && !supported.image_compression_control_swapchain
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "image_compression_control_swapchain",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.image_cube_array && !supported.image_cube_array {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "image_cube_array",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.image_footprint && !supported.image_footprint {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "image_footprint",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.image_sliced_view_of3_d && !supported.image_sliced_view_of3_d {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "image_sliced_view_of3_d",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.image_view2_d_on3_d_image && !supported.image_view2_d_on3_d_image {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "image_view2_d_on3_d_image",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.image_view_format_reinterpretation
            && !supported.image_view_format_reinterpretation
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "image_view_format_reinterpretation",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.image_view_format_swizzle && !supported.image_view_format_swizzle {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "image_view_format_swizzle",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.imageless_framebuffer && !supported.imageless_framebuffer {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "imageless_framebuffer",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.independent_blend && !supported.independent_blend {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "independent_blend",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.index_type_uint8 && !supported.index_type_uint8 {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "index_type_uint8",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.indirect_copy && !supported.indirect_copy {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "indirect_copy",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.inherited_conditional_rendering
            && !supported.inherited_conditional_rendering
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "inherited_conditional_rendering",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.inherited_queries && !supported.inherited_queries {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "inherited_queries",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.inherited_viewport_scissor2_d && !supported.inherited_viewport_scissor2_d
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "inherited_viewport_scissor2_d",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.inline_uniform_block && !supported.inline_uniform_block {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "inline_uniform_block",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.invocation_mask && !supported.invocation_mask {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "invocation_mask",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.large_points && !supported.large_points {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "large_points",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.least_representable_value_force_unorm_representation
            && !supported.least_representable_value_force_unorm_representation
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "least_representable_value_force_unorm_representation",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.legacy_dithering && !supported.legacy_dithering {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "legacy_dithering",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.linear_color_attachment && !supported.linear_color_attachment {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "linear_color_attachment",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.logic_op && !supported.logic_op {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "logic_op",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.maintenance4 && !supported.maintenance4 {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "maintenance4",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.maintenance5 && !supported.maintenance5 {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "maintenance5",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.maintenance6 && !supported.maintenance6 {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "maintenance6",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.memory_decompression && !supported.memory_decompression {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "memory_decompression",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.memory_map_placed && !supported.memory_map_placed {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "memory_map_placed",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.memory_map_range_placed && !supported.memory_map_range_placed {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "memory_map_range_placed",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.memory_priority && !supported.memory_priority {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "memory_priority",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.memory_unmap_reserve && !supported.memory_unmap_reserve {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "memory_unmap_reserve",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.mesh_shader && !supported.mesh_shader {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "mesh_shader",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.mesh_shader_queries && !supported.mesh_shader_queries {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "mesh_shader_queries",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.micromap && !supported.micromap {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "micromap",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.micromap_capture_replay && !supported.micromap_capture_replay {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "micromap_capture_replay",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.micromap_host_commands && !supported.micromap_host_commands {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "micromap_host_commands",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.min_lod && !supported.min_lod {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "min_lod",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.multi_draw && !supported.multi_draw {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "multi_draw",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.multi_draw_indirect && !supported.multi_draw_indirect {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "multi_draw_indirect",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.multi_viewport && !supported.multi_viewport {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "multi_viewport",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.multisample_array_image && !supported.multisample_array_image {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "multisample_array_image",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.multisampled_render_to_single_sampled
            && !supported.multisampled_render_to_single_sampled
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "multisampled_render_to_single_sampled",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.multiview && !supported.multiview {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "multiview",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.multiview_cluster_culling_shader
            && !supported.multiview_cluster_culling_shader
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "multiview_cluster_culling_shader",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.multiview_geometry_shader && !supported.multiview_geometry_shader {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "multiview_geometry_shader",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.multiview_mesh_shader && !supported.multiview_mesh_shader {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "multiview_mesh_shader",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.multiview_per_view_render_areas
            && !supported.multiview_per_view_render_areas
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "multiview_per_view_render_areas",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.multiview_per_view_viewports && !supported.multiview_per_view_viewports {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "multiview_per_view_viewports",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.multiview_tessellation_shader && !supported.multiview_tessellation_shader
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "multiview_tessellation_shader",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.mutable_comparison_samplers && !supported.mutable_comparison_samplers {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "mutable_comparison_samplers",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.mutable_descriptor_type && !supported.mutable_descriptor_type {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "mutable_descriptor_type",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.nested_command_buffer && !supported.nested_command_buffer {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "nested_command_buffer",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.nested_command_buffer_rendering
            && !supported.nested_command_buffer_rendering
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "nested_command_buffer_rendering",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.nested_command_buffer_simultaneous_use
            && !supported.nested_command_buffer_simultaneous_use
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "nested_command_buffer_simultaneous_use",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.no_invocation_fragment_shading_rates
            && !supported.no_invocation_fragment_shading_rates
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "no_invocation_fragment_shading_rates",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.non_seamless_cube_map && !supported.non_seamless_cube_map {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "non_seamless_cube_map",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.null_descriptor && !supported.null_descriptor {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "null_descriptor",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.occlusion_query_precise && !supported.occlusion_query_precise {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "occlusion_query_precise",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.optical_flow && !supported.optical_flow {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "optical_flow",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.pageable_device_local_memory && !supported.pageable_device_local_memory {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "pageable_device_local_memory",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.per_stage_descriptor_set && !supported.per_stage_descriptor_set {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "per_stage_descriptor_set",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.performance_counter_multiple_query_pools
            && !supported.performance_counter_multiple_query_pools
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "performance_counter_multiple_query_pools",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.performance_counter_query_pools
            && !supported.performance_counter_query_pools
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "performance_counter_query_pools",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.pipeline_creation_cache_control
            && !supported.pipeline_creation_cache_control
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "pipeline_creation_cache_control",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.pipeline_executable_info && !supported.pipeline_executable_info {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "pipeline_executable_info",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.pipeline_fragment_shading_rate
            && !supported.pipeline_fragment_shading_rate
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "pipeline_fragment_shading_rate",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.pipeline_library_group_handles
            && !supported.pipeline_library_group_handles
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "pipeline_library_group_handles",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.pipeline_properties_identifier
            && !supported.pipeline_properties_identifier
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "pipeline_properties_identifier",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.pipeline_protected_access && !supported.pipeline_protected_access {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "pipeline_protected_access",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.pipeline_robustness && !supported.pipeline_robustness {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "pipeline_robustness",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.pipeline_statistics_query && !supported.pipeline_statistics_query {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "pipeline_statistics_query",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.point_polygons && !supported.point_polygons {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "point_polygons",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.present_barrier && !supported.present_barrier {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "present_barrier",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.present_id && !supported.present_id {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "present_id",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.present_wait && !supported.present_wait {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "present_wait",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.primitive_fragment_shading_rate
            && !supported.primitive_fragment_shading_rate
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "primitive_fragment_shading_rate",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.primitive_fragment_shading_rate_mesh_shader
            && !supported.primitive_fragment_shading_rate_mesh_shader
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "primitive_fragment_shading_rate_mesh_shader",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.primitive_topology_list_restart
            && !supported.primitive_topology_list_restart
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "primitive_topology_list_restart",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.primitive_topology_patch_list_restart
            && !supported.primitive_topology_patch_list_restart
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "primitive_topology_patch_list_restart",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.primitives_generated_query && !supported.primitives_generated_query {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "primitives_generated_query",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.primitives_generated_query_with_non_zero_streams
            && !supported.primitives_generated_query_with_non_zero_streams
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "primitives_generated_query_with_non_zero_streams",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.primitives_generated_query_with_rasterizer_discard
            && !supported.primitives_generated_query_with_rasterizer_discard
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "primitives_generated_query_with_rasterizer_discard",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.private_data && !supported.private_data {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "private_data",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.protected_memory && !supported.protected_memory {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "protected_memory",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.provoking_vertex_last && !supported.provoking_vertex_last {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "provoking_vertex_last",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.rasterization_order_color_attachment_access
            && !supported.rasterization_order_color_attachment_access
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "rasterization_order_color_attachment_access",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.rasterization_order_depth_attachment_access
            && !supported.rasterization_order_depth_attachment_access
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "rasterization_order_depth_attachment_access",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.rasterization_order_stencil_attachment_access
            && !supported.rasterization_order_stencil_attachment_access
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "rasterization_order_stencil_attachment_access",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.ray_query && !supported.ray_query {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "ray_query",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.ray_tracing_invocation_reorder
            && !supported.ray_tracing_invocation_reorder
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "ray_tracing_invocation_reorder",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.ray_tracing_maintenance1 && !supported.ray_tracing_maintenance1 {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "ray_tracing_maintenance1",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.ray_tracing_motion_blur && !supported.ray_tracing_motion_blur {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "ray_tracing_motion_blur",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.ray_tracing_motion_blur_pipeline_trace_rays_indirect
            && !supported.ray_tracing_motion_blur_pipeline_trace_rays_indirect
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "ray_tracing_motion_blur_pipeline_trace_rays_indirect",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.ray_tracing_pipeline && !supported.ray_tracing_pipeline {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "ray_tracing_pipeline",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.ray_tracing_pipeline_shader_group_handle_capture_replay
            && !supported.ray_tracing_pipeline_shader_group_handle_capture_replay
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "ray_tracing_pipeline_shader_group_handle_capture_replay",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.ray_tracing_pipeline_shader_group_handle_capture_replay_mixed
            && !supported.ray_tracing_pipeline_shader_group_handle_capture_replay_mixed
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "ray_tracing_pipeline_shader_group_handle_capture_replay_mixed",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.ray_tracing_pipeline_trace_rays_indirect
            && !supported.ray_tracing_pipeline_trace_rays_indirect
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "ray_tracing_pipeline_trace_rays_indirect",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.ray_tracing_pipeline_trace_rays_indirect2
            && !supported.ray_tracing_pipeline_trace_rays_indirect2
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "ray_tracing_pipeline_trace_rays_indirect2",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.ray_tracing_position_fetch && !supported.ray_tracing_position_fetch {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "ray_tracing_position_fetch",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.ray_tracing_validation && !supported.ray_tracing_validation {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "ray_tracing_validation",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.ray_traversal_primitive_culling
            && !supported.ray_traversal_primitive_culling
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "ray_traversal_primitive_culling",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.rectangular_lines && !supported.rectangular_lines {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "rectangular_lines",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.relaxed_line_rasterization && !supported.relaxed_line_rasterization {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "relaxed_line_rasterization",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.render_pass_striped && !supported.render_pass_striped {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "render_pass_striped",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.report_address_binding && !supported.report_address_binding {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "report_address_binding",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.representative_fragment_test && !supported.representative_fragment_test {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "representative_fragment_test",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.robust_buffer_access && !supported.robust_buffer_access {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "robust_buffer_access",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.robust_buffer_access2 && !supported.robust_buffer_access2 {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "robust_buffer_access2",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.robust_image_access && !supported.robust_image_access {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "robust_image_access",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.robust_image_access2 && !supported.robust_image_access2 {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "robust_image_access2",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.runtime_descriptor_array && !supported.runtime_descriptor_array {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "runtime_descriptor_array",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.sample_rate_shading && !supported.sample_rate_shading {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "sample_rate_shading",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.sampler2_d_view_of3_d && !supported.sampler2_d_view_of3_d {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "sampler2_d_view_of3_d",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.sampler_anisotropy && !supported.sampler_anisotropy {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "sampler_anisotropy",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.sampler_filter_minmax && !supported.sampler_filter_minmax {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "sampler_filter_minmax",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.sampler_mip_lod_bias && !supported.sampler_mip_lod_bias {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "sampler_mip_lod_bias",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.sampler_mirror_clamp_to_edge && !supported.sampler_mirror_clamp_to_edge {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "sampler_mirror_clamp_to_edge",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.sampler_ycbcr_conversion && !supported.sampler_ycbcr_conversion {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "sampler_ycbcr_conversion",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.scalar_block_layout && !supported.scalar_block_layout {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "scalar_block_layout",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.scheduling_controls && !supported.scheduling_controls {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "scheduling_controls",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.screen_buffer_import && !supported.screen_buffer_import {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "screen_buffer_import",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.selectable_cubic_weights && !supported.selectable_cubic_weights {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "selectable_cubic_weights",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.separate_depth_stencil_layouts
            && !supported.separate_depth_stencil_layouts
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "separate_depth_stencil_layouts",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.separate_stencil_mask_ref && !supported.separate_stencil_mask_ref {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "separate_stencil_mask_ref",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.shader_buffer_float16_atomic_add
            && !supported.shader_buffer_float16_atomic_add
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "shader_buffer_float16_atomic_add",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.shader_buffer_float16_atomic_min_max
            && !supported.shader_buffer_float16_atomic_min_max
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "shader_buffer_float16_atomic_min_max",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.shader_buffer_float16_atomics && !supported.shader_buffer_float16_atomics
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "shader_buffer_float16_atomics",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.shader_buffer_float32_atomic_add
            && !supported.shader_buffer_float32_atomic_add
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "shader_buffer_float32_atomic_add",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.shader_buffer_float32_atomic_min_max
            && !supported.shader_buffer_float32_atomic_min_max
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "shader_buffer_float32_atomic_min_max",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.shader_buffer_float32_atomics && !supported.shader_buffer_float32_atomics
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "shader_buffer_float32_atomics",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.shader_buffer_float64_atomic_add
            && !supported.shader_buffer_float64_atomic_add
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "shader_buffer_float64_atomic_add",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.shader_buffer_float64_atomic_min_max
            && !supported.shader_buffer_float64_atomic_min_max
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "shader_buffer_float64_atomic_min_max",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.shader_buffer_float64_atomics && !supported.shader_buffer_float64_atomics
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "shader_buffer_float64_atomics",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.shader_buffer_int64_atomics && !supported.shader_buffer_int64_atomics {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "shader_buffer_int64_atomics",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.shader_clip_distance && !supported.shader_clip_distance {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "shader_clip_distance",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.shader_core_builtins && !supported.shader_core_builtins {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "shader_core_builtins",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.shader_cull_distance && !supported.shader_cull_distance {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "shader_cull_distance",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.shader_demote_to_helper_invocation
            && !supported.shader_demote_to_helper_invocation
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "shader_demote_to_helper_invocation",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.shader_device_clock && !supported.shader_device_clock {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "shader_device_clock",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.shader_draw_parameters && !supported.shader_draw_parameters {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "shader_draw_parameters",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.shader_early_and_late_fragment_tests
            && !supported.shader_early_and_late_fragment_tests
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "shader_early_and_late_fragment_tests",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.shader_enqueue && !supported.shader_enqueue {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "shader_enqueue",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.shader_expect_assume && !supported.shader_expect_assume {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "shader_expect_assume",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.shader_float16 && !supported.shader_float16 {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "shader_float16",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.shader_float16_vector_atomics && !supported.shader_float16_vector_atomics
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "shader_float16_vector_atomics",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.shader_float64 && !supported.shader_float64 {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "shader_float64",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.shader_float_controls2 && !supported.shader_float_controls2 {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "shader_float_controls2",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.shader_image_float32_atomic_add
            && !supported.shader_image_float32_atomic_add
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "shader_image_float32_atomic_add",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.shader_image_float32_atomic_min_max
            && !supported.shader_image_float32_atomic_min_max
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "shader_image_float32_atomic_min_max",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.shader_image_float32_atomics && !supported.shader_image_float32_atomics {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "shader_image_float32_atomics",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.shader_image_gather_extended && !supported.shader_image_gather_extended {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "shader_image_gather_extended",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.shader_image_int64_atomics && !supported.shader_image_int64_atomics {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "shader_image_int64_atomics",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.shader_input_attachment_array_dynamic_indexing
            && !supported.shader_input_attachment_array_dynamic_indexing
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "shader_input_attachment_array_dynamic_indexing",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.shader_input_attachment_array_non_uniform_indexing
            && !supported.shader_input_attachment_array_non_uniform_indexing
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "shader_input_attachment_array_non_uniform_indexing",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.shader_int16 && !supported.shader_int16 {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "shader_int16",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.shader_int64 && !supported.shader_int64 {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "shader_int64",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.shader_int8 && !supported.shader_int8 {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "shader_int8",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.shader_integer_dot_product && !supported.shader_integer_dot_product {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "shader_integer_dot_product",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.shader_integer_functions2 && !supported.shader_integer_functions2 {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "shader_integer_functions2",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.shader_maximal_reconvergence && !supported.shader_maximal_reconvergence {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "shader_maximal_reconvergence",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.shader_module_identifier && !supported.shader_module_identifier {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "shader_module_identifier",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.shader_object && !supported.shader_object {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "shader_object",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.shader_output_layer && !supported.shader_output_layer {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "shader_output_layer",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.shader_output_viewport_index && !supported.shader_output_viewport_index {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "shader_output_viewport_index",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.shader_quad_control && !supported.shader_quad_control {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "shader_quad_control",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.shader_raw_access_chains && !supported.shader_raw_access_chains {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "shader_raw_access_chains",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.shader_resource_min_lod && !supported.shader_resource_min_lod {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "shader_resource_min_lod",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.shader_resource_residency && !supported.shader_resource_residency {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "shader_resource_residency",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.shader_sample_rate_interpolation_functions
            && !supported.shader_sample_rate_interpolation_functions
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "shader_sample_rate_interpolation_functions",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.shader_sampled_image_array_dynamic_indexing
            && !supported.shader_sampled_image_array_dynamic_indexing
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "shader_sampled_image_array_dynamic_indexing",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.shader_sampled_image_array_non_uniform_indexing
            && !supported.shader_sampled_image_array_non_uniform_indexing
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "shader_sampled_image_array_non_uniform_indexing",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.shader_shared_float16_atomic_add
            && !supported.shader_shared_float16_atomic_add
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "shader_shared_float16_atomic_add",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.shader_shared_float16_atomic_min_max
            && !supported.shader_shared_float16_atomic_min_max
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "shader_shared_float16_atomic_min_max",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.shader_shared_float16_atomics && !supported.shader_shared_float16_atomics
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "shader_shared_float16_atomics",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.shader_shared_float32_atomic_add
            && !supported.shader_shared_float32_atomic_add
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "shader_shared_float32_atomic_add",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.shader_shared_float32_atomic_min_max
            && !supported.shader_shared_float32_atomic_min_max
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "shader_shared_float32_atomic_min_max",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.shader_shared_float32_atomics && !supported.shader_shared_float32_atomics
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "shader_shared_float32_atomics",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.shader_shared_float64_atomic_add
            && !supported.shader_shared_float64_atomic_add
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "shader_shared_float64_atomic_add",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.shader_shared_float64_atomic_min_max
            && !supported.shader_shared_float64_atomic_min_max
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "shader_shared_float64_atomic_min_max",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.shader_shared_float64_atomics && !supported.shader_shared_float64_atomics
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "shader_shared_float64_atomics",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.shader_shared_int64_atomics && !supported.shader_shared_int64_atomics {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "shader_shared_int64_atomics",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.shader_sm_builtins && !supported.shader_sm_builtins {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "shader_sm_builtins",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.shader_storage_buffer_array_dynamic_indexing
            && !supported.shader_storage_buffer_array_dynamic_indexing
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "shader_storage_buffer_array_dynamic_indexing",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.shader_storage_buffer_array_non_uniform_indexing
            && !supported.shader_storage_buffer_array_non_uniform_indexing
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "shader_storage_buffer_array_non_uniform_indexing",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.shader_storage_image_array_dynamic_indexing
            && !supported.shader_storage_image_array_dynamic_indexing
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "shader_storage_image_array_dynamic_indexing",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.shader_storage_image_array_non_uniform_indexing
            && !supported.shader_storage_image_array_non_uniform_indexing
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "shader_storage_image_array_non_uniform_indexing",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.shader_storage_image_extended_formats
            && !supported.shader_storage_image_extended_formats
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "shader_storage_image_extended_formats",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.shader_storage_image_multisample
            && !supported.shader_storage_image_multisample
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "shader_storage_image_multisample",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.shader_storage_image_read_without_format
            && !supported.shader_storage_image_read_without_format
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "shader_storage_image_read_without_format",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.shader_storage_image_write_without_format
            && !supported.shader_storage_image_write_without_format
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "shader_storage_image_write_without_format",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.shader_storage_texel_buffer_array_dynamic_indexing
            && !supported.shader_storage_texel_buffer_array_dynamic_indexing
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "shader_storage_texel_buffer_array_dynamic_indexing",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.shader_storage_texel_buffer_array_non_uniform_indexing
            && !supported.shader_storage_texel_buffer_array_non_uniform_indexing
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "shader_storage_texel_buffer_array_non_uniform_indexing",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.shader_subgroup_clock && !supported.shader_subgroup_clock {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "shader_subgroup_clock",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.shader_subgroup_extended_types
            && !supported.shader_subgroup_extended_types
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "shader_subgroup_extended_types",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.shader_subgroup_rotate && !supported.shader_subgroup_rotate {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "shader_subgroup_rotate",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.shader_subgroup_rotate_clustered
            && !supported.shader_subgroup_rotate_clustered
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "shader_subgroup_rotate_clustered",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.shader_subgroup_uniform_control_flow
            && !supported.shader_subgroup_uniform_control_flow
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "shader_subgroup_uniform_control_flow",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.shader_terminate_invocation && !supported.shader_terminate_invocation {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "shader_terminate_invocation",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.shader_tessellation_and_geometry_point_size
            && !supported.shader_tessellation_and_geometry_point_size
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "shader_tessellation_and_geometry_point_size",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.shader_tile_image_color_read_access
            && !supported.shader_tile_image_color_read_access
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "shader_tile_image_color_read_access",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.shader_tile_image_depth_read_access
            && !supported.shader_tile_image_depth_read_access
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "shader_tile_image_depth_read_access",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.shader_tile_image_stencil_read_access
            && !supported.shader_tile_image_stencil_read_access
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "shader_tile_image_stencil_read_access",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.shader_uniform_buffer_array_dynamic_indexing
            && !supported.shader_uniform_buffer_array_dynamic_indexing
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "shader_uniform_buffer_array_dynamic_indexing",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.shader_uniform_buffer_array_non_uniform_indexing
            && !supported.shader_uniform_buffer_array_non_uniform_indexing
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "shader_uniform_buffer_array_non_uniform_indexing",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.shader_uniform_texel_buffer_array_dynamic_indexing
            && !supported.shader_uniform_texel_buffer_array_dynamic_indexing
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "shader_uniform_texel_buffer_array_dynamic_indexing",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.shader_uniform_texel_buffer_array_non_uniform_indexing
            && !supported.shader_uniform_texel_buffer_array_non_uniform_indexing
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "shader_uniform_texel_buffer_array_non_uniform_indexing",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.shader_zero_initialize_workgroup_memory
            && !supported.shader_zero_initialize_workgroup_memory
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "shader_zero_initialize_workgroup_memory",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.shading_rate_coarse_sample_order
            && !supported.shading_rate_coarse_sample_order
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "shading_rate_coarse_sample_order",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.shading_rate_image && !supported.shading_rate_image {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "shading_rate_image",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.smooth_lines && !supported.smooth_lines {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "smooth_lines",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.sparse_binding && !supported.sparse_binding {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "sparse_binding",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.sparse_image_float32_atomic_add
            && !supported.sparse_image_float32_atomic_add
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "sparse_image_float32_atomic_add",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.sparse_image_float32_atomic_min_max
            && !supported.sparse_image_float32_atomic_min_max
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "sparse_image_float32_atomic_min_max",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.sparse_image_float32_atomics && !supported.sparse_image_float32_atomics {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "sparse_image_float32_atomics",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.sparse_image_int64_atomics && !supported.sparse_image_int64_atomics {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "sparse_image_int64_atomics",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.sparse_residency16_samples && !supported.sparse_residency16_samples {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "sparse_residency16_samples",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.sparse_residency2_samples && !supported.sparse_residency2_samples {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "sparse_residency2_samples",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.sparse_residency4_samples && !supported.sparse_residency4_samples {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "sparse_residency4_samples",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.sparse_residency8_samples && !supported.sparse_residency8_samples {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "sparse_residency8_samples",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.sparse_residency_aliased && !supported.sparse_residency_aliased {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "sparse_residency_aliased",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.sparse_residency_buffer && !supported.sparse_residency_buffer {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "sparse_residency_buffer",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.sparse_residency_image2_d && !supported.sparse_residency_image2_d {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "sparse_residency_image2_d",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.sparse_residency_image3_d && !supported.sparse_residency_image3_d {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "sparse_residency_image3_d",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.stippled_bresenham_lines && !supported.stippled_bresenham_lines {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "stippled_bresenham_lines",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.stippled_rectangular_lines && !supported.stippled_rectangular_lines {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "stippled_rectangular_lines",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.stippled_smooth_lines && !supported.stippled_smooth_lines {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "stippled_smooth_lines",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.storage_buffer16_bit_access && !supported.storage_buffer16_bit_access {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "storage_buffer16_bit_access",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.storage_buffer8_bit_access && !supported.storage_buffer8_bit_access {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "storage_buffer8_bit_access",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.storage_input_output16 && !supported.storage_input_output16 {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "storage_input_output16",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.storage_push_constant16 && !supported.storage_push_constant16 {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "storage_push_constant16",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.storage_push_constant8 && !supported.storage_push_constant8 {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "storage_push_constant8",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.subgroup_broadcast_dynamic_id && !supported.subgroup_broadcast_dynamic_id
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "subgroup_broadcast_dynamic_id",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.subgroup_size_control && !supported.subgroup_size_control {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "subgroup_size_control",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.subpass_merge_feedback && !supported.subpass_merge_feedback {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "subpass_merge_feedback",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.subpass_shading && !supported.subpass_shading {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "subpass_shading",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.supersample_fragment_shading_rates
            && !supported.supersample_fragment_shading_rates
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "supersample_fragment_shading_rates",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.swapchain_maintenance1 && !supported.swapchain_maintenance1 {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "swapchain_maintenance1",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.synchronization2 && !supported.synchronization2 {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "synchronization2",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.task_shader && !supported.task_shader {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "task_shader",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.tessellation_isolines && !supported.tessellation_isolines {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "tessellation_isolines",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.tessellation_point_mode && !supported.tessellation_point_mode {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "tessellation_point_mode",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.tessellation_shader && !supported.tessellation_shader {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "tessellation_shader",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.texel_buffer_alignment && !supported.texel_buffer_alignment {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "texel_buffer_alignment",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.texture_block_match && !supported.texture_block_match {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "texture_block_match",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.texture_block_match2 && !supported.texture_block_match2 {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "texture_block_match2",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.texture_box_filter && !supported.texture_box_filter {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "texture_box_filter",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.texture_compression_astc_hdr && !supported.texture_compression_astc_hdr {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "texture_compression_astc_hdr",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.texture_compression_astc_ldr && !supported.texture_compression_astc_ldr {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "texture_compression_astc_ldr",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.texture_compression_bc && !supported.texture_compression_bc {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "texture_compression_bc",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.texture_compression_etc2 && !supported.texture_compression_etc2 {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "texture_compression_etc2",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.texture_sample_weighted && !supported.texture_sample_weighted {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "texture_sample_weighted",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.tile_properties && !supported.tile_properties {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "tile_properties",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.timeline_semaphore && !supported.timeline_semaphore {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "timeline_semaphore",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.transform_feedback && !supported.transform_feedback {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "transform_feedback",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.transform_feedback_preserves_provoking_vertex
            && !supported.transform_feedback_preserves_provoking_vertex
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "transform_feedback_preserves_provoking_vertex",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.triangle_fans && !supported.triangle_fans {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "triangle_fans",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.uniform_and_storage_buffer16_bit_access
            && !supported.uniform_and_storage_buffer16_bit_access
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "uniform_and_storage_buffer16_bit_access",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.uniform_and_storage_buffer8_bit_access
            && !supported.uniform_and_storage_buffer8_bit_access
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "uniform_and_storage_buffer8_bit_access",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.uniform_buffer_standard_layout
            && !supported.uniform_buffer_standard_layout
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "uniform_buffer_standard_layout",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.variable_multisample_rate && !supported.variable_multisample_rate {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "variable_multisample_rate",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.variable_pointers && !supported.variable_pointers {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "variable_pointers",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.variable_pointers_storage_buffer
            && !supported.variable_pointers_storage_buffer
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "variable_pointers_storage_buffer",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.vertex_attribute_access_beyond_stride
            && !supported.vertex_attribute_access_beyond_stride
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "vertex_attribute_access_beyond_stride",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.vertex_attribute_instance_rate_divisor
            && !supported.vertex_attribute_instance_rate_divisor
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "vertex_attribute_instance_rate_divisor",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.vertex_attribute_instance_rate_zero_divisor
            && !supported.vertex_attribute_instance_rate_zero_divisor
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "vertex_attribute_instance_rate_zero_divisor",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.vertex_input_dynamic_state && !supported.vertex_input_dynamic_state {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "vertex_input_dynamic_state",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.vertex_pipeline_stores_and_atomics
            && !supported.vertex_pipeline_stores_and_atomics
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "vertex_pipeline_stores_and_atomics",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.video_maintenance1 && !supported.video_maintenance1 {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "video_maintenance1",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.vulkan_memory_model && !supported.vulkan_memory_model {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "vulkan_memory_model",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.vulkan_memory_model_availability_visibility_chains
            && !supported.vulkan_memory_model_availability_visibility_chains
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "vulkan_memory_model_availability_visibility_chains",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.vulkan_memory_model_device_scope
            && !supported.vulkan_memory_model_device_scope
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "vulkan_memory_model_device_scope",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.wide_lines && !supported.wide_lines {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "wide_lines",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.workgroup_memory_explicit_layout
            && !supported.workgroup_memory_explicit_layout
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "workgroup_memory_explicit_layout",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.workgroup_memory_explicit_layout16_bit_access
            && !supported.workgroup_memory_explicit_layout16_bit_access
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "workgroup_memory_explicit_layout16_bit_access",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.workgroup_memory_explicit_layout8_bit_access
            && !supported.workgroup_memory_explicit_layout8_bit_access
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "workgroup_memory_explicit_layout8_bit_access",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.workgroup_memory_explicit_layout_scalar_block_layout
            && !supported.workgroup_memory_explicit_layout_scalar_block_layout
        {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "workgroup_memory_explicit_layout_scalar_block_layout",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.ycbcr2plane444_formats && !supported.ycbcr2plane444_formats {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "ycbcr2plane444_formats",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.ycbcr_degamma && !supported.ycbcr_degamma {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "ycbcr_degamma",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        if self.ycbcr_image_arrays && !supported.ycbcr_image_arrays {
            return Err(
                Box::new(crate::ValidationError {
                    problem: format!(
                        "contains `{}`, but this feature is not supported \
                        by the physical device",
                        "ycbcr_image_arrays",
                    )
                        .into(),
                    ..Default::default()
                }),
            );
        }
        Ok(())
    }
    /// Returns a `DeviceFeatures` with none of the members set.
    #[inline]
    pub const fn empty() -> Self {
        Self {
            acceleration_structure: false,
            acceleration_structure_capture_replay: false,
            acceleration_structure_host_commands: false,
            acceleration_structure_indirect_build: false,
            advanced_blend_coherent_operations: false,
            alpha_to_one: false,
            amigo_profiling: false,
            attachment_feedback_loop_dynamic_state: false,
            attachment_feedback_loop_layout: false,
            attachment_fragment_shading_rate: false,
            border_color_swizzle: false,
            border_color_swizzle_from_image: false,
            bresenham_lines: false,
            buffer_device_address: false,
            buffer_device_address_capture_replay: false,
            buffer_device_address_multi_device: false,
            clusterculling_shader: false,
            color_write_enable: false,
            compute_derivative_group_linear: false,
            compute_derivative_group_quads: false,
            compute_full_subgroups: false,
            conditional_rendering: false,
            constant_alpha_color_blend_factors: false,
            cooperative_matrix: false,
            cooperative_matrix_robust_buffer_access: false,
            corner_sampled_image: false,
            coverage_reduction_mode: false,
            cubic_range_clamp: false,
            cuda_kernel_launch_features: false,
            custom_border_color_without_format: false,
            custom_border_colors: false,
            decode_mode_shared_exponent: false,
            dedicated_allocation_image_aliasing: false,
            depth_bias_clamp: false,
            depth_bias_control: false,
            depth_bias_exact: false,
            depth_bounds: false,
            depth_clamp: false,
            depth_clamp_zero_one: false,
            depth_clip_control: false,
            depth_clip_enable: false,
            descriptor_binding_acceleration_structure_update_after_bind: false,
            descriptor_binding_inline_uniform_block_update_after_bind: false,
            descriptor_binding_partially_bound: false,
            descriptor_binding_sampled_image_update_after_bind: false,
            descriptor_binding_storage_buffer_update_after_bind: false,
            descriptor_binding_storage_image_update_after_bind: false,
            descriptor_binding_storage_texel_buffer_update_after_bind: false,
            descriptor_binding_uniform_buffer_update_after_bind: false,
            descriptor_binding_uniform_texel_buffer_update_after_bind: false,
            descriptor_binding_update_unused_while_pending: false,
            descriptor_binding_variable_descriptor_count: false,
            descriptor_buffer: false,
            descriptor_buffer_capture_replay: false,
            descriptor_buffer_image_layout_ignored: false,
            descriptor_buffer_push_descriptors: false,
            descriptor_indexing: false,
            descriptor_pool_overallocation: false,
            descriptor_set_host_mapping: false,
            device_coherent_memory: false,
            device_fault: false,
            device_fault_vendor_binary: false,
            device_generated_commands: false,
            device_generated_compute: false,
            device_generated_compute_capture_replay: false,
            device_generated_compute_pipelines: false,
            device_memory_report: false,
            diagnostics_config: false,
            displacement_micromap: false,
            draw_indirect_count: false,
            draw_indirect_first_instance: false,
            dual_src_blend: false,
            dynamic_pipeline_layout: false,
            dynamic_rendering: false,
            dynamic_rendering_local_read: false,
            dynamic_rendering_unused_attachments: false,
            events: false,
            exclusive_scissor: false,
            extended_dynamic_state: false,
            extended_dynamic_state2: false,
            extended_dynamic_state2_logic_op: false,
            extended_dynamic_state2_patch_control_points: false,
            extended_dynamic_state3_alpha_to_coverage_enable: false,
            extended_dynamic_state3_alpha_to_one_enable: false,
            extended_dynamic_state3_color_blend_advanced: false,
            extended_dynamic_state3_color_blend_enable: false,
            extended_dynamic_state3_color_blend_equation: false,
            extended_dynamic_state3_color_write_mask: false,
            extended_dynamic_state3_conservative_rasterization_mode: false,
            extended_dynamic_state3_coverage_modulation_mode: false,
            extended_dynamic_state3_coverage_modulation_table: false,
            extended_dynamic_state3_coverage_modulation_table_enable: false,
            extended_dynamic_state3_coverage_reduction_mode: false,
            extended_dynamic_state3_coverage_to_color_enable: false,
            extended_dynamic_state3_coverage_to_color_location: false,
            extended_dynamic_state3_depth_clamp_enable: false,
            extended_dynamic_state3_depth_clip_enable: false,
            extended_dynamic_state3_depth_clip_negative_one_to_one: false,
            extended_dynamic_state3_extra_primitive_overestimation_size: false,
            extended_dynamic_state3_line_rasterization_mode: false,
            extended_dynamic_state3_line_stipple_enable: false,
            extended_dynamic_state3_logic_op_enable: false,
            extended_dynamic_state3_polygon_mode: false,
            extended_dynamic_state3_provoking_vertex_mode: false,
            extended_dynamic_state3_rasterization_samples: false,
            extended_dynamic_state3_rasterization_stream: false,
            extended_dynamic_state3_representative_fragment_test_enable: false,
            extended_dynamic_state3_sample_locations_enable: false,
            extended_dynamic_state3_sample_mask: false,
            extended_dynamic_state3_shading_rate_image_enable: false,
            extended_dynamic_state3_tessellation_domain_origin: false,
            extended_dynamic_state3_viewport_swizzle: false,
            extended_dynamic_state3_viewport_w_scaling_enable: false,
            extended_sparse_address_space: false,
            external_format_resolve: false,
            external_memory_rdma: false,
            fill_mode_non_solid: false,
            float_representation: false,
            format_a4b4g4r4: false,
            format_a4r4g4b4: false,
            format_rgba10x6_without_y_cb_cr_sampler: false,
            fragment_density_map: false,
            fragment_density_map_deferred: false,
            fragment_density_map_dynamic: false,
            fragment_density_map_non_subsampled_images: false,
            fragment_density_map_offset: false,
            fragment_shader_barycentric: false,
            fragment_shader_pixel_interlock: false,
            fragment_shader_sample_interlock: false,
            fragment_shader_shading_rate_interlock: false,
            fragment_shading_rate_enums: false,
            fragment_stores_and_atomics: false,
            frame_boundary: false,
            full_draw_index_uint32: false,
            geometry_shader: false,
            geometry_streams: false,
            global_priority_query: false,
            graphics_pipeline_library: false,
            host_image_copy: false,
            host_query_reset: false,
            image2_d_view_of3_d: false,
            image_compression_control: false,
            image_compression_control_swapchain: false,
            image_cube_array: false,
            image_footprint: false,
            image_sliced_view_of3_d: false,
            image_view2_d_on3_d_image: false,
            image_view_format_reinterpretation: false,
            image_view_format_swizzle: false,
            imageless_framebuffer: false,
            independent_blend: false,
            index_type_uint8: false,
            indirect_copy: false,
            inherited_conditional_rendering: false,
            inherited_queries: false,
            inherited_viewport_scissor2_d: false,
            inline_uniform_block: false,
            invocation_mask: false,
            large_points: false,
            least_representable_value_force_unorm_representation: false,
            legacy_dithering: false,
            linear_color_attachment: false,
            logic_op: false,
            maintenance4: false,
            maintenance5: false,
            maintenance6: false,
            memory_decompression: false,
            memory_map_placed: false,
            memory_map_range_placed: false,
            memory_priority: false,
            memory_unmap_reserve: false,
            mesh_shader: false,
            mesh_shader_queries: false,
            micromap: false,
            micromap_capture_replay: false,
            micromap_host_commands: false,
            min_lod: false,
            multi_draw: false,
            multi_draw_indirect: false,
            multi_viewport: false,
            multisample_array_image: false,
            multisampled_render_to_single_sampled: false,
            multiview: false,
            multiview_cluster_culling_shader: false,
            multiview_geometry_shader: false,
            multiview_mesh_shader: false,
            multiview_per_view_render_areas: false,
            multiview_per_view_viewports: false,
            multiview_tessellation_shader: false,
            mutable_comparison_samplers: false,
            mutable_descriptor_type: false,
            nested_command_buffer: false,
            nested_command_buffer_rendering: false,
            nested_command_buffer_simultaneous_use: false,
            no_invocation_fragment_shading_rates: false,
            non_seamless_cube_map: false,
            null_descriptor: false,
            occlusion_query_precise: false,
            optical_flow: false,
            pageable_device_local_memory: false,
            per_stage_descriptor_set: false,
            performance_counter_multiple_query_pools: false,
            performance_counter_query_pools: false,
            pipeline_creation_cache_control: false,
            pipeline_executable_info: false,
            pipeline_fragment_shading_rate: false,
            pipeline_library_group_handles: false,
            pipeline_properties_identifier: false,
            pipeline_protected_access: false,
            pipeline_robustness: false,
            pipeline_statistics_query: false,
            point_polygons: false,
            present_barrier: false,
            present_id: false,
            present_wait: false,
            primitive_fragment_shading_rate: false,
            primitive_fragment_shading_rate_mesh_shader: false,
            primitive_topology_list_restart: false,
            primitive_topology_patch_list_restart: false,
            primitives_generated_query: false,
            primitives_generated_query_with_non_zero_streams: false,
            primitives_generated_query_with_rasterizer_discard: false,
            private_data: false,
            protected_memory: false,
            provoking_vertex_last: false,
            rasterization_order_color_attachment_access: false,
            rasterization_order_depth_attachment_access: false,
            rasterization_order_stencil_attachment_access: false,
            ray_query: false,
            ray_tracing_invocation_reorder: false,
            ray_tracing_maintenance1: false,
            ray_tracing_motion_blur: false,
            ray_tracing_motion_blur_pipeline_trace_rays_indirect: false,
            ray_tracing_pipeline: false,
            ray_tracing_pipeline_shader_group_handle_capture_replay: false,
            ray_tracing_pipeline_shader_group_handle_capture_replay_mixed: false,
            ray_tracing_pipeline_trace_rays_indirect: false,
            ray_tracing_pipeline_trace_rays_indirect2: false,
            ray_tracing_position_fetch: false,
            ray_tracing_validation: false,
            ray_traversal_primitive_culling: false,
            rectangular_lines: false,
            relaxed_line_rasterization: false,
            render_pass_striped: false,
            report_address_binding: false,
            representative_fragment_test: false,
            robust_buffer_access: false,
            robust_buffer_access2: false,
            robust_image_access: false,
            robust_image_access2: false,
            runtime_descriptor_array: false,
            sample_rate_shading: false,
            sampler2_d_view_of3_d: false,
            sampler_anisotropy: false,
            sampler_filter_minmax: false,
            sampler_mip_lod_bias: false,
            sampler_mirror_clamp_to_edge: false,
            sampler_ycbcr_conversion: false,
            scalar_block_layout: false,
            scheduling_controls: false,
            screen_buffer_import: false,
            selectable_cubic_weights: false,
            separate_depth_stencil_layouts: false,
            separate_stencil_mask_ref: false,
            shader_buffer_float16_atomic_add: false,
            shader_buffer_float16_atomic_min_max: false,
            shader_buffer_float16_atomics: false,
            shader_buffer_float32_atomic_add: false,
            shader_buffer_float32_atomic_min_max: false,
            shader_buffer_float32_atomics: false,
            shader_buffer_float64_atomic_add: false,
            shader_buffer_float64_atomic_min_max: false,
            shader_buffer_float64_atomics: false,
            shader_buffer_int64_atomics: false,
            shader_clip_distance: false,
            shader_core_builtins: false,
            shader_cull_distance: false,
            shader_demote_to_helper_invocation: false,
            shader_device_clock: false,
            shader_draw_parameters: false,
            shader_early_and_late_fragment_tests: false,
            shader_enqueue: false,
            shader_expect_assume: false,
            shader_float16: false,
            shader_float16_vector_atomics: false,
            shader_float64: false,
            shader_float_controls2: false,
            shader_image_float32_atomic_add: false,
            shader_image_float32_atomic_min_max: false,
            shader_image_float32_atomics: false,
            shader_image_gather_extended: false,
            shader_image_int64_atomics: false,
            shader_input_attachment_array_dynamic_indexing: false,
            shader_input_attachment_array_non_uniform_indexing: false,
            shader_int16: false,
            shader_int64: false,
            shader_int8: false,
            shader_integer_dot_product: false,
            shader_integer_functions2: false,
            shader_maximal_reconvergence: false,
            shader_module_identifier: false,
            shader_object: false,
            shader_output_layer: false,
            shader_output_viewport_index: false,
            shader_quad_control: false,
            shader_raw_access_chains: false,
            shader_resource_min_lod: false,
            shader_resource_residency: false,
            shader_sample_rate_interpolation_functions: false,
            shader_sampled_image_array_dynamic_indexing: false,
            shader_sampled_image_array_non_uniform_indexing: false,
            shader_shared_float16_atomic_add: false,
            shader_shared_float16_atomic_min_max: false,
            shader_shared_float16_atomics: false,
            shader_shared_float32_atomic_add: false,
            shader_shared_float32_atomic_min_max: false,
            shader_shared_float32_atomics: false,
            shader_shared_float64_atomic_add: false,
            shader_shared_float64_atomic_min_max: false,
            shader_shared_float64_atomics: false,
            shader_shared_int64_atomics: false,
            shader_sm_builtins: false,
            shader_storage_buffer_array_dynamic_indexing: false,
            shader_storage_buffer_array_non_uniform_indexing: false,
            shader_storage_image_array_dynamic_indexing: false,
            shader_storage_image_array_non_uniform_indexing: false,
            shader_storage_image_extended_formats: false,
            shader_storage_image_multisample: false,
            shader_storage_image_read_without_format: false,
            shader_storage_image_write_without_format: false,
            shader_storage_texel_buffer_array_dynamic_indexing: false,
            shader_storage_texel_buffer_array_non_uniform_indexing: false,
            shader_subgroup_clock: false,
            shader_subgroup_extended_types: false,
            shader_subgroup_rotate: false,
            shader_subgroup_rotate_clustered: false,
            shader_subgroup_uniform_control_flow: false,
            shader_terminate_invocation: false,
            shader_tessellation_and_geometry_point_size: false,
            shader_tile_image_color_read_access: false,
            shader_tile_image_depth_read_access: false,
            shader_tile_image_stencil_read_access: false,
            shader_uniform_buffer_array_dynamic_indexing: false,
            shader_uniform_buffer_array_non_uniform_indexing: false,
            shader_uniform_texel_buffer_array_dynamic_indexing: false,
            shader_uniform_texel_buffer_array_non_uniform_indexing: false,
            shader_zero_initialize_workgroup_memory: false,
            shading_rate_coarse_sample_order: false,
            shading_rate_image: false,
            smooth_lines: false,
            sparse_binding: false,
            sparse_image_float32_atomic_add: false,
            sparse_image_float32_atomic_min_max: false,
            sparse_image_float32_atomics: false,
            sparse_image_int64_atomics: false,
            sparse_residency16_samples: false,
            sparse_residency2_samples: false,
            sparse_residency4_samples: false,
            sparse_residency8_samples: false,
            sparse_residency_aliased: false,
            sparse_residency_buffer: false,
            sparse_residency_image2_d: false,
            sparse_residency_image3_d: false,
            stippled_bresenham_lines: false,
            stippled_rectangular_lines: false,
            stippled_smooth_lines: false,
            storage_buffer16_bit_access: false,
            storage_buffer8_bit_access: false,
            storage_input_output16: false,
            storage_push_constant16: false,
            storage_push_constant8: false,
            subgroup_broadcast_dynamic_id: false,
            subgroup_size_control: false,
            subpass_merge_feedback: false,
            subpass_shading: false,
            supersample_fragment_shading_rates: false,
            swapchain_maintenance1: false,
            synchronization2: false,
            task_shader: false,
            tessellation_isolines: false,
            tessellation_point_mode: false,
            tessellation_shader: false,
            texel_buffer_alignment: false,
            texture_block_match: false,
            texture_block_match2: false,
            texture_box_filter: false,
            texture_compression_astc_hdr: false,
            texture_compression_astc_ldr: false,
            texture_compression_bc: false,
            texture_compression_etc2: false,
            texture_sample_weighted: false,
            tile_properties: false,
            timeline_semaphore: false,
            transform_feedback: false,
            transform_feedback_preserves_provoking_vertex: false,
            triangle_fans: false,
            uniform_and_storage_buffer16_bit_access: false,
            uniform_and_storage_buffer8_bit_access: false,
            uniform_buffer_standard_layout: false,
            variable_multisample_rate: false,
            variable_pointers: false,
            variable_pointers_storage_buffer: false,
            vertex_attribute_access_beyond_stride: false,
            vertex_attribute_instance_rate_divisor: false,
            vertex_attribute_instance_rate_zero_divisor: false,
            vertex_input_dynamic_state: false,
            vertex_pipeline_stores_and_atomics: false,
            video_maintenance1: false,
            vulkan_memory_model: false,
            vulkan_memory_model_availability_visibility_chains: false,
            vulkan_memory_model_device_scope: false,
            wide_lines: false,
            workgroup_memory_explicit_layout: false,
            workgroup_memory_explicit_layout16_bit_access: false,
            workgroup_memory_explicit_layout8_bit_access: false,
            workgroup_memory_explicit_layout_scalar_block_layout: false,
            ycbcr2plane444_formats: false,
            ycbcr_degamma: false,
            ycbcr_image_arrays: false,
            _ne: crate::NonExhaustive(()),
        }
    }
    /// Returns a `DeviceFeatures` with all of the members set.
    #[cfg(test)]
    pub(crate) const fn all() -> DeviceFeatures {
        Self {
            acceleration_structure: true,
            acceleration_structure_capture_replay: true,
            acceleration_structure_host_commands: true,
            acceleration_structure_indirect_build: true,
            advanced_blend_coherent_operations: true,
            alpha_to_one: true,
            amigo_profiling: true,
            attachment_feedback_loop_dynamic_state: true,
            attachment_feedback_loop_layout: true,
            attachment_fragment_shading_rate: true,
            border_color_swizzle: true,
            border_color_swizzle_from_image: true,
            bresenham_lines: true,
            buffer_device_address: true,
            buffer_device_address_capture_replay: true,
            buffer_device_address_multi_device: true,
            clusterculling_shader: true,
            color_write_enable: true,
            compute_derivative_group_linear: true,
            compute_derivative_group_quads: true,
            compute_full_subgroups: true,
            conditional_rendering: true,
            constant_alpha_color_blend_factors: true,
            cooperative_matrix: true,
            cooperative_matrix_robust_buffer_access: true,
            corner_sampled_image: true,
            coverage_reduction_mode: true,
            cubic_range_clamp: true,
            cuda_kernel_launch_features: true,
            custom_border_color_without_format: true,
            custom_border_colors: true,
            decode_mode_shared_exponent: true,
            dedicated_allocation_image_aliasing: true,
            depth_bias_clamp: true,
            depth_bias_control: true,
            depth_bias_exact: true,
            depth_bounds: true,
            depth_clamp: true,
            depth_clamp_zero_one: true,
            depth_clip_control: true,
            depth_clip_enable: true,
            descriptor_binding_acceleration_structure_update_after_bind: true,
            descriptor_binding_inline_uniform_block_update_after_bind: true,
            descriptor_binding_partially_bound: true,
            descriptor_binding_sampled_image_update_after_bind: true,
            descriptor_binding_storage_buffer_update_after_bind: true,
            descriptor_binding_storage_image_update_after_bind: true,
            descriptor_binding_storage_texel_buffer_update_after_bind: true,
            descriptor_binding_uniform_buffer_update_after_bind: true,
            descriptor_binding_uniform_texel_buffer_update_after_bind: true,
            descriptor_binding_update_unused_while_pending: true,
            descriptor_binding_variable_descriptor_count: true,
            descriptor_buffer: true,
            descriptor_buffer_capture_replay: true,
            descriptor_buffer_image_layout_ignored: true,
            descriptor_buffer_push_descriptors: true,
            descriptor_indexing: true,
            descriptor_pool_overallocation: true,
            descriptor_set_host_mapping: true,
            device_coherent_memory: true,
            device_fault: true,
            device_fault_vendor_binary: true,
            device_generated_commands: true,
            device_generated_compute: true,
            device_generated_compute_capture_replay: true,
            device_generated_compute_pipelines: true,
            device_memory_report: true,
            diagnostics_config: true,
            displacement_micromap: true,
            draw_indirect_count: true,
            draw_indirect_first_instance: true,
            dual_src_blend: true,
            dynamic_pipeline_layout: true,
            dynamic_rendering: true,
            dynamic_rendering_local_read: true,
            dynamic_rendering_unused_attachments: true,
            events: true,
            exclusive_scissor: true,
            extended_dynamic_state: true,
            extended_dynamic_state2: true,
            extended_dynamic_state2_logic_op: true,
            extended_dynamic_state2_patch_control_points: true,
            extended_dynamic_state3_alpha_to_coverage_enable: true,
            extended_dynamic_state3_alpha_to_one_enable: true,
            extended_dynamic_state3_color_blend_advanced: true,
            extended_dynamic_state3_color_blend_enable: true,
            extended_dynamic_state3_color_blend_equation: true,
            extended_dynamic_state3_color_write_mask: true,
            extended_dynamic_state3_conservative_rasterization_mode: true,
            extended_dynamic_state3_coverage_modulation_mode: true,
            extended_dynamic_state3_coverage_modulation_table: true,
            extended_dynamic_state3_coverage_modulation_table_enable: true,
            extended_dynamic_state3_coverage_reduction_mode: true,
            extended_dynamic_state3_coverage_to_color_enable: true,
            extended_dynamic_state3_coverage_to_color_location: true,
            extended_dynamic_state3_depth_clamp_enable: true,
            extended_dynamic_state3_depth_clip_enable: true,
            extended_dynamic_state3_depth_clip_negative_one_to_one: true,
            extended_dynamic_state3_extra_primitive_overestimation_size: true,
            extended_dynamic_state3_line_rasterization_mode: true,
            extended_dynamic_state3_line_stipple_enable: true,
            extended_dynamic_state3_logic_op_enable: true,
            extended_dynamic_state3_polygon_mode: true,
            extended_dynamic_state3_provoking_vertex_mode: true,
            extended_dynamic_state3_rasterization_samples: true,
            extended_dynamic_state3_rasterization_stream: true,
            extended_dynamic_state3_representative_fragment_test_enable: true,
            extended_dynamic_state3_sample_locations_enable: true,
            extended_dynamic_state3_sample_mask: true,
            extended_dynamic_state3_shading_rate_image_enable: true,
            extended_dynamic_state3_tessellation_domain_origin: true,
            extended_dynamic_state3_viewport_swizzle: true,
            extended_dynamic_state3_viewport_w_scaling_enable: true,
            extended_sparse_address_space: true,
            external_format_resolve: true,
            external_memory_rdma: true,
            fill_mode_non_solid: true,
            float_representation: true,
            format_a4b4g4r4: true,
            format_a4r4g4b4: true,
            format_rgba10x6_without_y_cb_cr_sampler: true,
            fragment_density_map: true,
            fragment_density_map_deferred: true,
            fragment_density_map_dynamic: true,
            fragment_density_map_non_subsampled_images: true,
            fragment_density_map_offset: true,
            fragment_shader_barycentric: true,
            fragment_shader_pixel_interlock: true,
            fragment_shader_sample_interlock: true,
            fragment_shader_shading_rate_interlock: true,
            fragment_shading_rate_enums: true,
            fragment_stores_and_atomics: true,
            frame_boundary: true,
            full_draw_index_uint32: true,
            geometry_shader: true,
            geometry_streams: true,
            global_priority_query: true,
            graphics_pipeline_library: true,
            host_image_copy: true,
            host_query_reset: true,
            image2_d_view_of3_d: true,
            image_compression_control: true,
            image_compression_control_swapchain: true,
            image_cube_array: true,
            image_footprint: true,
            image_sliced_view_of3_d: true,
            image_view2_d_on3_d_image: true,
            image_view_format_reinterpretation: true,
            image_view_format_swizzle: true,
            imageless_framebuffer: true,
            independent_blend: true,
            index_type_uint8: true,
            indirect_copy: true,
            inherited_conditional_rendering: true,
            inherited_queries: true,
            inherited_viewport_scissor2_d: true,
            inline_uniform_block: true,
            invocation_mask: true,
            large_points: true,
            least_representable_value_force_unorm_representation: true,
            legacy_dithering: true,
            linear_color_attachment: true,
            logic_op: true,
            maintenance4: true,
            maintenance5: true,
            maintenance6: true,
            memory_decompression: true,
            memory_map_placed: true,
            memory_map_range_placed: true,
            memory_priority: true,
            memory_unmap_reserve: true,
            mesh_shader: true,
            mesh_shader_queries: true,
            micromap: true,
            micromap_capture_replay: true,
            micromap_host_commands: true,
            min_lod: true,
            multi_draw: true,
            multi_draw_indirect: true,
            multi_viewport: true,
            multisample_array_image: true,
            multisampled_render_to_single_sampled: true,
            multiview: true,
            multiview_cluster_culling_shader: true,
            multiview_geometry_shader: true,
            multiview_mesh_shader: true,
            multiview_per_view_render_areas: true,
            multiview_per_view_viewports: true,
            multiview_tessellation_shader: true,
            mutable_comparison_samplers: true,
            mutable_descriptor_type: true,
            nested_command_buffer: true,
            nested_command_buffer_rendering: true,
            nested_command_buffer_simultaneous_use: true,
            no_invocation_fragment_shading_rates: true,
            non_seamless_cube_map: true,
            null_descriptor: true,
            occlusion_query_precise: true,
            optical_flow: true,
            pageable_device_local_memory: true,
            per_stage_descriptor_set: true,
            performance_counter_multiple_query_pools: true,
            performance_counter_query_pools: true,
            pipeline_creation_cache_control: true,
            pipeline_executable_info: true,
            pipeline_fragment_shading_rate: true,
            pipeline_library_group_handles: true,
            pipeline_properties_identifier: true,
            pipeline_protected_access: true,
            pipeline_robustness: true,
            pipeline_statistics_query: true,
            point_polygons: true,
            present_barrier: true,
            present_id: true,
            present_wait: true,
            primitive_fragment_shading_rate: true,
            primitive_fragment_shading_rate_mesh_shader: true,
            primitive_topology_list_restart: true,
            primitive_topology_patch_list_restart: true,
            primitives_generated_query: true,
            primitives_generated_query_with_non_zero_streams: true,
            primitives_generated_query_with_rasterizer_discard: true,
            private_data: true,
            protected_memory: true,
            provoking_vertex_last: true,
            rasterization_order_color_attachment_access: true,
            rasterization_order_depth_attachment_access: true,
            rasterization_order_stencil_attachment_access: true,
            ray_query: true,
            ray_tracing_invocation_reorder: true,
            ray_tracing_maintenance1: true,
            ray_tracing_motion_blur: true,
            ray_tracing_motion_blur_pipeline_trace_rays_indirect: true,
            ray_tracing_pipeline: true,
            ray_tracing_pipeline_shader_group_handle_capture_replay: true,
            ray_tracing_pipeline_shader_group_handle_capture_replay_mixed: true,
            ray_tracing_pipeline_trace_rays_indirect: true,
            ray_tracing_pipeline_trace_rays_indirect2: true,
            ray_tracing_position_fetch: true,
            ray_tracing_validation: true,
            ray_traversal_primitive_culling: true,
            rectangular_lines: true,
            relaxed_line_rasterization: true,
            render_pass_striped: true,
            report_address_binding: true,
            representative_fragment_test: true,
            robust_buffer_access: true,
            robust_buffer_access2: true,
            robust_image_access: true,
            robust_image_access2: true,
            runtime_descriptor_array: true,
            sample_rate_shading: true,
            sampler2_d_view_of3_d: true,
            sampler_anisotropy: true,
            sampler_filter_minmax: true,
            sampler_mip_lod_bias: true,
            sampler_mirror_clamp_to_edge: true,
            sampler_ycbcr_conversion: true,
            scalar_block_layout: true,
            scheduling_controls: true,
            screen_buffer_import: true,
            selectable_cubic_weights: true,
            separate_depth_stencil_layouts: true,
            separate_stencil_mask_ref: true,
            shader_buffer_float16_atomic_add: true,
            shader_buffer_float16_atomic_min_max: true,
            shader_buffer_float16_atomics: true,
            shader_buffer_float32_atomic_add: true,
            shader_buffer_float32_atomic_min_max: true,
            shader_buffer_float32_atomics: true,
            shader_buffer_float64_atomic_add: true,
            shader_buffer_float64_atomic_min_max: true,
            shader_buffer_float64_atomics: true,
            shader_buffer_int64_atomics: true,
            shader_clip_distance: true,
            shader_core_builtins: true,
            shader_cull_distance: true,
            shader_demote_to_helper_invocation: true,
            shader_device_clock: true,
            shader_draw_parameters: true,
            shader_early_and_late_fragment_tests: true,
            shader_enqueue: true,
            shader_expect_assume: true,
            shader_float16: true,
            shader_float16_vector_atomics: true,
            shader_float64: true,
            shader_float_controls2: true,
            shader_image_float32_atomic_add: true,
            shader_image_float32_atomic_min_max: true,
            shader_image_float32_atomics: true,
            shader_image_gather_extended: true,
            shader_image_int64_atomics: true,
            shader_input_attachment_array_dynamic_indexing: true,
            shader_input_attachment_array_non_uniform_indexing: true,
            shader_int16: true,
            shader_int64: true,
            shader_int8: true,
            shader_integer_dot_product: true,
            shader_integer_functions2: true,
            shader_maximal_reconvergence: true,
            shader_module_identifier: true,
            shader_object: true,
            shader_output_layer: true,
            shader_output_viewport_index: true,
            shader_quad_control: true,
            shader_raw_access_chains: true,
            shader_resource_min_lod: true,
            shader_resource_residency: true,
            shader_sample_rate_interpolation_functions: true,
            shader_sampled_image_array_dynamic_indexing: true,
            shader_sampled_image_array_non_uniform_indexing: true,
            shader_shared_float16_atomic_add: true,
            shader_shared_float16_atomic_min_max: true,
            shader_shared_float16_atomics: true,
            shader_shared_float32_atomic_add: true,
            shader_shared_float32_atomic_min_max: true,
            shader_shared_float32_atomics: true,
            shader_shared_float64_atomic_add: true,
            shader_shared_float64_atomic_min_max: true,
            shader_shared_float64_atomics: true,
            shader_shared_int64_atomics: true,
            shader_sm_builtins: true,
            shader_storage_buffer_array_dynamic_indexing: true,
            shader_storage_buffer_array_non_uniform_indexing: true,
            shader_storage_image_array_dynamic_indexing: true,
            shader_storage_image_array_non_uniform_indexing: true,
            shader_storage_image_extended_formats: true,
            shader_storage_image_multisample: true,
            shader_storage_image_read_without_format: true,
            shader_storage_image_write_without_format: true,
            shader_storage_texel_buffer_array_dynamic_indexing: true,
            shader_storage_texel_buffer_array_non_uniform_indexing: true,
            shader_subgroup_clock: true,
            shader_subgroup_extended_types: true,
            shader_subgroup_rotate: true,
            shader_subgroup_rotate_clustered: true,
            shader_subgroup_uniform_control_flow: true,
            shader_terminate_invocation: true,
            shader_tessellation_and_geometry_point_size: true,
            shader_tile_image_color_read_access: true,
            shader_tile_image_depth_read_access: true,
            shader_tile_image_stencil_read_access: true,
            shader_uniform_buffer_array_dynamic_indexing: true,
            shader_uniform_buffer_array_non_uniform_indexing: true,
            shader_uniform_texel_buffer_array_dynamic_indexing: true,
            shader_uniform_texel_buffer_array_non_uniform_indexing: true,
            shader_zero_initialize_workgroup_memory: true,
            shading_rate_coarse_sample_order: true,
            shading_rate_image: true,
            smooth_lines: true,
            sparse_binding: true,
            sparse_image_float32_atomic_add: true,
            sparse_image_float32_atomic_min_max: true,
            sparse_image_float32_atomics: true,
            sparse_image_int64_atomics: true,
            sparse_residency16_samples: true,
            sparse_residency2_samples: true,
            sparse_residency4_samples: true,
            sparse_residency8_samples: true,
            sparse_residency_aliased: true,
            sparse_residency_buffer: true,
            sparse_residency_image2_d: true,
            sparse_residency_image3_d: true,
            stippled_bresenham_lines: true,
            stippled_rectangular_lines: true,
            stippled_smooth_lines: true,
            storage_buffer16_bit_access: true,
            storage_buffer8_bit_access: true,
            storage_input_output16: true,
            storage_push_constant16: true,
            storage_push_constant8: true,
            subgroup_broadcast_dynamic_id: true,
            subgroup_size_control: true,
            subpass_merge_feedback: true,
            subpass_shading: true,
            supersample_fragment_shading_rates: true,
            swapchain_maintenance1: true,
            synchronization2: true,
            task_shader: true,
            tessellation_isolines: true,
            tessellation_point_mode: true,
            tessellation_shader: true,
            texel_buffer_alignment: true,
            texture_block_match: true,
            texture_block_match2: true,
            texture_box_filter: true,
            texture_compression_astc_hdr: true,
            texture_compression_astc_ldr: true,
            texture_compression_bc: true,
            texture_compression_etc2: true,
            texture_sample_weighted: true,
            tile_properties: true,
            timeline_semaphore: true,
            transform_feedback: true,
            transform_feedback_preserves_provoking_vertex: true,
            triangle_fans: true,
            uniform_and_storage_buffer16_bit_access: true,
            uniform_and_storage_buffer8_bit_access: true,
            uniform_buffer_standard_layout: true,
            variable_multisample_rate: true,
            variable_pointers: true,
            variable_pointers_storage_buffer: true,
            vertex_attribute_access_beyond_stride: true,
            vertex_attribute_instance_rate_divisor: true,
            vertex_attribute_instance_rate_zero_divisor: true,
            vertex_input_dynamic_state: true,
            vertex_pipeline_stores_and_atomics: true,
            video_maintenance1: true,
            vulkan_memory_model: true,
            vulkan_memory_model_availability_visibility_chains: true,
            vulkan_memory_model_device_scope: true,
            wide_lines: true,
            workgroup_memory_explicit_layout: true,
            workgroup_memory_explicit_layout16_bit_access: true,
            workgroup_memory_explicit_layout8_bit_access: true,
            workgroup_memory_explicit_layout_scalar_block_layout: true,
            ycbcr2plane444_formats: true,
            ycbcr_degamma: true,
            ycbcr_image_arrays: true,
            _ne: crate::NonExhaustive(()),
        }
    }
    /// Returns whether any members are set in both `self` and `other`.
    #[inline]
    pub const fn intersects(&self, other: &Self) -> bool {
        (self.acceleration_structure && other.acceleration_structure)
            || (self.acceleration_structure_capture_replay
                && other.acceleration_structure_capture_replay)
            || (self.acceleration_structure_host_commands
                && other.acceleration_structure_host_commands)
            || (self.acceleration_structure_indirect_build
                && other.acceleration_structure_indirect_build)
            || (self.advanced_blend_coherent_operations
                && other.advanced_blend_coherent_operations)
            || (self.alpha_to_one && other.alpha_to_one)
            || (self.amigo_profiling && other.amigo_profiling)
            || (self.attachment_feedback_loop_dynamic_state
                && other.attachment_feedback_loop_dynamic_state)
            || (self.attachment_feedback_loop_layout
                && other.attachment_feedback_loop_layout)
            || (self.attachment_fragment_shading_rate
                && other.attachment_fragment_shading_rate)
            || (self.border_color_swizzle && other.border_color_swizzle)
            || (self.border_color_swizzle_from_image
                && other.border_color_swizzle_from_image)
            || (self.bresenham_lines && other.bresenham_lines)
            || (self.buffer_device_address && other.buffer_device_address)
            || (self.buffer_device_address_capture_replay
                && other.buffer_device_address_capture_replay)
            || (self.buffer_device_address_multi_device
                && other.buffer_device_address_multi_device)
            || (self.clusterculling_shader && other.clusterculling_shader)
            || (self.color_write_enable && other.color_write_enable)
            || (self.compute_derivative_group_linear
                && other.compute_derivative_group_linear)
            || (self.compute_derivative_group_quads
                && other.compute_derivative_group_quads)
            || (self.compute_full_subgroups && other.compute_full_subgroups)
            || (self.conditional_rendering && other.conditional_rendering)
            || (self.constant_alpha_color_blend_factors
                && other.constant_alpha_color_blend_factors)
            || (self.cooperative_matrix && other.cooperative_matrix)
            || (self.cooperative_matrix_robust_buffer_access
                && other.cooperative_matrix_robust_buffer_access)
            || (self.corner_sampled_image && other.corner_sampled_image)
            || (self.coverage_reduction_mode && other.coverage_reduction_mode)
            || (self.cubic_range_clamp && other.cubic_range_clamp)
            || (self.cuda_kernel_launch_features && other.cuda_kernel_launch_features)
            || (self.custom_border_color_without_format
                && other.custom_border_color_without_format)
            || (self.custom_border_colors && other.custom_border_colors)
            || (self.decode_mode_shared_exponent && other.decode_mode_shared_exponent)
            || (self.dedicated_allocation_image_aliasing
                && other.dedicated_allocation_image_aliasing)
            || (self.depth_bias_clamp && other.depth_bias_clamp)
            || (self.depth_bias_control && other.depth_bias_control)
            || (self.depth_bias_exact && other.depth_bias_exact)
            || (self.depth_bounds && other.depth_bounds)
            || (self.depth_clamp && other.depth_clamp)
            || (self.depth_clamp_zero_one && other.depth_clamp_zero_one)
            || (self.depth_clip_control && other.depth_clip_control)
            || (self.depth_clip_enable && other.depth_clip_enable)
            || (self.descriptor_binding_acceleration_structure_update_after_bind
                && other.descriptor_binding_acceleration_structure_update_after_bind)
            || (self.descriptor_binding_inline_uniform_block_update_after_bind
                && other.descriptor_binding_inline_uniform_block_update_after_bind)
            || (self.descriptor_binding_partially_bound
                && other.descriptor_binding_partially_bound)
            || (self.descriptor_binding_sampled_image_update_after_bind
                && other.descriptor_binding_sampled_image_update_after_bind)
            || (self.descriptor_binding_storage_buffer_update_after_bind
                && other.descriptor_binding_storage_buffer_update_after_bind)
            || (self.descriptor_binding_storage_image_update_after_bind
                && other.descriptor_binding_storage_image_update_after_bind)
            || (self.descriptor_binding_storage_texel_buffer_update_after_bind
                && other.descriptor_binding_storage_texel_buffer_update_after_bind)
            || (self.descriptor_binding_uniform_buffer_update_after_bind
                && other.descriptor_binding_uniform_buffer_update_after_bind)
            || (self.descriptor_binding_uniform_texel_buffer_update_after_bind
                && other.descriptor_binding_uniform_texel_buffer_update_after_bind)
            || (self.descriptor_binding_update_unused_while_pending
                && other.descriptor_binding_update_unused_while_pending)
            || (self.descriptor_binding_variable_descriptor_count
                && other.descriptor_binding_variable_descriptor_count)
            || (self.descriptor_buffer && other.descriptor_buffer)
            || (self.descriptor_buffer_capture_replay
                && other.descriptor_buffer_capture_replay)
            || (self.descriptor_buffer_image_layout_ignored
                && other.descriptor_buffer_image_layout_ignored)
            || (self.descriptor_buffer_push_descriptors
                && other.descriptor_buffer_push_descriptors)
            || (self.descriptor_indexing && other.descriptor_indexing)
            || (self.descriptor_pool_overallocation
                && other.descriptor_pool_overallocation)
            || (self.descriptor_set_host_mapping && other.descriptor_set_host_mapping)
            || (self.device_coherent_memory && other.device_coherent_memory)
            || (self.device_fault && other.device_fault)
            || (self.device_fault_vendor_binary && other.device_fault_vendor_binary)
            || (self.device_generated_commands && other.device_generated_commands)
            || (self.device_generated_compute && other.device_generated_compute)
            || (self.device_generated_compute_capture_replay
                && other.device_generated_compute_capture_replay)
            || (self.device_generated_compute_pipelines
                && other.device_generated_compute_pipelines)
            || (self.device_memory_report && other.device_memory_report)
            || (self.diagnostics_config && other.diagnostics_config)
            || (self.displacement_micromap && other.displacement_micromap)
            || (self.draw_indirect_count && other.draw_indirect_count)
            || (self.draw_indirect_first_instance && other.draw_indirect_first_instance)
            || (self.dual_src_blend && other.dual_src_blend)
            || (self.dynamic_pipeline_layout && other.dynamic_pipeline_layout)
            || (self.dynamic_rendering && other.dynamic_rendering)
            || (self.dynamic_rendering_local_read && other.dynamic_rendering_local_read)
            || (self.dynamic_rendering_unused_attachments
                && other.dynamic_rendering_unused_attachments)
            || (self.events && other.events)
            || (self.exclusive_scissor && other.exclusive_scissor)
            || (self.extended_dynamic_state && other.extended_dynamic_state)
            || (self.extended_dynamic_state2 && other.extended_dynamic_state2)
            || (self.extended_dynamic_state2_logic_op
                && other.extended_dynamic_state2_logic_op)
            || (self.extended_dynamic_state2_patch_control_points
                && other.extended_dynamic_state2_patch_control_points)
            || (self.extended_dynamic_state3_alpha_to_coverage_enable
                && other.extended_dynamic_state3_alpha_to_coverage_enable)
            || (self.extended_dynamic_state3_alpha_to_one_enable
                && other.extended_dynamic_state3_alpha_to_one_enable)
            || (self.extended_dynamic_state3_color_blend_advanced
                && other.extended_dynamic_state3_color_blend_advanced)
            || (self.extended_dynamic_state3_color_blend_enable
                && other.extended_dynamic_state3_color_blend_enable)
            || (self.extended_dynamic_state3_color_blend_equation
                && other.extended_dynamic_state3_color_blend_equation)
            || (self.extended_dynamic_state3_color_write_mask
                && other.extended_dynamic_state3_color_write_mask)
            || (self.extended_dynamic_state3_conservative_rasterization_mode
                && other.extended_dynamic_state3_conservative_rasterization_mode)
            || (self.extended_dynamic_state3_coverage_modulation_mode
                && other.extended_dynamic_state3_coverage_modulation_mode)
            || (self.extended_dynamic_state3_coverage_modulation_table
                && other.extended_dynamic_state3_coverage_modulation_table)
            || (self.extended_dynamic_state3_coverage_modulation_table_enable
                && other.extended_dynamic_state3_coverage_modulation_table_enable)
            || (self.extended_dynamic_state3_coverage_reduction_mode
                && other.extended_dynamic_state3_coverage_reduction_mode)
            || (self.extended_dynamic_state3_coverage_to_color_enable
                && other.extended_dynamic_state3_coverage_to_color_enable)
            || (self.extended_dynamic_state3_coverage_to_color_location
                && other.extended_dynamic_state3_coverage_to_color_location)
            || (self.extended_dynamic_state3_depth_clamp_enable
                && other.extended_dynamic_state3_depth_clamp_enable)
            || (self.extended_dynamic_state3_depth_clip_enable
                && other.extended_dynamic_state3_depth_clip_enable)
            || (self.extended_dynamic_state3_depth_clip_negative_one_to_one
                && other.extended_dynamic_state3_depth_clip_negative_one_to_one)
            || (self.extended_dynamic_state3_extra_primitive_overestimation_size
                && other.extended_dynamic_state3_extra_primitive_overestimation_size)
            || (self.extended_dynamic_state3_line_rasterization_mode
                && other.extended_dynamic_state3_line_rasterization_mode)
            || (self.extended_dynamic_state3_line_stipple_enable
                && other.extended_dynamic_state3_line_stipple_enable)
            || (self.extended_dynamic_state3_logic_op_enable
                && other.extended_dynamic_state3_logic_op_enable)
            || (self.extended_dynamic_state3_polygon_mode
                && other.extended_dynamic_state3_polygon_mode)
            || (self.extended_dynamic_state3_provoking_vertex_mode
                && other.extended_dynamic_state3_provoking_vertex_mode)
            || (self.extended_dynamic_state3_rasterization_samples
                && other.extended_dynamic_state3_rasterization_samples)
            || (self.extended_dynamic_state3_rasterization_stream
                && other.extended_dynamic_state3_rasterization_stream)
            || (self.extended_dynamic_state3_representative_fragment_test_enable
                && other.extended_dynamic_state3_representative_fragment_test_enable)
            || (self.extended_dynamic_state3_sample_locations_enable
                && other.extended_dynamic_state3_sample_locations_enable)
            || (self.extended_dynamic_state3_sample_mask
                && other.extended_dynamic_state3_sample_mask)
            || (self.extended_dynamic_state3_shading_rate_image_enable
                && other.extended_dynamic_state3_shading_rate_image_enable)
            || (self.extended_dynamic_state3_tessellation_domain_origin
                && other.extended_dynamic_state3_tessellation_domain_origin)
            || (self.extended_dynamic_state3_viewport_swizzle
                && other.extended_dynamic_state3_viewport_swizzle)
            || (self.extended_dynamic_state3_viewport_w_scaling_enable
                && other.extended_dynamic_state3_viewport_w_scaling_enable)
            || (self.extended_sparse_address_space
                && other.extended_sparse_address_space)
            || (self.external_format_resolve && other.external_format_resolve)
            || (self.external_memory_rdma && other.external_memory_rdma)
            || (self.fill_mode_non_solid && other.fill_mode_non_solid)
            || (self.float_representation && other.float_representation)
            || (self.format_a4b4g4r4 && other.format_a4b4g4r4)
            || (self.format_a4r4g4b4 && other.format_a4r4g4b4)
            || (self.format_rgba10x6_without_y_cb_cr_sampler
                && other.format_rgba10x6_without_y_cb_cr_sampler)
            || (self.fragment_density_map && other.fragment_density_map)
            || (self.fragment_density_map_deferred
                && other.fragment_density_map_deferred)
            || (self.fragment_density_map_dynamic && other.fragment_density_map_dynamic)
            || (self.fragment_density_map_non_subsampled_images
                && other.fragment_density_map_non_subsampled_images)
            || (self.fragment_density_map_offset && other.fragment_density_map_offset)
            || (self.fragment_shader_barycentric && other.fragment_shader_barycentric)
            || (self.fragment_shader_pixel_interlock
                && other.fragment_shader_pixel_interlock)
            || (self.fragment_shader_sample_interlock
                && other.fragment_shader_sample_interlock)
            || (self.fragment_shader_shading_rate_interlock
                && other.fragment_shader_shading_rate_interlock)
            || (self.fragment_shading_rate_enums && other.fragment_shading_rate_enums)
            || (self.fragment_stores_and_atomics && other.fragment_stores_and_atomics)
            || (self.frame_boundary && other.frame_boundary)
            || (self.full_draw_index_uint32 && other.full_draw_index_uint32)
            || (self.geometry_shader && other.geometry_shader)
            || (self.geometry_streams && other.geometry_streams)
            || (self.global_priority_query && other.global_priority_query)
            || (self.graphics_pipeline_library && other.graphics_pipeline_library)
            || (self.host_image_copy && other.host_image_copy)
            || (self.host_query_reset && other.host_query_reset)
            || (self.image2_d_view_of3_d && other.image2_d_view_of3_d)
            || (self.image_compression_control && other.image_compression_control)
            || (self.image_compression_control_swapchain
                && other.image_compression_control_swapchain)
            || (self.image_cube_array && other.image_cube_array)
            || (self.image_footprint && other.image_footprint)
            || (self.image_sliced_view_of3_d && other.image_sliced_view_of3_d)
            || (self.image_view2_d_on3_d_image && other.image_view2_d_on3_d_image)
            || (self.image_view_format_reinterpretation
                && other.image_view_format_reinterpretation)
            || (self.image_view_format_swizzle && other.image_view_format_swizzle)
            || (self.imageless_framebuffer && other.imageless_framebuffer)
            || (self.independent_blend && other.independent_blend)
            || (self.index_type_uint8 && other.index_type_uint8)
            || (self.indirect_copy && other.indirect_copy)
            || (self.inherited_conditional_rendering
                && other.inherited_conditional_rendering)
            || (self.inherited_queries && other.inherited_queries)
            || (self.inherited_viewport_scissor2_d
                && other.inherited_viewport_scissor2_d)
            || (self.inline_uniform_block && other.inline_uniform_block)
            || (self.invocation_mask && other.invocation_mask)
            || (self.large_points && other.large_points)
            || (self.least_representable_value_force_unorm_representation
                && other.least_representable_value_force_unorm_representation)
            || (self.legacy_dithering && other.legacy_dithering)
            || (self.linear_color_attachment && other.linear_color_attachment)
            || (self.logic_op && other.logic_op)
            || (self.maintenance4 && other.maintenance4)
            || (self.maintenance5 && other.maintenance5)
            || (self.maintenance6 && other.maintenance6)
            || (self.memory_decompression && other.memory_decompression)
            || (self.memory_map_placed && other.memory_map_placed)
            || (self.memory_map_range_placed && other.memory_map_range_placed)
            || (self.memory_priority && other.memory_priority)
            || (self.memory_unmap_reserve && other.memory_unmap_reserve)
            || (self.mesh_shader && other.mesh_shader)
            || (self.mesh_shader_queries && other.mesh_shader_queries)
            || (self.micromap && other.micromap)
            || (self.micromap_capture_replay && other.micromap_capture_replay)
            || (self.micromap_host_commands && other.micromap_host_commands)
            || (self.min_lod && other.min_lod) || (self.multi_draw && other.multi_draw)
            || (self.multi_draw_indirect && other.multi_draw_indirect)
            || (self.multi_viewport && other.multi_viewport)
            || (self.multisample_array_image && other.multisample_array_image)
            || (self.multisampled_render_to_single_sampled
                && other.multisampled_render_to_single_sampled)
            || (self.multiview && other.multiview)
            || (self.multiview_cluster_culling_shader
                && other.multiview_cluster_culling_shader)
            || (self.multiview_geometry_shader && other.multiview_geometry_shader)
            || (self.multiview_mesh_shader && other.multiview_mesh_shader)
            || (self.multiview_per_view_render_areas
                && other.multiview_per_view_render_areas)
            || (self.multiview_per_view_viewports && other.multiview_per_view_viewports)
            || (self.multiview_tessellation_shader
                && other.multiview_tessellation_shader)
            || (self.mutable_comparison_samplers && other.mutable_comparison_samplers)
            || (self.mutable_descriptor_type && other.mutable_descriptor_type)
            || (self.nested_command_buffer && other.nested_command_buffer)
            || (self.nested_command_buffer_rendering
                && other.nested_command_buffer_rendering)
            || (self.nested_command_buffer_simultaneous_use
                && other.nested_command_buffer_simultaneous_use)
            || (self.no_invocation_fragment_shading_rates
                && other.no_invocation_fragment_shading_rates)
            || (self.non_seamless_cube_map && other.non_seamless_cube_map)
            || (self.null_descriptor && other.null_descriptor)
            || (self.occlusion_query_precise && other.occlusion_query_precise)
            || (self.optical_flow && other.optical_flow)
            || (self.pageable_device_local_memory && other.pageable_device_local_memory)
            || (self.per_stage_descriptor_set && other.per_stage_descriptor_set)
            || (self.performance_counter_multiple_query_pools
                && other.performance_counter_multiple_query_pools)
            || (self.performance_counter_query_pools
                && other.performance_counter_query_pools)
            || (self.pipeline_creation_cache_control
                && other.pipeline_creation_cache_control)
            || (self.pipeline_executable_info && other.pipeline_executable_info)
            || (self.pipeline_fragment_shading_rate
                && other.pipeline_fragment_shading_rate)
            || (self.pipeline_library_group_handles
                && other.pipeline_library_group_handles)
            || (self.pipeline_properties_identifier
                && other.pipeline_properties_identifier)
            || (self.pipeline_protected_access && other.pipeline_protected_access)
            || (self.pipeline_robustness && other.pipeline_robustness)
            || (self.pipeline_statistics_query && other.pipeline_statistics_query)
            || (self.point_polygons && other.point_polygons)
            || (self.present_barrier && other.present_barrier)
            || (self.present_id && other.present_id)
            || (self.present_wait && other.present_wait)
            || (self.primitive_fragment_shading_rate
                && other.primitive_fragment_shading_rate)
            || (self.primitive_fragment_shading_rate_mesh_shader
                && other.primitive_fragment_shading_rate_mesh_shader)
            || (self.primitive_topology_list_restart
                && other.primitive_topology_list_restart)
            || (self.primitive_topology_patch_list_restart
                && other.primitive_topology_patch_list_restart)
            || (self.primitives_generated_query && other.primitives_generated_query)
            || (self.primitives_generated_query_with_non_zero_streams
                && other.primitives_generated_query_with_non_zero_streams)
            || (self.primitives_generated_query_with_rasterizer_discard
                && other.primitives_generated_query_with_rasterizer_discard)
            || (self.private_data && other.private_data)
            || (self.protected_memory && other.protected_memory)
            || (self.provoking_vertex_last && other.provoking_vertex_last)
            || (self.rasterization_order_color_attachment_access
                && other.rasterization_order_color_attachment_access)
            || (self.rasterization_order_depth_attachment_access
                && other.rasterization_order_depth_attachment_access)
            || (self.rasterization_order_stencil_attachment_access
                && other.rasterization_order_stencil_attachment_access)
            || (self.ray_query && other.ray_query)
            || (self.ray_tracing_invocation_reorder
                && other.ray_tracing_invocation_reorder)
            || (self.ray_tracing_maintenance1 && other.ray_tracing_maintenance1)
            || (self.ray_tracing_motion_blur && other.ray_tracing_motion_blur)
            || (self.ray_tracing_motion_blur_pipeline_trace_rays_indirect
                && other.ray_tracing_motion_blur_pipeline_trace_rays_indirect)
            || (self.ray_tracing_pipeline && other.ray_tracing_pipeline)
            || (self.ray_tracing_pipeline_shader_group_handle_capture_replay
                && other.ray_tracing_pipeline_shader_group_handle_capture_replay)
            || (self.ray_tracing_pipeline_shader_group_handle_capture_replay_mixed
                && other.ray_tracing_pipeline_shader_group_handle_capture_replay_mixed)
            || (self.ray_tracing_pipeline_trace_rays_indirect
                && other.ray_tracing_pipeline_trace_rays_indirect)
            || (self.ray_tracing_pipeline_trace_rays_indirect2
                && other.ray_tracing_pipeline_trace_rays_indirect2)
            || (self.ray_tracing_position_fetch && other.ray_tracing_position_fetch)
            || (self.ray_tracing_validation && other.ray_tracing_validation)
            || (self.ray_traversal_primitive_culling
                && other.ray_traversal_primitive_culling)
            || (self.rectangular_lines && other.rectangular_lines)
            || (self.relaxed_line_rasterization && other.relaxed_line_rasterization)
            || (self.render_pass_striped && other.render_pass_striped)
            || (self.report_address_binding && other.report_address_binding)
            || (self.representative_fragment_test && other.representative_fragment_test)
            || (self.robust_buffer_access && other.robust_buffer_access)
            || (self.robust_buffer_access2 && other.robust_buffer_access2)
            || (self.robust_image_access && other.robust_image_access)
            || (self.robust_image_access2 && other.robust_image_access2)
            || (self.runtime_descriptor_array && other.runtime_descriptor_array)
            || (self.sample_rate_shading && other.sample_rate_shading)
            || (self.sampler2_d_view_of3_d && other.sampler2_d_view_of3_d)
            || (self.sampler_anisotropy && other.sampler_anisotropy)
            || (self.sampler_filter_minmax && other.sampler_filter_minmax)
            || (self.sampler_mip_lod_bias && other.sampler_mip_lod_bias)
            || (self.sampler_mirror_clamp_to_edge && other.sampler_mirror_clamp_to_edge)
            || (self.sampler_ycbcr_conversion && other.sampler_ycbcr_conversion)
            || (self.scalar_block_layout && other.scalar_block_layout)
            || (self.scheduling_controls && other.scheduling_controls)
            || (self.screen_buffer_import && other.screen_buffer_import)
            || (self.selectable_cubic_weights && other.selectable_cubic_weights)
            || (self.separate_depth_stencil_layouts
                && other.separate_depth_stencil_layouts)
            || (self.separate_stencil_mask_ref && other.separate_stencil_mask_ref)
            || (self.shader_buffer_float16_atomic_add
                && other.shader_buffer_float16_atomic_add)
            || (self.shader_buffer_float16_atomic_min_max
                && other.shader_buffer_float16_atomic_min_max)
            || (self.shader_buffer_float16_atomics
                && other.shader_buffer_float16_atomics)
            || (self.shader_buffer_float32_atomic_add
                && other.shader_buffer_float32_atomic_add)
            || (self.shader_buffer_float32_atomic_min_max
                && other.shader_buffer_float32_atomic_min_max)
            || (self.shader_buffer_float32_atomics
                && other.shader_buffer_float32_atomics)
            || (self.shader_buffer_float64_atomic_add
                && other.shader_buffer_float64_atomic_add)
            || (self.shader_buffer_float64_atomic_min_max
                && other.shader_buffer_float64_atomic_min_max)
            || (self.shader_buffer_float64_atomics
                && other.shader_buffer_float64_atomics)
            || (self.shader_buffer_int64_atomics && other.shader_buffer_int64_atomics)
            || (self.shader_clip_distance && other.shader_clip_distance)
            || (self.shader_core_builtins && other.shader_core_builtins)
            || (self.shader_cull_distance && other.shader_cull_distance)
            || (self.shader_demote_to_helper_invocation
                && other.shader_demote_to_helper_invocation)
            || (self.shader_device_clock && other.shader_device_clock)
            || (self.shader_draw_parameters && other.shader_draw_parameters)
            || (self.shader_early_and_late_fragment_tests
                && other.shader_early_and_late_fragment_tests)
            || (self.shader_enqueue && other.shader_enqueue)
            || (self.shader_expect_assume && other.shader_expect_assume)
            || (self.shader_float16 && other.shader_float16)
            || (self.shader_float16_vector_atomics
                && other.shader_float16_vector_atomics)
            || (self.shader_float64 && other.shader_float64)
            || (self.shader_float_controls2 && other.shader_float_controls2)
            || (self.shader_image_float32_atomic_add
                && other.shader_image_float32_atomic_add)
            || (self.shader_image_float32_atomic_min_max
                && other.shader_image_float32_atomic_min_max)
            || (self.shader_image_float32_atomics && other.shader_image_float32_atomics)
            || (self.shader_image_gather_extended && other.shader_image_gather_extended)
            || (self.shader_image_int64_atomics && other.shader_image_int64_atomics)
            || (self.shader_input_attachment_array_dynamic_indexing
                && other.shader_input_attachment_array_dynamic_indexing)
            || (self.shader_input_attachment_array_non_uniform_indexing
                && other.shader_input_attachment_array_non_uniform_indexing)
            || (self.shader_int16 && other.shader_int16)
            || (self.shader_int64 && other.shader_int64)
            || (self.shader_int8 && other.shader_int8)
            || (self.shader_integer_dot_product && other.shader_integer_dot_product)
            || (self.shader_integer_functions2 && other.shader_integer_functions2)
            || (self.shader_maximal_reconvergence && other.shader_maximal_reconvergence)
            || (self.shader_module_identifier && other.shader_module_identifier)
            || (self.shader_object && other.shader_object)
            || (self.shader_output_layer && other.shader_output_layer)
            || (self.shader_output_viewport_index && other.shader_output_viewport_index)
            || (self.shader_quad_control && other.shader_quad_control)
            || (self.shader_raw_access_chains && other.shader_raw_access_chains)
            || (self.shader_resource_min_lod && other.shader_resource_min_lod)
            || (self.shader_resource_residency && other.shader_resource_residency)
            || (self.shader_sample_rate_interpolation_functions
                && other.shader_sample_rate_interpolation_functions)
            || (self.shader_sampled_image_array_dynamic_indexing
                && other.shader_sampled_image_array_dynamic_indexing)
            || (self.shader_sampled_image_array_non_uniform_indexing
                && other.shader_sampled_image_array_non_uniform_indexing)
            || (self.shader_shared_float16_atomic_add
                && other.shader_shared_float16_atomic_add)
            || (self.shader_shared_float16_atomic_min_max
                && other.shader_shared_float16_atomic_min_max)
            || (self.shader_shared_float16_atomics
                && other.shader_shared_float16_atomics)
            || (self.shader_shared_float32_atomic_add
                && other.shader_shared_float32_atomic_add)
            || (self.shader_shared_float32_atomic_min_max
                && other.shader_shared_float32_atomic_min_max)
            || (self.shader_shared_float32_atomics
                && other.shader_shared_float32_atomics)
            || (self.shader_shared_float64_atomic_add
                && other.shader_shared_float64_atomic_add)
            || (self.shader_shared_float64_atomic_min_max
                && other.shader_shared_float64_atomic_min_max)
            || (self.shader_shared_float64_atomics
                && other.shader_shared_float64_atomics)
            || (self.shader_shared_int64_atomics && other.shader_shared_int64_atomics)
            || (self.shader_sm_builtins && other.shader_sm_builtins)
            || (self.shader_storage_buffer_array_dynamic_indexing
                && other.shader_storage_buffer_array_dynamic_indexing)
            || (self.shader_storage_buffer_array_non_uniform_indexing
                && other.shader_storage_buffer_array_non_uniform_indexing)
            || (self.shader_storage_image_array_dynamic_indexing
                && other.shader_storage_image_array_dynamic_indexing)
            || (self.shader_storage_image_array_non_uniform_indexing
                && other.shader_storage_image_array_non_uniform_indexing)
            || (self.shader_storage_image_extended_formats
                && other.shader_storage_image_extended_formats)
            || (self.shader_storage_image_multisample
                && other.shader_storage_image_multisample)
            || (self.shader_storage_image_read_without_format
                && other.shader_storage_image_read_without_format)
            || (self.shader_storage_image_write_without_format
                && other.shader_storage_image_write_without_format)
            || (self.shader_storage_texel_buffer_array_dynamic_indexing
                && other.shader_storage_texel_buffer_array_dynamic_indexing)
            || (self.shader_storage_texel_buffer_array_non_uniform_indexing
                && other.shader_storage_texel_buffer_array_non_uniform_indexing)
            || (self.shader_subgroup_clock && other.shader_subgroup_clock)
            || (self.shader_subgroup_extended_types
                && other.shader_subgroup_extended_types)
            || (self.shader_subgroup_rotate && other.shader_subgroup_rotate)
            || (self.shader_subgroup_rotate_clustered
                && other.shader_subgroup_rotate_clustered)
            || (self.shader_subgroup_uniform_control_flow
                && other.shader_subgroup_uniform_control_flow)
            || (self.shader_terminate_invocation && other.shader_terminate_invocation)
            || (self.shader_tessellation_and_geometry_point_size
                && other.shader_tessellation_and_geometry_point_size)
            || (self.shader_tile_image_color_read_access
                && other.shader_tile_image_color_read_access)
            || (self.shader_tile_image_depth_read_access
                && other.shader_tile_image_depth_read_access)
            || (self.shader_tile_image_stencil_read_access
                && other.shader_tile_image_stencil_read_access)
            || (self.shader_uniform_buffer_array_dynamic_indexing
                && other.shader_uniform_buffer_array_dynamic_indexing)
            || (self.shader_uniform_buffer_array_non_uniform_indexing
                && other.shader_uniform_buffer_array_non_uniform_indexing)
            || (self.shader_uniform_texel_buffer_array_dynamic_indexing
                && other.shader_uniform_texel_buffer_array_dynamic_indexing)
            || (self.shader_uniform_texel_buffer_array_non_uniform_indexing
                && other.shader_uniform_texel_buffer_array_non_uniform_indexing)
            || (self.shader_zero_initialize_workgroup_memory
                && other.shader_zero_initialize_workgroup_memory)
            || (self.shading_rate_coarse_sample_order
                && other.shading_rate_coarse_sample_order)
            || (self.shading_rate_image && other.shading_rate_image)
            || (self.smooth_lines && other.smooth_lines)
            || (self.sparse_binding && other.sparse_binding)
            || (self.sparse_image_float32_atomic_add
                && other.sparse_image_float32_atomic_add)
            || (self.sparse_image_float32_atomic_min_max
                && other.sparse_image_float32_atomic_min_max)
            || (self.sparse_image_float32_atomics && other.sparse_image_float32_atomics)
            || (self.sparse_image_int64_atomics && other.sparse_image_int64_atomics)
            || (self.sparse_residency16_samples && other.sparse_residency16_samples)
            || (self.sparse_residency2_samples && other.sparse_residency2_samples)
            || (self.sparse_residency4_samples && other.sparse_residency4_samples)
            || (self.sparse_residency8_samples && other.sparse_residency8_samples)
            || (self.sparse_residency_aliased && other.sparse_residency_aliased)
            || (self.sparse_residency_buffer && other.sparse_residency_buffer)
            || (self.sparse_residency_image2_d && other.sparse_residency_image2_d)
            || (self.sparse_residency_image3_d && other.sparse_residency_image3_d)
            || (self.stippled_bresenham_lines && other.stippled_bresenham_lines)
            || (self.stippled_rectangular_lines && other.stippled_rectangular_lines)
            || (self.stippled_smooth_lines && other.stippled_smooth_lines)
            || (self.storage_buffer16_bit_access && other.storage_buffer16_bit_access)
            || (self.storage_buffer8_bit_access && other.storage_buffer8_bit_access)
            || (self.storage_input_output16 && other.storage_input_output16)
            || (self.storage_push_constant16 && other.storage_push_constant16)
            || (self.storage_push_constant8 && other.storage_push_constant8)
            || (self.subgroup_broadcast_dynamic_id
                && other.subgroup_broadcast_dynamic_id)
            || (self.subgroup_size_control && other.subgroup_size_control)
            || (self.subpass_merge_feedback && other.subpass_merge_feedback)
            || (self.subpass_shading && other.subpass_shading)
            || (self.supersample_fragment_shading_rates
                && other.supersample_fragment_shading_rates)
            || (self.swapchain_maintenance1 && other.swapchain_maintenance1)
            || (self.synchronization2 && other.synchronization2)
            || (self.task_shader && other.task_shader)
            || (self.tessellation_isolines && other.tessellation_isolines)
            || (self.tessellation_point_mode && other.tessellation_point_mode)
            || (self.tessellation_shader && other.tessellation_shader)
            || (self.texel_buffer_alignment && other.texel_buffer_alignment)
            || (self.texture_block_match && other.texture_block_match)
            || (self.texture_block_match2 && other.texture_block_match2)
            || (self.texture_box_filter && other.texture_box_filter)
            || (self.texture_compression_astc_hdr && other.texture_compression_astc_hdr)
            || (self.texture_compression_astc_ldr && other.texture_compression_astc_ldr)
            || (self.texture_compression_bc && other.texture_compression_bc)
            || (self.texture_compression_etc2 && other.texture_compression_etc2)
            || (self.texture_sample_weighted && other.texture_sample_weighted)
            || (self.tile_properties && other.tile_properties)
            || (self.timeline_semaphore && other.timeline_semaphore)
            || (self.transform_feedback && other.transform_feedback)
            || (self.transform_feedback_preserves_provoking_vertex
                && other.transform_feedback_preserves_provoking_vertex)
            || (self.triangle_fans && other.triangle_fans)
            || (self.uniform_and_storage_buffer16_bit_access
                && other.uniform_and_storage_buffer16_bit_access)
            || (self.uniform_and_storage_buffer8_bit_access
                && other.uniform_and_storage_buffer8_bit_access)
            || (self.uniform_buffer_standard_layout
                && other.uniform_buffer_standard_layout)
            || (self.variable_multisample_rate && other.variable_multisample_rate)
            || (self.variable_pointers && other.variable_pointers)
            || (self.variable_pointers_storage_buffer
                && other.variable_pointers_storage_buffer)
            || (self.vertex_attribute_access_beyond_stride
                && other.vertex_attribute_access_beyond_stride)
            || (self.vertex_attribute_instance_rate_divisor
                && other.vertex_attribute_instance_rate_divisor)
            || (self.vertex_attribute_instance_rate_zero_divisor
                && other.vertex_attribute_instance_rate_zero_divisor)
            || (self.vertex_input_dynamic_state && other.vertex_input_dynamic_state)
            || (self.vertex_pipeline_stores_and_atomics
                && other.vertex_pipeline_stores_and_atomics)
            || (self.video_maintenance1 && other.video_maintenance1)
            || (self.vulkan_memory_model && other.vulkan_memory_model)
            || (self.vulkan_memory_model_availability_visibility_chains
                && other.vulkan_memory_model_availability_visibility_chains)
            || (self.vulkan_memory_model_device_scope
                && other.vulkan_memory_model_device_scope)
            || (self.wide_lines && other.wide_lines)
            || (self.workgroup_memory_explicit_layout
                && other.workgroup_memory_explicit_layout)
            || (self.workgroup_memory_explicit_layout16_bit_access
                && other.workgroup_memory_explicit_layout16_bit_access)
            || (self.workgroup_memory_explicit_layout8_bit_access
                && other.workgroup_memory_explicit_layout8_bit_access)
            || (self.workgroup_memory_explicit_layout_scalar_block_layout
                && other.workgroup_memory_explicit_layout_scalar_block_layout)
            || (self.ycbcr2plane444_formats && other.ycbcr2plane444_formats)
            || (self.ycbcr_degamma && other.ycbcr_degamma)
            || (self.ycbcr_image_arrays && other.ycbcr_image_arrays)
    }
    /// Returns whether all members in `other` are set in `self`.
    #[inline]
    pub const fn contains(&self, other: &Self) -> bool {
        (self.acceleration_structure || !other.acceleration_structure)
            && (self.acceleration_structure_capture_replay
                || !other.acceleration_structure_capture_replay)
            && (self.acceleration_structure_host_commands
                || !other.acceleration_structure_host_commands)
            && (self.acceleration_structure_indirect_build
                || !other.acceleration_structure_indirect_build)
            && (self.advanced_blend_coherent_operations
                || !other.advanced_blend_coherent_operations)
            && (self.alpha_to_one || !other.alpha_to_one)
            && (self.amigo_profiling || !other.amigo_profiling)
            && (self.attachment_feedback_loop_dynamic_state
                || !other.attachment_feedback_loop_dynamic_state)
            && (self.attachment_feedback_loop_layout
                || !other.attachment_feedback_loop_layout)
            && (self.attachment_fragment_shading_rate
                || !other.attachment_fragment_shading_rate)
            && (self.border_color_swizzle || !other.border_color_swizzle)
            && (self.border_color_swizzle_from_image
                || !other.border_color_swizzle_from_image)
            && (self.bresenham_lines || !other.bresenham_lines)
            && (self.buffer_device_address || !other.buffer_device_address)
            && (self.buffer_device_address_capture_replay
                || !other.buffer_device_address_capture_replay)
            && (self.buffer_device_address_multi_device
                || !other.buffer_device_address_multi_device)
            && (self.clusterculling_shader || !other.clusterculling_shader)
            && (self.color_write_enable || !other.color_write_enable)
            && (self.compute_derivative_group_linear
                || !other.compute_derivative_group_linear)
            && (self.compute_derivative_group_quads
                || !other.compute_derivative_group_quads)
            && (self.compute_full_subgroups || !other.compute_full_subgroups)
            && (self.conditional_rendering || !other.conditional_rendering)
            && (self.constant_alpha_color_blend_factors
                || !other.constant_alpha_color_blend_factors)
            && (self.cooperative_matrix || !other.cooperative_matrix)
            && (self.cooperative_matrix_robust_buffer_access
                || !other.cooperative_matrix_robust_buffer_access)
            && (self.corner_sampled_image || !other.corner_sampled_image)
            && (self.coverage_reduction_mode || !other.coverage_reduction_mode)
            && (self.cubic_range_clamp || !other.cubic_range_clamp)
            && (self.cuda_kernel_launch_features || !other.cuda_kernel_launch_features)
            && (self.custom_border_color_without_format
                || !other.custom_border_color_without_format)
            && (self.custom_border_colors || !other.custom_border_colors)
            && (self.decode_mode_shared_exponent || !other.decode_mode_shared_exponent)
            && (self.dedicated_allocation_image_aliasing
                || !other.dedicated_allocation_image_aliasing)
            && (self.depth_bias_clamp || !other.depth_bias_clamp)
            && (self.depth_bias_control || !other.depth_bias_control)
            && (self.depth_bias_exact || !other.depth_bias_exact)
            && (self.depth_bounds || !other.depth_bounds)
            && (self.depth_clamp || !other.depth_clamp)
            && (self.depth_clamp_zero_one || !other.depth_clamp_zero_one)
            && (self.depth_clip_control || !other.depth_clip_control)
            && (self.depth_clip_enable || !other.depth_clip_enable)
            && (self.descriptor_binding_acceleration_structure_update_after_bind
                || !other.descriptor_binding_acceleration_structure_update_after_bind)
            && (self.descriptor_binding_inline_uniform_block_update_after_bind
                || !other.descriptor_binding_inline_uniform_block_update_after_bind)
            && (self.descriptor_binding_partially_bound
                || !other.descriptor_binding_partially_bound)
            && (self.descriptor_binding_sampled_image_update_after_bind
                || !other.descriptor_binding_sampled_image_update_after_bind)
            && (self.descriptor_binding_storage_buffer_update_after_bind
                || !other.descriptor_binding_storage_buffer_update_after_bind)
            && (self.descriptor_binding_storage_image_update_after_bind
                || !other.descriptor_binding_storage_image_update_after_bind)
            && (self.descriptor_binding_storage_texel_buffer_update_after_bind
                || !other.descriptor_binding_storage_texel_buffer_update_after_bind)
            && (self.descriptor_binding_uniform_buffer_update_after_bind
                || !other.descriptor_binding_uniform_buffer_update_after_bind)
            && (self.descriptor_binding_uniform_texel_buffer_update_after_bind
                || !other.descriptor_binding_uniform_texel_buffer_update_after_bind)
            && (self.descriptor_binding_update_unused_while_pending
                || !other.descriptor_binding_update_unused_while_pending)
            && (self.descriptor_binding_variable_descriptor_count
                || !other.descriptor_binding_variable_descriptor_count)
            && (self.descriptor_buffer || !other.descriptor_buffer)
            && (self.descriptor_buffer_capture_replay
                || !other.descriptor_buffer_capture_replay)
            && (self.descriptor_buffer_image_layout_ignored
                || !other.descriptor_buffer_image_layout_ignored)
            && (self.descriptor_buffer_push_descriptors
                || !other.descriptor_buffer_push_descriptors)
            && (self.descriptor_indexing || !other.descriptor_indexing)
            && (self.descriptor_pool_overallocation
                || !other.descriptor_pool_overallocation)
            && (self.descriptor_set_host_mapping || !other.descriptor_set_host_mapping)
            && (self.device_coherent_memory || !other.device_coherent_memory)
            && (self.device_fault || !other.device_fault)
            && (self.device_fault_vendor_binary || !other.device_fault_vendor_binary)
            && (self.device_generated_commands || !other.device_generated_commands)
            && (self.device_generated_compute || !other.device_generated_compute)
            && (self.device_generated_compute_capture_replay
                || !other.device_generated_compute_capture_replay)
            && (self.device_generated_compute_pipelines
                || !other.device_generated_compute_pipelines)
            && (self.device_memory_report || !other.device_memory_report)
            && (self.diagnostics_config || !other.diagnostics_config)
            && (self.displacement_micromap || !other.displacement_micromap)
            && (self.draw_indirect_count || !other.draw_indirect_count)
            && (self.draw_indirect_first_instance || !other.draw_indirect_first_instance)
            && (self.dual_src_blend || !other.dual_src_blend)
            && (self.dynamic_pipeline_layout || !other.dynamic_pipeline_layout)
            && (self.dynamic_rendering || !other.dynamic_rendering)
            && (self.dynamic_rendering_local_read || !other.dynamic_rendering_local_read)
            && (self.dynamic_rendering_unused_attachments
                || !other.dynamic_rendering_unused_attachments)
            && (self.events || !other.events)
            && (self.exclusive_scissor || !other.exclusive_scissor)
            && (self.extended_dynamic_state || !other.extended_dynamic_state)
            && (self.extended_dynamic_state2 || !other.extended_dynamic_state2)
            && (self.extended_dynamic_state2_logic_op
                || !other.extended_dynamic_state2_logic_op)
            && (self.extended_dynamic_state2_patch_control_points
                || !other.extended_dynamic_state2_patch_control_points)
            && (self.extended_dynamic_state3_alpha_to_coverage_enable
                || !other.extended_dynamic_state3_alpha_to_coverage_enable)
            && (self.extended_dynamic_state3_alpha_to_one_enable
                || !other.extended_dynamic_state3_alpha_to_one_enable)
            && (self.extended_dynamic_state3_color_blend_advanced
                || !other.extended_dynamic_state3_color_blend_advanced)
            && (self.extended_dynamic_state3_color_blend_enable
                || !other.extended_dynamic_state3_color_blend_enable)
            && (self.extended_dynamic_state3_color_blend_equation
                || !other.extended_dynamic_state3_color_blend_equation)
            && (self.extended_dynamic_state3_color_write_mask
                || !other.extended_dynamic_state3_color_write_mask)
            && (self.extended_dynamic_state3_conservative_rasterization_mode
                || !other.extended_dynamic_state3_conservative_rasterization_mode)
            && (self.extended_dynamic_state3_coverage_modulation_mode
                || !other.extended_dynamic_state3_coverage_modulation_mode)
            && (self.extended_dynamic_state3_coverage_modulation_table
                || !other.extended_dynamic_state3_coverage_modulation_table)
            && (self.extended_dynamic_state3_coverage_modulation_table_enable
                || !other.extended_dynamic_state3_coverage_modulation_table_enable)
            && (self.extended_dynamic_state3_coverage_reduction_mode
                || !other.extended_dynamic_state3_coverage_reduction_mode)
            && (self.extended_dynamic_state3_coverage_to_color_enable
                || !other.extended_dynamic_state3_coverage_to_color_enable)
            && (self.extended_dynamic_state3_coverage_to_color_location
                || !other.extended_dynamic_state3_coverage_to_color_location)
            && (self.extended_dynamic_state3_depth_clamp_enable
                || !other.extended_dynamic_state3_depth_clamp_enable)
            && (self.extended_dynamic_state3_depth_clip_enable
                || !other.extended_dynamic_state3_depth_clip_enable)
            && (self.extended_dynamic_state3_depth_clip_negative_one_to_one
                || !other.extended_dynamic_state3_depth_clip_negative_one_to_one)
            && (self.extended_dynamic_state3_extra_primitive_overestimation_size
                || !other.extended_dynamic_state3_extra_primitive_overestimation_size)
            && (self.extended_dynamic_state3_line_rasterization_mode
                || !other.extended_dynamic_state3_line_rasterization_mode)
            && (self.extended_dynamic_state3_line_stipple_enable
                || !other.extended_dynamic_state3_line_stipple_enable)
            && (self.extended_dynamic_state3_logic_op_enable
                || !other.extended_dynamic_state3_logic_op_enable)
            && (self.extended_dynamic_state3_polygon_mode
                || !other.extended_dynamic_state3_polygon_mode)
            && (self.extended_dynamic_state3_provoking_vertex_mode
                || !other.extended_dynamic_state3_provoking_vertex_mode)
            && (self.extended_dynamic_state3_rasterization_samples
                || !other.extended_dynamic_state3_rasterization_samples)
            && (self.extended_dynamic_state3_rasterization_stream
                || !other.extended_dynamic_state3_rasterization_stream)
            && (self.extended_dynamic_state3_representative_fragment_test_enable
                || !other.extended_dynamic_state3_representative_fragment_test_enable)
            && (self.extended_dynamic_state3_sample_locations_enable
                || !other.extended_dynamic_state3_sample_locations_enable)
            && (self.extended_dynamic_state3_sample_mask
                || !other.extended_dynamic_state3_sample_mask)
            && (self.extended_dynamic_state3_shading_rate_image_enable
                || !other.extended_dynamic_state3_shading_rate_image_enable)
            && (self.extended_dynamic_state3_tessellation_domain_origin
                || !other.extended_dynamic_state3_tessellation_domain_origin)
            && (self.extended_dynamic_state3_viewport_swizzle
                || !other.extended_dynamic_state3_viewport_swizzle)
            && (self.extended_dynamic_state3_viewport_w_scaling_enable
                || !other.extended_dynamic_state3_viewport_w_scaling_enable)
            && (self.extended_sparse_address_space
                || !other.extended_sparse_address_space)
            && (self.external_format_resolve || !other.external_format_resolve)
            && (self.external_memory_rdma || !other.external_memory_rdma)
            && (self.fill_mode_non_solid || !other.fill_mode_non_solid)
            && (self.float_representation || !other.float_representation)
            && (self.format_a4b4g4r4 || !other.format_a4b4g4r4)
            && (self.format_a4r4g4b4 || !other.format_a4r4g4b4)
            && (self.format_rgba10x6_without_y_cb_cr_sampler
                || !other.format_rgba10x6_without_y_cb_cr_sampler)
            && (self.fragment_density_map || !other.fragment_density_map)
            && (self.fragment_density_map_deferred
                || !other.fragment_density_map_deferred)
            && (self.fragment_density_map_dynamic || !other.fragment_density_map_dynamic)
            && (self.fragment_density_map_non_subsampled_images
                || !other.fragment_density_map_non_subsampled_images)
            && (self.fragment_density_map_offset || !other.fragment_density_map_offset)
            && (self.fragment_shader_barycentric || !other.fragment_shader_barycentric)
            && (self.fragment_shader_pixel_interlock
                || !other.fragment_shader_pixel_interlock)
            && (self.fragment_shader_sample_interlock
                || !other.fragment_shader_sample_interlock)
            && (self.fragment_shader_shading_rate_interlock
                || !other.fragment_shader_shading_rate_interlock)
            && (self.fragment_shading_rate_enums || !other.fragment_shading_rate_enums)
            && (self.fragment_stores_and_atomics || !other.fragment_stores_and_atomics)
            && (self.frame_boundary || !other.frame_boundary)
            && (self.full_draw_index_uint32 || !other.full_draw_index_uint32)
            && (self.geometry_shader || !other.geometry_shader)
            && (self.geometry_streams || !other.geometry_streams)
            && (self.global_priority_query || !other.global_priority_query)
            && (self.graphics_pipeline_library || !other.graphics_pipeline_library)
            && (self.host_image_copy || !other.host_image_copy)
            && (self.host_query_reset || !other.host_query_reset)
            && (self.image2_d_view_of3_d || !other.image2_d_view_of3_d)
            && (self.image_compression_control || !other.image_compression_control)
            && (self.image_compression_control_swapchain
                || !other.image_compression_control_swapchain)
            && (self.image_cube_array || !other.image_cube_array)
            && (self.image_footprint || !other.image_footprint)
            && (self.image_sliced_view_of3_d || !other.image_sliced_view_of3_d)
            && (self.image_view2_d_on3_d_image || !other.image_view2_d_on3_d_image)
            && (self.image_view_format_reinterpretation
                || !other.image_view_format_reinterpretation)
            && (self.image_view_format_swizzle || !other.image_view_format_swizzle)
            && (self.imageless_framebuffer || !other.imageless_framebuffer)
            && (self.independent_blend || !other.independent_blend)
            && (self.index_type_uint8 || !other.index_type_uint8)
            && (self.indirect_copy || !other.indirect_copy)
            && (self.inherited_conditional_rendering
                || !other.inherited_conditional_rendering)
            && (self.inherited_queries || !other.inherited_queries)
            && (self.inherited_viewport_scissor2_d
                || !other.inherited_viewport_scissor2_d)
            && (self.inline_uniform_block || !other.inline_uniform_block)
            && (self.invocation_mask || !other.invocation_mask)
            && (self.large_points || !other.large_points)
            && (self.least_representable_value_force_unorm_representation
                || !other.least_representable_value_force_unorm_representation)
            && (self.legacy_dithering || !other.legacy_dithering)
            && (self.linear_color_attachment || !other.linear_color_attachment)
            && (self.logic_op || !other.logic_op)
            && (self.maintenance4 || !other.maintenance4)
            && (self.maintenance5 || !other.maintenance5)
            && (self.maintenance6 || !other.maintenance6)
            && (self.memory_decompression || !other.memory_decompression)
            && (self.memory_map_placed || !other.memory_map_placed)
            && (self.memory_map_range_placed || !other.memory_map_range_placed)
            && (self.memory_priority || !other.memory_priority)
            && (self.memory_unmap_reserve || !other.memory_unmap_reserve)
            && (self.mesh_shader || !other.mesh_shader)
            && (self.mesh_shader_queries || !other.mesh_shader_queries)
            && (self.micromap || !other.micromap)
            && (self.micromap_capture_replay || !other.micromap_capture_replay)
            && (self.micromap_host_commands || !other.micromap_host_commands)
            && (self.min_lod || !other.min_lod) && (self.multi_draw || !other.multi_draw)
            && (self.multi_draw_indirect || !other.multi_draw_indirect)
            && (self.multi_viewport || !other.multi_viewport)
            && (self.multisample_array_image || !other.multisample_array_image)
            && (self.multisampled_render_to_single_sampled
                || !other.multisampled_render_to_single_sampled)
            && (self.multiview || !other.multiview)
            && (self.multiview_cluster_culling_shader
                || !other.multiview_cluster_culling_shader)
            && (self.multiview_geometry_shader || !other.multiview_geometry_shader)
            && (self.multiview_mesh_shader || !other.multiview_mesh_shader)
            && (self.multiview_per_view_render_areas
                || !other.multiview_per_view_render_areas)
            && (self.multiview_per_view_viewports || !other.multiview_per_view_viewports)
            && (self.multiview_tessellation_shader
                || !other.multiview_tessellation_shader)
            && (self.mutable_comparison_samplers || !other.mutable_comparison_samplers)
            && (self.mutable_descriptor_type || !other.mutable_descriptor_type)
            && (self.nested_command_buffer || !other.nested_command_buffer)
            && (self.nested_command_buffer_rendering
                || !other.nested_command_buffer_rendering)
            && (self.nested_command_buffer_simultaneous_use
                || !other.nested_command_buffer_simultaneous_use)
            && (self.no_invocation_fragment_shading_rates
                || !other.no_invocation_fragment_shading_rates)
            && (self.non_seamless_cube_map || !other.non_seamless_cube_map)
            && (self.null_descriptor || !other.null_descriptor)
            && (self.occlusion_query_precise || !other.occlusion_query_precise)
            && (self.optical_flow || !other.optical_flow)
            && (self.pageable_device_local_memory || !other.pageable_device_local_memory)
            && (self.per_stage_descriptor_set || !other.per_stage_descriptor_set)
            && (self.performance_counter_multiple_query_pools
                || !other.performance_counter_multiple_query_pools)
            && (self.performance_counter_query_pools
                || !other.performance_counter_query_pools)
            && (self.pipeline_creation_cache_control
                || !other.pipeline_creation_cache_control)
            && (self.pipeline_executable_info || !other.pipeline_executable_info)
            && (self.pipeline_fragment_shading_rate
                || !other.pipeline_fragment_shading_rate)
            && (self.pipeline_library_group_handles
                || !other.pipeline_library_group_handles)
            && (self.pipeline_properties_identifier
                || !other.pipeline_properties_identifier)
            && (self.pipeline_protected_access || !other.pipeline_protected_access)
            && (self.pipeline_robustness || !other.pipeline_robustness)
            && (self.pipeline_statistics_query || !other.pipeline_statistics_query)
            && (self.point_polygons || !other.point_polygons)
            && (self.present_barrier || !other.present_barrier)
            && (self.present_id || !other.present_id)
            && (self.present_wait || !other.present_wait)
            && (self.primitive_fragment_shading_rate
                || !other.primitive_fragment_shading_rate)
            && (self.primitive_fragment_shading_rate_mesh_shader
                || !other.primitive_fragment_shading_rate_mesh_shader)
            && (self.primitive_topology_list_restart
                || !other.primitive_topology_list_restart)
            && (self.primitive_topology_patch_list_restart
                || !other.primitive_topology_patch_list_restart)
            && (self.primitives_generated_query || !other.primitives_generated_query)
            && (self.primitives_generated_query_with_non_zero_streams
                || !other.primitives_generated_query_with_non_zero_streams)
            && (self.primitives_generated_query_with_rasterizer_discard
                || !other.primitives_generated_query_with_rasterizer_discard)
            && (self.private_data || !other.private_data)
            && (self.protected_memory || !other.protected_memory)
            && (self.provoking_vertex_last || !other.provoking_vertex_last)
            && (self.rasterization_order_color_attachment_access
                || !other.rasterization_order_color_attachment_access)
            && (self.rasterization_order_depth_attachment_access
                || !other.rasterization_order_depth_attachment_access)
            && (self.rasterization_order_stencil_attachment_access
                || !other.rasterization_order_stencil_attachment_access)
            && (self.ray_query || !other.ray_query)
            && (self.ray_tracing_invocation_reorder
                || !other.ray_tracing_invocation_reorder)
            && (self.ray_tracing_maintenance1 || !other.ray_tracing_maintenance1)
            && (self.ray_tracing_motion_blur || !other.ray_tracing_motion_blur)
            && (self.ray_tracing_motion_blur_pipeline_trace_rays_indirect
                || !other.ray_tracing_motion_blur_pipeline_trace_rays_indirect)
            && (self.ray_tracing_pipeline || !other.ray_tracing_pipeline)
            && (self.ray_tracing_pipeline_shader_group_handle_capture_replay
                || !other.ray_tracing_pipeline_shader_group_handle_capture_replay)
            && (self.ray_tracing_pipeline_shader_group_handle_capture_replay_mixed
                || !other.ray_tracing_pipeline_shader_group_handle_capture_replay_mixed)
            && (self.ray_tracing_pipeline_trace_rays_indirect
                || !other.ray_tracing_pipeline_trace_rays_indirect)
            && (self.ray_tracing_pipeline_trace_rays_indirect2
                || !other.ray_tracing_pipeline_trace_rays_indirect2)
            && (self.ray_tracing_position_fetch || !other.ray_tracing_position_fetch)
            && (self.ray_tracing_validation || !other.ray_tracing_validation)
            && (self.ray_traversal_primitive_culling
                || !other.ray_traversal_primitive_culling)
            && (self.rectangular_lines || !other.rectangular_lines)
            && (self.relaxed_line_rasterization || !other.relaxed_line_rasterization)
            && (self.render_pass_striped || !other.render_pass_striped)
            && (self.report_address_binding || !other.report_address_binding)
            && (self.representative_fragment_test || !other.representative_fragment_test)
            && (self.robust_buffer_access || !other.robust_buffer_access)
            && (self.robust_buffer_access2 || !other.robust_buffer_access2)
            && (self.robust_image_access || !other.robust_image_access)
            && (self.robust_image_access2 || !other.robust_image_access2)
            && (self.runtime_descriptor_array || !other.runtime_descriptor_array)
            && (self.sample_rate_shading || !other.sample_rate_shading)
            && (self.sampler2_d_view_of3_d || !other.sampler2_d_view_of3_d)
            && (self.sampler_anisotropy || !other.sampler_anisotropy)
            && (self.sampler_filter_minmax || !other.sampler_filter_minmax)
            && (self.sampler_mip_lod_bias || !other.sampler_mip_lod_bias)
            && (self.sampler_mirror_clamp_to_edge || !other.sampler_mirror_clamp_to_edge)
            && (self.sampler_ycbcr_conversion || !other.sampler_ycbcr_conversion)
            && (self.scalar_block_layout || !other.scalar_block_layout)
            && (self.scheduling_controls || !other.scheduling_controls)
            && (self.screen_buffer_import || !other.screen_buffer_import)
            && (self.selectable_cubic_weights || !other.selectable_cubic_weights)
            && (self.separate_depth_stencil_layouts
                || !other.separate_depth_stencil_layouts)
            && (self.separate_stencil_mask_ref || !other.separate_stencil_mask_ref)
            && (self.shader_buffer_float16_atomic_add
                || !other.shader_buffer_float16_atomic_add)
            && (self.shader_buffer_float16_atomic_min_max
                || !other.shader_buffer_float16_atomic_min_max)
            && (self.shader_buffer_float16_atomics
                || !other.shader_buffer_float16_atomics)
            && (self.shader_buffer_float32_atomic_add
                || !other.shader_buffer_float32_atomic_add)
            && (self.shader_buffer_float32_atomic_min_max
                || !other.shader_buffer_float32_atomic_min_max)
            && (self.shader_buffer_float32_atomics
                || !other.shader_buffer_float32_atomics)
            && (self.shader_buffer_float64_atomic_add
                || !other.shader_buffer_float64_atomic_add)
            && (self.shader_buffer_float64_atomic_min_max
                || !other.shader_buffer_float64_atomic_min_max)
            && (self.shader_buffer_float64_atomics
                || !other.shader_buffer_float64_atomics)
            && (self.shader_buffer_int64_atomics || !other.shader_buffer_int64_atomics)
            && (self.shader_clip_distance || !other.shader_clip_distance)
            && (self.shader_core_builtins || !other.shader_core_builtins)
            && (self.shader_cull_distance || !other.shader_cull_distance)
            && (self.shader_demote_to_helper_invocation
                || !other.shader_demote_to_helper_invocation)
            && (self.shader_device_clock || !other.shader_device_clock)
            && (self.shader_draw_parameters || !other.shader_draw_parameters)
            && (self.shader_early_and_late_fragment_tests
                || !other.shader_early_and_late_fragment_tests)
            && (self.shader_enqueue || !other.shader_enqueue)
            && (self.shader_expect_assume || !other.shader_expect_assume)
            && (self.shader_float16 || !other.shader_float16)
            && (self.shader_float16_vector_atomics
                || !other.shader_float16_vector_atomics)
            && (self.shader_float64 || !other.shader_float64)
            && (self.shader_float_controls2 || !other.shader_float_controls2)
            && (self.shader_image_float32_atomic_add
                || !other.shader_image_float32_atomic_add)
            && (self.shader_image_float32_atomic_min_max
                || !other.shader_image_float32_atomic_min_max)
            && (self.shader_image_float32_atomics || !other.shader_image_float32_atomics)
            && (self.shader_image_gather_extended || !other.shader_image_gather_extended)
            && (self.shader_image_int64_atomics || !other.shader_image_int64_atomics)
            && (self.shader_input_attachment_array_dynamic_indexing
                || !other.shader_input_attachment_array_dynamic_indexing)
            && (self.shader_input_attachment_array_non_uniform_indexing
                || !other.shader_input_attachment_array_non_uniform_indexing)
            && (self.shader_int16 || !other.shader_int16)
            && (self.shader_int64 || !other.shader_int64)
            && (self.shader_int8 || !other.shader_int8)
            && (self.shader_integer_dot_product || !other.shader_integer_dot_product)
            && (self.shader_integer_functions2 || !other.shader_integer_functions2)
            && (self.shader_maximal_reconvergence || !other.shader_maximal_reconvergence)
            && (self.shader_module_identifier || !other.shader_module_identifier)
            && (self.shader_object || !other.shader_object)
            && (self.shader_output_layer || !other.shader_output_layer)
            && (self.shader_output_viewport_index || !other.shader_output_viewport_index)
            && (self.shader_quad_control || !other.shader_quad_control)
            && (self.shader_raw_access_chains || !other.shader_raw_access_chains)
            && (self.shader_resource_min_lod || !other.shader_resource_min_lod)
            && (self.shader_resource_residency || !other.shader_resource_residency)
            && (self.shader_sample_rate_interpolation_functions
                || !other.shader_sample_rate_interpolation_functions)
            && (self.shader_sampled_image_array_dynamic_indexing
                || !other.shader_sampled_image_array_dynamic_indexing)
            && (self.shader_sampled_image_array_non_uniform_indexing
                || !other.shader_sampled_image_array_non_uniform_indexing)
            && (self.shader_shared_float16_atomic_add
                || !other.shader_shared_float16_atomic_add)
            && (self.shader_shared_float16_atomic_min_max
                || !other.shader_shared_float16_atomic_min_max)
            && (self.shader_shared_float16_atomics
                || !other.shader_shared_float16_atomics)
            && (self.shader_shared_float32_atomic_add
                || !other.shader_shared_float32_atomic_add)
            && (self.shader_shared_float32_atomic_min_max
                || !other.shader_shared_float32_atomic_min_max)
            && (self.shader_shared_float32_atomics
                || !other.shader_shared_float32_atomics)
            && (self.shader_shared_float64_atomic_add
                || !other.shader_shared_float64_atomic_add)
            && (self.shader_shared_float64_atomic_min_max
                || !other.shader_shared_float64_atomic_min_max)
            && (self.shader_shared_float64_atomics
                || !other.shader_shared_float64_atomics)
            && (self.shader_shared_int64_atomics || !other.shader_shared_int64_atomics)
            && (self.shader_sm_builtins || !other.shader_sm_builtins)
            && (self.shader_storage_buffer_array_dynamic_indexing
                || !other.shader_storage_buffer_array_dynamic_indexing)
            && (self.shader_storage_buffer_array_non_uniform_indexing
                || !other.shader_storage_buffer_array_non_uniform_indexing)
            && (self.shader_storage_image_array_dynamic_indexing
                || !other.shader_storage_image_array_dynamic_indexing)
            && (self.shader_storage_image_array_non_uniform_indexing
                || !other.shader_storage_image_array_non_uniform_indexing)
            && (self.shader_storage_image_extended_formats
                || !other.shader_storage_image_extended_formats)
            && (self.shader_storage_image_multisample
                || !other.shader_storage_image_multisample)
            && (self.shader_storage_image_read_without_format
                || !other.shader_storage_image_read_without_format)
            && (self.shader_storage_image_write_without_format
                || !other.shader_storage_image_write_without_format)
            && (self.shader_storage_texel_buffer_array_dynamic_indexing
                || !other.shader_storage_texel_buffer_array_dynamic_indexing)
            && (self.shader_storage_texel_buffer_array_non_uniform_indexing
                || !other.shader_storage_texel_buffer_array_non_uniform_indexing)
            && (self.shader_subgroup_clock || !other.shader_subgroup_clock)
            && (self.shader_subgroup_extended_types
                || !other.shader_subgroup_extended_types)
            && (self.shader_subgroup_rotate || !other.shader_subgroup_rotate)
            && (self.shader_subgroup_rotate_clustered
                || !other.shader_subgroup_rotate_clustered)
            && (self.shader_subgroup_uniform_control_flow
                || !other.shader_subgroup_uniform_control_flow)
            && (self.shader_terminate_invocation || !other.shader_terminate_invocation)
            && (self.shader_tessellation_and_geometry_point_size
                || !other.shader_tessellation_and_geometry_point_size)
            && (self.shader_tile_image_color_read_access
                || !other.shader_tile_image_color_read_access)
            && (self.shader_tile_image_depth_read_access
                || !other.shader_tile_image_depth_read_access)
            && (self.shader_tile_image_stencil_read_access
                || !other.shader_tile_image_stencil_read_access)
            && (self.shader_uniform_buffer_array_dynamic_indexing
                || !other.shader_uniform_buffer_array_dynamic_indexing)
            && (self.shader_uniform_buffer_array_non_uniform_indexing
                || !other.shader_uniform_buffer_array_non_uniform_indexing)
            && (self.shader_uniform_texel_buffer_array_dynamic_indexing
                || !other.shader_uniform_texel_buffer_array_dynamic_indexing)
            && (self.shader_uniform_texel_buffer_array_non_uniform_indexing
                || !other.shader_uniform_texel_buffer_array_non_uniform_indexing)
            && (self.shader_zero_initialize_workgroup_memory
                || !other.shader_zero_initialize_workgroup_memory)
            && (self.shading_rate_coarse_sample_order
                || !other.shading_rate_coarse_sample_order)
            && (self.shading_rate_image || !other.shading_rate_image)
            && (self.smooth_lines || !other.smooth_lines)
            && (self.sparse_binding || !other.sparse_binding)
            && (self.sparse_image_float32_atomic_add
                || !other.sparse_image_float32_atomic_add)
            && (self.sparse_image_float32_atomic_min_max
                || !other.sparse_image_float32_atomic_min_max)
            && (self.sparse_image_float32_atomics || !other.sparse_image_float32_atomics)
            && (self.sparse_image_int64_atomics || !other.sparse_image_int64_atomics)
            && (self.sparse_residency16_samples || !other.sparse_residency16_samples)
            && (self.sparse_residency2_samples || !other.sparse_residency2_samples)
            && (self.sparse_residency4_samples || !other.sparse_residency4_samples)
            && (self.sparse_residency8_samples || !other.sparse_residency8_samples)
            && (self.sparse_residency_aliased || !other.sparse_residency_aliased)
            && (self.sparse_residency_buffer || !other.sparse_residency_buffer)
            && (self.sparse_residency_image2_d || !other.sparse_residency_image2_d)
            && (self.sparse_residency_image3_d || !other.sparse_residency_image3_d)
            && (self.stippled_bresenham_lines || !other.stippled_bresenham_lines)
            && (self.stippled_rectangular_lines || !other.stippled_rectangular_lines)
            && (self.stippled_smooth_lines || !other.stippled_smooth_lines)
            && (self.storage_buffer16_bit_access || !other.storage_buffer16_bit_access)
            && (self.storage_buffer8_bit_access || !other.storage_buffer8_bit_access)
            && (self.storage_input_output16 || !other.storage_input_output16)
            && (self.storage_push_constant16 || !other.storage_push_constant16)
            && (self.storage_push_constant8 || !other.storage_push_constant8)
            && (self.subgroup_broadcast_dynamic_id
                || !other.subgroup_broadcast_dynamic_id)
            && (self.subgroup_size_control || !other.subgroup_size_control)
            && (self.subpass_merge_feedback || !other.subpass_merge_feedback)
            && (self.subpass_shading || !other.subpass_shading)
            && (self.supersample_fragment_shading_rates
                || !other.supersample_fragment_shading_rates)
            && (self.swapchain_maintenance1 || !other.swapchain_maintenance1)
            && (self.synchronization2 || !other.synchronization2)
            && (self.task_shader || !other.task_shader)
            && (self.tessellation_isolines || !other.tessellation_isolines)
            && (self.tessellation_point_mode || !other.tessellation_point_mode)
            && (self.tessellation_shader || !other.tessellation_shader)
            && (self.texel_buffer_alignment || !other.texel_buffer_alignment)
            && (self.texture_block_match || !other.texture_block_match)
            && (self.texture_block_match2 || !other.texture_block_match2)
            && (self.texture_box_filter || !other.texture_box_filter)
            && (self.texture_compression_astc_hdr || !other.texture_compression_astc_hdr)
            && (self.texture_compression_astc_ldr || !other.texture_compression_astc_ldr)
            && (self.texture_compression_bc || !other.texture_compression_bc)
            && (self.texture_compression_etc2 || !other.texture_compression_etc2)
            && (self.texture_sample_weighted || !other.texture_sample_weighted)
            && (self.tile_properties || !other.tile_properties)
            && (self.timeline_semaphore || !other.timeline_semaphore)
            && (self.transform_feedback || !other.transform_feedback)
            && (self.transform_feedback_preserves_provoking_vertex
                || !other.transform_feedback_preserves_provoking_vertex)
            && (self.triangle_fans || !other.triangle_fans)
            && (self.uniform_and_storage_buffer16_bit_access
                || !other.uniform_and_storage_buffer16_bit_access)
            && (self.uniform_and_storage_buffer8_bit_access
                || !other.uniform_and_storage_buffer8_bit_access)
            && (self.uniform_buffer_standard_layout
                || !other.uniform_buffer_standard_layout)
            && (self.variable_multisample_rate || !other.variable_multisample_rate)
            && (self.variable_pointers || !other.variable_pointers)
            && (self.variable_pointers_storage_buffer
                || !other.variable_pointers_storage_buffer)
            && (self.vertex_attribute_access_beyond_stride
                || !other.vertex_attribute_access_beyond_stride)
            && (self.vertex_attribute_instance_rate_divisor
                || !other.vertex_attribute_instance_rate_divisor)
            && (self.vertex_attribute_instance_rate_zero_divisor
                || !other.vertex_attribute_instance_rate_zero_divisor)
            && (self.vertex_input_dynamic_state || !other.vertex_input_dynamic_state)
            && (self.vertex_pipeline_stores_and_atomics
                || !other.vertex_pipeline_stores_and_atomics)
            && (self.video_maintenance1 || !other.video_maintenance1)
            && (self.vulkan_memory_model || !other.vulkan_memory_model)
            && (self.vulkan_memory_model_availability_visibility_chains
                || !other.vulkan_memory_model_availability_visibility_chains)
            && (self.vulkan_memory_model_device_scope
                || !other.vulkan_memory_model_device_scope)
            && (self.wide_lines || !other.wide_lines)
            && (self.workgroup_memory_explicit_layout
                || !other.workgroup_memory_explicit_layout)
            && (self.workgroup_memory_explicit_layout16_bit_access
                || !other.workgroup_memory_explicit_layout16_bit_access)
            && (self.workgroup_memory_explicit_layout8_bit_access
                || !other.workgroup_memory_explicit_layout8_bit_access)
            && (self.workgroup_memory_explicit_layout_scalar_block_layout
                || !other.workgroup_memory_explicit_layout_scalar_block_layout)
            && (self.ycbcr2plane444_formats || !other.ycbcr2plane444_formats)
            && (self.ycbcr_degamma || !other.ycbcr_degamma)
            && (self.ycbcr_image_arrays || !other.ycbcr_image_arrays)
    }
    /// Returns the union of `self` and `other`.
    #[inline]
    pub const fn union(&self, other: &Self) -> Self {
        Self {
            acceleration_structure: self.acceleration_structure
                || other.acceleration_structure,
            acceleration_structure_capture_replay: self
                .acceleration_structure_capture_replay
                || other.acceleration_structure_capture_replay,
            acceleration_structure_host_commands: self
                .acceleration_structure_host_commands
                || other.acceleration_structure_host_commands,
            acceleration_structure_indirect_build: self
                .acceleration_structure_indirect_build
                || other.acceleration_structure_indirect_build,
            advanced_blend_coherent_operations: self.advanced_blend_coherent_operations
                || other.advanced_blend_coherent_operations,
            alpha_to_one: self.alpha_to_one || other.alpha_to_one,
            amigo_profiling: self.amigo_profiling || other.amigo_profiling,
            attachment_feedback_loop_dynamic_state: self
                .attachment_feedback_loop_dynamic_state
                || other.attachment_feedback_loop_dynamic_state,
            attachment_feedback_loop_layout: self.attachment_feedback_loop_layout
                || other.attachment_feedback_loop_layout,
            attachment_fragment_shading_rate: self.attachment_fragment_shading_rate
                || other.attachment_fragment_shading_rate,
            border_color_swizzle: self.border_color_swizzle
                || other.border_color_swizzle,
            border_color_swizzle_from_image: self.border_color_swizzle_from_image
                || other.border_color_swizzle_from_image,
            bresenham_lines: self.bresenham_lines || other.bresenham_lines,
            buffer_device_address: self.buffer_device_address
                || other.buffer_device_address,
            buffer_device_address_capture_replay: self
                .buffer_device_address_capture_replay
                || other.buffer_device_address_capture_replay,
            buffer_device_address_multi_device: self.buffer_device_address_multi_device
                || other.buffer_device_address_multi_device,
            clusterculling_shader: self.clusterculling_shader
                || other.clusterculling_shader,
            color_write_enable: self.color_write_enable || other.color_write_enable,
            compute_derivative_group_linear: self.compute_derivative_group_linear
                || other.compute_derivative_group_linear,
            compute_derivative_group_quads: self.compute_derivative_group_quads
                || other.compute_derivative_group_quads,
            compute_full_subgroups: self.compute_full_subgroups
                || other.compute_full_subgroups,
            conditional_rendering: self.conditional_rendering
                || other.conditional_rendering,
            constant_alpha_color_blend_factors: self.constant_alpha_color_blend_factors
                || other.constant_alpha_color_blend_factors,
            cooperative_matrix: self.cooperative_matrix || other.cooperative_matrix,
            cooperative_matrix_robust_buffer_access: self
                .cooperative_matrix_robust_buffer_access
                || other.cooperative_matrix_robust_buffer_access,
            corner_sampled_image: self.corner_sampled_image
                || other.corner_sampled_image,
            coverage_reduction_mode: self.coverage_reduction_mode
                || other.coverage_reduction_mode,
            cubic_range_clamp: self.cubic_range_clamp || other.cubic_range_clamp,
            cuda_kernel_launch_features: self.cuda_kernel_launch_features
                || other.cuda_kernel_launch_features,
            custom_border_color_without_format: self.custom_border_color_without_format
                || other.custom_border_color_without_format,
            custom_border_colors: self.custom_border_colors
                || other.custom_border_colors,
            decode_mode_shared_exponent: self.decode_mode_shared_exponent
                || other.decode_mode_shared_exponent,
            dedicated_allocation_image_aliasing: self.dedicated_allocation_image_aliasing
                || other.dedicated_allocation_image_aliasing,
            depth_bias_clamp: self.depth_bias_clamp || other.depth_bias_clamp,
            depth_bias_control: self.depth_bias_control || other.depth_bias_control,
            depth_bias_exact: self.depth_bias_exact || other.depth_bias_exact,
            depth_bounds: self.depth_bounds || other.depth_bounds,
            depth_clamp: self.depth_clamp || other.depth_clamp,
            depth_clamp_zero_one: self.depth_clamp_zero_one
                || other.depth_clamp_zero_one,
            depth_clip_control: self.depth_clip_control || other.depth_clip_control,
            depth_clip_enable: self.depth_clip_enable || other.depth_clip_enable,
            descriptor_binding_acceleration_structure_update_after_bind: self
                .descriptor_binding_acceleration_structure_update_after_bind
                || other.descriptor_binding_acceleration_structure_update_after_bind,
            descriptor_binding_inline_uniform_block_update_after_bind: self
                .descriptor_binding_inline_uniform_block_update_after_bind
                || other.descriptor_binding_inline_uniform_block_update_after_bind,
            descriptor_binding_partially_bound: self.descriptor_binding_partially_bound
                || other.descriptor_binding_partially_bound,
            descriptor_binding_sampled_image_update_after_bind: self
                .descriptor_binding_sampled_image_update_after_bind
                || other.descriptor_binding_sampled_image_update_after_bind,
            descriptor_binding_storage_buffer_update_after_bind: self
                .descriptor_binding_storage_buffer_update_after_bind
                || other.descriptor_binding_storage_buffer_update_after_bind,
            descriptor_binding_storage_image_update_after_bind: self
                .descriptor_binding_storage_image_update_after_bind
                || other.descriptor_binding_storage_image_update_after_bind,
            descriptor_binding_storage_texel_buffer_update_after_bind: self
                .descriptor_binding_storage_texel_buffer_update_after_bind
                || other.descriptor_binding_storage_texel_buffer_update_after_bind,
            descriptor_binding_uniform_buffer_update_after_bind: self
                .descriptor_binding_uniform_buffer_update_after_bind
                || other.descriptor_binding_uniform_buffer_update_after_bind,
            descriptor_binding_uniform_texel_buffer_update_after_bind: self
                .descriptor_binding_uniform_texel_buffer_update_after_bind
                || other.descriptor_binding_uniform_texel_buffer_update_after_bind,
            descriptor_binding_update_unused_while_pending: self
                .descriptor_binding_update_unused_while_pending
                || other.descriptor_binding_update_unused_while_pending,
            descriptor_binding_variable_descriptor_count: self
                .descriptor_binding_variable_descriptor_count
                || other.descriptor_binding_variable_descriptor_count,
            descriptor_buffer: self.descriptor_buffer || other.descriptor_buffer,
            descriptor_buffer_capture_replay: self.descriptor_buffer_capture_replay
                || other.descriptor_buffer_capture_replay,
            descriptor_buffer_image_layout_ignored: self
                .descriptor_buffer_image_layout_ignored
                || other.descriptor_buffer_image_layout_ignored,
            descriptor_buffer_push_descriptors: self.descriptor_buffer_push_descriptors
                || other.descriptor_buffer_push_descriptors,
            descriptor_indexing: self.descriptor_indexing || other.descriptor_indexing,
            descriptor_pool_overallocation: self.descriptor_pool_overallocation
                || other.descriptor_pool_overallocation,
            descriptor_set_host_mapping: self.descriptor_set_host_mapping
                || other.descriptor_set_host_mapping,
            device_coherent_memory: self.device_coherent_memory
                || other.device_coherent_memory,
            device_fault: self.device_fault || other.device_fault,
            device_fault_vendor_binary: self.device_fault_vendor_binary
                || other.device_fault_vendor_binary,
            device_generated_commands: self.device_generated_commands
                || other.device_generated_commands,
            device_generated_compute: self.device_generated_compute
                || other.device_generated_compute,
            device_generated_compute_capture_replay: self
                .device_generated_compute_capture_replay
                || other.device_generated_compute_capture_replay,
            device_generated_compute_pipelines: self.device_generated_compute_pipelines
                || other.device_generated_compute_pipelines,
            device_memory_report: self.device_memory_report
                || other.device_memory_report,
            diagnostics_config: self.diagnostics_config || other.diagnostics_config,
            displacement_micromap: self.displacement_micromap
                || other.displacement_micromap,
            draw_indirect_count: self.draw_indirect_count || other.draw_indirect_count,
            draw_indirect_first_instance: self.draw_indirect_first_instance
                || other.draw_indirect_first_instance,
            dual_src_blend: self.dual_src_blend || other.dual_src_blend,
            dynamic_pipeline_layout: self.dynamic_pipeline_layout
                || other.dynamic_pipeline_layout,
            dynamic_rendering: self.dynamic_rendering || other.dynamic_rendering,
            dynamic_rendering_local_read: self.dynamic_rendering_local_read
                || other.dynamic_rendering_local_read,
            dynamic_rendering_unused_attachments: self
                .dynamic_rendering_unused_attachments
                || other.dynamic_rendering_unused_attachments,
            events: self.events || other.events,
            exclusive_scissor: self.exclusive_scissor || other.exclusive_scissor,
            extended_dynamic_state: self.extended_dynamic_state
                || other.extended_dynamic_state,
            extended_dynamic_state2: self.extended_dynamic_state2
                || other.extended_dynamic_state2,
            extended_dynamic_state2_logic_op: self.extended_dynamic_state2_logic_op
                || other.extended_dynamic_state2_logic_op,
            extended_dynamic_state2_patch_control_points: self
                .extended_dynamic_state2_patch_control_points
                || other.extended_dynamic_state2_patch_control_points,
            extended_dynamic_state3_alpha_to_coverage_enable: self
                .extended_dynamic_state3_alpha_to_coverage_enable
                || other.extended_dynamic_state3_alpha_to_coverage_enable,
            extended_dynamic_state3_alpha_to_one_enable: self
                .extended_dynamic_state3_alpha_to_one_enable
                || other.extended_dynamic_state3_alpha_to_one_enable,
            extended_dynamic_state3_color_blend_advanced: self
                .extended_dynamic_state3_color_blend_advanced
                || other.extended_dynamic_state3_color_blend_advanced,
            extended_dynamic_state3_color_blend_enable: self
                .extended_dynamic_state3_color_blend_enable
                || other.extended_dynamic_state3_color_blend_enable,
            extended_dynamic_state3_color_blend_equation: self
                .extended_dynamic_state3_color_blend_equation
                || other.extended_dynamic_state3_color_blend_equation,
            extended_dynamic_state3_color_write_mask: self
                .extended_dynamic_state3_color_write_mask
                || other.extended_dynamic_state3_color_write_mask,
            extended_dynamic_state3_conservative_rasterization_mode: self
                .extended_dynamic_state3_conservative_rasterization_mode
                || other.extended_dynamic_state3_conservative_rasterization_mode,
            extended_dynamic_state3_coverage_modulation_mode: self
                .extended_dynamic_state3_coverage_modulation_mode
                || other.extended_dynamic_state3_coverage_modulation_mode,
            extended_dynamic_state3_coverage_modulation_table: self
                .extended_dynamic_state3_coverage_modulation_table
                || other.extended_dynamic_state3_coverage_modulation_table,
            extended_dynamic_state3_coverage_modulation_table_enable: self
                .extended_dynamic_state3_coverage_modulation_table_enable
                || other.extended_dynamic_state3_coverage_modulation_table_enable,
            extended_dynamic_state3_coverage_reduction_mode: self
                .extended_dynamic_state3_coverage_reduction_mode
                || other.extended_dynamic_state3_coverage_reduction_mode,
            extended_dynamic_state3_coverage_to_color_enable: self
                .extended_dynamic_state3_coverage_to_color_enable
                || other.extended_dynamic_state3_coverage_to_color_enable,
            extended_dynamic_state3_coverage_to_color_location: self
                .extended_dynamic_state3_coverage_to_color_location
                || other.extended_dynamic_state3_coverage_to_color_location,
            extended_dynamic_state3_depth_clamp_enable: self
                .extended_dynamic_state3_depth_clamp_enable
                || other.extended_dynamic_state3_depth_clamp_enable,
            extended_dynamic_state3_depth_clip_enable: self
                .extended_dynamic_state3_depth_clip_enable
                || other.extended_dynamic_state3_depth_clip_enable,
            extended_dynamic_state3_depth_clip_negative_one_to_one: self
                .extended_dynamic_state3_depth_clip_negative_one_to_one
                || other.extended_dynamic_state3_depth_clip_negative_one_to_one,
            extended_dynamic_state3_extra_primitive_overestimation_size: self
                .extended_dynamic_state3_extra_primitive_overestimation_size
                || other.extended_dynamic_state3_extra_primitive_overestimation_size,
            extended_dynamic_state3_line_rasterization_mode: self
                .extended_dynamic_state3_line_rasterization_mode
                || other.extended_dynamic_state3_line_rasterization_mode,
            extended_dynamic_state3_line_stipple_enable: self
                .extended_dynamic_state3_line_stipple_enable
                || other.extended_dynamic_state3_line_stipple_enable,
            extended_dynamic_state3_logic_op_enable: self
                .extended_dynamic_state3_logic_op_enable
                || other.extended_dynamic_state3_logic_op_enable,
            extended_dynamic_state3_polygon_mode: self
                .extended_dynamic_state3_polygon_mode
                || other.extended_dynamic_state3_polygon_mode,
            extended_dynamic_state3_provoking_vertex_mode: self
                .extended_dynamic_state3_provoking_vertex_mode
                || other.extended_dynamic_state3_provoking_vertex_mode,
            extended_dynamic_state3_rasterization_samples: self
                .extended_dynamic_state3_rasterization_samples
                || other.extended_dynamic_state3_rasterization_samples,
            extended_dynamic_state3_rasterization_stream: self
                .extended_dynamic_state3_rasterization_stream
                || other.extended_dynamic_state3_rasterization_stream,
            extended_dynamic_state3_representative_fragment_test_enable: self
                .extended_dynamic_state3_representative_fragment_test_enable
                || other.extended_dynamic_state3_representative_fragment_test_enable,
            extended_dynamic_state3_sample_locations_enable: self
                .extended_dynamic_state3_sample_locations_enable
                || other.extended_dynamic_state3_sample_locations_enable,
            extended_dynamic_state3_sample_mask: self.extended_dynamic_state3_sample_mask
                || other.extended_dynamic_state3_sample_mask,
            extended_dynamic_state3_shading_rate_image_enable: self
                .extended_dynamic_state3_shading_rate_image_enable
                || other.extended_dynamic_state3_shading_rate_image_enable,
            extended_dynamic_state3_tessellation_domain_origin: self
                .extended_dynamic_state3_tessellation_domain_origin
                || other.extended_dynamic_state3_tessellation_domain_origin,
            extended_dynamic_state3_viewport_swizzle: self
                .extended_dynamic_state3_viewport_swizzle
                || other.extended_dynamic_state3_viewport_swizzle,
            extended_dynamic_state3_viewport_w_scaling_enable: self
                .extended_dynamic_state3_viewport_w_scaling_enable
                || other.extended_dynamic_state3_viewport_w_scaling_enable,
            extended_sparse_address_space: self.extended_sparse_address_space
                || other.extended_sparse_address_space,
            external_format_resolve: self.external_format_resolve
                || other.external_format_resolve,
            external_memory_rdma: self.external_memory_rdma
                || other.external_memory_rdma,
            fill_mode_non_solid: self.fill_mode_non_solid || other.fill_mode_non_solid,
            float_representation: self.float_representation
                || other.float_representation,
            format_a4b4g4r4: self.format_a4b4g4r4 || other.format_a4b4g4r4,
            format_a4r4g4b4: self.format_a4r4g4b4 || other.format_a4r4g4b4,
            format_rgba10x6_without_y_cb_cr_sampler: self
                .format_rgba10x6_without_y_cb_cr_sampler
                || other.format_rgba10x6_without_y_cb_cr_sampler,
            fragment_density_map: self.fragment_density_map
                || other.fragment_density_map,
            fragment_density_map_deferred: self.fragment_density_map_deferred
                || other.fragment_density_map_deferred,
            fragment_density_map_dynamic: self.fragment_density_map_dynamic
                || other.fragment_density_map_dynamic,
            fragment_density_map_non_subsampled_images: self
                .fragment_density_map_non_subsampled_images
                || other.fragment_density_map_non_subsampled_images,
            fragment_density_map_offset: self.fragment_density_map_offset
                || other.fragment_density_map_offset,
            fragment_shader_barycentric: self.fragment_shader_barycentric
                || other.fragment_shader_barycentric,
            fragment_shader_pixel_interlock: self.fragment_shader_pixel_interlock
                || other.fragment_shader_pixel_interlock,
            fragment_shader_sample_interlock: self.fragment_shader_sample_interlock
                || other.fragment_shader_sample_interlock,
            fragment_shader_shading_rate_interlock: self
                .fragment_shader_shading_rate_interlock
                || other.fragment_shader_shading_rate_interlock,
            fragment_shading_rate_enums: self.fragment_shading_rate_enums
                || other.fragment_shading_rate_enums,
            fragment_stores_and_atomics: self.fragment_stores_and_atomics
                || other.fragment_stores_and_atomics,
            frame_boundary: self.frame_boundary || other.frame_boundary,
            full_draw_index_uint32: self.full_draw_index_uint32
                || other.full_draw_index_uint32,
            geometry_shader: self.geometry_shader || other.geometry_shader,
            geometry_streams: self.geometry_streams || other.geometry_streams,
            global_priority_query: self.global_priority_query
                || other.global_priority_query,
            graphics_pipeline_library: self.graphics_pipeline_library
                || other.graphics_pipeline_library,
            host_image_copy: self.host_image_copy || other.host_image_copy,
            host_query_reset: self.host_query_reset || other.host_query_reset,
            image2_d_view_of3_d: self.image2_d_view_of3_d || other.image2_d_view_of3_d,
            image_compression_control: self.image_compression_control
                || other.image_compression_control,
            image_compression_control_swapchain: self.image_compression_control_swapchain
                || other.image_compression_control_swapchain,
            image_cube_array: self.image_cube_array || other.image_cube_array,
            image_footprint: self.image_footprint || other.image_footprint,
            image_sliced_view_of3_d: self.image_sliced_view_of3_d
                || other.image_sliced_view_of3_d,
            image_view2_d_on3_d_image: self.image_view2_d_on3_d_image
                || other.image_view2_d_on3_d_image,
            image_view_format_reinterpretation: self.image_view_format_reinterpretation
                || other.image_view_format_reinterpretation,
            image_view_format_swizzle: self.image_view_format_swizzle
                || other.image_view_format_swizzle,
            imageless_framebuffer: self.imageless_framebuffer
                || other.imageless_framebuffer,
            independent_blend: self.independent_blend || other.independent_blend,
            index_type_uint8: self.index_type_uint8 || other.index_type_uint8,
            indirect_copy: self.indirect_copy || other.indirect_copy,
            inherited_conditional_rendering: self.inherited_conditional_rendering
                || other.inherited_conditional_rendering,
            inherited_queries: self.inherited_queries || other.inherited_queries,
            inherited_viewport_scissor2_d: self.inherited_viewport_scissor2_d
                || other.inherited_viewport_scissor2_d,
            inline_uniform_block: self.inline_uniform_block
                || other.inline_uniform_block,
            invocation_mask: self.invocation_mask || other.invocation_mask,
            large_points: self.large_points || other.large_points,
            least_representable_value_force_unorm_representation: self
                .least_representable_value_force_unorm_representation
                || other.least_representable_value_force_unorm_representation,
            legacy_dithering: self.legacy_dithering || other.legacy_dithering,
            linear_color_attachment: self.linear_color_attachment
                || other.linear_color_attachment,
            logic_op: self.logic_op || other.logic_op,
            maintenance4: self.maintenance4 || other.maintenance4,
            maintenance5: self.maintenance5 || other.maintenance5,
            maintenance6: self.maintenance6 || other.maintenance6,
            memory_decompression: self.memory_decompression
                || other.memory_decompression,
            memory_map_placed: self.memory_map_placed || other.memory_map_placed,
            memory_map_range_placed: self.memory_map_range_placed
                || other.memory_map_range_placed,
            memory_priority: self.memory_priority || other.memory_priority,
            memory_unmap_reserve: self.memory_unmap_reserve
                || other.memory_unmap_reserve,
            mesh_shader: self.mesh_shader || other.mesh_shader,
            mesh_shader_queries: self.mesh_shader_queries || other.mesh_shader_queries,
            micromap: self.micromap || other.micromap,
            micromap_capture_replay: self.micromap_capture_replay
                || other.micromap_capture_replay,
            micromap_host_commands: self.micromap_host_commands
                || other.micromap_host_commands,
            min_lod: self.min_lod || other.min_lod,
            multi_draw: self.multi_draw || other.multi_draw,
            multi_draw_indirect: self.multi_draw_indirect || other.multi_draw_indirect,
            multi_viewport: self.multi_viewport || other.multi_viewport,
            multisample_array_image: self.multisample_array_image
                || other.multisample_array_image,
            multisampled_render_to_single_sampled: self
                .multisampled_render_to_single_sampled
                || other.multisampled_render_to_single_sampled,
            multiview: self.multiview || other.multiview,
            multiview_cluster_culling_shader: self.multiview_cluster_culling_shader
                || other.multiview_cluster_culling_shader,
            multiview_geometry_shader: self.multiview_geometry_shader
                || other.multiview_geometry_shader,
            multiview_mesh_shader: self.multiview_mesh_shader
                || other.multiview_mesh_shader,
            multiview_per_view_render_areas: self.multiview_per_view_render_areas
                || other.multiview_per_view_render_areas,
            multiview_per_view_viewports: self.multiview_per_view_viewports
                || other.multiview_per_view_viewports,
            multiview_tessellation_shader: self.multiview_tessellation_shader
                || other.multiview_tessellation_shader,
            mutable_comparison_samplers: self.mutable_comparison_samplers
                || other.mutable_comparison_samplers,
            mutable_descriptor_type: self.mutable_descriptor_type
                || other.mutable_descriptor_type,
            nested_command_buffer: self.nested_command_buffer
                || other.nested_command_buffer,
            nested_command_buffer_rendering: self.nested_command_buffer_rendering
                || other.nested_command_buffer_rendering,
            nested_command_buffer_simultaneous_use: self
                .nested_command_buffer_simultaneous_use
                || other.nested_command_buffer_simultaneous_use,
            no_invocation_fragment_shading_rates: self
                .no_invocation_fragment_shading_rates
                || other.no_invocation_fragment_shading_rates,
            non_seamless_cube_map: self.non_seamless_cube_map
                || other.non_seamless_cube_map,
            null_descriptor: self.null_descriptor || other.null_descriptor,
            occlusion_query_precise: self.occlusion_query_precise
                || other.occlusion_query_precise,
            optical_flow: self.optical_flow || other.optical_flow,
            pageable_device_local_memory: self.pageable_device_local_memory
                || other.pageable_device_local_memory,
            per_stage_descriptor_set: self.per_stage_descriptor_set
                || other.per_stage_descriptor_set,
            performance_counter_multiple_query_pools: self
                .performance_counter_multiple_query_pools
                || other.performance_counter_multiple_query_pools,
            performance_counter_query_pools: self.performance_counter_query_pools
                || other.performance_counter_query_pools,
            pipeline_creation_cache_control: self.pipeline_creation_cache_control
                || other.pipeline_creation_cache_control,
            pipeline_executable_info: self.pipeline_executable_info
                || other.pipeline_executable_info,
            pipeline_fragment_shading_rate: self.pipeline_fragment_shading_rate
                || other.pipeline_fragment_shading_rate,
            pipeline_library_group_handles: self.pipeline_library_group_handles
                || other.pipeline_library_group_handles,
            pipeline_properties_identifier: self.pipeline_properties_identifier
                || other.pipeline_properties_identifier,
            pipeline_protected_access: self.pipeline_protected_access
                || other.pipeline_protected_access,
            pipeline_robustness: self.pipeline_robustness || other.pipeline_robustness,
            pipeline_statistics_query: self.pipeline_statistics_query
                || other.pipeline_statistics_query,
            point_polygons: self.point_polygons || other.point_polygons,
            present_barrier: self.present_barrier || other.present_barrier,
            present_id: self.present_id || other.present_id,
            present_wait: self.present_wait || other.present_wait,
            primitive_fragment_shading_rate: self.primitive_fragment_shading_rate
                || other.primitive_fragment_shading_rate,
            primitive_fragment_shading_rate_mesh_shader: self
                .primitive_fragment_shading_rate_mesh_shader
                || other.primitive_fragment_shading_rate_mesh_shader,
            primitive_topology_list_restart: self.primitive_topology_list_restart
                || other.primitive_topology_list_restart,
            primitive_topology_patch_list_restart: self
                .primitive_topology_patch_list_restart
                || other.primitive_topology_patch_list_restart,
            primitives_generated_query: self.primitives_generated_query
                || other.primitives_generated_query,
            primitives_generated_query_with_non_zero_streams: self
                .primitives_generated_query_with_non_zero_streams
                || other.primitives_generated_query_with_non_zero_streams,
            primitives_generated_query_with_rasterizer_discard: self
                .primitives_generated_query_with_rasterizer_discard
                || other.primitives_generated_query_with_rasterizer_discard,
            private_data: self.private_data || other.private_data,
            protected_memory: self.protected_memory || other.protected_memory,
            provoking_vertex_last: self.provoking_vertex_last
                || other.provoking_vertex_last,
            rasterization_order_color_attachment_access: self
                .rasterization_order_color_attachment_access
                || other.rasterization_order_color_attachment_access,
            rasterization_order_depth_attachment_access: self
                .rasterization_order_depth_attachment_access
                || other.rasterization_order_depth_attachment_access,
            rasterization_order_stencil_attachment_access: self
                .rasterization_order_stencil_attachment_access
                || other.rasterization_order_stencil_attachment_access,
            ray_query: self.ray_query || other.ray_query,
            ray_tracing_invocation_reorder: self.ray_tracing_invocation_reorder
                || other.ray_tracing_invocation_reorder,
            ray_tracing_maintenance1: self.ray_tracing_maintenance1
                || other.ray_tracing_maintenance1,
            ray_tracing_motion_blur: self.ray_tracing_motion_blur
                || other.ray_tracing_motion_blur,
            ray_tracing_motion_blur_pipeline_trace_rays_indirect: self
                .ray_tracing_motion_blur_pipeline_trace_rays_indirect
                || other.ray_tracing_motion_blur_pipeline_trace_rays_indirect,
            ray_tracing_pipeline: self.ray_tracing_pipeline
                || other.ray_tracing_pipeline,
            ray_tracing_pipeline_shader_group_handle_capture_replay: self
                .ray_tracing_pipeline_shader_group_handle_capture_replay
                || other.ray_tracing_pipeline_shader_group_handle_capture_replay,
            ray_tracing_pipeline_shader_group_handle_capture_replay_mixed: self
                .ray_tracing_pipeline_shader_group_handle_capture_replay_mixed
                || other.ray_tracing_pipeline_shader_group_handle_capture_replay_mixed,
            ray_tracing_pipeline_trace_rays_indirect: self
                .ray_tracing_pipeline_trace_rays_indirect
                || other.ray_tracing_pipeline_trace_rays_indirect,
            ray_tracing_pipeline_trace_rays_indirect2: self
                .ray_tracing_pipeline_trace_rays_indirect2
                || other.ray_tracing_pipeline_trace_rays_indirect2,
            ray_tracing_position_fetch: self.ray_tracing_position_fetch
                || other.ray_tracing_position_fetch,
            ray_tracing_validation: self.ray_tracing_validation
                || other.ray_tracing_validation,
            ray_traversal_primitive_culling: self.ray_traversal_primitive_culling
                || other.ray_traversal_primitive_culling,
            rectangular_lines: self.rectangular_lines || other.rectangular_lines,
            relaxed_line_rasterization: self.relaxed_line_rasterization
                || other.relaxed_line_rasterization,
            render_pass_striped: self.render_pass_striped || other.render_pass_striped,
            report_address_binding: self.report_address_binding
                || other.report_address_binding,
            representative_fragment_test: self.representative_fragment_test
                || other.representative_fragment_test,
            robust_buffer_access: self.robust_buffer_access
                || other.robust_buffer_access,
            robust_buffer_access2: self.robust_buffer_access2
                || other.robust_buffer_access2,
            robust_image_access: self.robust_image_access || other.robust_image_access,
            robust_image_access2: self.robust_image_access2
                || other.robust_image_access2,
            runtime_descriptor_array: self.runtime_descriptor_array
                || other.runtime_descriptor_array,
            sample_rate_shading: self.sample_rate_shading || other.sample_rate_shading,
            sampler2_d_view_of3_d: self.sampler2_d_view_of3_d
                || other.sampler2_d_view_of3_d,
            sampler_anisotropy: self.sampler_anisotropy || other.sampler_anisotropy,
            sampler_filter_minmax: self.sampler_filter_minmax
                || other.sampler_filter_minmax,
            sampler_mip_lod_bias: self.sampler_mip_lod_bias
                || other.sampler_mip_lod_bias,
            sampler_mirror_clamp_to_edge: self.sampler_mirror_clamp_to_edge
                || other.sampler_mirror_clamp_to_edge,
            sampler_ycbcr_conversion: self.sampler_ycbcr_conversion
                || other.sampler_ycbcr_conversion,
            scalar_block_layout: self.scalar_block_layout || other.scalar_block_layout,
            scheduling_controls: self.scheduling_controls || other.scheduling_controls,
            screen_buffer_import: self.screen_buffer_import
                || other.screen_buffer_import,
            selectable_cubic_weights: self.selectable_cubic_weights
                || other.selectable_cubic_weights,
            separate_depth_stencil_layouts: self.separate_depth_stencil_layouts
                || other.separate_depth_stencil_layouts,
            separate_stencil_mask_ref: self.separate_stencil_mask_ref
                || other.separate_stencil_mask_ref,
            shader_buffer_float16_atomic_add: self.shader_buffer_float16_atomic_add
                || other.shader_buffer_float16_atomic_add,
            shader_buffer_float16_atomic_min_max: self
                .shader_buffer_float16_atomic_min_max
                || other.shader_buffer_float16_atomic_min_max,
            shader_buffer_float16_atomics: self.shader_buffer_float16_atomics
                || other.shader_buffer_float16_atomics,
            shader_buffer_float32_atomic_add: self.shader_buffer_float32_atomic_add
                || other.shader_buffer_float32_atomic_add,
            shader_buffer_float32_atomic_min_max: self
                .shader_buffer_float32_atomic_min_max
                || other.shader_buffer_float32_atomic_min_max,
            shader_buffer_float32_atomics: self.shader_buffer_float32_atomics
                || other.shader_buffer_float32_atomics,
            shader_buffer_float64_atomic_add: self.shader_buffer_float64_atomic_add
                || other.shader_buffer_float64_atomic_add,
            shader_buffer_float64_atomic_min_max: self
                .shader_buffer_float64_atomic_min_max
                || other.shader_buffer_float64_atomic_min_max,
            shader_buffer_float64_atomics: self.shader_buffer_float64_atomics
                || other.shader_buffer_float64_atomics,
            shader_buffer_int64_atomics: self.shader_buffer_int64_atomics
                || other.shader_buffer_int64_atomics,
            shader_clip_distance: self.shader_clip_distance
                || other.shader_clip_distance,
            shader_core_builtins: self.shader_core_builtins
                || other.shader_core_builtins,
            shader_cull_distance: self.shader_cull_distance
                || other.shader_cull_distance,
            shader_demote_to_helper_invocation: self.shader_demote_to_helper_invocation
                || other.shader_demote_to_helper_invocation,
            shader_device_clock: self.shader_device_clock || other.shader_device_clock,
            shader_draw_parameters: self.shader_draw_parameters
                || other.shader_draw_parameters,
            shader_early_and_late_fragment_tests: self
                .shader_early_and_late_fragment_tests
                || other.shader_early_and_late_fragment_tests,
            shader_enqueue: self.shader_enqueue || other.shader_enqueue,
            shader_expect_assume: self.shader_expect_assume
                || other.shader_expect_assume,
            shader_float16: self.shader_float16 || other.shader_float16,
            shader_float16_vector_atomics: self.shader_float16_vector_atomics
                || other.shader_float16_vector_atomics,
            shader_float64: self.shader_float64 || other.shader_float64,
            shader_float_controls2: self.shader_float_controls2
                || other.shader_float_controls2,
            shader_image_float32_atomic_add: self.shader_image_float32_atomic_add
                || other.shader_image_float32_atomic_add,
            shader_image_float32_atomic_min_max: self.shader_image_float32_atomic_min_max
                || other.shader_image_float32_atomic_min_max,
            shader_image_float32_atomics: self.shader_image_float32_atomics
                || other.shader_image_float32_atomics,
            shader_image_gather_extended: self.shader_image_gather_extended
                || other.shader_image_gather_extended,
            shader_image_int64_atomics: self.shader_image_int64_atomics
                || other.shader_image_int64_atomics,
            shader_input_attachment_array_dynamic_indexing: self
                .shader_input_attachment_array_dynamic_indexing
                || other.shader_input_attachment_array_dynamic_indexing,
            shader_input_attachment_array_non_uniform_indexing: self
                .shader_input_attachment_array_non_uniform_indexing
                || other.shader_input_attachment_array_non_uniform_indexing,
            shader_int16: self.shader_int16 || other.shader_int16,
            shader_int64: self.shader_int64 || other.shader_int64,
            shader_int8: self.shader_int8 || other.shader_int8,
            shader_integer_dot_product: self.shader_integer_dot_product
                || other.shader_integer_dot_product,
            shader_integer_functions2: self.shader_integer_functions2
                || other.shader_integer_functions2,
            shader_maximal_reconvergence: self.shader_maximal_reconvergence
                || other.shader_maximal_reconvergence,
            shader_module_identifier: self.shader_module_identifier
                || other.shader_module_identifier,
            shader_object: self.shader_object || other.shader_object,
            shader_output_layer: self.shader_output_layer || other.shader_output_layer,
            shader_output_viewport_index: self.shader_output_viewport_index
                || other.shader_output_viewport_index,
            shader_quad_control: self.shader_quad_control || other.shader_quad_control,
            shader_raw_access_chains: self.shader_raw_access_chains
                || other.shader_raw_access_chains,
            shader_resource_min_lod: self.shader_resource_min_lod
                || other.shader_resource_min_lod,
            shader_resource_residency: self.shader_resource_residency
                || other.shader_resource_residency,
            shader_sample_rate_interpolation_functions: self
                .shader_sample_rate_interpolation_functions
                || other.shader_sample_rate_interpolation_functions,
            shader_sampled_image_array_dynamic_indexing: self
                .shader_sampled_image_array_dynamic_indexing
                || other.shader_sampled_image_array_dynamic_indexing,
            shader_sampled_image_array_non_uniform_indexing: self
                .shader_sampled_image_array_non_uniform_indexing
                || other.shader_sampled_image_array_non_uniform_indexing,
            shader_shared_float16_atomic_add: self.shader_shared_float16_atomic_add
                || other.shader_shared_float16_atomic_add,
            shader_shared_float16_atomic_min_max: self
                .shader_shared_float16_atomic_min_max
                || other.shader_shared_float16_atomic_min_max,
            shader_shared_float16_atomics: self.shader_shared_float16_atomics
                || other.shader_shared_float16_atomics,
            shader_shared_float32_atomic_add: self.shader_shared_float32_atomic_add
                || other.shader_shared_float32_atomic_add,
            shader_shared_float32_atomic_min_max: self
                .shader_shared_float32_atomic_min_max
                || other.shader_shared_float32_atomic_min_max,
            shader_shared_float32_atomics: self.shader_shared_float32_atomics
                || other.shader_shared_float32_atomics,
            shader_shared_float64_atomic_add: self.shader_shared_float64_atomic_add
                || other.shader_shared_float64_atomic_add,
            shader_shared_float64_atomic_min_max: self
                .shader_shared_float64_atomic_min_max
                || other.shader_shared_float64_atomic_min_max,
            shader_shared_float64_atomics: self.shader_shared_float64_atomics
                || other.shader_shared_float64_atomics,
            shader_shared_int64_atomics: self.shader_shared_int64_atomics
                || other.shader_shared_int64_atomics,
            shader_sm_builtins: self.shader_sm_builtins || other.shader_sm_builtins,
            shader_storage_buffer_array_dynamic_indexing: self
                .shader_storage_buffer_array_dynamic_indexing
                || other.shader_storage_buffer_array_dynamic_indexing,
            shader_storage_buffer_array_non_uniform_indexing: self
                .shader_storage_buffer_array_non_uniform_indexing
                || other.shader_storage_buffer_array_non_uniform_indexing,
            shader_storage_image_array_dynamic_indexing: self
                .shader_storage_image_array_dynamic_indexing
                || other.shader_storage_image_array_dynamic_indexing,
            shader_storage_image_array_non_uniform_indexing: self
                .shader_storage_image_array_non_uniform_indexing
                || other.shader_storage_image_array_non_uniform_indexing,
            shader_storage_image_extended_formats: self
                .shader_storage_image_extended_formats
                || other.shader_storage_image_extended_formats,
            shader_storage_image_multisample: self.shader_storage_image_multisample
                || other.shader_storage_image_multisample,
            shader_storage_image_read_without_format: self
                .shader_storage_image_read_without_format
                || other.shader_storage_image_read_without_format,
            shader_storage_image_write_without_format: self
                .shader_storage_image_write_without_format
                || other.shader_storage_image_write_without_format,
            shader_storage_texel_buffer_array_dynamic_indexing: self
                .shader_storage_texel_buffer_array_dynamic_indexing
                || other.shader_storage_texel_buffer_array_dynamic_indexing,
            shader_storage_texel_buffer_array_non_uniform_indexing: self
                .shader_storage_texel_buffer_array_non_uniform_indexing
                || other.shader_storage_texel_buffer_array_non_uniform_indexing,
            shader_subgroup_clock: self.shader_subgroup_clock
                || other.shader_subgroup_clock,
            shader_subgroup_extended_types: self.shader_subgroup_extended_types
                || other.shader_subgroup_extended_types,
            shader_subgroup_rotate: self.shader_subgroup_rotate
                || other.shader_subgroup_rotate,
            shader_subgroup_rotate_clustered: self.shader_subgroup_rotate_clustered
                || other.shader_subgroup_rotate_clustered,
            shader_subgroup_uniform_control_flow: self
                .shader_subgroup_uniform_control_flow
                || other.shader_subgroup_uniform_control_flow,
            shader_terminate_invocation: self.shader_terminate_invocation
                || other.shader_terminate_invocation,
            shader_tessellation_and_geometry_point_size: self
                .shader_tessellation_and_geometry_point_size
                || other.shader_tessellation_and_geometry_point_size,
            shader_tile_image_color_read_access: self.shader_tile_image_color_read_access
                || other.shader_tile_image_color_read_access,
            shader_tile_image_depth_read_access: self.shader_tile_image_depth_read_access
                || other.shader_tile_image_depth_read_access,
            shader_tile_image_stencil_read_access: self
                .shader_tile_image_stencil_read_access
                || other.shader_tile_image_stencil_read_access,
            shader_uniform_buffer_array_dynamic_indexing: self
                .shader_uniform_buffer_array_dynamic_indexing
                || other.shader_uniform_buffer_array_dynamic_indexing,
            shader_uniform_buffer_array_non_uniform_indexing: self
                .shader_uniform_buffer_array_non_uniform_indexing
                || other.shader_uniform_buffer_array_non_uniform_indexing,
            shader_uniform_texel_buffer_array_dynamic_indexing: self
                .shader_uniform_texel_buffer_array_dynamic_indexing
                || other.shader_uniform_texel_buffer_array_dynamic_indexing,
            shader_uniform_texel_buffer_array_non_uniform_indexing: self
                .shader_uniform_texel_buffer_array_non_uniform_indexing
                || other.shader_uniform_texel_buffer_array_non_uniform_indexing,
            shader_zero_initialize_workgroup_memory: self
                .shader_zero_initialize_workgroup_memory
                || other.shader_zero_initialize_workgroup_memory,
            shading_rate_coarse_sample_order: self.shading_rate_coarse_sample_order
                || other.shading_rate_coarse_sample_order,
            shading_rate_image: self.shading_rate_image || other.shading_rate_image,
            smooth_lines: self.smooth_lines || other.smooth_lines,
            sparse_binding: self.sparse_binding || other.sparse_binding,
            sparse_image_float32_atomic_add: self.sparse_image_float32_atomic_add
                || other.sparse_image_float32_atomic_add,
            sparse_image_float32_atomic_min_max: self.sparse_image_float32_atomic_min_max
                || other.sparse_image_float32_atomic_min_max,
            sparse_image_float32_atomics: self.sparse_image_float32_atomics
                || other.sparse_image_float32_atomics,
            sparse_image_int64_atomics: self.sparse_image_int64_atomics
                || other.sparse_image_int64_atomics,
            sparse_residency16_samples: self.sparse_residency16_samples
                || other.sparse_residency16_samples,
            sparse_residency2_samples: self.sparse_residency2_samples
                || other.sparse_residency2_samples,
            sparse_residency4_samples: self.sparse_residency4_samples
                || other.sparse_residency4_samples,
            sparse_residency8_samples: self.sparse_residency8_samples
                || other.sparse_residency8_samples,
            sparse_residency_aliased: self.sparse_residency_aliased
                || other.sparse_residency_aliased,
            sparse_residency_buffer: self.sparse_residency_buffer
                || other.sparse_residency_buffer,
            sparse_residency_image2_d: self.sparse_residency_image2_d
                || other.sparse_residency_image2_d,
            sparse_residency_image3_d: self.sparse_residency_image3_d
                || other.sparse_residency_image3_d,
            stippled_bresenham_lines: self.stippled_bresenham_lines
                || other.stippled_bresenham_lines,
            stippled_rectangular_lines: self.stippled_rectangular_lines
                || other.stippled_rectangular_lines,
            stippled_smooth_lines: self.stippled_smooth_lines
                || other.stippled_smooth_lines,
            storage_buffer16_bit_access: self.storage_buffer16_bit_access
                || other.storage_buffer16_bit_access,
            storage_buffer8_bit_access: self.storage_buffer8_bit_access
                || other.storage_buffer8_bit_access,
            storage_input_output16: self.storage_input_output16
                || other.storage_input_output16,
            storage_push_constant16: self.storage_push_constant16
                || other.storage_push_constant16,
            storage_push_constant8: self.storage_push_constant8
                || other.storage_push_constant8,
            subgroup_broadcast_dynamic_id: self.subgroup_broadcast_dynamic_id
                || other.subgroup_broadcast_dynamic_id,
            subgroup_size_control: self.subgroup_size_control
                || other.subgroup_size_control,
            subpass_merge_feedback: self.subpass_merge_feedback
                || other.subpass_merge_feedback,
            subpass_shading: self.subpass_shading || other.subpass_shading,
            supersample_fragment_shading_rates: self.supersample_fragment_shading_rates
                || other.supersample_fragment_shading_rates,
            swapchain_maintenance1: self.swapchain_maintenance1
                || other.swapchain_maintenance1,
            synchronization2: self.synchronization2 || other.synchronization2,
            task_shader: self.task_shader || other.task_shader,
            tessellation_isolines: self.tessellation_isolines
                || other.tessellation_isolines,
            tessellation_point_mode: self.tessellation_point_mode
                || other.tessellation_point_mode,
            tessellation_shader: self.tessellation_shader || other.tessellation_shader,
            texel_buffer_alignment: self.texel_buffer_alignment
                || other.texel_buffer_alignment,
            texture_block_match: self.texture_block_match || other.texture_block_match,
            texture_block_match2: self.texture_block_match2
                || other.texture_block_match2,
            texture_box_filter: self.texture_box_filter || other.texture_box_filter,
            texture_compression_astc_hdr: self.texture_compression_astc_hdr
                || other.texture_compression_astc_hdr,
            texture_compression_astc_ldr: self.texture_compression_astc_ldr
                || other.texture_compression_astc_ldr,
            texture_compression_bc: self.texture_compression_bc
                || other.texture_compression_bc,
            texture_compression_etc2: self.texture_compression_etc2
                || other.texture_compression_etc2,
            texture_sample_weighted: self.texture_sample_weighted
                || other.texture_sample_weighted,
            tile_properties: self.tile_properties || other.tile_properties,
            timeline_semaphore: self.timeline_semaphore || other.timeline_semaphore,
            transform_feedback: self.transform_feedback || other.transform_feedback,
            transform_feedback_preserves_provoking_vertex: self
                .transform_feedback_preserves_provoking_vertex
                || other.transform_feedback_preserves_provoking_vertex,
            triangle_fans: self.triangle_fans || other.triangle_fans,
            uniform_and_storage_buffer16_bit_access: self
                .uniform_and_storage_buffer16_bit_access
                || other.uniform_and_storage_buffer16_bit_access,
            uniform_and_storage_buffer8_bit_access: self
                .uniform_and_storage_buffer8_bit_access
                || other.uniform_and_storage_buffer8_bit_access,
            uniform_buffer_standard_layout: self.uniform_buffer_standard_layout
                || other.uniform_buffer_standard_layout,
            variable_multisample_rate: self.variable_multisample_rate
                || other.variable_multisample_rate,
            variable_pointers: self.variable_pointers || other.variable_pointers,
            variable_pointers_storage_buffer: self.variable_pointers_storage_buffer
                || other.variable_pointers_storage_buffer,
            vertex_attribute_access_beyond_stride: self
                .vertex_attribute_access_beyond_stride
                || other.vertex_attribute_access_beyond_stride,
            vertex_attribute_instance_rate_divisor: self
                .vertex_attribute_instance_rate_divisor
                || other.vertex_attribute_instance_rate_divisor,
            vertex_attribute_instance_rate_zero_divisor: self
                .vertex_attribute_instance_rate_zero_divisor
                || other.vertex_attribute_instance_rate_zero_divisor,
            vertex_input_dynamic_state: self.vertex_input_dynamic_state
                || other.vertex_input_dynamic_state,
            vertex_pipeline_stores_and_atomics: self.vertex_pipeline_stores_and_atomics
                || other.vertex_pipeline_stores_and_atomics,
            video_maintenance1: self.video_maintenance1 || other.video_maintenance1,
            vulkan_memory_model: self.vulkan_memory_model || other.vulkan_memory_model,
            vulkan_memory_model_availability_visibility_chains: self
                .vulkan_memory_model_availability_visibility_chains
                || other.vulkan_memory_model_availability_visibility_chains,
            vulkan_memory_model_device_scope: self.vulkan_memory_model_device_scope
                || other.vulkan_memory_model_device_scope,
            wide_lines: self.wide_lines || other.wide_lines,
            workgroup_memory_explicit_layout: self.workgroup_memory_explicit_layout
                || other.workgroup_memory_explicit_layout,
            workgroup_memory_explicit_layout16_bit_access: self
                .workgroup_memory_explicit_layout16_bit_access
                || other.workgroup_memory_explicit_layout16_bit_access,
            workgroup_memory_explicit_layout8_bit_access: self
                .workgroup_memory_explicit_layout8_bit_access
                || other.workgroup_memory_explicit_layout8_bit_access,
            workgroup_memory_explicit_layout_scalar_block_layout: self
                .workgroup_memory_explicit_layout_scalar_block_layout
                || other.workgroup_memory_explicit_layout_scalar_block_layout,
            ycbcr2plane444_formats: self.ycbcr2plane444_formats
                || other.ycbcr2plane444_formats,
            ycbcr_degamma: self.ycbcr_degamma || other.ycbcr_degamma,
            ycbcr_image_arrays: self.ycbcr_image_arrays || other.ycbcr_image_arrays,
            _ne: crate::NonExhaustive(()),
        }
    }
    /// Returns the intersection of `self` and `other`.
    #[inline]
    pub const fn intersection(&self, other: &Self) -> Self {
        Self {
            acceleration_structure: self.acceleration_structure
                && other.acceleration_structure,
            acceleration_structure_capture_replay: self
                .acceleration_structure_capture_replay
                && other.acceleration_structure_capture_replay,
            acceleration_structure_host_commands: self
                .acceleration_structure_host_commands
                && other.acceleration_structure_host_commands,
            acceleration_structure_indirect_build: self
                .acceleration_structure_indirect_build
                && other.acceleration_structure_indirect_build,
            advanced_blend_coherent_operations: self.advanced_blend_coherent_operations
                && other.advanced_blend_coherent_operations,
            alpha_to_one: self.alpha_to_one && other.alpha_to_one,
            amigo_profiling: self.amigo_profiling && other.amigo_profiling,
            attachment_feedback_loop_dynamic_state: self
                .attachment_feedback_loop_dynamic_state
                && other.attachment_feedback_loop_dynamic_state,
            attachment_feedback_loop_layout: self.attachment_feedback_loop_layout
                && other.attachment_feedback_loop_layout,
            attachment_fragment_shading_rate: self.attachment_fragment_shading_rate
                && other.attachment_fragment_shading_rate,
            border_color_swizzle: self.border_color_swizzle
                && other.border_color_swizzle,
            border_color_swizzle_from_image: self.border_color_swizzle_from_image
                && other.border_color_swizzle_from_image,
            bresenham_lines: self.bresenham_lines && other.bresenham_lines,
            buffer_device_address: self.buffer_device_address
                && other.buffer_device_address,
            buffer_device_address_capture_replay: self
                .buffer_device_address_capture_replay
                && other.buffer_device_address_capture_replay,
            buffer_device_address_multi_device: self.buffer_device_address_multi_device
                && other.buffer_device_address_multi_device,
            clusterculling_shader: self.clusterculling_shader
                && other.clusterculling_shader,
            color_write_enable: self.color_write_enable && other.color_write_enable,
            compute_derivative_group_linear: self.compute_derivative_group_linear
                && other.compute_derivative_group_linear,
            compute_derivative_group_quads: self.compute_derivative_group_quads
                && other.compute_derivative_group_quads,
            compute_full_subgroups: self.compute_full_subgroups
                && other.compute_full_subgroups,
            conditional_rendering: self.conditional_rendering
                && other.conditional_rendering,
            constant_alpha_color_blend_factors: self.constant_alpha_color_blend_factors
                && other.constant_alpha_color_blend_factors,
            cooperative_matrix: self.cooperative_matrix && other.cooperative_matrix,
            cooperative_matrix_robust_buffer_access: self
                .cooperative_matrix_robust_buffer_access
                && other.cooperative_matrix_robust_buffer_access,
            corner_sampled_image: self.corner_sampled_image
                && other.corner_sampled_image,
            coverage_reduction_mode: self.coverage_reduction_mode
                && other.coverage_reduction_mode,
            cubic_range_clamp: self.cubic_range_clamp && other.cubic_range_clamp,
            cuda_kernel_launch_features: self.cuda_kernel_launch_features
                && other.cuda_kernel_launch_features,
            custom_border_color_without_format: self.custom_border_color_without_format
                && other.custom_border_color_without_format,
            custom_border_colors: self.custom_border_colors
                && other.custom_border_colors,
            decode_mode_shared_exponent: self.decode_mode_shared_exponent
                && other.decode_mode_shared_exponent,
            dedicated_allocation_image_aliasing: self.dedicated_allocation_image_aliasing
                && other.dedicated_allocation_image_aliasing,
            depth_bias_clamp: self.depth_bias_clamp && other.depth_bias_clamp,
            depth_bias_control: self.depth_bias_control && other.depth_bias_control,
            depth_bias_exact: self.depth_bias_exact && other.depth_bias_exact,
            depth_bounds: self.depth_bounds && other.depth_bounds,
            depth_clamp: self.depth_clamp && other.depth_clamp,
            depth_clamp_zero_one: self.depth_clamp_zero_one
                && other.depth_clamp_zero_one,
            depth_clip_control: self.depth_clip_control && other.depth_clip_control,
            depth_clip_enable: self.depth_clip_enable && other.depth_clip_enable,
            descriptor_binding_acceleration_structure_update_after_bind: self
                .descriptor_binding_acceleration_structure_update_after_bind
                && other.descriptor_binding_acceleration_structure_update_after_bind,
            descriptor_binding_inline_uniform_block_update_after_bind: self
                .descriptor_binding_inline_uniform_block_update_after_bind
                && other.descriptor_binding_inline_uniform_block_update_after_bind,
            descriptor_binding_partially_bound: self.descriptor_binding_partially_bound
                && other.descriptor_binding_partially_bound,
            descriptor_binding_sampled_image_update_after_bind: self
                .descriptor_binding_sampled_image_update_after_bind
                && other.descriptor_binding_sampled_image_update_after_bind,
            descriptor_binding_storage_buffer_update_after_bind: self
                .descriptor_binding_storage_buffer_update_after_bind
                && other.descriptor_binding_storage_buffer_update_after_bind,
            descriptor_binding_storage_image_update_after_bind: self
                .descriptor_binding_storage_image_update_after_bind
                && other.descriptor_binding_storage_image_update_after_bind,
            descriptor_binding_storage_texel_buffer_update_after_bind: self
                .descriptor_binding_storage_texel_buffer_update_after_bind
                && other.descriptor_binding_storage_texel_buffer_update_after_bind,
            descriptor_binding_uniform_buffer_update_after_bind: self
                .descriptor_binding_uniform_buffer_update_after_bind
                && other.descriptor_binding_uniform_buffer_update_after_bind,
            descriptor_binding_uniform_texel_buffer_update_after_bind: self
                .descriptor_binding_uniform_texel_buffer_update_after_bind
                && other.descriptor_binding_uniform_texel_buffer_update_after_bind,
            descriptor_binding_update_unused_while_pending: self
                .descriptor_binding_update_unused_while_pending
                && other.descriptor_binding_update_unused_while_pending,
            descriptor_binding_variable_descriptor_count: self
                .descriptor_binding_variable_descriptor_count
                && other.descriptor_binding_variable_descriptor_count,
            descriptor_buffer: self.descriptor_buffer && other.descriptor_buffer,
            descriptor_buffer_capture_replay: self.descriptor_buffer_capture_replay
                && other.descriptor_buffer_capture_replay,
            descriptor_buffer_image_layout_ignored: self
                .descriptor_buffer_image_layout_ignored
                && other.descriptor_buffer_image_layout_ignored,
            descriptor_buffer_push_descriptors: self.descriptor_buffer_push_descriptors
                && other.descriptor_buffer_push_descriptors,
            descriptor_indexing: self.descriptor_indexing && other.descriptor_indexing,
            descriptor_pool_overallocation: self.descriptor_pool_overallocation
                && other.descriptor_pool_overallocation,
            descriptor_set_host_mapping: self.descriptor_set_host_mapping
                && other.descriptor_set_host_mapping,
            device_coherent_memory: self.device_coherent_memory
                && other.device_coherent_memory,
            device_fault: self.device_fault && other.device_fault,
            device_fault_vendor_binary: self.device_fault_vendor_binary
                && other.device_fault_vendor_binary,
            device_generated_commands: self.device_generated_commands
                && other.device_generated_commands,
            device_generated_compute: self.device_generated_compute
                && other.device_generated_compute,
            device_generated_compute_capture_replay: self
                .device_generated_compute_capture_replay
                && other.device_generated_compute_capture_replay,
            device_generated_compute_pipelines: self.device_generated_compute_pipelines
                && other.device_generated_compute_pipelines,
            device_memory_report: self.device_memory_report
                && other.device_memory_report,
            diagnostics_config: self.diagnostics_config && other.diagnostics_config,
            displacement_micromap: self.displacement_micromap
                && other.displacement_micromap,
            draw_indirect_count: self.draw_indirect_count && other.draw_indirect_count,
            draw_indirect_first_instance: self.draw_indirect_first_instance
                && other.draw_indirect_first_instance,
            dual_src_blend: self.dual_src_blend && other.dual_src_blend,
            dynamic_pipeline_layout: self.dynamic_pipeline_layout
                && other.dynamic_pipeline_layout,
            dynamic_rendering: self.dynamic_rendering && other.dynamic_rendering,
            dynamic_rendering_local_read: self.dynamic_rendering_local_read
                && other.dynamic_rendering_local_read,
            dynamic_rendering_unused_attachments: self
                .dynamic_rendering_unused_attachments
                && other.dynamic_rendering_unused_attachments,
            events: self.events && other.events,
            exclusive_scissor: self.exclusive_scissor && other.exclusive_scissor,
            extended_dynamic_state: self.extended_dynamic_state
                && other.extended_dynamic_state,
            extended_dynamic_state2: self.extended_dynamic_state2
                && other.extended_dynamic_state2,
            extended_dynamic_state2_logic_op: self.extended_dynamic_state2_logic_op
                && other.extended_dynamic_state2_logic_op,
            extended_dynamic_state2_patch_control_points: self
                .extended_dynamic_state2_patch_control_points
                && other.extended_dynamic_state2_patch_control_points,
            extended_dynamic_state3_alpha_to_coverage_enable: self
                .extended_dynamic_state3_alpha_to_coverage_enable
                && other.extended_dynamic_state3_alpha_to_coverage_enable,
            extended_dynamic_state3_alpha_to_one_enable: self
                .extended_dynamic_state3_alpha_to_one_enable
                && other.extended_dynamic_state3_alpha_to_one_enable,
            extended_dynamic_state3_color_blend_advanced: self
                .extended_dynamic_state3_color_blend_advanced
                && other.extended_dynamic_state3_color_blend_advanced,
            extended_dynamic_state3_color_blend_enable: self
                .extended_dynamic_state3_color_blend_enable
                && other.extended_dynamic_state3_color_blend_enable,
            extended_dynamic_state3_color_blend_equation: self
                .extended_dynamic_state3_color_blend_equation
                && other.extended_dynamic_state3_color_blend_equation,
            extended_dynamic_state3_color_write_mask: self
                .extended_dynamic_state3_color_write_mask
                && other.extended_dynamic_state3_color_write_mask,
            extended_dynamic_state3_conservative_rasterization_mode: self
                .extended_dynamic_state3_conservative_rasterization_mode
                && other.extended_dynamic_state3_conservative_rasterization_mode,
            extended_dynamic_state3_coverage_modulation_mode: self
                .extended_dynamic_state3_coverage_modulation_mode
                && other.extended_dynamic_state3_coverage_modulation_mode,
            extended_dynamic_state3_coverage_modulation_table: self
                .extended_dynamic_state3_coverage_modulation_table
                && other.extended_dynamic_state3_coverage_modulation_table,
            extended_dynamic_state3_coverage_modulation_table_enable: self
                .extended_dynamic_state3_coverage_modulation_table_enable
                && other.extended_dynamic_state3_coverage_modulation_table_enable,
            extended_dynamic_state3_coverage_reduction_mode: self
                .extended_dynamic_state3_coverage_reduction_mode
                && other.extended_dynamic_state3_coverage_reduction_mode,
            extended_dynamic_state3_coverage_to_color_enable: self
                .extended_dynamic_state3_coverage_to_color_enable
                && other.extended_dynamic_state3_coverage_to_color_enable,
            extended_dynamic_state3_coverage_to_color_location: self
                .extended_dynamic_state3_coverage_to_color_location
                && other.extended_dynamic_state3_coverage_to_color_location,
            extended_dynamic_state3_depth_clamp_enable: self
                .extended_dynamic_state3_depth_clamp_enable
                && other.extended_dynamic_state3_depth_clamp_enable,
            extended_dynamic_state3_depth_clip_enable: self
                .extended_dynamic_state3_depth_clip_enable
                && other.extended_dynamic_state3_depth_clip_enable,
            extended_dynamic_state3_depth_clip_negative_one_to_one: self
                .extended_dynamic_state3_depth_clip_negative_one_to_one
                && other.extended_dynamic_state3_depth_clip_negative_one_to_one,
            extended_dynamic_state3_extra_primitive_overestimation_size: self
                .extended_dynamic_state3_extra_primitive_overestimation_size
                && other.extended_dynamic_state3_extra_primitive_overestimation_size,
            extended_dynamic_state3_line_rasterization_mode: self
                .extended_dynamic_state3_line_rasterization_mode
                && other.extended_dynamic_state3_line_rasterization_mode,
            extended_dynamic_state3_line_stipple_enable: self
                .extended_dynamic_state3_line_stipple_enable
                && other.extended_dynamic_state3_line_stipple_enable,
            extended_dynamic_state3_logic_op_enable: self
                .extended_dynamic_state3_logic_op_enable
                && other.extended_dynamic_state3_logic_op_enable,
            extended_dynamic_state3_polygon_mode: self
                .extended_dynamic_state3_polygon_mode
                && other.extended_dynamic_state3_polygon_mode,
            extended_dynamic_state3_provoking_vertex_mode: self
                .extended_dynamic_state3_provoking_vertex_mode
                && other.extended_dynamic_state3_provoking_vertex_mode,
            extended_dynamic_state3_rasterization_samples: self
                .extended_dynamic_state3_rasterization_samples
                && other.extended_dynamic_state3_rasterization_samples,
            extended_dynamic_state3_rasterization_stream: self
                .extended_dynamic_state3_rasterization_stream
                && other.extended_dynamic_state3_rasterization_stream,
            extended_dynamic_state3_representative_fragment_test_enable: self
                .extended_dynamic_state3_representative_fragment_test_enable
                && other.extended_dynamic_state3_representative_fragment_test_enable,
            extended_dynamic_state3_sample_locations_enable: self
                .extended_dynamic_state3_sample_locations_enable
                && other.extended_dynamic_state3_sample_locations_enable,
            extended_dynamic_state3_sample_mask: self.extended_dynamic_state3_sample_mask
                && other.extended_dynamic_state3_sample_mask,
            extended_dynamic_state3_shading_rate_image_enable: self
                .extended_dynamic_state3_shading_rate_image_enable
                && other.extended_dynamic_state3_shading_rate_image_enable,
            extended_dynamic_state3_tessellation_domain_origin: self
                .extended_dynamic_state3_tessellation_domain_origin
                && other.extended_dynamic_state3_tessellation_domain_origin,
            extended_dynamic_state3_viewport_swizzle: self
                .extended_dynamic_state3_viewport_swizzle
                && other.extended_dynamic_state3_viewport_swizzle,
            extended_dynamic_state3_viewport_w_scaling_enable: self
                .extended_dynamic_state3_viewport_w_scaling_enable
                && other.extended_dynamic_state3_viewport_w_scaling_enable,
            extended_sparse_address_space: self.extended_sparse_address_space
                && other.extended_sparse_address_space,
            external_format_resolve: self.external_format_resolve
                && other.external_format_resolve,
            external_memory_rdma: self.external_memory_rdma
                && other.external_memory_rdma,
            fill_mode_non_solid: self.fill_mode_non_solid && other.fill_mode_non_solid,
            float_representation: self.float_representation
                && other.float_representation,
            format_a4b4g4r4: self.format_a4b4g4r4 && other.format_a4b4g4r4,
            format_a4r4g4b4: self.format_a4r4g4b4 && other.format_a4r4g4b4,
            format_rgba10x6_without_y_cb_cr_sampler: self
                .format_rgba10x6_without_y_cb_cr_sampler
                && other.format_rgba10x6_without_y_cb_cr_sampler,
            fragment_density_map: self.fragment_density_map
                && other.fragment_density_map,
            fragment_density_map_deferred: self.fragment_density_map_deferred
                && other.fragment_density_map_deferred,
            fragment_density_map_dynamic: self.fragment_density_map_dynamic
                && other.fragment_density_map_dynamic,
            fragment_density_map_non_subsampled_images: self
                .fragment_density_map_non_subsampled_images
                && other.fragment_density_map_non_subsampled_images,
            fragment_density_map_offset: self.fragment_density_map_offset
                && other.fragment_density_map_offset,
            fragment_shader_barycentric: self.fragment_shader_barycentric
                && other.fragment_shader_barycentric,
            fragment_shader_pixel_interlock: self.fragment_shader_pixel_interlock
                && other.fragment_shader_pixel_interlock,
            fragment_shader_sample_interlock: self.fragment_shader_sample_interlock
                && other.fragment_shader_sample_interlock,
            fragment_shader_shading_rate_interlock: self
                .fragment_shader_shading_rate_interlock
                && other.fragment_shader_shading_rate_interlock,
            fragment_shading_rate_enums: self.fragment_shading_rate_enums
                && other.fragment_shading_rate_enums,
            fragment_stores_and_atomics: self.fragment_stores_and_atomics
                && other.fragment_stores_and_atomics,
            frame_boundary: self.frame_boundary && other.frame_boundary,
            full_draw_index_uint32: self.full_draw_index_uint32
                && other.full_draw_index_uint32,
            geometry_shader: self.geometry_shader && other.geometry_shader,
            geometry_streams: self.geometry_streams && other.geometry_streams,
            global_priority_query: self.global_priority_query
                && other.global_priority_query,
            graphics_pipeline_library: self.graphics_pipeline_library
                && other.graphics_pipeline_library,
            host_image_copy: self.host_image_copy && other.host_image_copy,
            host_query_reset: self.host_query_reset && other.host_query_reset,
            image2_d_view_of3_d: self.image2_d_view_of3_d && other.image2_d_view_of3_d,
            image_compression_control: self.image_compression_control
                && other.image_compression_control,
            image_compression_control_swapchain: self.image_compression_control_swapchain
                && other.image_compression_control_swapchain,
            image_cube_array: self.image_cube_array && other.image_cube_array,
            image_footprint: self.image_footprint && other.image_footprint,
            image_sliced_view_of3_d: self.image_sliced_view_of3_d
                && other.image_sliced_view_of3_d,
            image_view2_d_on3_d_image: self.image_view2_d_on3_d_image
                && other.image_view2_d_on3_d_image,
            image_view_format_reinterpretation: self.image_view_format_reinterpretation
                && other.image_view_format_reinterpretation,
            image_view_format_swizzle: self.image_view_format_swizzle
                && other.image_view_format_swizzle,
            imageless_framebuffer: self.imageless_framebuffer
                && other.imageless_framebuffer,
            independent_blend: self.independent_blend && other.independent_blend,
            index_type_uint8: self.index_type_uint8 && other.index_type_uint8,
            indirect_copy: self.indirect_copy && other.indirect_copy,
            inherited_conditional_rendering: self.inherited_conditional_rendering
                && other.inherited_conditional_rendering,
            inherited_queries: self.inherited_queries && other.inherited_queries,
            inherited_viewport_scissor2_d: self.inherited_viewport_scissor2_d
                && other.inherited_viewport_scissor2_d,
            inline_uniform_block: self.inline_uniform_block
                && other.inline_uniform_block,
            invocation_mask: self.invocation_mask && other.invocation_mask,
            large_points: self.large_points && other.large_points,
            least_representable_value_force_unorm_representation: self
                .least_representable_value_force_unorm_representation
                && other.least_representable_value_force_unorm_representation,
            legacy_dithering: self.legacy_dithering && other.legacy_dithering,
            linear_color_attachment: self.linear_color_attachment
                && other.linear_color_attachment,
            logic_op: self.logic_op && other.logic_op,
            maintenance4: self.maintenance4 && other.maintenance4,
            maintenance5: self.maintenance5 && other.maintenance5,
            maintenance6: self.maintenance6 && other.maintenance6,
            memory_decompression: self.memory_decompression
                && other.memory_decompression,
            memory_map_placed: self.memory_map_placed && other.memory_map_placed,
            memory_map_range_placed: self.memory_map_range_placed
                && other.memory_map_range_placed,
            memory_priority: self.memory_priority && other.memory_priority,
            memory_unmap_reserve: self.memory_unmap_reserve
                && other.memory_unmap_reserve,
            mesh_shader: self.mesh_shader && other.mesh_shader,
            mesh_shader_queries: self.mesh_shader_queries && other.mesh_shader_queries,
            micromap: self.micromap && other.micromap,
            micromap_capture_replay: self.micromap_capture_replay
                && other.micromap_capture_replay,
            micromap_host_commands: self.micromap_host_commands
                && other.micromap_host_commands,
            min_lod: self.min_lod && other.min_lod,
            multi_draw: self.multi_draw && other.multi_draw,
            multi_draw_indirect: self.multi_draw_indirect && other.multi_draw_indirect,
            multi_viewport: self.multi_viewport && other.multi_viewport,
            multisample_array_image: self.multisample_array_image
                && other.multisample_array_image,
            multisampled_render_to_single_sampled: self
                .multisampled_render_to_single_sampled
                && other.multisampled_render_to_single_sampled,
            multiview: self.multiview && other.multiview,
            multiview_cluster_culling_shader: self.multiview_cluster_culling_shader
                && other.multiview_cluster_culling_shader,
            multiview_geometry_shader: self.multiview_geometry_shader
                && other.multiview_geometry_shader,
            multiview_mesh_shader: self.multiview_mesh_shader
                && other.multiview_mesh_shader,
            multiview_per_view_render_areas: self.multiview_per_view_render_areas
                && other.multiview_per_view_render_areas,
            multiview_per_view_viewports: self.multiview_per_view_viewports
                && other.multiview_per_view_viewports,
            multiview_tessellation_shader: self.multiview_tessellation_shader
                && other.multiview_tessellation_shader,
            mutable_comparison_samplers: self.mutable_comparison_samplers
                && other.mutable_comparison_samplers,
            mutable_descriptor_type: self.mutable_descriptor_type
                && other.mutable_descriptor_type,
            nested_command_buffer: self.nested_command_buffer
                && other.nested_command_buffer,
            nested_command_buffer_rendering: self.nested_command_buffer_rendering
                && other.nested_command_buffer_rendering,
            nested_command_buffer_simultaneous_use: self
                .nested_command_buffer_simultaneous_use
                && other.nested_command_buffer_simultaneous_use,
            no_invocation_fragment_shading_rates: self
                .no_invocation_fragment_shading_rates
                && other.no_invocation_fragment_shading_rates,
            non_seamless_cube_map: self.non_seamless_cube_map
                && other.non_seamless_cube_map,
            null_descriptor: self.null_descriptor && other.null_descriptor,
            occlusion_query_precise: self.occlusion_query_precise
                && other.occlusion_query_precise,
            optical_flow: self.optical_flow && other.optical_flow,
            pageable_device_local_memory: self.pageable_device_local_memory
                && other.pageable_device_local_memory,
            per_stage_descriptor_set: self.per_stage_descriptor_set
                && other.per_stage_descriptor_set,
            performance_counter_multiple_query_pools: self
                .performance_counter_multiple_query_pools
                && other.performance_counter_multiple_query_pools,
            performance_counter_query_pools: self.performance_counter_query_pools
                && other.performance_counter_query_pools,
            pipeline_creation_cache_control: self.pipeline_creation_cache_control
                && other.pipeline_creation_cache_control,
            pipeline_executable_info: self.pipeline_executable_info
                && other.pipeline_executable_info,
            pipeline_fragment_shading_rate: self.pipeline_fragment_shading_rate
                && other.pipeline_fragment_shading_rate,
            pipeline_library_group_handles: self.pipeline_library_group_handles
                && other.pipeline_library_group_handles,
            pipeline_properties_identifier: self.pipeline_properties_identifier
                && other.pipeline_properties_identifier,
            pipeline_protected_access: self.pipeline_protected_access
                && other.pipeline_protected_access,
            pipeline_robustness: self.pipeline_robustness && other.pipeline_robustness,
            pipeline_statistics_query: self.pipeline_statistics_query
                && other.pipeline_statistics_query,
            point_polygons: self.point_polygons && other.point_polygons,
            present_barrier: self.present_barrier && other.present_barrier,
            present_id: self.present_id && other.present_id,
            present_wait: self.present_wait && other.present_wait,
            primitive_fragment_shading_rate: self.primitive_fragment_shading_rate
                && other.primitive_fragment_shading_rate,
            primitive_fragment_shading_rate_mesh_shader: self
                .primitive_fragment_shading_rate_mesh_shader
                && other.primitive_fragment_shading_rate_mesh_shader,
            primitive_topology_list_restart: self.primitive_topology_list_restart
                && other.primitive_topology_list_restart,
            primitive_topology_patch_list_restart: self
                .primitive_topology_patch_list_restart
                && other.primitive_topology_patch_list_restart,
            primitives_generated_query: self.primitives_generated_query
                && other.primitives_generated_query,
            primitives_generated_query_with_non_zero_streams: self
                .primitives_generated_query_with_non_zero_streams
                && other.primitives_generated_query_with_non_zero_streams,
            primitives_generated_query_with_rasterizer_discard: self
                .primitives_generated_query_with_rasterizer_discard
                && other.primitives_generated_query_with_rasterizer_discard,
            private_data: self.private_data && other.private_data,
            protected_memory: self.protected_memory && other.protected_memory,
            provoking_vertex_last: self.provoking_vertex_last
                && other.provoking_vertex_last,
            rasterization_order_color_attachment_access: self
                .rasterization_order_color_attachment_access
                && other.rasterization_order_color_attachment_access,
            rasterization_order_depth_attachment_access: self
                .rasterization_order_depth_attachment_access
                && other.rasterization_order_depth_attachment_access,
            rasterization_order_stencil_attachment_access: self
                .rasterization_order_stencil_attachment_access
                && other.rasterization_order_stencil_attachment_access,
            ray_query: self.ray_query && other.ray_query,
            ray_tracing_invocation_reorder: self.ray_tracing_invocation_reorder
                && other.ray_tracing_invocation_reorder,
            ray_tracing_maintenance1: self.ray_tracing_maintenance1
                && other.ray_tracing_maintenance1,
            ray_tracing_motion_blur: self.ray_tracing_motion_blur
                && other.ray_tracing_motion_blur,
            ray_tracing_motion_blur_pipeline_trace_rays_indirect: self
                .ray_tracing_motion_blur_pipeline_trace_rays_indirect
                && other.ray_tracing_motion_blur_pipeline_trace_rays_indirect,
            ray_tracing_pipeline: self.ray_tracing_pipeline
                && other.ray_tracing_pipeline,
            ray_tracing_pipeline_shader_group_handle_capture_replay: self
                .ray_tracing_pipeline_shader_group_handle_capture_replay
                && other.ray_tracing_pipeline_shader_group_handle_capture_replay,
            ray_tracing_pipeline_shader_group_handle_capture_replay_mixed: self
                .ray_tracing_pipeline_shader_group_handle_capture_replay_mixed
                && other.ray_tracing_pipeline_shader_group_handle_capture_replay_mixed,
            ray_tracing_pipeline_trace_rays_indirect: self
                .ray_tracing_pipeline_trace_rays_indirect
                && other.ray_tracing_pipeline_trace_rays_indirect,
            ray_tracing_pipeline_trace_rays_indirect2: self
                .ray_tracing_pipeline_trace_rays_indirect2
                && other.ray_tracing_pipeline_trace_rays_indirect2,
            ray_tracing_position_fetch: self.ray_tracing_position_fetch
                && other.ray_tracing_position_fetch,
            ray_tracing_validation: self.ray_tracing_validation
                && other.ray_tracing_validation,
            ray_traversal_primitive_culling: self.ray_traversal_primitive_culling
                && other.ray_traversal_primitive_culling,
            rectangular_lines: self.rectangular_lines && other.rectangular_lines,
            relaxed_line_rasterization: self.relaxed_line_rasterization
                && other.relaxed_line_rasterization,
            render_pass_striped: self.render_pass_striped && other.render_pass_striped,
            report_address_binding: self.report_address_binding
                && other.report_address_binding,
            representative_fragment_test: self.representative_fragment_test
                && other.representative_fragment_test,
            robust_buffer_access: self.robust_buffer_access
                && other.robust_buffer_access,
            robust_buffer_access2: self.robust_buffer_access2
                && other.robust_buffer_access2,
            robust_image_access: self.robust_image_access && other.robust_image_access,
            robust_image_access2: self.robust_image_access2
                && other.robust_image_access2,
            runtime_descriptor_array: self.runtime_descriptor_array
                && other.runtime_descriptor_array,
            sample_rate_shading: self.sample_rate_shading && other.sample_rate_shading,
            sampler2_d_view_of3_d: self.sampler2_d_view_of3_d
                && other.sampler2_d_view_of3_d,
            sampler_anisotropy: self.sampler_anisotropy && other.sampler_anisotropy,
            sampler_filter_minmax: self.sampler_filter_minmax
                && other.sampler_filter_minmax,
            sampler_mip_lod_bias: self.sampler_mip_lod_bias
                && other.sampler_mip_lod_bias,
            sampler_mirror_clamp_to_edge: self.sampler_mirror_clamp_to_edge
                && other.sampler_mirror_clamp_to_edge,
            sampler_ycbcr_conversion: self.sampler_ycbcr_conversion
                && other.sampler_ycbcr_conversion,
            scalar_block_layout: self.scalar_block_layout && other.scalar_block_layout,
            scheduling_controls: self.scheduling_controls && other.scheduling_controls,
            screen_buffer_import: self.screen_buffer_import
                && other.screen_buffer_import,
            selectable_cubic_weights: self.selectable_cubic_weights
                && other.selectable_cubic_weights,
            separate_depth_stencil_layouts: self.separate_depth_stencil_layouts
                && other.separate_depth_stencil_layouts,
            separate_stencil_mask_ref: self.separate_stencil_mask_ref
                && other.separate_stencil_mask_ref,
            shader_buffer_float16_atomic_add: self.shader_buffer_float16_atomic_add
                && other.shader_buffer_float16_atomic_add,
            shader_buffer_float16_atomic_min_max: self
                .shader_buffer_float16_atomic_min_max
                && other.shader_buffer_float16_atomic_min_max,
            shader_buffer_float16_atomics: self.shader_buffer_float16_atomics
                && other.shader_buffer_float16_atomics,
            shader_buffer_float32_atomic_add: self.shader_buffer_float32_atomic_add
                && other.shader_buffer_float32_atomic_add,
            shader_buffer_float32_atomic_min_max: self
                .shader_buffer_float32_atomic_min_max
                && other.shader_buffer_float32_atomic_min_max,
            shader_buffer_float32_atomics: self.shader_buffer_float32_atomics
                && other.shader_buffer_float32_atomics,
            shader_buffer_float64_atomic_add: self.shader_buffer_float64_atomic_add
                && other.shader_buffer_float64_atomic_add,
            shader_buffer_float64_atomic_min_max: self
                .shader_buffer_float64_atomic_min_max
                && other.shader_buffer_float64_atomic_min_max,
            shader_buffer_float64_atomics: self.shader_buffer_float64_atomics
                && other.shader_buffer_float64_atomics,
            shader_buffer_int64_atomics: self.shader_buffer_int64_atomics
                && other.shader_buffer_int64_atomics,
            shader_clip_distance: self.shader_clip_distance
                && other.shader_clip_distance,
            shader_core_builtins: self.shader_core_builtins
                && other.shader_core_builtins,
            shader_cull_distance: self.shader_cull_distance
                && other.shader_cull_distance,
            shader_demote_to_helper_invocation: self.shader_demote_to_helper_invocation
                && other.shader_demote_to_helper_invocation,
            shader_device_clock: self.shader_device_clock && other.shader_device_clock,
            shader_draw_parameters: self.shader_draw_parameters
                && other.shader_draw_parameters,
            shader_early_and_late_fragment_tests: self
                .shader_early_and_late_fragment_tests
                && other.shader_early_and_late_fragment_tests,
            shader_enqueue: self.shader_enqueue && other.shader_enqueue,
            shader_expect_assume: self.shader_expect_assume
                && other.shader_expect_assume,
            shader_float16: self.shader_float16 && other.shader_float16,
            shader_float16_vector_atomics: self.shader_float16_vector_atomics
                && other.shader_float16_vector_atomics,
            shader_float64: self.shader_float64 && other.shader_float64,
            shader_float_controls2: self.shader_float_controls2
                && other.shader_float_controls2,
            shader_image_float32_atomic_add: self.shader_image_float32_atomic_add
                && other.shader_image_float32_atomic_add,
            shader_image_float32_atomic_min_max: self.shader_image_float32_atomic_min_max
                && other.shader_image_float32_atomic_min_max,
            shader_image_float32_atomics: self.shader_image_float32_atomics
                && other.shader_image_float32_atomics,
            shader_image_gather_extended: self.shader_image_gather_extended
                && other.shader_image_gather_extended,
            shader_image_int64_atomics: self.shader_image_int64_atomics
                && other.shader_image_int64_atomics,
            shader_input_attachment_array_dynamic_indexing: self
                .shader_input_attachment_array_dynamic_indexing
                && other.shader_input_attachment_array_dynamic_indexing,
            shader_input_attachment_array_non_uniform_indexing: self
                .shader_input_attachment_array_non_uniform_indexing
                && other.shader_input_attachment_array_non_uniform_indexing,
            shader_int16: self.shader_int16 && other.shader_int16,
            shader_int64: self.shader_int64 && other.shader_int64,
            shader_int8: self.shader_int8 && other.shader_int8,
            shader_integer_dot_product: self.shader_integer_dot_product
                && other.shader_integer_dot_product,
            shader_integer_functions2: self.shader_integer_functions2
                && other.shader_integer_functions2,
            shader_maximal_reconvergence: self.shader_maximal_reconvergence
                && other.shader_maximal_reconvergence,
            shader_module_identifier: self.shader_module_identifier
                && other.shader_module_identifier,
            shader_object: self.shader_object && other.shader_object,
            shader_output_layer: self.shader_output_layer && other.shader_output_layer,
            shader_output_viewport_index: self.shader_output_viewport_index
                && other.shader_output_viewport_index,
            shader_quad_control: self.shader_quad_control && other.shader_quad_control,
            shader_raw_access_chains: self.shader_raw_access_chains
                && other.shader_raw_access_chains,
            shader_resource_min_lod: self.shader_resource_min_lod
                && other.shader_resource_min_lod,
            shader_resource_residency: self.shader_resource_residency
                && other.shader_resource_residency,
            shader_sample_rate_interpolation_functions: self
                .shader_sample_rate_interpolation_functions
                && other.shader_sample_rate_interpolation_functions,
            shader_sampled_image_array_dynamic_indexing: self
                .shader_sampled_image_array_dynamic_indexing
                && other.shader_sampled_image_array_dynamic_indexing,
            shader_sampled_image_array_non_uniform_indexing: self
                .shader_sampled_image_array_non_uniform_indexing
                && other.shader_sampled_image_array_non_uniform_indexing,
            shader_shared_float16_atomic_add: self.shader_shared_float16_atomic_add
                && other.shader_shared_float16_atomic_add,
            shader_shared_float16_atomic_min_max: self
                .shader_shared_float16_atomic_min_max
                && other.shader_shared_float16_atomic_min_max,
            shader_shared_float16_atomics: self.shader_shared_float16_atomics
                && other.shader_shared_float16_atomics,
            shader_shared_float32_atomic_add: self.shader_shared_float32_atomic_add
                && other.shader_shared_float32_atomic_add,
            shader_shared_float32_atomic_min_max: self
                .shader_shared_float32_atomic_min_max
                && other.shader_shared_float32_atomic_min_max,
            shader_shared_float32_atomics: self.shader_shared_float32_atomics
                && other.shader_shared_float32_atomics,
            shader_shared_float64_atomic_add: self.shader_shared_float64_atomic_add
                && other.shader_shared_float64_atomic_add,
            shader_shared_float64_atomic_min_max: self
                .shader_shared_float64_atomic_min_max
                && other.shader_shared_float64_atomic_min_max,
            shader_shared_float64_atomics: self.shader_shared_float64_atomics
                && other.shader_shared_float64_atomics,
            shader_shared_int64_atomics: self.shader_shared_int64_atomics
                && other.shader_shared_int64_atomics,
            shader_sm_builtins: self.shader_sm_builtins && other.shader_sm_builtins,
            shader_storage_buffer_array_dynamic_indexing: self
                .shader_storage_buffer_array_dynamic_indexing
                && other.shader_storage_buffer_array_dynamic_indexing,
            shader_storage_buffer_array_non_uniform_indexing: self
                .shader_storage_buffer_array_non_uniform_indexing
                && other.shader_storage_buffer_array_non_uniform_indexing,
            shader_storage_image_array_dynamic_indexing: self
                .shader_storage_image_array_dynamic_indexing
                && other.shader_storage_image_array_dynamic_indexing,
            shader_storage_image_array_non_uniform_indexing: self
                .shader_storage_image_array_non_uniform_indexing
                && other.shader_storage_image_array_non_uniform_indexing,
            shader_storage_image_extended_formats: self
                .shader_storage_image_extended_formats
                && other.shader_storage_image_extended_formats,
            shader_storage_image_multisample: self.shader_storage_image_multisample
                && other.shader_storage_image_multisample,
            shader_storage_image_read_without_format: self
                .shader_storage_image_read_without_format
                && other.shader_storage_image_read_without_format,
            shader_storage_image_write_without_format: self
                .shader_storage_image_write_without_format
                && other.shader_storage_image_write_without_format,
            shader_storage_texel_buffer_array_dynamic_indexing: self
                .shader_storage_texel_buffer_array_dynamic_indexing
                && other.shader_storage_texel_buffer_array_dynamic_indexing,
            shader_storage_texel_buffer_array_non_uniform_indexing: self
                .shader_storage_texel_buffer_array_non_uniform_indexing
                && other.shader_storage_texel_buffer_array_non_uniform_indexing,
            shader_subgroup_clock: self.shader_subgroup_clock
                && other.shader_subgroup_clock,
            shader_subgroup_extended_types: self.shader_subgroup_extended_types
                && other.shader_subgroup_extended_types,
            shader_subgroup_rotate: self.shader_subgroup_rotate
                && other.shader_subgroup_rotate,
            shader_subgroup_rotate_clustered: self.shader_subgroup_rotate_clustered
                && other.shader_subgroup_rotate_clustered,
            shader_subgroup_uniform_control_flow: self
                .shader_subgroup_uniform_control_flow
                && other.shader_subgroup_uniform_control_flow,
            shader_terminate_invocation: self.shader_terminate_invocation
                && other.shader_terminate_invocation,
            shader_tessellation_and_geometry_point_size: self
                .shader_tessellation_and_geometry_point_size
                && other.shader_tessellation_and_geometry_point_size,
            shader_tile_image_color_read_access: self.shader_tile_image_color_read_access
                && other.shader_tile_image_color_read_access,
            shader_tile_image_depth_read_access: self.shader_tile_image_depth_read_access
                && other.shader_tile_image_depth_read_access,
            shader_tile_image_stencil_read_access: self
                .shader_tile_image_stencil_read_access
                && other.shader_tile_image_stencil_read_access,
            shader_uniform_buffer_array_dynamic_indexing: self
                .shader_uniform_buffer_array_dynamic_indexing
                && other.shader_uniform_buffer_array_dynamic_indexing,
            shader_uniform_buffer_array_non_uniform_indexing: self
                .shader_uniform_buffer_array_non_uniform_indexing
                && other.shader_uniform_buffer_array_non_uniform_indexing,
            shader_uniform_texel_buffer_array_dynamic_indexing: self
                .shader_uniform_texel_buffer_array_dynamic_indexing
                && other.shader_uniform_texel_buffer_array_dynamic_indexing,
            shader_uniform_texel_buffer_array_non_uniform_indexing: self
                .shader_uniform_texel_buffer_array_non_uniform_indexing
                && other.shader_uniform_texel_buffer_array_non_uniform_indexing,
            shader_zero_initialize_workgroup_memory: self
                .shader_zero_initialize_workgroup_memory
                && other.shader_zero_initialize_workgroup_memory,
            shading_rate_coarse_sample_order: self.shading_rate_coarse_sample_order
                && other.shading_rate_coarse_sample_order,
            shading_rate_image: self.shading_rate_image && other.shading_rate_image,
            smooth_lines: self.smooth_lines && other.smooth_lines,
            sparse_binding: self.sparse_binding && other.sparse_binding,
            sparse_image_float32_atomic_add: self.sparse_image_float32_atomic_add
                && other.sparse_image_float32_atomic_add,
            sparse_image_float32_atomic_min_max: self.sparse_image_float32_atomic_min_max
                && other.sparse_image_float32_atomic_min_max,
            sparse_image_float32_atomics: self.sparse_image_float32_atomics
                && other.sparse_image_float32_atomics,
            sparse_image_int64_atomics: self.sparse_image_int64_atomics
                && other.sparse_image_int64_atomics,
            sparse_residency16_samples: self.sparse_residency16_samples
                && other.sparse_residency16_samples,
            sparse_residency2_samples: self.sparse_residency2_samples
                && other.sparse_residency2_samples,
            sparse_residency4_samples: self.sparse_residency4_samples
                && other.sparse_residency4_samples,
            sparse_residency8_samples: self.sparse_residency8_samples
                && other.sparse_residency8_samples,
            sparse_residency_aliased: self.sparse_residency_aliased
                && other.sparse_residency_aliased,
            sparse_residency_buffer: self.sparse_residency_buffer
                && other.sparse_residency_buffer,
            sparse_residency_image2_d: self.sparse_residency_image2_d
                && other.sparse_residency_image2_d,
            sparse_residency_image3_d: self.sparse_residency_image3_d
                && other.sparse_residency_image3_d,
            stippled_bresenham_lines: self.stippled_bresenham_lines
                && other.stippled_bresenham_lines,
            stippled_rectangular_lines: self.stippled_rectangular_lines
                && other.stippled_rectangular_lines,
            stippled_smooth_lines: self.stippled_smooth_lines
                && other.stippled_smooth_lines,
            storage_buffer16_bit_access: self.storage_buffer16_bit_access
                && other.storage_buffer16_bit_access,
            storage_buffer8_bit_access: self.storage_buffer8_bit_access
                && other.storage_buffer8_bit_access,
            storage_input_output16: self.storage_input_output16
                && other.storage_input_output16,
            storage_push_constant16: self.storage_push_constant16
                && other.storage_push_constant16,
            storage_push_constant8: self.storage_push_constant8
                && other.storage_push_constant8,
            subgroup_broadcast_dynamic_id: self.subgroup_broadcast_dynamic_id
                && other.subgroup_broadcast_dynamic_id,
            subgroup_size_control: self.subgroup_size_control
                && other.subgroup_size_control,
            subpass_merge_feedback: self.subpass_merge_feedback
                && other.subpass_merge_feedback,
            subpass_shading: self.subpass_shading && other.subpass_shading,
            supersample_fragment_shading_rates: self.supersample_fragment_shading_rates
                && other.supersample_fragment_shading_rates,
            swapchain_maintenance1: self.swapchain_maintenance1
                && other.swapchain_maintenance1,
            synchronization2: self.synchronization2 && other.synchronization2,
            task_shader: self.task_shader && other.task_shader,
            tessellation_isolines: self.tessellation_isolines
                && other.tessellation_isolines,
            tessellation_point_mode: self.tessellation_point_mode
                && other.tessellation_point_mode,
            tessellation_shader: self.tessellation_shader && other.tessellation_shader,
            texel_buffer_alignment: self.texel_buffer_alignment
                && other.texel_buffer_alignment,
            texture_block_match: self.texture_block_match && other.texture_block_match,
            texture_block_match2: self.texture_block_match2
                && other.texture_block_match2,
            texture_box_filter: self.texture_box_filter && other.texture_box_filter,
            texture_compression_astc_hdr: self.texture_compression_astc_hdr
                && other.texture_compression_astc_hdr,
            texture_compression_astc_ldr: self.texture_compression_astc_ldr
                && other.texture_compression_astc_ldr,
            texture_compression_bc: self.texture_compression_bc
                && other.texture_compression_bc,
            texture_compression_etc2: self.texture_compression_etc2
                && other.texture_compression_etc2,
            texture_sample_weighted: self.texture_sample_weighted
                && other.texture_sample_weighted,
            tile_properties: self.tile_properties && other.tile_properties,
            timeline_semaphore: self.timeline_semaphore && other.timeline_semaphore,
            transform_feedback: self.transform_feedback && other.transform_feedback,
            transform_feedback_preserves_provoking_vertex: self
                .transform_feedback_preserves_provoking_vertex
                && other.transform_feedback_preserves_provoking_vertex,
            triangle_fans: self.triangle_fans && other.triangle_fans,
            uniform_and_storage_buffer16_bit_access: self
                .uniform_and_storage_buffer16_bit_access
                && other.uniform_and_storage_buffer16_bit_access,
            uniform_and_storage_buffer8_bit_access: self
                .uniform_and_storage_buffer8_bit_access
                && other.uniform_and_storage_buffer8_bit_access,
            uniform_buffer_standard_layout: self.uniform_buffer_standard_layout
                && other.uniform_buffer_standard_layout,
            variable_multisample_rate: self.variable_multisample_rate
                && other.variable_multisample_rate,
            variable_pointers: self.variable_pointers && other.variable_pointers,
            variable_pointers_storage_buffer: self.variable_pointers_storage_buffer
                && other.variable_pointers_storage_buffer,
            vertex_attribute_access_beyond_stride: self
                .vertex_attribute_access_beyond_stride
                && other.vertex_attribute_access_beyond_stride,
            vertex_attribute_instance_rate_divisor: self
                .vertex_attribute_instance_rate_divisor
                && other.vertex_attribute_instance_rate_divisor,
            vertex_attribute_instance_rate_zero_divisor: self
                .vertex_attribute_instance_rate_zero_divisor
                && other.vertex_attribute_instance_rate_zero_divisor,
            vertex_input_dynamic_state: self.vertex_input_dynamic_state
                && other.vertex_input_dynamic_state,
            vertex_pipeline_stores_and_atomics: self.vertex_pipeline_stores_and_atomics
                && other.vertex_pipeline_stores_and_atomics,
            video_maintenance1: self.video_maintenance1 && other.video_maintenance1,
            vulkan_memory_model: self.vulkan_memory_model && other.vulkan_memory_model,
            vulkan_memory_model_availability_visibility_chains: self
                .vulkan_memory_model_availability_visibility_chains
                && other.vulkan_memory_model_availability_visibility_chains,
            vulkan_memory_model_device_scope: self.vulkan_memory_model_device_scope
                && other.vulkan_memory_model_device_scope,
            wide_lines: self.wide_lines && other.wide_lines,
            workgroup_memory_explicit_layout: self.workgroup_memory_explicit_layout
                && other.workgroup_memory_explicit_layout,
            workgroup_memory_explicit_layout16_bit_access: self
                .workgroup_memory_explicit_layout16_bit_access
                && other.workgroup_memory_explicit_layout16_bit_access,
            workgroup_memory_explicit_layout8_bit_access: self
                .workgroup_memory_explicit_layout8_bit_access
                && other.workgroup_memory_explicit_layout8_bit_access,
            workgroup_memory_explicit_layout_scalar_block_layout: self
                .workgroup_memory_explicit_layout_scalar_block_layout
                && other.workgroup_memory_explicit_layout_scalar_block_layout,
            ycbcr2plane444_formats: self.ycbcr2plane444_formats
                && other.ycbcr2plane444_formats,
            ycbcr_degamma: self.ycbcr_degamma && other.ycbcr_degamma,
            ycbcr_image_arrays: self.ycbcr_image_arrays && other.ycbcr_image_arrays,
            _ne: crate::NonExhaustive(()),
        }
    }
    /// Returns `self` without the members set in `other`.
    #[inline]
    pub const fn difference(&self, other: &Self) -> Self {
        Self {
            acceleration_structure: self.acceleration_structure
                && !other.acceleration_structure,
            acceleration_structure_capture_replay: self
                .acceleration_structure_capture_replay
                && !other.acceleration_structure_capture_replay,
            acceleration_structure_host_commands: self
                .acceleration_structure_host_commands
                && !other.acceleration_structure_host_commands,
            acceleration_structure_indirect_build: self
                .acceleration_structure_indirect_build
                && !other.acceleration_structure_indirect_build,
            advanced_blend_coherent_operations: self.advanced_blend_coherent_operations
                && !other.advanced_blend_coherent_operations,
            alpha_to_one: self.alpha_to_one && !other.alpha_to_one,
            amigo_profiling: self.amigo_profiling && !other.amigo_profiling,
            attachment_feedback_loop_dynamic_state: self
                .attachment_feedback_loop_dynamic_state
                && !other.attachment_feedback_loop_dynamic_state,
            attachment_feedback_loop_layout: self.attachment_feedback_loop_layout
                && !other.attachment_feedback_loop_layout,
            attachment_fragment_shading_rate: self.attachment_fragment_shading_rate
                && !other.attachment_fragment_shading_rate,
            border_color_swizzle: self.border_color_swizzle
                && !other.border_color_swizzle,
            border_color_swizzle_from_image: self.border_color_swizzle_from_image
                && !other.border_color_swizzle_from_image,
            bresenham_lines: self.bresenham_lines && !other.bresenham_lines,
            buffer_device_address: self.buffer_device_address
                && !other.buffer_device_address,
            buffer_device_address_capture_replay: self
                .buffer_device_address_capture_replay
                && !other.buffer_device_address_capture_replay,
            buffer_device_address_multi_device: self.buffer_device_address_multi_device
                && !other.buffer_device_address_multi_device,
            clusterculling_shader: self.clusterculling_shader
                && !other.clusterculling_shader,
            color_write_enable: self.color_write_enable && !other.color_write_enable,
            compute_derivative_group_linear: self.compute_derivative_group_linear
                && !other.compute_derivative_group_linear,
            compute_derivative_group_quads: self.compute_derivative_group_quads
                && !other.compute_derivative_group_quads,
            compute_full_subgroups: self.compute_full_subgroups
                && !other.compute_full_subgroups,
            conditional_rendering: self.conditional_rendering
                && !other.conditional_rendering,
            constant_alpha_color_blend_factors: self.constant_alpha_color_blend_factors
                && !other.constant_alpha_color_blend_factors,
            cooperative_matrix: self.cooperative_matrix && !other.cooperative_matrix,
            cooperative_matrix_robust_buffer_access: self
                .cooperative_matrix_robust_buffer_access
                && !other.cooperative_matrix_robust_buffer_access,
            corner_sampled_image: self.corner_sampled_image
                && !other.corner_sampled_image,
            coverage_reduction_mode: self.coverage_reduction_mode
                && !other.coverage_reduction_mode,
            cubic_range_clamp: self.cubic_range_clamp && !other.cubic_range_clamp,
            cuda_kernel_launch_features: self.cuda_kernel_launch_features
                && !other.cuda_kernel_launch_features,
            custom_border_color_without_format: self.custom_border_color_without_format
                && !other.custom_border_color_without_format,
            custom_border_colors: self.custom_border_colors
                && !other.custom_border_colors,
            decode_mode_shared_exponent: self.decode_mode_shared_exponent
                && !other.decode_mode_shared_exponent,
            dedicated_allocation_image_aliasing: self.dedicated_allocation_image_aliasing
                && !other.dedicated_allocation_image_aliasing,
            depth_bias_clamp: self.depth_bias_clamp && !other.depth_bias_clamp,
            depth_bias_control: self.depth_bias_control && !other.depth_bias_control,
            depth_bias_exact: self.depth_bias_exact && !other.depth_bias_exact,
            depth_bounds: self.depth_bounds && !other.depth_bounds,
            depth_clamp: self.depth_clamp && !other.depth_clamp,
            depth_clamp_zero_one: self.depth_clamp_zero_one
                && !other.depth_clamp_zero_one,
            depth_clip_control: self.depth_clip_control && !other.depth_clip_control,
            depth_clip_enable: self.depth_clip_enable && !other.depth_clip_enable,
            descriptor_binding_acceleration_structure_update_after_bind: self
                .descriptor_binding_acceleration_structure_update_after_bind
                && !other.descriptor_binding_acceleration_structure_update_after_bind,
            descriptor_binding_inline_uniform_block_update_after_bind: self
                .descriptor_binding_inline_uniform_block_update_after_bind
                && !other.descriptor_binding_inline_uniform_block_update_after_bind,
            descriptor_binding_partially_bound: self.descriptor_binding_partially_bound
                && !other.descriptor_binding_partially_bound,
            descriptor_binding_sampled_image_update_after_bind: self
                .descriptor_binding_sampled_image_update_after_bind
                && !other.descriptor_binding_sampled_image_update_after_bind,
            descriptor_binding_storage_buffer_update_after_bind: self
                .descriptor_binding_storage_buffer_update_after_bind
                && !other.descriptor_binding_storage_buffer_update_after_bind,
            descriptor_binding_storage_image_update_after_bind: self
                .descriptor_binding_storage_image_update_after_bind
                && !other.descriptor_binding_storage_image_update_after_bind,
            descriptor_binding_storage_texel_buffer_update_after_bind: self
                .descriptor_binding_storage_texel_buffer_update_after_bind
                && !other.descriptor_binding_storage_texel_buffer_update_after_bind,
            descriptor_binding_uniform_buffer_update_after_bind: self
                .descriptor_binding_uniform_buffer_update_after_bind
                && !other.descriptor_binding_uniform_buffer_update_after_bind,
            descriptor_binding_uniform_texel_buffer_update_after_bind: self
                .descriptor_binding_uniform_texel_buffer_update_after_bind
                && !other.descriptor_binding_uniform_texel_buffer_update_after_bind,
            descriptor_binding_update_unused_while_pending: self
                .descriptor_binding_update_unused_while_pending
                && !other.descriptor_binding_update_unused_while_pending,
            descriptor_binding_variable_descriptor_count: self
                .descriptor_binding_variable_descriptor_count
                && !other.descriptor_binding_variable_descriptor_count,
            descriptor_buffer: self.descriptor_buffer && !other.descriptor_buffer,
            descriptor_buffer_capture_replay: self.descriptor_buffer_capture_replay
                && !other.descriptor_buffer_capture_replay,
            descriptor_buffer_image_layout_ignored: self
                .descriptor_buffer_image_layout_ignored
                && !other.descriptor_buffer_image_layout_ignored,
            descriptor_buffer_push_descriptors: self.descriptor_buffer_push_descriptors
                && !other.descriptor_buffer_push_descriptors,
            descriptor_indexing: self.descriptor_indexing && !other.descriptor_indexing,
            descriptor_pool_overallocation: self.descriptor_pool_overallocation
                && !other.descriptor_pool_overallocation,
            descriptor_set_host_mapping: self.descriptor_set_host_mapping
                && !other.descriptor_set_host_mapping,
            device_coherent_memory: self.device_coherent_memory
                && !other.device_coherent_memory,
            device_fault: self.device_fault && !other.device_fault,
            device_fault_vendor_binary: self.device_fault_vendor_binary
                && !other.device_fault_vendor_binary,
            device_generated_commands: self.device_generated_commands
                && !other.device_generated_commands,
            device_generated_compute: self.device_generated_compute
                && !other.device_generated_compute,
            device_generated_compute_capture_replay: self
                .device_generated_compute_capture_replay
                && !other.device_generated_compute_capture_replay,
            device_generated_compute_pipelines: self.device_generated_compute_pipelines
                && !other.device_generated_compute_pipelines,
            device_memory_report: self.device_memory_report
                && !other.device_memory_report,
            diagnostics_config: self.diagnostics_config && !other.diagnostics_config,
            displacement_micromap: self.displacement_micromap
                && !other.displacement_micromap,
            draw_indirect_count: self.draw_indirect_count && !other.draw_indirect_count,
            draw_indirect_first_instance: self.draw_indirect_first_instance
                && !other.draw_indirect_first_instance,
            dual_src_blend: self.dual_src_blend && !other.dual_src_blend,
            dynamic_pipeline_layout: self.dynamic_pipeline_layout
                && !other.dynamic_pipeline_layout,
            dynamic_rendering: self.dynamic_rendering && !other.dynamic_rendering,
            dynamic_rendering_local_read: self.dynamic_rendering_local_read
                && !other.dynamic_rendering_local_read,
            dynamic_rendering_unused_attachments: self
                .dynamic_rendering_unused_attachments
                && !other.dynamic_rendering_unused_attachments,
            events: self.events && !other.events,
            exclusive_scissor: self.exclusive_scissor && !other.exclusive_scissor,
            extended_dynamic_state: self.extended_dynamic_state
                && !other.extended_dynamic_state,
            extended_dynamic_state2: self.extended_dynamic_state2
                && !other.extended_dynamic_state2,
            extended_dynamic_state2_logic_op: self.extended_dynamic_state2_logic_op
                && !other.extended_dynamic_state2_logic_op,
            extended_dynamic_state2_patch_control_points: self
                .extended_dynamic_state2_patch_control_points
                && !other.extended_dynamic_state2_patch_control_points,
            extended_dynamic_state3_alpha_to_coverage_enable: self
                .extended_dynamic_state3_alpha_to_coverage_enable
                && !other.extended_dynamic_state3_alpha_to_coverage_enable,
            extended_dynamic_state3_alpha_to_one_enable: self
                .extended_dynamic_state3_alpha_to_one_enable
                && !other.extended_dynamic_state3_alpha_to_one_enable,
            extended_dynamic_state3_color_blend_advanced: self
                .extended_dynamic_state3_color_blend_advanced
                && !other.extended_dynamic_state3_color_blend_advanced,
            extended_dynamic_state3_color_blend_enable: self
                .extended_dynamic_state3_color_blend_enable
                && !other.extended_dynamic_state3_color_blend_enable,
            extended_dynamic_state3_color_blend_equation: self
                .extended_dynamic_state3_color_blend_equation
                && !other.extended_dynamic_state3_color_blend_equation,
            extended_dynamic_state3_color_write_mask: self
                .extended_dynamic_state3_color_write_mask
                && !other.extended_dynamic_state3_color_write_mask,
            extended_dynamic_state3_conservative_rasterization_mode: self
                .extended_dynamic_state3_conservative_rasterization_mode
                && !other.extended_dynamic_state3_conservative_rasterization_mode,
            extended_dynamic_state3_coverage_modulation_mode: self
                .extended_dynamic_state3_coverage_modulation_mode
                && !other.extended_dynamic_state3_coverage_modulation_mode,
            extended_dynamic_state3_coverage_modulation_table: self
                .extended_dynamic_state3_coverage_modulation_table
                && !other.extended_dynamic_state3_coverage_modulation_table,
            extended_dynamic_state3_coverage_modulation_table_enable: self
                .extended_dynamic_state3_coverage_modulation_table_enable
                && !other.extended_dynamic_state3_coverage_modulation_table_enable,
            extended_dynamic_state3_coverage_reduction_mode: self
                .extended_dynamic_state3_coverage_reduction_mode
                && !other.extended_dynamic_state3_coverage_reduction_mode,
            extended_dynamic_state3_coverage_to_color_enable: self
                .extended_dynamic_state3_coverage_to_color_enable
                && !other.extended_dynamic_state3_coverage_to_color_enable,
            extended_dynamic_state3_coverage_to_color_location: self
                .extended_dynamic_state3_coverage_to_color_location
                && !other.extended_dynamic_state3_coverage_to_color_location,
            extended_dynamic_state3_depth_clamp_enable: self
                .extended_dynamic_state3_depth_clamp_enable
                && !other.extended_dynamic_state3_depth_clamp_enable,
            extended_dynamic_state3_depth_clip_enable: self
                .extended_dynamic_state3_depth_clip_enable
                && !other.extended_dynamic_state3_depth_clip_enable,
            extended_dynamic_state3_depth_clip_negative_one_to_one: self
                .extended_dynamic_state3_depth_clip_negative_one_to_one
                && !other.extended_dynamic_state3_depth_clip_negative_one_to_one,
            extended_dynamic_state3_extra_primitive_overestimation_size: self
                .extended_dynamic_state3_extra_primitive_overestimation_size
                && !other.extended_dynamic_state3_extra_primitive_overestimation_size,
            extended_dynamic_state3_line_rasterization_mode: self
                .extended_dynamic_state3_line_rasterization_mode
                && !other.extended_dynamic_state3_line_rasterization_mode,
            extended_dynamic_state3_line_stipple_enable: self
                .extended_dynamic_state3_line_stipple_enable
                && !other.extended_dynamic_state3_line_stipple_enable,
            extended_dynamic_state3_logic_op_enable: self
                .extended_dynamic_state3_logic_op_enable
                && !other.extended_dynamic_state3_logic_op_enable,
            extended_dynamic_state3_polygon_mode: self
                .extended_dynamic_state3_polygon_mode
                && !other.extended_dynamic_state3_polygon_mode,
            extended_dynamic_state3_provoking_vertex_mode: self
                .extended_dynamic_state3_provoking_vertex_mode
                && !other.extended_dynamic_state3_provoking_vertex_mode,
            extended_dynamic_state3_rasterization_samples: self
                .extended_dynamic_state3_rasterization_samples
                && !other.extended_dynamic_state3_rasterization_samples,
            extended_dynamic_state3_rasterization_stream: self
                .extended_dynamic_state3_rasterization_stream
                && !other.extended_dynamic_state3_rasterization_stream,
            extended_dynamic_state3_representative_fragment_test_enable: self
                .extended_dynamic_state3_representative_fragment_test_enable
                && !other.extended_dynamic_state3_representative_fragment_test_enable,
            extended_dynamic_state3_sample_locations_enable: self
                .extended_dynamic_state3_sample_locations_enable
                && !other.extended_dynamic_state3_sample_locations_enable,
            extended_dynamic_state3_sample_mask: self.extended_dynamic_state3_sample_mask
                && !other.extended_dynamic_state3_sample_mask,
            extended_dynamic_state3_shading_rate_image_enable: self
                .extended_dynamic_state3_shading_rate_image_enable
                && !other.extended_dynamic_state3_shading_rate_image_enable,
            extended_dynamic_state3_tessellation_domain_origin: self
                .extended_dynamic_state3_tessellation_domain_origin
                && !other.extended_dynamic_state3_tessellation_domain_origin,
            extended_dynamic_state3_viewport_swizzle: self
                .extended_dynamic_state3_viewport_swizzle
                && !other.extended_dynamic_state3_viewport_swizzle,
            extended_dynamic_state3_viewport_w_scaling_enable: self
                .extended_dynamic_state3_viewport_w_scaling_enable
                && !other.extended_dynamic_state3_viewport_w_scaling_enable,
            extended_sparse_address_space: self.extended_sparse_address_space
                && !other.extended_sparse_address_space,
            external_format_resolve: self.external_format_resolve
                && !other.external_format_resolve,
            external_memory_rdma: self.external_memory_rdma
                && !other.external_memory_rdma,
            fill_mode_non_solid: self.fill_mode_non_solid && !other.fill_mode_non_solid,
            float_representation: self.float_representation
                && !other.float_representation,
            format_a4b4g4r4: self.format_a4b4g4r4 && !other.format_a4b4g4r4,
            format_a4r4g4b4: self.format_a4r4g4b4 && !other.format_a4r4g4b4,
            format_rgba10x6_without_y_cb_cr_sampler: self
                .format_rgba10x6_without_y_cb_cr_sampler
                && !other.format_rgba10x6_without_y_cb_cr_sampler,
            fragment_density_map: self.fragment_density_map
                && !other.fragment_density_map,
            fragment_density_map_deferred: self.fragment_density_map_deferred
                && !other.fragment_density_map_deferred,
            fragment_density_map_dynamic: self.fragment_density_map_dynamic
                && !other.fragment_density_map_dynamic,
            fragment_density_map_non_subsampled_images: self
                .fragment_density_map_non_subsampled_images
                && !other.fragment_density_map_non_subsampled_images,
            fragment_density_map_offset: self.fragment_density_map_offset
                && !other.fragment_density_map_offset,
            fragment_shader_barycentric: self.fragment_shader_barycentric
                && !other.fragment_shader_barycentric,
            fragment_shader_pixel_interlock: self.fragment_shader_pixel_interlock
                && !other.fragment_shader_pixel_interlock,
            fragment_shader_sample_interlock: self.fragment_shader_sample_interlock
                && !other.fragment_shader_sample_interlock,
            fragment_shader_shading_rate_interlock: self
                .fragment_shader_shading_rate_interlock
                && !other.fragment_shader_shading_rate_interlock,
            fragment_shading_rate_enums: self.fragment_shading_rate_enums
                && !other.fragment_shading_rate_enums,
            fragment_stores_and_atomics: self.fragment_stores_and_atomics
                && !other.fragment_stores_and_atomics,
            frame_boundary: self.frame_boundary && !other.frame_boundary,
            full_draw_index_uint32: self.full_draw_index_uint32
                && !other.full_draw_index_uint32,
            geometry_shader: self.geometry_shader && !other.geometry_shader,
            geometry_streams: self.geometry_streams && !other.geometry_streams,
            global_priority_query: self.global_priority_query
                && !other.global_priority_query,
            graphics_pipeline_library: self.graphics_pipeline_library
                && !other.graphics_pipeline_library,
            host_image_copy: self.host_image_copy && !other.host_image_copy,
            host_query_reset: self.host_query_reset && !other.host_query_reset,
            image2_d_view_of3_d: self.image2_d_view_of3_d && !other.image2_d_view_of3_d,
            image_compression_control: self.image_compression_control
                && !other.image_compression_control,
            image_compression_control_swapchain: self.image_compression_control_swapchain
                && !other.image_compression_control_swapchain,
            image_cube_array: self.image_cube_array && !other.image_cube_array,
            image_footprint: self.image_footprint && !other.image_footprint,
            image_sliced_view_of3_d: self.image_sliced_view_of3_d
                && !other.image_sliced_view_of3_d,
            image_view2_d_on3_d_image: self.image_view2_d_on3_d_image
                && !other.image_view2_d_on3_d_image,
            image_view_format_reinterpretation: self.image_view_format_reinterpretation
                && !other.image_view_format_reinterpretation,
            image_view_format_swizzle: self.image_view_format_swizzle
                && !other.image_view_format_swizzle,
            imageless_framebuffer: self.imageless_framebuffer
                && !other.imageless_framebuffer,
            independent_blend: self.independent_blend && !other.independent_blend,
            index_type_uint8: self.index_type_uint8 && !other.index_type_uint8,
            indirect_copy: self.indirect_copy && !other.indirect_copy,
            inherited_conditional_rendering: self.inherited_conditional_rendering
                && !other.inherited_conditional_rendering,
            inherited_queries: self.inherited_queries && !other.inherited_queries,
            inherited_viewport_scissor2_d: self.inherited_viewport_scissor2_d
                && !other.inherited_viewport_scissor2_d,
            inline_uniform_block: self.inline_uniform_block
                && !other.inline_uniform_block,
            invocation_mask: self.invocation_mask && !other.invocation_mask,
            large_points: self.large_points && !other.large_points,
            least_representable_value_force_unorm_representation: self
                .least_representable_value_force_unorm_representation
                && !other.least_representable_value_force_unorm_representation,
            legacy_dithering: self.legacy_dithering && !other.legacy_dithering,
            linear_color_attachment: self.linear_color_attachment
                && !other.linear_color_attachment,
            logic_op: self.logic_op && !other.logic_op,
            maintenance4: self.maintenance4 && !other.maintenance4,
            maintenance5: self.maintenance5 && !other.maintenance5,
            maintenance6: self.maintenance6 && !other.maintenance6,
            memory_decompression: self.memory_decompression
                && !other.memory_decompression,
            memory_map_placed: self.memory_map_placed && !other.memory_map_placed,
            memory_map_range_placed: self.memory_map_range_placed
                && !other.memory_map_range_placed,
            memory_priority: self.memory_priority && !other.memory_priority,
            memory_unmap_reserve: self.memory_unmap_reserve
                && !other.memory_unmap_reserve,
            mesh_shader: self.mesh_shader && !other.mesh_shader,
            mesh_shader_queries: self.mesh_shader_queries && !other.mesh_shader_queries,
            micromap: self.micromap && !other.micromap,
            micromap_capture_replay: self.micromap_capture_replay
                && !other.micromap_capture_replay,
            micromap_host_commands: self.micromap_host_commands
                && !other.micromap_host_commands,
            min_lod: self.min_lod && !other.min_lod,
            multi_draw: self.multi_draw && !other.multi_draw,
            multi_draw_indirect: self.multi_draw_indirect && !other.multi_draw_indirect,
            multi_viewport: self.multi_viewport && !other.multi_viewport,
            multisample_array_image: self.multisample_array_image
                && !other.multisample_array_image,
            multisampled_render_to_single_sampled: self
                .multisampled_render_to_single_sampled
                && !other.multisampled_render_to_single_sampled,
            multiview: self.multiview && !other.multiview,
            multiview_cluster_culling_shader: self.multiview_cluster_culling_shader
                && !other.multiview_cluster_culling_shader,
            multiview_geometry_shader: self.multiview_geometry_shader
                && !other.multiview_geometry_shader,
            multiview_mesh_shader: self.multiview_mesh_shader
                && !other.multiview_mesh_shader,
            multiview_per_view_render_areas: self.multiview_per_view_render_areas
                && !other.multiview_per_view_render_areas,
            multiview_per_view_viewports: self.multiview_per_view_viewports
                && !other.multiview_per_view_viewports,
            multiview_tessellation_shader: self.multiview_tessellation_shader
                && !other.multiview_tessellation_shader,
            mutable_comparison_samplers: self.mutable_comparison_samplers
                && !other.mutable_comparison_samplers,
            mutable_descriptor_type: self.mutable_descriptor_type
                && !other.mutable_descriptor_type,
            nested_command_buffer: self.nested_command_buffer
                && !other.nested_command_buffer,
            nested_command_buffer_rendering: self.nested_command_buffer_rendering
                && !other.nested_command_buffer_rendering,
            nested_command_buffer_simultaneous_use: self
                .nested_command_buffer_simultaneous_use
                && !other.nested_command_buffer_simultaneous_use,
            no_invocation_fragment_shading_rates: self
                .no_invocation_fragment_shading_rates
                && !other.no_invocation_fragment_shading_rates,
            non_seamless_cube_map: self.non_seamless_cube_map
                && !other.non_seamless_cube_map,
            null_descriptor: self.null_descriptor && !other.null_descriptor,
            occlusion_query_precise: self.occlusion_query_precise
                && !other.occlusion_query_precise,
            optical_flow: self.optical_flow && !other.optical_flow,
            pageable_device_local_memory: self.pageable_device_local_memory
                && !other.pageable_device_local_memory,
            per_stage_descriptor_set: self.per_stage_descriptor_set
                && !other.per_stage_descriptor_set,
            performance_counter_multiple_query_pools: self
                .performance_counter_multiple_query_pools
                && !other.performance_counter_multiple_query_pools,
            performance_counter_query_pools: self.performance_counter_query_pools
                && !other.performance_counter_query_pools,
            pipeline_creation_cache_control: self.pipeline_creation_cache_control
                && !other.pipeline_creation_cache_control,
            pipeline_executable_info: self.pipeline_executable_info
                && !other.pipeline_executable_info,
            pipeline_fragment_shading_rate: self.pipeline_fragment_shading_rate
                && !other.pipeline_fragment_shading_rate,
            pipeline_library_group_handles: self.pipeline_library_group_handles
                && !other.pipeline_library_group_handles,
            pipeline_properties_identifier: self.pipeline_properties_identifier
                && !other.pipeline_properties_identifier,
            pipeline_protected_access: self.pipeline_protected_access
                && !other.pipeline_protected_access,
            pipeline_robustness: self.pipeline_robustness && !other.pipeline_robustness,
            pipeline_statistics_query: self.pipeline_statistics_query
                && !other.pipeline_statistics_query,
            point_polygons: self.point_polygons && !other.point_polygons,
            present_barrier: self.present_barrier && !other.present_barrier,
            present_id: self.present_id && !other.present_id,
            present_wait: self.present_wait && !other.present_wait,
            primitive_fragment_shading_rate: self.primitive_fragment_shading_rate
                && !other.primitive_fragment_shading_rate,
            primitive_fragment_shading_rate_mesh_shader: self
                .primitive_fragment_shading_rate_mesh_shader
                && !other.primitive_fragment_shading_rate_mesh_shader,
            primitive_topology_list_restart: self.primitive_topology_list_restart
                && !other.primitive_topology_list_restart,
            primitive_topology_patch_list_restart: self
                .primitive_topology_patch_list_restart
                && !other.primitive_topology_patch_list_restart,
            primitives_generated_query: self.primitives_generated_query
                && !other.primitives_generated_query,
            primitives_generated_query_with_non_zero_streams: self
                .primitives_generated_query_with_non_zero_streams
                && !other.primitives_generated_query_with_non_zero_streams,
            primitives_generated_query_with_rasterizer_discard: self
                .primitives_generated_query_with_rasterizer_discard
                && !other.primitives_generated_query_with_rasterizer_discard,
            private_data: self.private_data && !other.private_data,
            protected_memory: self.protected_memory && !other.protected_memory,
            provoking_vertex_last: self.provoking_vertex_last
                && !other.provoking_vertex_last,
            rasterization_order_color_attachment_access: self
                .rasterization_order_color_attachment_access
                && !other.rasterization_order_color_attachment_access,
            rasterization_order_depth_attachment_access: self
                .rasterization_order_depth_attachment_access
                && !other.rasterization_order_depth_attachment_access,
            rasterization_order_stencil_attachment_access: self
                .rasterization_order_stencil_attachment_access
                && !other.rasterization_order_stencil_attachment_access,
            ray_query: self.ray_query && !other.ray_query,
            ray_tracing_invocation_reorder: self.ray_tracing_invocation_reorder
                && !other.ray_tracing_invocation_reorder,
            ray_tracing_maintenance1: self.ray_tracing_maintenance1
                && !other.ray_tracing_maintenance1,
            ray_tracing_motion_blur: self.ray_tracing_motion_blur
                && !other.ray_tracing_motion_blur,
            ray_tracing_motion_blur_pipeline_trace_rays_indirect: self
                .ray_tracing_motion_blur_pipeline_trace_rays_indirect
                && !other.ray_tracing_motion_blur_pipeline_trace_rays_indirect,
            ray_tracing_pipeline: self.ray_tracing_pipeline
                && !other.ray_tracing_pipeline,
            ray_tracing_pipeline_shader_group_handle_capture_replay: self
                .ray_tracing_pipeline_shader_group_handle_capture_replay
                && !other.ray_tracing_pipeline_shader_group_handle_capture_replay,
            ray_tracing_pipeline_shader_group_handle_capture_replay_mixed: self
                .ray_tracing_pipeline_shader_group_handle_capture_replay_mixed
                && !other.ray_tracing_pipeline_shader_group_handle_capture_replay_mixed,
            ray_tracing_pipeline_trace_rays_indirect: self
                .ray_tracing_pipeline_trace_rays_indirect
                && !other.ray_tracing_pipeline_trace_rays_indirect,
            ray_tracing_pipeline_trace_rays_indirect2: self
                .ray_tracing_pipeline_trace_rays_indirect2
                && !other.ray_tracing_pipeline_trace_rays_indirect2,
            ray_tracing_position_fetch: self.ray_tracing_position_fetch
                && !other.ray_tracing_position_fetch,
            ray_tracing_validation: self.ray_tracing_validation
                && !other.ray_tracing_validation,
            ray_traversal_primitive_culling: self.ray_traversal_primitive_culling
                && !other.ray_traversal_primitive_culling,
            rectangular_lines: self.rectangular_lines && !other.rectangular_lines,
            relaxed_line_rasterization: self.relaxed_line_rasterization
                && !other.relaxed_line_rasterization,
            render_pass_striped: self.render_pass_striped && !other.render_pass_striped,
            report_address_binding: self.report_address_binding
                && !other.report_address_binding,
            representative_fragment_test: self.representative_fragment_test
                && !other.representative_fragment_test,
            robust_buffer_access: self.robust_buffer_access
                && !other.robust_buffer_access,
            robust_buffer_access2: self.robust_buffer_access2
                && !other.robust_buffer_access2,
            robust_image_access: self.robust_image_access && !other.robust_image_access,
            robust_image_access2: self.robust_image_access2
                && !other.robust_image_access2,
            runtime_descriptor_array: self.runtime_descriptor_array
                && !other.runtime_descriptor_array,
            sample_rate_shading: self.sample_rate_shading && !other.sample_rate_shading,
            sampler2_d_view_of3_d: self.sampler2_d_view_of3_d
                && !other.sampler2_d_view_of3_d,
            sampler_anisotropy: self.sampler_anisotropy && !other.sampler_anisotropy,
            sampler_filter_minmax: self.sampler_filter_minmax
                && !other.sampler_filter_minmax,
            sampler_mip_lod_bias: self.sampler_mip_lod_bias
                && !other.sampler_mip_lod_bias,
            sampler_mirror_clamp_to_edge: self.sampler_mirror_clamp_to_edge
                && !other.sampler_mirror_clamp_to_edge,
            sampler_ycbcr_conversion: self.sampler_ycbcr_conversion
                && !other.sampler_ycbcr_conversion,
            scalar_block_layout: self.scalar_block_layout && !other.scalar_block_layout,
            scheduling_controls: self.scheduling_controls && !other.scheduling_controls,
            screen_buffer_import: self.screen_buffer_import
                && !other.screen_buffer_import,
            selectable_cubic_weights: self.selectable_cubic_weights
                && !other.selectable_cubic_weights,
            separate_depth_stencil_layouts: self.separate_depth_stencil_layouts
                && !other.separate_depth_stencil_layouts,
            separate_stencil_mask_ref: self.separate_stencil_mask_ref
                && !other.separate_stencil_mask_ref,
            shader_buffer_float16_atomic_add: self.shader_buffer_float16_atomic_add
                && !other.shader_buffer_float16_atomic_add,
            shader_buffer_float16_atomic_min_max: self
                .shader_buffer_float16_atomic_min_max
                && !other.shader_buffer_float16_atomic_min_max,
            shader_buffer_float16_atomics: self.shader_buffer_float16_atomics
                && !other.shader_buffer_float16_atomics,
            shader_buffer_float32_atomic_add: self.shader_buffer_float32_atomic_add
                && !other.shader_buffer_float32_atomic_add,
            shader_buffer_float32_atomic_min_max: self
                .shader_buffer_float32_atomic_min_max
                && !other.shader_buffer_float32_atomic_min_max,
            shader_buffer_float32_atomics: self.shader_buffer_float32_atomics
                && !other.shader_buffer_float32_atomics,
            shader_buffer_float64_atomic_add: self.shader_buffer_float64_atomic_add
                && !other.shader_buffer_float64_atomic_add,
            shader_buffer_float64_atomic_min_max: self
                .shader_buffer_float64_atomic_min_max
                && !other.shader_buffer_float64_atomic_min_max,
            shader_buffer_float64_atomics: self.shader_buffer_float64_atomics
                && !other.shader_buffer_float64_atomics,
            shader_buffer_int64_atomics: self.shader_buffer_int64_atomics
                && !other.shader_buffer_int64_atomics,
            shader_clip_distance: self.shader_clip_distance
                && !other.shader_clip_distance,
            shader_core_builtins: self.shader_core_builtins
                && !other.shader_core_builtins,
            shader_cull_distance: self.shader_cull_distance
                && !other.shader_cull_distance,
            shader_demote_to_helper_invocation: self.shader_demote_to_helper_invocation
                && !other.shader_demote_to_helper_invocation,
            shader_device_clock: self.shader_device_clock && !other.shader_device_clock,
            shader_draw_parameters: self.shader_draw_parameters
                && !other.shader_draw_parameters,
            shader_early_and_late_fragment_tests: self
                .shader_early_and_late_fragment_tests
                && !other.shader_early_and_late_fragment_tests,
            shader_enqueue: self.shader_enqueue && !other.shader_enqueue,
            shader_expect_assume: self.shader_expect_assume
                && !other.shader_expect_assume,
            shader_float16: self.shader_float16 && !other.shader_float16,
            shader_float16_vector_atomics: self.shader_float16_vector_atomics
                && !other.shader_float16_vector_atomics,
            shader_float64: self.shader_float64 && !other.shader_float64,
            shader_float_controls2: self.shader_float_controls2
                && !other.shader_float_controls2,
            shader_image_float32_atomic_add: self.shader_image_float32_atomic_add
                && !other.shader_image_float32_atomic_add,
            shader_image_float32_atomic_min_max: self.shader_image_float32_atomic_min_max
                && !other.shader_image_float32_atomic_min_max,
            shader_image_float32_atomics: self.shader_image_float32_atomics
                && !other.shader_image_float32_atomics,
            shader_image_gather_extended: self.shader_image_gather_extended
                && !other.shader_image_gather_extended,
            shader_image_int64_atomics: self.shader_image_int64_atomics
                && !other.shader_image_int64_atomics,
            shader_input_attachment_array_dynamic_indexing: self
                .shader_input_attachment_array_dynamic_indexing
                && !other.shader_input_attachment_array_dynamic_indexing,
            shader_input_attachment_array_non_uniform_indexing: self
                .shader_input_attachment_array_non_uniform_indexing
                && !other.shader_input_attachment_array_non_uniform_indexing,
            shader_int16: self.shader_int16 && !other.shader_int16,
            shader_int64: self.shader_int64 && !other.shader_int64,
            shader_int8: self.shader_int8 && !other.shader_int8,
            shader_integer_dot_product: self.shader_integer_dot_product
                && !other.shader_integer_dot_product,
            shader_integer_functions2: self.shader_integer_functions2
                && !other.shader_integer_functions2,
            shader_maximal_reconvergence: self.shader_maximal_reconvergence
                && !other.shader_maximal_reconvergence,
            shader_module_identifier: self.shader_module_identifier
                && !other.shader_module_identifier,
            shader_object: self.shader_object && !other.shader_object,
            shader_output_layer: self.shader_output_layer && !other.shader_output_layer,
            shader_output_viewport_index: self.shader_output_viewport_index
                && !other.shader_output_viewport_index,
            shader_quad_control: self.shader_quad_control && !other.shader_quad_control,
            shader_raw_access_chains: self.shader_raw_access_chains
                && !other.shader_raw_access_chains,
            shader_resource_min_lod: self.shader_resource_min_lod
                && !other.shader_resource_min_lod,
            shader_resource_residency: self.shader_resource_residency
                && !other.shader_resource_residency,
            shader_sample_rate_interpolation_functions: self
                .shader_sample_rate_interpolation_functions
                && !other.shader_sample_rate_interpolation_functions,
            shader_sampled_image_array_dynamic_indexing: self
                .shader_sampled_image_array_dynamic_indexing
                && !other.shader_sampled_image_array_dynamic_indexing,
            shader_sampled_image_array_non_uniform_indexing: self
                .shader_sampled_image_array_non_uniform_indexing
                && !other.shader_sampled_image_array_non_uniform_indexing,
            shader_shared_float16_atomic_add: self.shader_shared_float16_atomic_add
                && !other.shader_shared_float16_atomic_add,
            shader_shared_float16_atomic_min_max: self
                .shader_shared_float16_atomic_min_max
                && !other.shader_shared_float16_atomic_min_max,
            shader_shared_float16_atomics: self.shader_shared_float16_atomics
                && !other.shader_shared_float16_atomics,
            shader_shared_float32_atomic_add: self.shader_shared_float32_atomic_add
                && !other.shader_shared_float32_atomic_add,
            shader_shared_float32_atomic_min_max: self
                .shader_shared_float32_atomic_min_max
                && !other.shader_shared_float32_atomic_min_max,
            shader_shared_float32_atomics: self.shader_shared_float32_atomics
                && !other.shader_shared_float32_atomics,
            shader_shared_float64_atomic_add: self.shader_shared_float64_atomic_add
                && !other.shader_shared_float64_atomic_add,
            shader_shared_float64_atomic_min_max: self
                .shader_shared_float64_atomic_min_max
                && !other.shader_shared_float64_atomic_min_max,
            shader_shared_float64_atomics: self.shader_shared_float64_atomics
                && !other.shader_shared_float64_atomics,
            shader_shared_int64_atomics: self.shader_shared_int64_atomics
                && !other.shader_shared_int64_atomics,
            shader_sm_builtins: self.shader_sm_builtins && !other.shader_sm_builtins,
            shader_storage_buffer_array_dynamic_indexing: self
                .shader_storage_buffer_array_dynamic_indexing
                && !other.shader_storage_buffer_array_dynamic_indexing,
            shader_storage_buffer_array_non_uniform_indexing: self
                .shader_storage_buffer_array_non_uniform_indexing
                && !other.shader_storage_buffer_array_non_uniform_indexing,
            shader_storage_image_array_dynamic_indexing: self
                .shader_storage_image_array_dynamic_indexing
                && !other.shader_storage_image_array_dynamic_indexing,
            shader_storage_image_array_non_uniform_indexing: self
                .shader_storage_image_array_non_uniform_indexing
                && !other.shader_storage_image_array_non_uniform_indexing,
            shader_storage_image_extended_formats: self
                .shader_storage_image_extended_formats
                && !other.shader_storage_image_extended_formats,
            shader_storage_image_multisample: self.shader_storage_image_multisample
                && !other.shader_storage_image_multisample,
            shader_storage_image_read_without_format: self
                .shader_storage_image_read_without_format
                && !other.shader_storage_image_read_without_format,
            shader_storage_image_write_without_format: self
                .shader_storage_image_write_without_format
                && !other.shader_storage_image_write_without_format,
            shader_storage_texel_buffer_array_dynamic_indexing: self
                .shader_storage_texel_buffer_array_dynamic_indexing
                && !other.shader_storage_texel_buffer_array_dynamic_indexing,
            shader_storage_texel_buffer_array_non_uniform_indexing: self
                .shader_storage_texel_buffer_array_non_uniform_indexing
                && !other.shader_storage_texel_buffer_array_non_uniform_indexing,
            shader_subgroup_clock: self.shader_subgroup_clock
                && !other.shader_subgroup_clock,
            shader_subgroup_extended_types: self.shader_subgroup_extended_types
                && !other.shader_subgroup_extended_types,
            shader_subgroup_rotate: self.shader_subgroup_rotate
                && !other.shader_subgroup_rotate,
            shader_subgroup_rotate_clustered: self.shader_subgroup_rotate_clustered
                && !other.shader_subgroup_rotate_clustered,
            shader_subgroup_uniform_control_flow: self
                .shader_subgroup_uniform_control_flow
                && !other.shader_subgroup_uniform_control_flow,
            shader_terminate_invocation: self.shader_terminate_invocation
                && !other.shader_terminate_invocation,
            shader_tessellation_and_geometry_point_size: self
                .shader_tessellation_and_geometry_point_size
                && !other.shader_tessellation_and_geometry_point_size,
            shader_tile_image_color_read_access: self.shader_tile_image_color_read_access
                && !other.shader_tile_image_color_read_access,
            shader_tile_image_depth_read_access: self.shader_tile_image_depth_read_access
                && !other.shader_tile_image_depth_read_access,
            shader_tile_image_stencil_read_access: self
                .shader_tile_image_stencil_read_access
                && !other.shader_tile_image_stencil_read_access,
            shader_uniform_buffer_array_dynamic_indexing: self
                .shader_uniform_buffer_array_dynamic_indexing
                && !other.shader_uniform_buffer_array_dynamic_indexing,
            shader_uniform_buffer_array_non_uniform_indexing: self
                .shader_uniform_buffer_array_non_uniform_indexing
                && !other.shader_uniform_buffer_array_non_uniform_indexing,
            shader_uniform_texel_buffer_array_dynamic_indexing: self
                .shader_uniform_texel_buffer_array_dynamic_indexing
                && !other.shader_uniform_texel_buffer_array_dynamic_indexing,
            shader_uniform_texel_buffer_array_non_uniform_indexing: self
                .shader_uniform_texel_buffer_array_non_uniform_indexing
                && !other.shader_uniform_texel_buffer_array_non_uniform_indexing,
            shader_zero_initialize_workgroup_memory: self
                .shader_zero_initialize_workgroup_memory
                && !other.shader_zero_initialize_workgroup_memory,
            shading_rate_coarse_sample_order: self.shading_rate_coarse_sample_order
                && !other.shading_rate_coarse_sample_order,
            shading_rate_image: self.shading_rate_image && !other.shading_rate_image,
            smooth_lines: self.smooth_lines && !other.smooth_lines,
            sparse_binding: self.sparse_binding && !other.sparse_binding,
            sparse_image_float32_atomic_add: self.sparse_image_float32_atomic_add
                && !other.sparse_image_float32_atomic_add,
            sparse_image_float32_atomic_min_max: self.sparse_image_float32_atomic_min_max
                && !other.sparse_image_float32_atomic_min_max,
            sparse_image_float32_atomics: self.sparse_image_float32_atomics
                && !other.sparse_image_float32_atomics,
            sparse_image_int64_atomics: self.sparse_image_int64_atomics
                && !other.sparse_image_int64_atomics,
            sparse_residency16_samples: self.sparse_residency16_samples
                && !other.sparse_residency16_samples,
            sparse_residency2_samples: self.sparse_residency2_samples
                && !other.sparse_residency2_samples,
            sparse_residency4_samples: self.sparse_residency4_samples
                && !other.sparse_residency4_samples,
            sparse_residency8_samples: self.sparse_residency8_samples
                && !other.sparse_residency8_samples,
            sparse_residency_aliased: self.sparse_residency_aliased
                && !other.sparse_residency_aliased,
            sparse_residency_buffer: self.sparse_residency_buffer
                && !other.sparse_residency_buffer,
            sparse_residency_image2_d: self.sparse_residency_image2_d
                && !other.sparse_residency_image2_d,
            sparse_residency_image3_d: self.sparse_residency_image3_d
                && !other.sparse_residency_image3_d,
            stippled_bresenham_lines: self.stippled_bresenham_lines
                && !other.stippled_bresenham_lines,
            stippled_rectangular_lines: self.stippled_rectangular_lines
                && !other.stippled_rectangular_lines,
            stippled_smooth_lines: self.stippled_smooth_lines
                && !other.stippled_smooth_lines,
            storage_buffer16_bit_access: self.storage_buffer16_bit_access
                && !other.storage_buffer16_bit_access,
            storage_buffer8_bit_access: self.storage_buffer8_bit_access
                && !other.storage_buffer8_bit_access,
            storage_input_output16: self.storage_input_output16
                && !other.storage_input_output16,
            storage_push_constant16: self.storage_push_constant16
                && !other.storage_push_constant16,
            storage_push_constant8: self.storage_push_constant8
                && !other.storage_push_constant8,
            subgroup_broadcast_dynamic_id: self.subgroup_broadcast_dynamic_id
                && !other.subgroup_broadcast_dynamic_id,
            subgroup_size_control: self.subgroup_size_control
                && !other.subgroup_size_control,
            subpass_merge_feedback: self.subpass_merge_feedback
                && !other.subpass_merge_feedback,
            subpass_shading: self.subpass_shading && !other.subpass_shading,
            supersample_fragment_shading_rates: self.supersample_fragment_shading_rates
                && !other.supersample_fragment_shading_rates,
            swapchain_maintenance1: self.swapchain_maintenance1
                && !other.swapchain_maintenance1,
            synchronization2: self.synchronization2 && !other.synchronization2,
            task_shader: self.task_shader && !other.task_shader,
            tessellation_isolines: self.tessellation_isolines
                && !other.tessellation_isolines,
            tessellation_point_mode: self.tessellation_point_mode
                && !other.tessellation_point_mode,
            tessellation_shader: self.tessellation_shader && !other.tessellation_shader,
            texel_buffer_alignment: self.texel_buffer_alignment
                && !other.texel_buffer_alignment,
            texture_block_match: self.texture_block_match && !other.texture_block_match,
            texture_block_match2: self.texture_block_match2
                && !other.texture_block_match2,
            texture_box_filter: self.texture_box_filter && !other.texture_box_filter,
            texture_compression_astc_hdr: self.texture_compression_astc_hdr
                && !other.texture_compression_astc_hdr,
            texture_compression_astc_ldr: self.texture_compression_astc_ldr
                && !other.texture_compression_astc_ldr,
            texture_compression_bc: self.texture_compression_bc
                && !other.texture_compression_bc,
            texture_compression_etc2: self.texture_compression_etc2
                && !other.texture_compression_etc2,
            texture_sample_weighted: self.texture_sample_weighted
                && !other.texture_sample_weighted,
            tile_properties: self.tile_properties && !other.tile_properties,
            timeline_semaphore: self.timeline_semaphore && !other.timeline_semaphore,
            transform_feedback: self.transform_feedback && !other.transform_feedback,
            transform_feedback_preserves_provoking_vertex: self
                .transform_feedback_preserves_provoking_vertex
                && !other.transform_feedback_preserves_provoking_vertex,
            triangle_fans: self.triangle_fans && !other.triangle_fans,
            uniform_and_storage_buffer16_bit_access: self
                .uniform_and_storage_buffer16_bit_access
                && !other.uniform_and_storage_buffer16_bit_access,
            uniform_and_storage_buffer8_bit_access: self
                .uniform_and_storage_buffer8_bit_access
                && !other.uniform_and_storage_buffer8_bit_access,
            uniform_buffer_standard_layout: self.uniform_buffer_standard_layout
                && !other.uniform_buffer_standard_layout,
            variable_multisample_rate: self.variable_multisample_rate
                && !other.variable_multisample_rate,
            variable_pointers: self.variable_pointers && !other.variable_pointers,
            variable_pointers_storage_buffer: self.variable_pointers_storage_buffer
                && !other.variable_pointers_storage_buffer,
            vertex_attribute_access_beyond_stride: self
                .vertex_attribute_access_beyond_stride
                && !other.vertex_attribute_access_beyond_stride,
            vertex_attribute_instance_rate_divisor: self
                .vertex_attribute_instance_rate_divisor
                && !other.vertex_attribute_instance_rate_divisor,
            vertex_attribute_instance_rate_zero_divisor: self
                .vertex_attribute_instance_rate_zero_divisor
                && !other.vertex_attribute_instance_rate_zero_divisor,
            vertex_input_dynamic_state: self.vertex_input_dynamic_state
                && !other.vertex_input_dynamic_state,
            vertex_pipeline_stores_and_atomics: self.vertex_pipeline_stores_and_atomics
                && !other.vertex_pipeline_stores_and_atomics,
            video_maintenance1: self.video_maintenance1 && !other.video_maintenance1,
            vulkan_memory_model: self.vulkan_memory_model && !other.vulkan_memory_model,
            vulkan_memory_model_availability_visibility_chains: self
                .vulkan_memory_model_availability_visibility_chains
                && !other.vulkan_memory_model_availability_visibility_chains,
            vulkan_memory_model_device_scope: self.vulkan_memory_model_device_scope
                && !other.vulkan_memory_model_device_scope,
            wide_lines: self.wide_lines && !other.wide_lines,
            workgroup_memory_explicit_layout: self.workgroup_memory_explicit_layout
                && !other.workgroup_memory_explicit_layout,
            workgroup_memory_explicit_layout16_bit_access: self
                .workgroup_memory_explicit_layout16_bit_access
                && !other.workgroup_memory_explicit_layout16_bit_access,
            workgroup_memory_explicit_layout8_bit_access: self
                .workgroup_memory_explicit_layout8_bit_access
                && !other.workgroup_memory_explicit_layout8_bit_access,
            workgroup_memory_explicit_layout_scalar_block_layout: self
                .workgroup_memory_explicit_layout_scalar_block_layout
                && !other.workgroup_memory_explicit_layout_scalar_block_layout,
            ycbcr2plane444_formats: self.ycbcr2plane444_formats
                && !other.ycbcr2plane444_formats,
            ycbcr_degamma: self.ycbcr_degamma && !other.ycbcr_degamma,
            ycbcr_image_arrays: self.ycbcr_image_arrays && !other.ycbcr_image_arrays,
            _ne: crate::NonExhaustive(()),
        }
    }
    /// Returns the members set in `self` or `other`, but not both.
    #[inline]
    pub const fn symmetric_difference(&self, other: &Self) -> Self {
        Self {
            acceleration_structure: self.acceleration_structure
                ^ other.acceleration_structure,
            acceleration_structure_capture_replay: self
                .acceleration_structure_capture_replay
                ^ other.acceleration_structure_capture_replay,
            acceleration_structure_host_commands: self
                .acceleration_structure_host_commands
                ^ other.acceleration_structure_host_commands,
            acceleration_structure_indirect_build: self
                .acceleration_structure_indirect_build
                ^ other.acceleration_structure_indirect_build,
            advanced_blend_coherent_operations: self.advanced_blend_coherent_operations
                ^ other.advanced_blend_coherent_operations,
            alpha_to_one: self.alpha_to_one ^ other.alpha_to_one,
            amigo_profiling: self.amigo_profiling ^ other.amigo_profiling,
            attachment_feedback_loop_dynamic_state: self
                .attachment_feedback_loop_dynamic_state
                ^ other.attachment_feedback_loop_dynamic_state,
            attachment_feedback_loop_layout: self.attachment_feedback_loop_layout
                ^ other.attachment_feedback_loop_layout,
            attachment_fragment_shading_rate: self.attachment_fragment_shading_rate
                ^ other.attachment_fragment_shading_rate,
            border_color_swizzle: self.border_color_swizzle ^ other.border_color_swizzle,
            border_color_swizzle_from_image: self.border_color_swizzle_from_image
                ^ other.border_color_swizzle_from_image,
            bresenham_lines: self.bresenham_lines ^ other.bresenham_lines,
            buffer_device_address: self.buffer_device_address
                ^ other.buffer_device_address,
            buffer_device_address_capture_replay: self
                .buffer_device_address_capture_replay
                ^ other.buffer_device_address_capture_replay,
            buffer_device_address_multi_device: self.buffer_device_address_multi_device
                ^ other.buffer_device_address_multi_device,
            clusterculling_shader: self.clusterculling_shader
                ^ other.clusterculling_shader,
            color_write_enable: self.color_write_enable ^ other.color_write_enable,
            compute_derivative_group_linear: self.compute_derivative_group_linear
                ^ other.compute_derivative_group_linear,
            compute_derivative_group_quads: self.compute_derivative_group_quads
                ^ other.compute_derivative_group_quads,
            compute_full_subgroups: self.compute_full_subgroups
                ^ other.compute_full_subgroups,
            conditional_rendering: self.conditional_rendering
                ^ other.conditional_rendering,
            constant_alpha_color_blend_factors: self.constant_alpha_color_blend_factors
                ^ other.constant_alpha_color_blend_factors,
            cooperative_matrix: self.cooperative_matrix ^ other.cooperative_matrix,
            cooperative_matrix_robust_buffer_access: self
                .cooperative_matrix_robust_buffer_access
                ^ other.cooperative_matrix_robust_buffer_access,
            corner_sampled_image: self.corner_sampled_image ^ other.corner_sampled_image,
            coverage_reduction_mode: self.coverage_reduction_mode
                ^ other.coverage_reduction_mode,
            cubic_range_clamp: self.cubic_range_clamp ^ other.cubic_range_clamp,
            cuda_kernel_launch_features: self.cuda_kernel_launch_features
                ^ other.cuda_kernel_launch_features,
            custom_border_color_without_format: self.custom_border_color_without_format
                ^ other.custom_border_color_without_format,
            custom_border_colors: self.custom_border_colors ^ other.custom_border_colors,
            decode_mode_shared_exponent: self.decode_mode_shared_exponent
                ^ other.decode_mode_shared_exponent,
            dedicated_allocation_image_aliasing: self.dedicated_allocation_image_aliasing
                ^ other.dedicated_allocation_image_aliasing,
            depth_bias_clamp: self.depth_bias_clamp ^ other.depth_bias_clamp,
            depth_bias_control: self.depth_bias_control ^ other.depth_bias_control,
            depth_bias_exact: self.depth_bias_exact ^ other.depth_bias_exact,
            depth_bounds: self.depth_bounds ^ other.depth_bounds,
            depth_clamp: self.depth_clamp ^ other.depth_clamp,
            depth_clamp_zero_one: self.depth_clamp_zero_one ^ other.depth_clamp_zero_one,
            depth_clip_control: self.depth_clip_control ^ other.depth_clip_control,
            depth_clip_enable: self.depth_clip_enable ^ other.depth_clip_enable,
            descriptor_binding_acceleration_structure_update_after_bind: self
                .descriptor_binding_acceleration_structure_update_after_bind
                ^ other.descriptor_binding_acceleration_structure_update_after_bind,
            descriptor_binding_inline_uniform_block_update_after_bind: self
                .descriptor_binding_inline_uniform_block_update_after_bind
                ^ other.descriptor_binding_inline_uniform_block_update_after_bind,
            descriptor_binding_partially_bound: self.descriptor_binding_partially_bound
                ^ other.descriptor_binding_partially_bound,
            descriptor_binding_sampled_image_update_after_bind: self
                .descriptor_binding_sampled_image_update_after_bind
                ^ other.descriptor_binding_sampled_image_update_after_bind,
            descriptor_binding_storage_buffer_update_after_bind: self
                .descriptor_binding_storage_buffer_update_after_bind
                ^ other.descriptor_binding_storage_buffer_update_after_bind,
            descriptor_binding_storage_image_update_after_bind: self
                .descriptor_binding_storage_image_update_after_bind
                ^ other.descriptor_binding_storage_image_update_after_bind,
            descriptor_binding_storage_texel_buffer_update_after_bind: self
                .descriptor_binding_storage_texel_buffer_update_after_bind
                ^ other.descriptor_binding_storage_texel_buffer_update_after_bind,
            descriptor_binding_uniform_buffer_update_after_bind: self
                .descriptor_binding_uniform_buffer_update_after_bind
                ^ other.descriptor_binding_uniform_buffer_update_after_bind,
            descriptor_binding_uniform_texel_buffer_update_after_bind: self
                .descriptor_binding_uniform_texel_buffer_update_after_bind
                ^ other.descriptor_binding_uniform_texel_buffer_update_after_bind,
            descriptor_binding_update_unused_while_pending: self
                .descriptor_binding_update_unused_while_pending
                ^ other.descriptor_binding_update_unused_while_pending,
            descriptor_binding_variable_descriptor_count: self
                .descriptor_binding_variable_descriptor_count
                ^ other.descriptor_binding_variable_descriptor_count,
            descriptor_buffer: self.descriptor_buffer ^ other.descriptor_buffer,
            descriptor_buffer_capture_replay: self.descriptor_buffer_capture_replay
                ^ other.descriptor_buffer_capture_replay,
            descriptor_buffer_image_layout_ignored: self
                .descriptor_buffer_image_layout_ignored
                ^ other.descriptor_buffer_image_layout_ignored,
            descriptor_buffer_push_descriptors: self.descriptor_buffer_push_descriptors
                ^ other.descriptor_buffer_push_descriptors,
            descriptor_indexing: self.descriptor_indexing ^ other.descriptor_indexing,
            descriptor_pool_overallocation: self.descriptor_pool_overallocation
                ^ other.descriptor_pool_overallocation,
            descriptor_set_host_mapping: self.descriptor_set_host_mapping
                ^ other.descriptor_set_host_mapping,
            device_coherent_memory: self.device_coherent_memory
                ^ other.device_coherent_memory,
            device_fault: self.device_fault ^ other.device_fault,
            device_fault_vendor_binary: self.device_fault_vendor_binary
                ^ other.device_fault_vendor_binary,
            device_generated_commands: self.device_generated_commands
                ^ other.device_generated_commands,
            device_generated_compute: self.device_generated_compute
                ^ other.device_generated_compute,
            device_generated_compute_capture_replay: self
                .device_generated_compute_capture_replay
                ^ other.device_generated_compute_capture_replay,
            device_generated_compute_pipelines: self.device_generated_compute_pipelines
                ^ other.device_generated_compute_pipelines,
            device_memory_report: self.device_memory_report ^ other.device_memory_report,
            diagnostics_config: self.diagnostics_config ^ other.diagnostics_config,
            displacement_micromap: self.displacement_micromap
                ^ other.displacement_micromap,
            draw_indirect_count: self.draw_indirect_count ^ other.draw_indirect_count,
            draw_indirect_first_instance: self.draw_indirect_first_instance
                ^ other.draw_indirect_first_instance,
            dual_src_blend: self.dual_src_blend ^ other.dual_src_blend,
            dynamic_pipeline_layout: self.dynamic_pipeline_layout
                ^ other.dynamic_pipeline_layout,
            dynamic_rendering: self.dynamic_rendering ^ other.dynamic_rendering,
            dynamic_rendering_local_read: self.dynamic_rendering_local_read
                ^ other.dynamic_rendering_local_read,
            dynamic_rendering_unused_attachments: self
                .dynamic_rendering_unused_attachments
                ^ other.dynamic_rendering_unused_attachments,
            events: self.events ^ other.events,
            exclusive_scissor: self.exclusive_scissor ^ other.exclusive_scissor,
            extended_dynamic_state: self.extended_dynamic_state
                ^ other.extended_dynamic_state,
            extended_dynamic_state2: self.extended_dynamic_state2
                ^ other.extended_dynamic_state2,
            extended_dynamic_state2_logic_op: self.extended_dynamic_state2_logic_op
                ^ other.extended_dynamic_state2_logic_op,
            extended_dynamic_state2_patch_control_points: self
                .extended_dynamic_state2_patch_control_points
                ^ other.extended_dynamic_state2_patch_control_points,
            extended_dynamic_state3_alpha_to_coverage_enable: self
                .extended_dynamic_state3_alpha_to_coverage_enable
                ^ other.extended_dynamic_state3_alpha_to_coverage_enable,
            extended_dynamic_state3_alpha_to_one_enable: self
                .extended_dynamic_state3_alpha_to_one_enable
                ^ other.extended_dynamic_state3_alpha_to_one_enable,
            extended_dynamic_state3_color_blend_advanced: self
                .extended_dynamic_state3_color_blend_advanced
                ^ other.extended_dynamic_state3_color_blend_advanced,
            extended_dynamic_state3_color_blend_enable: self
                .extended_dynamic_state3_color_blend_enable
                ^ other.extended_dynamic_state3_color_blend_enable,
            extended_dynamic_state3_color_blend_equation: self
                .extended_dynamic_state3_color_blend_equation
                ^ other.extended_dynamic_state3_color_blend_equation,
            extended_dynamic_state3_color_write_mask: self
                .extended_dynamic_state3_color_write_mask
                ^ other.extended_dynamic_state3_color_write_mask,
            extended_dynamic_state3_conservative_rasterization_mode: self
                .extended_dynamic_state3_conservative_rasterization_mode
                ^ other.extended_dynamic_state3_conservative_rasterization_mode,
            extended_dynamic_state3_coverage_modulation_mode: self
                .extended_dynamic_state3_coverage_modulation_mode
                ^ other.extended_dynamic_state3_coverage_modulation_mode,
            extended_dynamic_state3_coverage_modulation_table: self
                .extended_dynamic_state3_coverage_modulation_table
                ^ other.extended_dynamic_state3_coverage_modulation_table,
            extended_dynamic_state3_coverage_modulation_table_enable: self
                .extended_dynamic_state3_coverage_modulation_table_enable
                ^ other.extended_dynamic_state3_coverage_modulation_table_enable,
            extended_dynamic_state3_coverage_reduction_mode: self
                .extended_dynamic_state3_coverage_reduction_mode
                ^ other.extended_dynamic_state3_coverage_reduction_mode,
            extended_dynamic_state3_coverage_to_color_enable: self
                .extended_dynamic_state3_coverage_to_color_enable
                ^ other.extended_dynamic_state3_coverage_to_color_enable,
            extended_dynamic_state3_coverage_to_color_location: self
                .extended_dynamic_state3_coverage_to_color_location
                ^ other.extended_dynamic_state3_coverage_to_color_location,
            extended_dynamic_state3_depth_clamp_enable: self
                .extended_dynamic_state3_depth_clamp_enable
                ^ other.extended_dynamic_state3_depth_clamp_enable,
            extended_dynamic_state3_depth_clip_enable: self
                .extended_dynamic_state3_depth_clip_enable
                ^ other.extended_dynamic_state3_depth_clip_enable,
            extended_dynamic_state3_depth_clip_negative_one_to_one: self
                .extended_dynamic_state3_depth_clip_negative_one_to_one
                ^ other.extended_dynamic_state3_depth_clip_negative_one_to_one,
            extended_dynamic_state3_extra_primitive_overestimation_size: self
                .extended_dynamic_state3_extra_primitive_overestimation_size
                ^ other.extended_dynamic_state3_extra_primitive_overestimation_size,
            extended_dynamic_state3_line_rasterization_mode: self
                .extended_dynamic_state3_line_rasterization_mode
                ^ other.extended_dynamic_state3_line_rasterization_mode,
            extended_dynamic_state3_line_stipple_enable: self
                .extended_dynamic_state3_line_stipple_enable
                ^ other.extended_dynamic_state3_line_stipple_enable,
            extended_dynamic_state3_logic_op_enable: self
                .extended_dynamic_state3_logic_op_enable
                ^ other.extended_dynamic_state3_logic_op_enable,
            extended_dynamic_state3_polygon_mode: self
                .extended_dynamic_state3_polygon_mode
                ^ other.extended_dynamic_state3_polygon_mode,
            extended_dynamic_state3_provoking_vertex_mode: self
                .extended_dynamic_state3_provoking_vertex_mode
                ^ other.extended_dynamic_state3_provoking_vertex_mode,
            extended_dynamic_state3_rasterization_samples: self
                .extended_dynamic_state3_rasterization_samples
                ^ other.extended_dynamic_state3_rasterization_samples,
            extended_dynamic_state3_rasterization_stream: self
                .extended_dynamic_state3_rasterization_stream
                ^ other.extended_dynamic_state3_rasterization_stream,
            extended_dynamic_state3_representative_fragment_test_enable: self
                .extended_dynamic_state3_representative_fragment_test_enable
                ^ other.extended_dynamic_state3_representative_fragment_test_enable,
            extended_dynamic_state3_sample_locations_enable: self
                .extended_dynamic_state3_sample_locations_enable
                ^ other.extended_dynamic_state3_sample_locations_enable,
            extended_dynamic_state3_sample_mask: self.extended_dynamic_state3_sample_mask
                ^ other.extended_dynamic_state3_sample_mask,
            extended_dynamic_state3_shading_rate_image_enable: self
                .extended_dynamic_state3_shading_rate_image_enable
                ^ other.extended_dynamic_state3_shading_rate_image_enable,
            extended_dynamic_state3_tessellation_domain_origin: self
                .extended_dynamic_state3_tessellation_domain_origin
                ^ other.extended_dynamic_state3_tessellation_domain_origin,
            extended_dynamic_state3_viewport_swizzle: self
                .extended_dynamic_state3_viewport_swizzle
                ^ other.extended_dynamic_state3_viewport_swizzle,
            extended_dynamic_state3_viewport_w_scaling_enable: self
                .extended_dynamic_state3_viewport_w_scaling_enable
                ^ other.extended_dynamic_state3_viewport_w_scaling_enable,
            extended_sparse_address_space: self.extended_sparse_address_space
                ^ other.extended_sparse_address_space,
            external_format_resolve: self.external_format_resolve
                ^ other.external_format_resolve,
            external_memory_rdma: self.external_memory_rdma ^ other.external_memory_rdma,
            fill_mode_non_solid: self.fill_mode_non_solid ^ other.fill_mode_non_solid,
            float_representation: self.float_representation ^ other.float_representation,
            format_a4b4g4r4: self.format_a4b4g4r4 ^ other.format_a4b4g4r4,
            format_a4r4g4b4: self.format_a4r4g4b4 ^ other.format_a4r4g4b4,
            format_rgba10x6_without_y_cb_cr_sampler: self
                .format_rgba10x6_without_y_cb_cr_sampler
                ^ other.format_rgba10x6_without_y_cb_cr_sampler,
            fragment_density_map: self.fragment_density_map ^ other.fragment_density_map,
            fragment_density_map_deferred: self.fragment_density_map_deferred
                ^ other.fragment_density_map_deferred,
            fragment_density_map_dynamic: self.fragment_density_map_dynamic
                ^ other.fragment_density_map_dynamic,
            fragment_density_map_non_subsampled_images: self
                .fragment_density_map_non_subsampled_images
                ^ other.fragment_density_map_non_subsampled_images,
            fragment_density_map_offset: self.fragment_density_map_offset
                ^ other.fragment_density_map_offset,
            fragment_shader_barycentric: self.fragment_shader_barycentric
                ^ other.fragment_shader_barycentric,
            fragment_shader_pixel_interlock: self.fragment_shader_pixel_interlock
                ^ other.fragment_shader_pixel_interlock,
            fragment_shader_sample_interlock: self.fragment_shader_sample_interlock
                ^ other.fragment_shader_sample_interlock,
            fragment_shader_shading_rate_interlock: self
                .fragment_shader_shading_rate_interlock
                ^ other.fragment_shader_shading_rate_interlock,
            fragment_shading_rate_enums: self.fragment_shading_rate_enums
                ^ other.fragment_shading_rate_enums,
            fragment_stores_and_atomics: self.fragment_stores_and_atomics
                ^ other.fragment_stores_and_atomics,
            frame_boundary: self.frame_boundary ^ other.frame_boundary,
            full_draw_index_uint32: self.full_draw_index_uint32
                ^ other.full_draw_index_uint32,
            geometry_shader: self.geometry_shader ^ other.geometry_shader,
            geometry_streams: self.geometry_streams ^ other.geometry_streams,
            global_priority_query: self.global_priority_query
                ^ other.global_priority_query,
            graphics_pipeline_library: self.graphics_pipeline_library
                ^ other.graphics_pipeline_library,
            host_image_copy: self.host_image_copy ^ other.host_image_copy,
            host_query_reset: self.host_query_reset ^ other.host_query_reset,
            image2_d_view_of3_d: self.image2_d_view_of3_d ^ other.image2_d_view_of3_d,
            image_compression_control: self.image_compression_control
                ^ other.image_compression_control,
            image_compression_control_swapchain: self.image_compression_control_swapchain
                ^ other.image_compression_control_swapchain,
            image_cube_array: self.image_cube_array ^ other.image_cube_array,
            image_footprint: self.image_footprint ^ other.image_footprint,
            image_sliced_view_of3_d: self.image_sliced_view_of3_d
                ^ other.image_sliced_view_of3_d,
            image_view2_d_on3_d_image: self.image_view2_d_on3_d_image
                ^ other.image_view2_d_on3_d_image,
            image_view_format_reinterpretation: self.image_view_format_reinterpretation
                ^ other.image_view_format_reinterpretation,
            image_view_format_swizzle: self.image_view_format_swizzle
                ^ other.image_view_format_swizzle,
            imageless_framebuffer: self.imageless_framebuffer
                ^ other.imageless_framebuffer,
            independent_blend: self.independent_blend ^ other.independent_blend,
            index_type_uint8: self.index_type_uint8 ^ other.index_type_uint8,
            indirect_copy: self.indirect_copy ^ other.indirect_copy,
            inherited_conditional_rendering: self.inherited_conditional_rendering
                ^ other.inherited_conditional_rendering,
            inherited_queries: self.inherited_queries ^ other.inherited_queries,
            inherited_viewport_scissor2_d: self.inherited_viewport_scissor2_d
                ^ other.inherited_viewport_scissor2_d,
            inline_uniform_block: self.inline_uniform_block ^ other.inline_uniform_block,
            invocation_mask: self.invocation_mask ^ other.invocation_mask,
            large_points: self.large_points ^ other.large_points,
            least_representable_value_force_unorm_representation: self
                .least_representable_value_force_unorm_representation
                ^ other.least_representable_value_force_unorm_representation,
            legacy_dithering: self.legacy_dithering ^ other.legacy_dithering,
            linear_color_attachment: self.linear_color_attachment
                ^ other.linear_color_attachment,
            logic_op: self.logic_op ^ other.logic_op,
            maintenance4: self.maintenance4 ^ other.maintenance4,
            maintenance5: self.maintenance5 ^ other.maintenance5,
            maintenance6: self.maintenance6 ^ other.maintenance6,
            memory_decompression: self.memory_decompression ^ other.memory_decompression,
            memory_map_placed: self.memory_map_placed ^ other.memory_map_placed,
            memory_map_range_placed: self.memory_map_range_placed
                ^ other.memory_map_range_placed,
            memory_priority: self.memory_priority ^ other.memory_priority,
            memory_unmap_reserve: self.memory_unmap_reserve ^ other.memory_unmap_reserve,
            mesh_shader: self.mesh_shader ^ other.mesh_shader,
            mesh_shader_queries: self.mesh_shader_queries ^ other.mesh_shader_queries,
            micromap: self.micromap ^ other.micromap,
            micromap_capture_replay: self.micromap_capture_replay
                ^ other.micromap_capture_replay,
            micromap_host_commands: self.micromap_host_commands
                ^ other.micromap_host_commands,
            min_lod: self.min_lod ^ other.min_lod,
            multi_draw: self.multi_draw ^ other.multi_draw,
            multi_draw_indirect: self.multi_draw_indirect ^ other.multi_draw_indirect,
            multi_viewport: self.multi_viewport ^ other.multi_viewport,
            multisample_array_image: self.multisample_array_image
                ^ other.multisample_array_image,
            multisampled_render_to_single_sampled: self
                .multisampled_render_to_single_sampled
                ^ other.multisampled_render_to_single_sampled,
            multiview: self.multiview ^ other.multiview,
            multiview_cluster_culling_shader: self.multiview_cluster_culling_shader
                ^ other.multiview_cluster_culling_shader,
            multiview_geometry_shader: self.multiview_geometry_shader
                ^ other.multiview_geometry_shader,
            multiview_mesh_shader: self.multiview_mesh_shader
                ^ other.multiview_mesh_shader,
            multiview_per_view_render_areas: self.multiview_per_view_render_areas
                ^ other.multiview_per_view_render_areas,
            multiview_per_view_viewports: self.multiview_per_view_viewports
                ^ other.multiview_per_view_viewports,
            multiview_tessellation_shader: self.multiview_tessellation_shader
                ^ other.multiview_tessellation_shader,
            mutable_comparison_samplers: self.mutable_comparison_samplers
                ^ other.mutable_comparison_samplers,
            mutable_descriptor_type: self.mutable_descriptor_type
                ^ other.mutable_descriptor_type,
            nested_command_buffer: self.nested_command_buffer
                ^ other.nested_command_buffer,
            nested_command_buffer_rendering: self.nested_command_buffer_rendering
                ^ other.nested_command_buffer_rendering,
            nested_command_buffer_simultaneous_use: self
                .nested_command_buffer_simultaneous_use
                ^ other.nested_command_buffer_simultaneous_use,
            no_invocation_fragment_shading_rates: self
                .no_invocation_fragment_shading_rates
                ^ other.no_invocation_fragment_shading_rates,
            non_seamless_cube_map: self.non_seamless_cube_map
                ^ other.non_seamless_cube_map,
            null_descriptor: self.null_descriptor ^ other.null_descriptor,
            occlusion_query_precise: self.occlusion_query_precise
                ^ other.occlusion_query_precise,
            optical_flow: self.optical_flow ^ other.optical_flow,
            pageable_device_local_memory: self.pageable_device_local_memory
                ^ other.pageable_device_local_memory,
            per_stage_descriptor_set: self.per_stage_descriptor_set
                ^ other.per_stage_descriptor_set,
            performance_counter_multiple_query_pools: self
                .performance_counter_multiple_query_pools
                ^ other.performance_counter_multiple_query_pools,
            performance_counter_query_pools: self.performance_counter_query_pools
                ^ other.performance_counter_query_pools,
            pipeline_creation_cache_control: self.pipeline_creation_cache_control
                ^ other.pipeline_creation_cache_control,
            pipeline_executable_info: self.pipeline_executable_info
                ^ other.pipeline_executable_info,
            pipeline_fragment_shading_rate: self.pipeline_fragment_shading_rate
                ^ other.pipeline_fragment_shading_rate,
            pipeline_library_group_handles: self.pipeline_library_group_handles
                ^ other.pipeline_library_group_handles,
            pipeline_properties_identifier: self.pipeline_properties_identifier
                ^ other.pipeline_properties_identifier,
            pipeline_protected_access: self.pipeline_protected_access
                ^ other.pipeline_protected_access,
            pipeline_robustness: self.pipeline_robustness ^ other.pipeline_robustness,
            pipeline_statistics_query: self.pipeline_statistics_query
                ^ other.pipeline_statistics_query,
            point_polygons: self.point_polygons ^ other.point_polygons,
            present_barrier: self.present_barrier ^ other.present_barrier,
            present_id: self.present_id ^ other.present_id,
            present_wait: self.present_wait ^ other.present_wait,
            primitive_fragment_shading_rate: self.primitive_fragment_shading_rate
                ^ other.primitive_fragment_shading_rate,
            primitive_fragment_shading_rate_mesh_shader: self
                .primitive_fragment_shading_rate_mesh_shader
                ^ other.primitive_fragment_shading_rate_mesh_shader,
            primitive_topology_list_restart: self.primitive_topology_list_restart
                ^ other.primitive_topology_list_restart,
            primitive_topology_patch_list_restart: self
                .primitive_topology_patch_list_restart
                ^ other.primitive_topology_patch_list_restart,
            primitives_generated_query: self.primitives_generated_query
                ^ other.primitives_generated_query,
            primitives_generated_query_with_non_zero_streams: self
                .primitives_generated_query_with_non_zero_streams
                ^ other.primitives_generated_query_with_non_zero_streams,
            primitives_generated_query_with_rasterizer_discard: self
                .primitives_generated_query_with_rasterizer_discard
                ^ other.primitives_generated_query_with_rasterizer_discard,
            private_data: self.private_data ^ other.private_data,
            protected_memory: self.protected_memory ^ other.protected_memory,
            provoking_vertex_last: self.provoking_vertex_last
                ^ other.provoking_vertex_last,
            rasterization_order_color_attachment_access: self
                .rasterization_order_color_attachment_access
                ^ other.rasterization_order_color_attachment_access,
            rasterization_order_depth_attachment_access: self
                .rasterization_order_depth_attachment_access
                ^ other.rasterization_order_depth_attachment_access,
            rasterization_order_stencil_attachment_access: self
                .rasterization_order_stencil_attachment_access
                ^ other.rasterization_order_stencil_attachment_access,
            ray_query: self.ray_query ^ other.ray_query,
            ray_tracing_invocation_reorder: self.ray_tracing_invocation_reorder
                ^ other.ray_tracing_invocation_reorder,
            ray_tracing_maintenance1: self.ray_tracing_maintenance1
                ^ other.ray_tracing_maintenance1,
            ray_tracing_motion_blur: self.ray_tracing_motion_blur
                ^ other.ray_tracing_motion_blur,
            ray_tracing_motion_blur_pipeline_trace_rays_indirect: self
                .ray_tracing_motion_blur_pipeline_trace_rays_indirect
                ^ other.ray_tracing_motion_blur_pipeline_trace_rays_indirect,
            ray_tracing_pipeline: self.ray_tracing_pipeline ^ other.ray_tracing_pipeline,
            ray_tracing_pipeline_shader_group_handle_capture_replay: self
                .ray_tracing_pipeline_shader_group_handle_capture_replay
                ^ other.ray_tracing_pipeline_shader_group_handle_capture_replay,
            ray_tracing_pipeline_shader_group_handle_capture_replay_mixed: self
                .ray_tracing_pipeline_shader_group_handle_capture_replay_mixed
                ^ other.ray_tracing_pipeline_shader_group_handle_capture_replay_mixed,
            ray_tracing_pipeline_trace_rays_indirect: self
                .ray_tracing_pipeline_trace_rays_indirect
                ^ other.ray_tracing_pipeline_trace_rays_indirect,
            ray_tracing_pipeline_trace_rays_indirect2: self
                .ray_tracing_pipeline_trace_rays_indirect2
                ^ other.ray_tracing_pipeline_trace_rays_indirect2,
            ray_tracing_position_fetch: self.ray_tracing_position_fetch
                ^ other.ray_tracing_position_fetch,
            ray_tracing_validation: self.ray_tracing_validation
                ^ other.ray_tracing_validation,
            ray_traversal_primitive_culling: self.ray_traversal_primitive_culling
                ^ other.ray_traversal_primitive_culling,
            rectangular_lines: self.rectangular_lines ^ other.rectangular_lines,
            relaxed_line_rasterization: self.relaxed_line_rasterization
                ^ other.relaxed_line_rasterization,
            render_pass_striped: self.render_pass_striped ^ other.render_pass_striped,
            report_address_binding: self.report_address_binding
                ^ other.report_address_binding,
            representative_fragment_test: self.representative_fragment_test
                ^ other.representative_fragment_test,
            robust_buffer_access: self.robust_buffer_access ^ other.robust_buffer_access,
            robust_buffer_access2: self.robust_buffer_access2
                ^ other.robust_buffer_access2,
            robust_image_access: self.robust_image_access ^ other.robust_image_access,
            robust_image_access2: self.robust_image_access2 ^ other.robust_image_access2,
            runtime_descriptor_array: self.runtime_descriptor_array
                ^ other.runtime_descriptor_array,
            sample_rate_shading: self.sample_rate_shading ^ other.sample_rate_shading,
            sampler2_d_view_of3_d: self.sampler2_d_view_of3_d
                ^ other.sampler2_d_view_of3_d,
            sampler_anisotropy: self.sampler_anisotropy ^ other.sampler_anisotropy,
            sampler_filter_minmax: self.sampler_filter_minmax
                ^ other.sampler_filter_minmax,
            sampler_mip_lod_bias: self.sampler_mip_lod_bias ^ other.sampler_mip_lod_bias,
            sampler_mirror_clamp_to_edge: self.sampler_mirror_clamp_to_edge
                ^ other.sampler_mirror_clamp_to_edge,
            sampler_ycbcr_conversion: self.sampler_ycbcr_conversion
                ^ other.sampler_ycbcr_conversion,
            scalar_block_layout: self.scalar_block_layout ^ other.scalar_block_layout,
            scheduling_controls: self.scheduling_controls ^ other.scheduling_controls,
            screen_buffer_import: self.screen_buffer_import ^ other.screen_buffer_import,
            selectable_cubic_weights: self.selectable_cubic_weights
                ^ other.selectable_cubic_weights,
            separate_depth_stencil_layouts: self.separate_depth_stencil_layouts
                ^ other.separate_depth_stencil_layouts,
            separate_stencil_mask_ref: self.separate_stencil_mask_ref
                ^ other.separate_stencil_mask_ref,
            shader_buffer_float16_atomic_add: self.shader_buffer_float16_atomic_add
                ^ other.shader_buffer_float16_atomic_add,
            shader_buffer_float16_atomic_min_max: self
                .shader_buffer_float16_atomic_min_max
                ^ other.shader_buffer_float16_atomic_min_max,
            shader_buffer_float16_atomics: self.shader_buffer_float16_atomics
                ^ other.shader_buffer_float16_atomics,
            shader_buffer_float32_atomic_add: self.shader_buffer_float32_atomic_add
                ^ other.shader_buffer_float32_atomic_add,
            shader_buffer_float32_atomic_min_max: self
                .shader_buffer_float32_atomic_min_max
                ^ other.shader_buffer_float32_atomic_min_max,
            shader_buffer_float32_atomics: self.shader_buffer_float32_atomics
                ^ other.shader_buffer_float32_atomics,
            shader_buffer_float64_atomic_add: self.shader_buffer_float64_atomic_add
                ^ other.shader_buffer_float64_atomic_add,
            shader_buffer_float64_atomic_min_max: self
                .shader_buffer_float64_atomic_min_max
                ^ other.shader_buffer_float64_atomic_min_max,
            shader_buffer_float64_atomics: self.shader_buffer_float64_atomics
                ^ other.shader_buffer_float64_atomics,
            shader_buffer_int64_atomics: self.shader_buffer_int64_atomics
                ^ other.shader_buffer_int64_atomics,
            shader_clip_distance: self.shader_clip_distance ^ other.shader_clip_distance,
            shader_core_builtins: self.shader_core_builtins ^ other.shader_core_builtins,
            shader_cull_distance: self.shader_cull_distance ^ other.shader_cull_distance,
            shader_demote_to_helper_invocation: self.shader_demote_to_helper_invocation
                ^ other.shader_demote_to_helper_invocation,
            shader_device_clock: self.shader_device_clock ^ other.shader_device_clock,
            shader_draw_parameters: self.shader_draw_parameters
                ^ other.shader_draw_parameters,
            shader_early_and_late_fragment_tests: self
                .shader_early_and_late_fragment_tests
                ^ other.shader_early_and_late_fragment_tests,
            shader_enqueue: self.shader_enqueue ^ other.shader_enqueue,
            shader_expect_assume: self.shader_expect_assume ^ other.shader_expect_assume,
            shader_float16: self.shader_float16 ^ other.shader_float16,
            shader_float16_vector_atomics: self.shader_float16_vector_atomics
                ^ other.shader_float16_vector_atomics,
            shader_float64: self.shader_float64 ^ other.shader_float64,
            shader_float_controls2: self.shader_float_controls2
                ^ other.shader_float_controls2,
            shader_image_float32_atomic_add: self.shader_image_float32_atomic_add
                ^ other.shader_image_float32_atomic_add,
            shader_image_float32_atomic_min_max: self.shader_image_float32_atomic_min_max
                ^ other.shader_image_float32_atomic_min_max,
            shader_image_float32_atomics: self.shader_image_float32_atomics
                ^ other.shader_image_float32_atomics,
            shader_image_gather_extended: self.shader_image_gather_extended
                ^ other.shader_image_gather_extended,
            shader_image_int64_atomics: self.shader_image_int64_atomics
                ^ other.shader_image_int64_atomics,
            shader_input_attachment_array_dynamic_indexing: self
                .shader_input_attachment_array_dynamic_indexing
                ^ other.shader_input_attachment_array_dynamic_indexing,
            shader_input_attachment_array_non_uniform_indexing: self
                .shader_input_attachment_array_non_uniform_indexing
                ^ other.shader_input_attachment_array_non_uniform_indexing,
            shader_int16: self.shader_int16 ^ other.shader_int16,
            shader_int64: self.shader_int64 ^ other.shader_int64,
            shader_int8: self.shader_int8 ^ other.shader_int8,
            shader_integer_dot_product: self.shader_integer_dot_product
                ^ other.shader_integer_dot_product,
            shader_integer_functions2: self.shader_integer_functions2
                ^ other.shader_integer_functions2,
            shader_maximal_reconvergence: self.shader_maximal_reconvergence
                ^ other.shader_maximal_reconvergence,
            shader_module_identifier: self.shader_module_identifier
                ^ other.shader_module_identifier,
            shader_object: self.shader_object ^ other.shader_object,
            shader_output_layer: self.shader_output_layer ^ other.shader_output_layer,
            shader_output_viewport_index: self.shader_output_viewport_index
                ^ other.shader_output_viewport_index,
            shader_quad_control: self.shader_quad_control ^ other.shader_quad_control,
            shader_raw_access_chains: self.shader_raw_access_chains
                ^ other.shader_raw_access_chains,
            shader_resource_min_lod: self.shader_resource_min_lod
                ^ other.shader_resource_min_lod,
            shader_resource_residency: self.shader_resource_residency
                ^ other.shader_resource_residency,
            shader_sample_rate_interpolation_functions: self
                .shader_sample_rate_interpolation_functions
                ^ other.shader_sample_rate_interpolation_functions,
            shader_sampled_image_array_dynamic_indexing: self
                .shader_sampled_image_array_dynamic_indexing
                ^ other.shader_sampled_image_array_dynamic_indexing,
            shader_sampled_image_array_non_uniform_indexing: self
                .shader_sampled_image_array_non_uniform_indexing
                ^ other.shader_sampled_image_array_non_uniform_indexing,
            shader_shared_float16_atomic_add: self.shader_shared_float16_atomic_add
                ^ other.shader_shared_float16_atomic_add,
            shader_shared_float16_atomic_min_max: self
                .shader_shared_float16_atomic_min_max
                ^ other.shader_shared_float16_atomic_min_max,
            shader_shared_float16_atomics: self.shader_shared_float16_atomics
                ^ other.shader_shared_float16_atomics,
            shader_shared_float32_atomic_add: self.shader_shared_float32_atomic_add
                ^ other.shader_shared_float32_atomic_add,
            shader_shared_float32_atomic_min_max: self
                .shader_shared_float32_atomic_min_max
                ^ other.shader_shared_float32_atomic_min_max,
            shader_shared_float32_atomics: self.shader_shared_float32_atomics
                ^ other.shader_shared_float32_atomics,
            shader_shared_float64_atomic_add: self.shader_shared_float64_atomic_add
                ^ other.shader_shared_float64_atomic_add,
            shader_shared_float64_atomic_min_max: self
                .shader_shared_float64_atomic_min_max
                ^ other.shader_shared_float64_atomic_min_max,
            shader_shared_float64_atomics: self.shader_shared_float64_atomics
                ^ other.shader_shared_float64_atomics,
            shader_shared_int64_atomics: self.shader_shared_int64_atomics
                ^ other.shader_shared_int64_atomics,
            shader_sm_builtins: self.shader_sm_builtins ^ other.shader_sm_builtins,
            shader_storage_buffer_array_dynamic_indexing: self
                .shader_storage_buffer_array_dynamic_indexing
                ^ other.shader_storage_buffer_array_dynamic_indexing,
            shader_storage_buffer_array_non_uniform_indexing: self
                .shader_storage_buffer_array_non_uniform_indexing
                ^ other.shader_storage_buffer_array_non_uniform_indexing,
            shader_storage_image_array_dynamic_indexing: self
                .shader_storage_image_array_dynamic_indexing
                ^ other.shader_storage_image_array_dynamic_indexing,
            shader_storage_image_array_non_uniform_indexing: self
                .shader_storage_image_array_non_uniform_indexing
                ^ other.shader_storage_image_array_non_uniform_indexing,
            shader_storage_image_extended_formats: self
                .shader_storage_image_extended_formats
                ^ other.shader_storage_image_extended_formats,
            shader_storage_image_multisample: self.shader_storage_image_multisample
                ^ other.shader_storage_image_multisample,
            shader_storage_image_read_without_format: self
                .shader_storage_image_read_without_format
                ^ other.shader_storage_image_read_without_format,
            shader_storage_image_write_without_format: self
                .shader_storage_image_write_without_format
                ^ other.shader_storage_image_write_without_format,
            shader_storage_texel_buffer_array_dynamic_indexing: self
                .shader_storage_texel_buffer_array_dynamic_indexing
                ^ other.shader_storage_texel_buffer_array_dynamic_indexing,
            shader_storage_texel_buffer_array_non_uniform_indexing: self
                .shader_storage_texel_buffer_array_non_uniform_indexing
                ^ other.shader_storage_texel_buffer_array_non_uniform_indexing,
            shader_subgroup_clock: self.shader_subgroup_clock
                ^ other.shader_subgroup_clock,
            shader_subgroup_extended_types: self.shader_subgroup_extended_types
                ^ other.shader_subgroup_extended_types,
            shader_subgroup_rotate: self.shader_subgroup_rotate
                ^ other.shader_subgroup_rotate,
            shader_subgroup_rotate_clustered: self.shader_subgroup_rotate_clustered
                ^ other.shader_subgroup_rotate_clustered,
            shader_subgroup_uniform_control_flow: self
                .shader_subgroup_uniform_control_flow
                ^ other.shader_subgroup_uniform_control_flow,
            shader_terminate_invocation: self.shader_terminate_invocation
                ^ other.shader_terminate_invocation,
            shader_tessellation_and_geometry_point_size: self
                .shader_tessellation_and_geometry_point_size
                ^ other.shader_tessellation_and_geometry_point_size,
            shader_tile_image_color_read_access: self.shader_tile_image_color_read_access
                ^ other.shader_tile_image_color_read_access,
            shader_tile_image_depth_read_access: self.shader_tile_image_depth_read_access
                ^ other.shader_tile_image_depth_read_access,
            shader_tile_image_stencil_read_access: self
                .shader_tile_image_stencil_read_access
                ^ other.shader_tile_image_stencil_read_access,
            shader_uniform_buffer_array_dynamic_indexing: self
                .shader_uniform_buffer_array_dynamic_indexing
                ^ other.shader_uniform_buffer_array_dynamic_indexing,
            shader_uniform_buffer_array_non_uniform_indexing: self
                .shader_uniform_buffer_array_non_uniform_indexing
                ^ other.shader_uniform_buffer_array_non_uniform_indexing,
            shader_uniform_texel_buffer_array_dynamic_indexing: self
                .shader_uniform_texel_buffer_array_dynamic_indexing
                ^ other.shader_uniform_texel_buffer_array_dynamic_indexing,
            shader_uniform_texel_buffer_array_non_uniform_indexing: self
                .shader_uniform_texel_buffer_array_non_uniform_indexing
                ^ other.shader_uniform_texel_buffer_array_non_uniform_indexing,
            shader_zero_initialize_workgroup_memory: self
                .shader_zero_initialize_workgroup_memory
                ^ other.shader_zero_initialize_workgroup_memory,
            shading_rate_coarse_sample_order: self.shading_rate_coarse_sample_order
                ^ other.shading_rate_coarse_sample_order,
            shading_rate_image: self.shading_rate_image ^ other.shading_rate_image,
            smooth_lines: self.smooth_lines ^ other.smooth_lines,
            sparse_binding: self.sparse_binding ^ other.sparse_binding,
            sparse_image_float32_atomic_add: self.sparse_image_float32_atomic_add
                ^ other.sparse_image_float32_atomic_add,
            sparse_image_float32_atomic_min_max: self.sparse_image_float32_atomic_min_max
                ^ other.sparse_image_float32_atomic_min_max,
            sparse_image_float32_atomics: self.sparse_image_float32_atomics
                ^ other.sparse_image_float32_atomics,
            sparse_image_int64_atomics: self.sparse_image_int64_atomics
                ^ other.sparse_image_int64_atomics,
            sparse_residency16_samples: self.sparse_residency16_samples
                ^ other.sparse_residency16_samples,
            sparse_residency2_samples: self.sparse_residency2_samples
                ^ other.sparse_residency2_samples,
            sparse_residency4_samples: self.sparse_residency4_samples
                ^ other.sparse_residency4_samples,
            sparse_residency8_samples: self.sparse_residency8_samples
                ^ other.sparse_residency8_samples,
            sparse_residency_aliased: self.sparse_residency_aliased
                ^ other.sparse_residency_aliased,
            sparse_residency_buffer: self.sparse_residency_buffer
                ^ other.sparse_residency_buffer,
            sparse_residency_image2_d: self.sparse_residency_image2_d
                ^ other.sparse_residency_image2_d,
            sparse_residency_image3_d: self.sparse_residency_image3_d
                ^ other.sparse_residency_image3_d,
            stippled_bresenham_lines: self.stippled_bresenham_lines
                ^ other.stippled_bresenham_lines,
            stippled_rectangular_lines: self.stippled_rectangular_lines
                ^ other.stippled_rectangular_lines,
            stippled_smooth_lines: self.stippled_smooth_lines
                ^ other.stippled_smooth_lines,
            storage_buffer16_bit_access: self.storage_buffer16_bit_access
                ^ other.storage_buffer16_bit_access,
            storage_buffer8_bit_access: self.storage_buffer8_bit_access
                ^ other.storage_buffer8_bit_access,
            storage_input_output16: self.storage_input_output16
                ^ other.storage_input_output16,
            storage_push_constant16: self.storage_push_constant16
                ^ other.storage_push_constant16,
            storage_push_constant8: self.storage_push_constant8
                ^ other.storage_push_constant8,
            subgroup_broadcast_dynamic_id: self.subgroup_broadcast_dynamic_id
                ^ other.subgroup_broadcast_dynamic_id,
            subgroup_size_control: self.subgroup_size_control
                ^ other.subgroup_size_control,
            subpass_merge_feedback: self.subpass_merge_feedback
                ^ other.subpass_merge_feedback,
            subpass_shading: self.subpass_shading ^ other.subpass_shading,
            supersample_fragment_shading_rates: self.supersample_fragment_shading_rates
                ^ other.supersample_fragment_shading_rates,
            swapchain_maintenance1: self.swapchain_maintenance1
                ^ other.swapchain_maintenance1,
            synchronization2: self.synchronization2 ^ other.synchronization2,
            task_shader: self.task_shader ^ other.task_shader,
            tessellation_isolines: self.tessellation_isolines
                ^ other.tessellation_isolines,
            tessellation_point_mode: self.tessellation_point_mode
                ^ other.tessellation_point_mode,
            tessellation_shader: self.tessellation_shader ^ other.tessellation_shader,
            texel_buffer_alignment: self.texel_buffer_alignment
                ^ other.texel_buffer_alignment,
            texture_block_match: self.texture_block_match ^ other.texture_block_match,
            texture_block_match2: self.texture_block_match2 ^ other.texture_block_match2,
            texture_box_filter: self.texture_box_filter ^ other.texture_box_filter,
            texture_compression_astc_hdr: self.texture_compression_astc_hdr
                ^ other.texture_compression_astc_hdr,
            texture_compression_astc_ldr: self.texture_compression_astc_ldr
                ^ other.texture_compression_astc_ldr,
            texture_compression_bc: self.texture_compression_bc
                ^ other.texture_compression_bc,
            texture_compression_etc2: self.texture_compression_etc2
                ^ other.texture_compression_etc2,
            texture_sample_weighted: self.texture_sample_weighted
                ^ other.texture_sample_weighted,
            tile_properties: self.tile_properties ^ other.tile_properties,
            timeline_semaphore: self.timeline_semaphore ^ other.timeline_semaphore,
            transform_feedback: self.transform_feedback ^ other.transform_feedback,
            transform_feedback_preserves_provoking_vertex: self
                .transform_feedback_preserves_provoking_vertex
                ^ other.transform_feedback_preserves_provoking_vertex,
            triangle_fans: self.triangle_fans ^ other.triangle_fans,
            uniform_and_storage_buffer16_bit_access: self
                .uniform_and_storage_buffer16_bit_access
                ^ other.uniform_and_storage_buffer16_bit_access,
            uniform_and_storage_buffer8_bit_access: self
                .uniform_and_storage_buffer8_bit_access
                ^ other.uniform_and_storage_buffer8_bit_access,
            uniform_buffer_standard_layout: self.uniform_buffer_standard_layout
                ^ other.uniform_buffer_standard_layout,
            variable_multisample_rate: self.variable_multisample_rate
                ^ other.variable_multisample_rate,
            variable_pointers: self.variable_pointers ^ other.variable_pointers,
            variable_pointers_storage_buffer: self.variable_pointers_storage_buffer
                ^ other.variable_pointers_storage_buffer,
            vertex_attribute_access_beyond_stride: self
                .vertex_attribute_access_beyond_stride
                ^ other.vertex_attribute_access_beyond_stride,
            vertex_attribute_instance_rate_divisor: self
                .vertex_attribute_instance_rate_divisor
                ^ other.vertex_attribute_instance_rate_divisor,
            vertex_attribute_instance_rate_zero_divisor: self
                .vertex_attribute_instance_rate_zero_divisor
                ^ other.vertex_attribute_instance_rate_zero_divisor,
            vertex_input_dynamic_state: self.vertex_input_dynamic_state
                ^ other.vertex_input_dynamic_state,
            vertex_pipeline_stores_and_atomics: self.vertex_pipeline_stores_and_atomics
                ^ other.vertex_pipeline_stores_and_atomics,
            video_maintenance1: self.video_maintenance1 ^ other.video_maintenance1,
            vulkan_memory_model: self.vulkan_memory_model ^ other.vulkan_memory_model,
            vulkan_memory_model_availability_visibility_chains: self
                .vulkan_memory_model_availability_visibility_chains
                ^ other.vulkan_memory_model_availability_visibility_chains,
            vulkan_memory_model_device_scope: self.vulkan_memory_model_device_scope
                ^ other.vulkan_memory_model_device_scope,
            wide_lines: self.wide_lines ^ other.wide_lines,
            workgroup_memory_explicit_layout: self.workgroup_memory_explicit_layout
                ^ other.workgroup_memory_explicit_layout,
            workgroup_memory_explicit_layout16_bit_access: self
                .workgroup_memory_explicit_layout16_bit_access
                ^ other.workgroup_memory_explicit_layout16_bit_access,
            workgroup_memory_explicit_layout8_bit_access: self
                .workgroup_memory_explicit_layout8_bit_access
                ^ other.workgroup_memory_explicit_layout8_bit_access,
            workgroup_memory_explicit_layout_scalar_block_layout: self
                .workgroup_memory_explicit_layout_scalar_block_layout
                ^ other.workgroup_memory_explicit_layout_scalar_block_layout,
            ycbcr2plane444_formats: self.ycbcr2plane444_formats
                ^ other.ycbcr2plane444_formats,
            ycbcr_degamma: self.ycbcr_degamma ^ other.ycbcr_degamma,
            ycbcr_image_arrays: self.ycbcr_image_arrays ^ other.ycbcr_image_arrays,
            _ne: crate::NonExhaustive(()),
        }
    }
}
impl std::ops::BitAnd for DeviceFeatures {
    type Output = DeviceFeatures;
    #[inline]
    fn bitand(self, rhs: Self) -> Self::Output {
        self.intersection(&rhs)
    }
}
impl std::ops::BitAndAssign for DeviceFeatures {
    #[inline]
    fn bitand_assign(&mut self, rhs: Self) {
        *self = self.intersection(&rhs);
    }
}
impl std::ops::BitOr for DeviceFeatures {
    type Output = DeviceFeatures;
    #[inline]
    fn bitor(self, rhs: Self) -> Self::Output {
        self.union(&rhs)
    }
}
impl std::ops::BitOrAssign for DeviceFeatures {
    #[inline]
    fn bitor_assign(&mut self, rhs: Self) {
        *self = self.union(&rhs);
    }
}
impl std::ops::BitXor for DeviceFeatures {
    type Output = DeviceFeatures;
    #[inline]
    fn bitxor(self, rhs: Self) -> Self::Output {
        self.symmetric_difference(&rhs)
    }
}
impl std::ops::BitXorAssign for DeviceFeatures {
    #[inline]
    fn bitxor_assign(&mut self, rhs: Self) {
        *self = self.symmetric_difference(&rhs);
    }
}
impl std::ops::Sub for DeviceFeatures {
    type Output = DeviceFeatures;
    #[inline]
    fn sub(self, rhs: Self) -> Self::Output {
        self.difference(&rhs)
    }
}
impl std::ops::SubAssign for DeviceFeatures {
    #[inline]
    fn sub_assign(&mut self, rhs: Self) {
        *self = self.difference(&rhs);
    }
}
impl std::fmt::Debug for DeviceFeatures {
    #[allow(unused_assignments)]
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(f, "[")?;
        let mut first = true;
        if self.acceleration_structure {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("accelerationStructure")?;
        }
        if self.acceleration_structure_capture_replay {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("accelerationStructureCaptureReplay")?;
        }
        if self.acceleration_structure_host_commands {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("accelerationStructureHostCommands")?;
        }
        if self.acceleration_structure_indirect_build {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("accelerationStructureIndirectBuild")?;
        }
        if self.advanced_blend_coherent_operations {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("advancedBlendCoherentOperations")?;
        }
        if self.alpha_to_one {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("alphaToOne")?;
        }
        if self.amigo_profiling {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("amigoProfiling")?;
        }
        if self.attachment_feedback_loop_dynamic_state {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("attachmentFeedbackLoopDynamicState")?;
        }
        if self.attachment_feedback_loop_layout {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("attachmentFeedbackLoopLayout")?;
        }
        if self.attachment_fragment_shading_rate {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("attachmentFragmentShadingRate")?;
        }
        if self.border_color_swizzle {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("borderColorSwizzle")?;
        }
        if self.border_color_swizzle_from_image {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("borderColorSwizzleFromImage")?;
        }
        if self.bresenham_lines {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("bresenhamLines")?;
        }
        if self.buffer_device_address {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("bufferDeviceAddress")?;
        }
        if self.buffer_device_address_capture_replay {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("bufferDeviceAddressCaptureReplay")?;
        }
        if self.buffer_device_address_multi_device {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("bufferDeviceAddressMultiDevice")?;
        }
        if self.clusterculling_shader {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("clustercullingShader")?;
        }
        if self.color_write_enable {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("colorWriteEnable")?;
        }
        if self.compute_derivative_group_linear {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("computeDerivativeGroupLinear")?;
        }
        if self.compute_derivative_group_quads {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("computeDerivativeGroupQuads")?;
        }
        if self.compute_full_subgroups {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("computeFullSubgroups")?;
        }
        if self.conditional_rendering {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("conditionalRendering")?;
        }
        if self.constant_alpha_color_blend_factors {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("constantAlphaColorBlendFactors")?;
        }
        if self.cooperative_matrix {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("cooperativeMatrix")?;
        }
        if self.cooperative_matrix_robust_buffer_access {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("cooperativeMatrixRobustBufferAccess")?;
        }
        if self.corner_sampled_image {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("cornerSampledImage")?;
        }
        if self.coverage_reduction_mode {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("coverageReductionMode")?;
        }
        if self.cubic_range_clamp {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("cubicRangeClamp")?;
        }
        if self.cuda_kernel_launch_features {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("cudaKernelLaunchFeatures")?;
        }
        if self.custom_border_color_without_format {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("customBorderColorWithoutFormat")?;
        }
        if self.custom_border_colors {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("customBorderColors")?;
        }
        if self.decode_mode_shared_exponent {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("decodeModeSharedExponent")?;
        }
        if self.dedicated_allocation_image_aliasing {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("dedicatedAllocationImageAliasing")?;
        }
        if self.depth_bias_clamp {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("depthBiasClamp")?;
        }
        if self.depth_bias_control {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("depthBiasControl")?;
        }
        if self.depth_bias_exact {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("depthBiasExact")?;
        }
        if self.depth_bounds {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("depthBounds")?;
        }
        if self.depth_clamp {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("depthClamp")?;
        }
        if self.depth_clamp_zero_one {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("depthClampZeroOne")?;
        }
        if self.depth_clip_control {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("depthClipControl")?;
        }
        if self.depth_clip_enable {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("depthClipEnable")?;
        }
        if self.descriptor_binding_acceleration_structure_update_after_bind {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("descriptorBindingAccelerationStructureUpdateAfterBind")?;
        }
        if self.descriptor_binding_inline_uniform_block_update_after_bind {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("descriptorBindingInlineUniformBlockUpdateAfterBind")?;
        }
        if self.descriptor_binding_partially_bound {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("descriptorBindingPartiallyBound")?;
        }
        if self.descriptor_binding_sampled_image_update_after_bind {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("descriptorBindingSampledImageUpdateAfterBind")?;
        }
        if self.descriptor_binding_storage_buffer_update_after_bind {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("descriptorBindingStorageBufferUpdateAfterBind")?;
        }
        if self.descriptor_binding_storage_image_update_after_bind {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("descriptorBindingStorageImageUpdateAfterBind")?;
        }
        if self.descriptor_binding_storage_texel_buffer_update_after_bind {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("descriptorBindingStorageTexelBufferUpdateAfterBind")?;
        }
        if self.descriptor_binding_uniform_buffer_update_after_bind {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("descriptorBindingUniformBufferUpdateAfterBind")?;
        }
        if self.descriptor_binding_uniform_texel_buffer_update_after_bind {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("descriptorBindingUniformTexelBufferUpdateAfterBind")?;
        }
        if self.descriptor_binding_update_unused_while_pending {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("descriptorBindingUpdateUnusedWhilePending")?;
        }
        if self.descriptor_binding_variable_descriptor_count {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("descriptorBindingVariableDescriptorCount")?;
        }
        if self.descriptor_buffer {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("descriptorBuffer")?;
        }
        if self.descriptor_buffer_capture_replay {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("descriptorBufferCaptureReplay")?;
        }
        if self.descriptor_buffer_image_layout_ignored {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("descriptorBufferImageLayoutIgnored")?;
        }
        if self.descriptor_buffer_push_descriptors {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("descriptorBufferPushDescriptors")?;
        }
        if self.descriptor_indexing {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("descriptorIndexing")?;
        }
        if self.descriptor_pool_overallocation {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("descriptorPoolOverallocation")?;
        }
        if self.descriptor_set_host_mapping {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("descriptorSetHostMapping")?;
        }
        if self.device_coherent_memory {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("deviceCoherentMemory")?;
        }
        if self.device_fault {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("deviceFault")?;
        }
        if self.device_fault_vendor_binary {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("deviceFaultVendorBinary")?;
        }
        if self.device_generated_commands {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("deviceGeneratedCommands")?;
        }
        if self.device_generated_compute {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("deviceGeneratedCompute")?;
        }
        if self.device_generated_compute_capture_replay {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("deviceGeneratedComputeCaptureReplay")?;
        }
        if self.device_generated_compute_pipelines {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("deviceGeneratedComputePipelines")?;
        }
        if self.device_memory_report {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("deviceMemoryReport")?;
        }
        if self.diagnostics_config {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("diagnosticsConfig")?;
        }
        if self.displacement_micromap {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("displacementMicromap")?;
        }
        if self.draw_indirect_count {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("drawIndirectCount")?;
        }
        if self.draw_indirect_first_instance {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("drawIndirectFirstInstance")?;
        }
        if self.dual_src_blend {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("dualSrcBlend")?;
        }
        if self.dynamic_pipeline_layout {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("dynamicPipelineLayout")?;
        }
        if self.dynamic_rendering {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("dynamicRendering")?;
        }
        if self.dynamic_rendering_local_read {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("dynamicRenderingLocalRead")?;
        }
        if self.dynamic_rendering_unused_attachments {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("dynamicRenderingUnusedAttachments")?;
        }
        if self.events {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("events")?;
        }
        if self.exclusive_scissor {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("exclusiveScissor")?;
        }
        if self.extended_dynamic_state {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("extendedDynamicState")?;
        }
        if self.extended_dynamic_state2 {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("extendedDynamicState2")?;
        }
        if self.extended_dynamic_state2_logic_op {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("extendedDynamicState2LogicOp")?;
        }
        if self.extended_dynamic_state2_patch_control_points {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("extendedDynamicState2PatchControlPoints")?;
        }
        if self.extended_dynamic_state3_alpha_to_coverage_enable {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("extendedDynamicState3AlphaToCoverageEnable")?;
        }
        if self.extended_dynamic_state3_alpha_to_one_enable {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("extendedDynamicState3AlphaToOneEnable")?;
        }
        if self.extended_dynamic_state3_color_blend_advanced {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("extendedDynamicState3ColorBlendAdvanced")?;
        }
        if self.extended_dynamic_state3_color_blend_enable {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("extendedDynamicState3ColorBlendEnable")?;
        }
        if self.extended_dynamic_state3_color_blend_equation {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("extendedDynamicState3ColorBlendEquation")?;
        }
        if self.extended_dynamic_state3_color_write_mask {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("extendedDynamicState3ColorWriteMask")?;
        }
        if self.extended_dynamic_state3_conservative_rasterization_mode {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("extendedDynamicState3ConservativeRasterizationMode")?;
        }
        if self.extended_dynamic_state3_coverage_modulation_mode {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("extendedDynamicState3CoverageModulationMode")?;
        }
        if self.extended_dynamic_state3_coverage_modulation_table {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("extendedDynamicState3CoverageModulationTable")?;
        }
        if self.extended_dynamic_state3_coverage_modulation_table_enable {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("extendedDynamicState3CoverageModulationTableEnable")?;
        }
        if self.extended_dynamic_state3_coverage_reduction_mode {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("extendedDynamicState3CoverageReductionMode")?;
        }
        if self.extended_dynamic_state3_coverage_to_color_enable {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("extendedDynamicState3CoverageToColorEnable")?;
        }
        if self.extended_dynamic_state3_coverage_to_color_location {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("extendedDynamicState3CoverageToColorLocation")?;
        }
        if self.extended_dynamic_state3_depth_clamp_enable {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("extendedDynamicState3DepthClampEnable")?;
        }
        if self.extended_dynamic_state3_depth_clip_enable {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("extendedDynamicState3DepthClipEnable")?;
        }
        if self.extended_dynamic_state3_depth_clip_negative_one_to_one {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("extendedDynamicState3DepthClipNegativeOneToOne")?;
        }
        if self.extended_dynamic_state3_extra_primitive_overestimation_size {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("extendedDynamicState3ExtraPrimitiveOverestimationSize")?;
        }
        if self.extended_dynamic_state3_line_rasterization_mode {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("extendedDynamicState3LineRasterizationMode")?;
        }
        if self.extended_dynamic_state3_line_stipple_enable {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("extendedDynamicState3LineStippleEnable")?;
        }
        if self.extended_dynamic_state3_logic_op_enable {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("extendedDynamicState3LogicOpEnable")?;
        }
        if self.extended_dynamic_state3_polygon_mode {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("extendedDynamicState3PolygonMode")?;
        }
        if self.extended_dynamic_state3_provoking_vertex_mode {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("extendedDynamicState3ProvokingVertexMode")?;
        }
        if self.extended_dynamic_state3_rasterization_samples {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("extendedDynamicState3RasterizationSamples")?;
        }
        if self.extended_dynamic_state3_rasterization_stream {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("extendedDynamicState3RasterizationStream")?;
        }
        if self.extended_dynamic_state3_representative_fragment_test_enable {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("extendedDynamicState3RepresentativeFragmentTestEnable")?;
        }
        if self.extended_dynamic_state3_sample_locations_enable {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("extendedDynamicState3SampleLocationsEnable")?;
        }
        if self.extended_dynamic_state3_sample_mask {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("extendedDynamicState3SampleMask")?;
        }
        if self.extended_dynamic_state3_shading_rate_image_enable {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("extendedDynamicState3ShadingRateImageEnable")?;
        }
        if self.extended_dynamic_state3_tessellation_domain_origin {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("extendedDynamicState3TessellationDomainOrigin")?;
        }
        if self.extended_dynamic_state3_viewport_swizzle {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("extendedDynamicState3ViewportSwizzle")?;
        }
        if self.extended_dynamic_state3_viewport_w_scaling_enable {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("extendedDynamicState3ViewportWScalingEnable")?;
        }
        if self.extended_sparse_address_space {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("extendedSparseAddressSpace")?;
        }
        if self.external_format_resolve {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("externalFormatResolve")?;
        }
        if self.external_memory_rdma {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("externalMemoryRDMA")?;
        }
        if self.fill_mode_non_solid {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("fillModeNonSolid")?;
        }
        if self.float_representation {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("floatRepresentation")?;
        }
        if self.format_a4b4g4r4 {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("formatA4B4G4R4")?;
        }
        if self.format_a4r4g4b4 {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("formatA4R4G4B4")?;
        }
        if self.format_rgba10x6_without_y_cb_cr_sampler {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("formatRgba10x6WithoutYCbCrSampler")?;
        }
        if self.fragment_density_map {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("fragmentDensityMap")?;
        }
        if self.fragment_density_map_deferred {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("fragmentDensityMapDeferred")?;
        }
        if self.fragment_density_map_dynamic {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("fragmentDensityMapDynamic")?;
        }
        if self.fragment_density_map_non_subsampled_images {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("fragmentDensityMapNonSubsampledImages")?;
        }
        if self.fragment_density_map_offset {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("fragmentDensityMapOffset")?;
        }
        if self.fragment_shader_barycentric {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("fragmentShaderBarycentric")?;
        }
        if self.fragment_shader_pixel_interlock {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("fragmentShaderPixelInterlock")?;
        }
        if self.fragment_shader_sample_interlock {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("fragmentShaderSampleInterlock")?;
        }
        if self.fragment_shader_shading_rate_interlock {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("fragmentShaderShadingRateInterlock")?;
        }
        if self.fragment_shading_rate_enums {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("fragmentShadingRateEnums")?;
        }
        if self.fragment_stores_and_atomics {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("fragmentStoresAndAtomics")?;
        }
        if self.frame_boundary {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("frameBoundary")?;
        }
        if self.full_draw_index_uint32 {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("fullDrawIndexUint32")?;
        }
        if self.geometry_shader {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("geometryShader")?;
        }
        if self.geometry_streams {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("geometryStreams")?;
        }
        if self.global_priority_query {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("globalPriorityQuery")?;
        }
        if self.graphics_pipeline_library {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("graphicsPipelineLibrary")?;
        }
        if self.host_image_copy {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("hostImageCopy")?;
        }
        if self.host_query_reset {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("hostQueryReset")?;
        }
        if self.image2_d_view_of3_d {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("image2DViewOf3D")?;
        }
        if self.image_compression_control {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("imageCompressionControl")?;
        }
        if self.image_compression_control_swapchain {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("imageCompressionControlSwapchain")?;
        }
        if self.image_cube_array {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("imageCubeArray")?;
        }
        if self.image_footprint {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("imageFootprint")?;
        }
        if self.image_sliced_view_of3_d {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("imageSlicedViewOf3D")?;
        }
        if self.image_view2_d_on3_d_image {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("imageView2DOn3DImage")?;
        }
        if self.image_view_format_reinterpretation {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("imageViewFormatReinterpretation")?;
        }
        if self.image_view_format_swizzle {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("imageViewFormatSwizzle")?;
        }
        if self.imageless_framebuffer {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("imagelessFramebuffer")?;
        }
        if self.independent_blend {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("independentBlend")?;
        }
        if self.index_type_uint8 {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("indexTypeUint8")?;
        }
        if self.indirect_copy {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("indirectCopy")?;
        }
        if self.inherited_conditional_rendering {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("inheritedConditionalRendering")?;
        }
        if self.inherited_queries {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("inheritedQueries")?;
        }
        if self.inherited_viewport_scissor2_d {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("inheritedViewportScissor2D")?;
        }
        if self.inline_uniform_block {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("inlineUniformBlock")?;
        }
        if self.invocation_mask {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("invocationMask")?;
        }
        if self.large_points {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("largePoints")?;
        }
        if self.least_representable_value_force_unorm_representation {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("leastRepresentableValueForceUnormRepresentation")?;
        }
        if self.legacy_dithering {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("legacyDithering")?;
        }
        if self.linear_color_attachment {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("linearColorAttachment")?;
        }
        if self.logic_op {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("logicOp")?;
        }
        if self.maintenance4 {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("maintenance4")?;
        }
        if self.maintenance5 {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("maintenance5")?;
        }
        if self.maintenance6 {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("maintenance6")?;
        }
        if self.memory_decompression {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("memoryDecompression")?;
        }
        if self.memory_map_placed {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("memoryMapPlaced")?;
        }
        if self.memory_map_range_placed {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("memoryMapRangePlaced")?;
        }
        if self.memory_priority {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("memoryPriority")?;
        }
        if self.memory_unmap_reserve {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("memoryUnmapReserve")?;
        }
        if self.mesh_shader {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("meshShader")?;
        }
        if self.mesh_shader_queries {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("meshShaderQueries")?;
        }
        if self.micromap {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("micromap")?;
        }
        if self.micromap_capture_replay {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("micromapCaptureReplay")?;
        }
        if self.micromap_host_commands {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("micromapHostCommands")?;
        }
        if self.min_lod {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("minLod")?;
        }
        if self.multi_draw {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("multiDraw")?;
        }
        if self.multi_draw_indirect {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("multiDrawIndirect")?;
        }
        if self.multi_viewport {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("multiViewport")?;
        }
        if self.multisample_array_image {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("multisampleArrayImage")?;
        }
        if self.multisampled_render_to_single_sampled {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("multisampledRenderToSingleSampled")?;
        }
        if self.multiview {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("multiview")?;
        }
        if self.multiview_cluster_culling_shader {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("multiviewClusterCullingShader")?;
        }
        if self.multiview_geometry_shader {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("multiviewGeometryShader")?;
        }
        if self.multiview_mesh_shader {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("multiviewMeshShader")?;
        }
        if self.multiview_per_view_render_areas {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("multiviewPerViewRenderAreas")?;
        }
        if self.multiview_per_view_viewports {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("multiviewPerViewViewports")?;
        }
        if self.multiview_tessellation_shader {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("multiviewTessellationShader")?;
        }
        if self.mutable_comparison_samplers {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("mutableComparisonSamplers")?;
        }
        if self.mutable_descriptor_type {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("mutableDescriptorType")?;
        }
        if self.nested_command_buffer {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("nestedCommandBuffer")?;
        }
        if self.nested_command_buffer_rendering {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("nestedCommandBufferRendering")?;
        }
        if self.nested_command_buffer_simultaneous_use {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("nestedCommandBufferSimultaneousUse")?;
        }
        if self.no_invocation_fragment_shading_rates {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("noInvocationFragmentShadingRates")?;
        }
        if self.non_seamless_cube_map {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("nonSeamlessCubeMap")?;
        }
        if self.null_descriptor {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("nullDescriptor")?;
        }
        if self.occlusion_query_precise {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("occlusionQueryPrecise")?;
        }
        if self.optical_flow {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("opticalFlow")?;
        }
        if self.pageable_device_local_memory {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("pageableDeviceLocalMemory")?;
        }
        if self.per_stage_descriptor_set {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("perStageDescriptorSet")?;
        }
        if self.performance_counter_multiple_query_pools {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("performanceCounterMultipleQueryPools")?;
        }
        if self.performance_counter_query_pools {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("performanceCounterQueryPools")?;
        }
        if self.pipeline_creation_cache_control {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("pipelineCreationCacheControl")?;
        }
        if self.pipeline_executable_info {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("pipelineExecutableInfo")?;
        }
        if self.pipeline_fragment_shading_rate {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("pipelineFragmentShadingRate")?;
        }
        if self.pipeline_library_group_handles {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("pipelineLibraryGroupHandles")?;
        }
        if self.pipeline_properties_identifier {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("pipelinePropertiesIdentifier")?;
        }
        if self.pipeline_protected_access {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("pipelineProtectedAccess")?;
        }
        if self.pipeline_robustness {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("pipelineRobustness")?;
        }
        if self.pipeline_statistics_query {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("pipelineStatisticsQuery")?;
        }
        if self.point_polygons {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("pointPolygons")?;
        }
        if self.present_barrier {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("presentBarrier")?;
        }
        if self.present_id {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("presentId")?;
        }
        if self.present_wait {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("presentWait")?;
        }
        if self.primitive_fragment_shading_rate {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("primitiveFragmentShadingRate")?;
        }
        if self.primitive_fragment_shading_rate_mesh_shader {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("primitiveFragmentShadingRateMeshShader")?;
        }
        if self.primitive_topology_list_restart {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("primitiveTopologyListRestart")?;
        }
        if self.primitive_topology_patch_list_restart {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("primitiveTopologyPatchListRestart")?;
        }
        if self.primitives_generated_query {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("primitivesGeneratedQuery")?;
        }
        if self.primitives_generated_query_with_non_zero_streams {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("primitivesGeneratedQueryWithNonZeroStreams")?;
        }
        if self.primitives_generated_query_with_rasterizer_discard {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("primitivesGeneratedQueryWithRasterizerDiscard")?;
        }
        if self.private_data {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("privateData")?;
        }
        if self.protected_memory {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("protectedMemory")?;
        }
        if self.provoking_vertex_last {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("provokingVertexLast")?;
        }
        if self.rasterization_order_color_attachment_access {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("rasterizationOrderColorAttachmentAccess")?;
        }
        if self.rasterization_order_depth_attachment_access {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("rasterizationOrderDepthAttachmentAccess")?;
        }
        if self.rasterization_order_stencil_attachment_access {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("rasterizationOrderStencilAttachmentAccess")?;
        }
        if self.ray_query {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("rayQuery")?;
        }
        if self.ray_tracing_invocation_reorder {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("rayTracingInvocationReorder")?;
        }
        if self.ray_tracing_maintenance1 {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("rayTracingMaintenance1")?;
        }
        if self.ray_tracing_motion_blur {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("rayTracingMotionBlur")?;
        }
        if self.ray_tracing_motion_blur_pipeline_trace_rays_indirect {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("rayTracingMotionBlurPipelineTraceRaysIndirect")?;
        }
        if self.ray_tracing_pipeline {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("rayTracingPipeline")?;
        }
        if self.ray_tracing_pipeline_shader_group_handle_capture_replay {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("rayTracingPipelineShaderGroupHandleCaptureReplay")?;
        }
        if self.ray_tracing_pipeline_shader_group_handle_capture_replay_mixed {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("rayTracingPipelineShaderGroupHandleCaptureReplayMixed")?;
        }
        if self.ray_tracing_pipeline_trace_rays_indirect {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("rayTracingPipelineTraceRaysIndirect")?;
        }
        if self.ray_tracing_pipeline_trace_rays_indirect2 {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("rayTracingPipelineTraceRaysIndirect2")?;
        }
        if self.ray_tracing_position_fetch {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("rayTracingPositionFetch")?;
        }
        if self.ray_tracing_validation {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("rayTracingValidation")?;
        }
        if self.ray_traversal_primitive_culling {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("rayTraversalPrimitiveCulling")?;
        }
        if self.rectangular_lines {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("rectangularLines")?;
        }
        if self.relaxed_line_rasterization {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("relaxedLineRasterization")?;
        }
        if self.render_pass_striped {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("renderPassStriped")?;
        }
        if self.report_address_binding {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("reportAddressBinding")?;
        }
        if self.representative_fragment_test {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("representativeFragmentTest")?;
        }
        if self.robust_buffer_access {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("robustBufferAccess")?;
        }
        if self.robust_buffer_access2 {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("robustBufferAccess2")?;
        }
        if self.robust_image_access {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("robustImageAccess")?;
        }
        if self.robust_image_access2 {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("robustImageAccess2")?;
        }
        if self.runtime_descriptor_array {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("runtimeDescriptorArray")?;
        }
        if self.sample_rate_shading {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("sampleRateShading")?;
        }
        if self.sampler2_d_view_of3_d {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("sampler2DViewOf3D")?;
        }
        if self.sampler_anisotropy {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("samplerAnisotropy")?;
        }
        if self.sampler_filter_minmax {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("samplerFilterMinmax")?;
        }
        if self.sampler_mip_lod_bias {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("samplerMipLodBias")?;
        }
        if self.sampler_mirror_clamp_to_edge {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("samplerMirrorClampToEdge")?;
        }
        if self.sampler_ycbcr_conversion {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("samplerYcbcrConversion")?;
        }
        if self.scalar_block_layout {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("scalarBlockLayout")?;
        }
        if self.scheduling_controls {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("schedulingControls")?;
        }
        if self.screen_buffer_import {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("screenBufferImport")?;
        }
        if self.selectable_cubic_weights {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("selectableCubicWeights")?;
        }
        if self.separate_depth_stencil_layouts {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("separateDepthStencilLayouts")?;
        }
        if self.separate_stencil_mask_ref {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("separateStencilMaskRef")?;
        }
        if self.shader_buffer_float16_atomic_add {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("shaderBufferFloat16AtomicAdd")?;
        }
        if self.shader_buffer_float16_atomic_min_max {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("shaderBufferFloat16AtomicMinMax")?;
        }
        if self.shader_buffer_float16_atomics {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("shaderBufferFloat16Atomics")?;
        }
        if self.shader_buffer_float32_atomic_add {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("shaderBufferFloat32AtomicAdd")?;
        }
        if self.shader_buffer_float32_atomic_min_max {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("shaderBufferFloat32AtomicMinMax")?;
        }
        if self.shader_buffer_float32_atomics {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("shaderBufferFloat32Atomics")?;
        }
        if self.shader_buffer_float64_atomic_add {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("shaderBufferFloat64AtomicAdd")?;
        }
        if self.shader_buffer_float64_atomic_min_max {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("shaderBufferFloat64AtomicMinMax")?;
        }
        if self.shader_buffer_float64_atomics {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("shaderBufferFloat64Atomics")?;
        }
        if self.shader_buffer_int64_atomics {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("shaderBufferInt64Atomics")?;
        }
        if self.shader_clip_distance {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("shaderClipDistance")?;
        }
        if self.shader_core_builtins {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("shaderCoreBuiltins")?;
        }
        if self.shader_cull_distance {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("shaderCullDistance")?;
        }
        if self.shader_demote_to_helper_invocation {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("shaderDemoteToHelperInvocation")?;
        }
        if self.shader_device_clock {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("shaderDeviceClock")?;
        }
        if self.shader_draw_parameters {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("shaderDrawParameters")?;
        }
        if self.shader_early_and_late_fragment_tests {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("shaderEarlyAndLateFragmentTests")?;
        }
        if self.shader_enqueue {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("shaderEnqueue")?;
        }
        if self.shader_expect_assume {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("shaderExpectAssume")?;
        }
        if self.shader_float16 {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("shaderFloat16")?;
        }
        if self.shader_float16_vector_atomics {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("shaderFloat16VectorAtomics")?;
        }
        if self.shader_float64 {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("shaderFloat64")?;
        }
        if self.shader_float_controls2 {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("shaderFloatControls2")?;
        }
        if self.shader_image_float32_atomic_add {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("shaderImageFloat32AtomicAdd")?;
        }
        if self.shader_image_float32_atomic_min_max {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("shaderImageFloat32AtomicMinMax")?;
        }
        if self.shader_image_float32_atomics {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("shaderImageFloat32Atomics")?;
        }
        if self.shader_image_gather_extended {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("shaderImageGatherExtended")?;
        }
        if self.shader_image_int64_atomics {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("shaderImageInt64Atomics")?;
        }
        if self.shader_input_attachment_array_dynamic_indexing {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("shaderInputAttachmentArrayDynamicIndexing")?;
        }
        if self.shader_input_attachment_array_non_uniform_indexing {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("shaderInputAttachmentArrayNonUniformIndexing")?;
        }
        if self.shader_int16 {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("shaderInt16")?;
        }
        if self.shader_int64 {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("shaderInt64")?;
        }
        if self.shader_int8 {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("shaderInt8")?;
        }
        if self.shader_integer_dot_product {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("shaderIntegerDotProduct")?;
        }
        if self.shader_integer_functions2 {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("shaderIntegerFunctions2")?;
        }
        if self.shader_maximal_reconvergence {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("shaderMaximalReconvergence")?;
        }
        if self.shader_module_identifier {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("shaderModuleIdentifier")?;
        }
        if self.shader_object {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("shaderObject")?;
        }
        if self.shader_output_layer {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("shaderOutputLayer")?;
        }
        if self.shader_output_viewport_index {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("shaderOutputViewportIndex")?;
        }
        if self.shader_quad_control {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("shaderQuadControl")?;
        }
        if self.shader_raw_access_chains {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("shaderRawAccessChains")?;
        }
        if self.shader_resource_min_lod {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("shaderResourceMinLod")?;
        }
        if self.shader_resource_residency {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("shaderResourceResidency")?;
        }
        if self.shader_sample_rate_interpolation_functions {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("shaderSampleRateInterpolationFunctions")?;
        }
        if self.shader_sampled_image_array_dynamic_indexing {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("shaderSampledImageArrayDynamicIndexing")?;
        }
        if self.shader_sampled_image_array_non_uniform_indexing {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("shaderSampledImageArrayNonUniformIndexing")?;
        }
        if self.shader_shared_float16_atomic_add {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("shaderSharedFloat16AtomicAdd")?;
        }
        if self.shader_shared_float16_atomic_min_max {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("shaderSharedFloat16AtomicMinMax")?;
        }
        if self.shader_shared_float16_atomics {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("shaderSharedFloat16Atomics")?;
        }
        if self.shader_shared_float32_atomic_add {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("shaderSharedFloat32AtomicAdd")?;
        }
        if self.shader_shared_float32_atomic_min_max {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("shaderSharedFloat32AtomicMinMax")?;
        }
        if self.shader_shared_float32_atomics {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("shaderSharedFloat32Atomics")?;
        }
        if self.shader_shared_float64_atomic_add {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("shaderSharedFloat64AtomicAdd")?;
        }
        if self.shader_shared_float64_atomic_min_max {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("shaderSharedFloat64AtomicMinMax")?;
        }
        if self.shader_shared_float64_atomics {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("shaderSharedFloat64Atomics")?;
        }
        if self.shader_shared_int64_atomics {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("shaderSharedInt64Atomics")?;
        }
        if self.shader_sm_builtins {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("shaderSMBuiltins")?;
        }
        if self.shader_storage_buffer_array_dynamic_indexing {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("shaderStorageBufferArrayDynamicIndexing")?;
        }
        if self.shader_storage_buffer_array_non_uniform_indexing {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("shaderStorageBufferArrayNonUniformIndexing")?;
        }
        if self.shader_storage_image_array_dynamic_indexing {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("shaderStorageImageArrayDynamicIndexing")?;
        }
        if self.shader_storage_image_array_non_uniform_indexing {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("shaderStorageImageArrayNonUniformIndexing")?;
        }
        if self.shader_storage_image_extended_formats {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("shaderStorageImageExtendedFormats")?;
        }
        if self.shader_storage_image_multisample {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("shaderStorageImageMultisample")?;
        }
        if self.shader_storage_image_read_without_format {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("shaderStorageImageReadWithoutFormat")?;
        }
        if self.shader_storage_image_write_without_format {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("shaderStorageImageWriteWithoutFormat")?;
        }
        if self.shader_storage_texel_buffer_array_dynamic_indexing {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("shaderStorageTexelBufferArrayDynamicIndexing")?;
        }
        if self.shader_storage_texel_buffer_array_non_uniform_indexing {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("shaderStorageTexelBufferArrayNonUniformIndexing")?;
        }
        if self.shader_subgroup_clock {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("shaderSubgroupClock")?;
        }
        if self.shader_subgroup_extended_types {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("shaderSubgroupExtendedTypes")?;
        }
        if self.shader_subgroup_rotate {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("shaderSubgroupRotate")?;
        }
        if self.shader_subgroup_rotate_clustered {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("shaderSubgroupRotateClustered")?;
        }
        if self.shader_subgroup_uniform_control_flow {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("shaderSubgroupUniformControlFlow")?;
        }
        if self.shader_terminate_invocation {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("shaderTerminateInvocation")?;
        }
        if self.shader_tessellation_and_geometry_point_size {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("shaderTessellationAndGeometryPointSize")?;
        }
        if self.shader_tile_image_color_read_access {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("shaderTileImageColorReadAccess")?;
        }
        if self.shader_tile_image_depth_read_access {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("shaderTileImageDepthReadAccess")?;
        }
        if self.shader_tile_image_stencil_read_access {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("shaderTileImageStencilReadAccess")?;
        }
        if self.shader_uniform_buffer_array_dynamic_indexing {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("shaderUniformBufferArrayDynamicIndexing")?;
        }
        if self.shader_uniform_buffer_array_non_uniform_indexing {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("shaderUniformBufferArrayNonUniformIndexing")?;
        }
        if self.shader_uniform_texel_buffer_array_dynamic_indexing {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("shaderUniformTexelBufferArrayDynamicIndexing")?;
        }
        if self.shader_uniform_texel_buffer_array_non_uniform_indexing {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("shaderUniformTexelBufferArrayNonUniformIndexing")?;
        }
        if self.shader_zero_initialize_workgroup_memory {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("shaderZeroInitializeWorkgroupMemory")?;
        }
        if self.shading_rate_coarse_sample_order {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("shadingRateCoarseSampleOrder")?;
        }
        if self.shading_rate_image {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("shadingRateImage")?;
        }
        if self.smooth_lines {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("smoothLines")?;
        }
        if self.sparse_binding {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("sparseBinding")?;
        }
        if self.sparse_image_float32_atomic_add {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("sparseImageFloat32AtomicAdd")?;
        }
        if self.sparse_image_float32_atomic_min_max {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("sparseImageFloat32AtomicMinMax")?;
        }
        if self.sparse_image_float32_atomics {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("sparseImageFloat32Atomics")?;
        }
        if self.sparse_image_int64_atomics {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("sparseImageInt64Atomics")?;
        }
        if self.sparse_residency16_samples {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("sparseResidency16Samples")?;
        }
        if self.sparse_residency2_samples {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("sparseResidency2Samples")?;
        }
        if self.sparse_residency4_samples {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("sparseResidency4Samples")?;
        }
        if self.sparse_residency8_samples {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("sparseResidency8Samples")?;
        }
        if self.sparse_residency_aliased {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("sparseResidencyAliased")?;
        }
        if self.sparse_residency_buffer {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("sparseResidencyBuffer")?;
        }
        if self.sparse_residency_image2_d {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("sparseResidencyImage2D")?;
        }
        if self.sparse_residency_image3_d {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("sparseResidencyImage3D")?;
        }
        if self.stippled_bresenham_lines {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("stippledBresenhamLines")?;
        }
        if self.stippled_rectangular_lines {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("stippledRectangularLines")?;
        }
        if self.stippled_smooth_lines {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("stippledSmoothLines")?;
        }
        if self.storage_buffer16_bit_access {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("storageBuffer16BitAccess")?;
        }
        if self.storage_buffer8_bit_access {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("storageBuffer8BitAccess")?;
        }
        if self.storage_input_output16 {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("storageInputOutput16")?;
        }
        if self.storage_push_constant16 {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("storagePushConstant16")?;
        }
        if self.storage_push_constant8 {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("storagePushConstant8")?;
        }
        if self.subgroup_broadcast_dynamic_id {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("subgroupBroadcastDynamicId")?;
        }
        if self.subgroup_size_control {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("subgroupSizeControl")?;
        }
        if self.subpass_merge_feedback {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("subpassMergeFeedback")?;
        }
        if self.subpass_shading {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("subpassShading")?;
        }
        if self.supersample_fragment_shading_rates {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("supersampleFragmentShadingRates")?;
        }
        if self.swapchain_maintenance1 {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("swapchainMaintenance1")?;
        }
        if self.synchronization2 {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("synchronization2")?;
        }
        if self.task_shader {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("taskShader")?;
        }
        if self.tessellation_isolines {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("tessellationIsolines")?;
        }
        if self.tessellation_point_mode {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("tessellationPointMode")?;
        }
        if self.tessellation_shader {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("tessellationShader")?;
        }
        if self.texel_buffer_alignment {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("texelBufferAlignment")?;
        }
        if self.texture_block_match {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("textureBlockMatch")?;
        }
        if self.texture_block_match2 {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("textureBlockMatch2")?;
        }
        if self.texture_box_filter {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("textureBoxFilter")?;
        }
        if self.texture_compression_astc_hdr {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("textureCompressionASTC_HDR")?;
        }
        if self.texture_compression_astc_ldr {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("textureCompressionASTC_LDR")?;
        }
        if self.texture_compression_bc {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("textureCompressionBC")?;
        }
        if self.texture_compression_etc2 {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("textureCompressionETC2")?;
        }
        if self.texture_sample_weighted {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("textureSampleWeighted")?;
        }
        if self.tile_properties {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("tileProperties")?;
        }
        if self.timeline_semaphore {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("timelineSemaphore")?;
        }
        if self.transform_feedback {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("transformFeedback")?;
        }
        if self.transform_feedback_preserves_provoking_vertex {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("transformFeedbackPreservesProvokingVertex")?;
        }
        if self.triangle_fans {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("triangleFans")?;
        }
        if self.uniform_and_storage_buffer16_bit_access {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("uniformAndStorageBuffer16BitAccess")?;
        }
        if self.uniform_and_storage_buffer8_bit_access {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("uniformAndStorageBuffer8BitAccess")?;
        }
        if self.uniform_buffer_standard_layout {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("uniformBufferStandardLayout")?;
        }
        if self.variable_multisample_rate {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("variableMultisampleRate")?;
        }
        if self.variable_pointers {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("variablePointers")?;
        }
        if self.variable_pointers_storage_buffer {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("variablePointersStorageBuffer")?;
        }
        if self.vertex_attribute_access_beyond_stride {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("vertexAttributeAccessBeyondStride")?;
        }
        if self.vertex_attribute_instance_rate_divisor {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("vertexAttributeInstanceRateDivisor")?;
        }
        if self.vertex_attribute_instance_rate_zero_divisor {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("vertexAttributeInstanceRateZeroDivisor")?;
        }
        if self.vertex_input_dynamic_state {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("vertexInputDynamicState")?;
        }
        if self.vertex_pipeline_stores_and_atomics {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("vertexPipelineStoresAndAtomics")?;
        }
        if self.video_maintenance1 {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("videoMaintenance1")?;
        }
        if self.vulkan_memory_model {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("vulkanMemoryModel")?;
        }
        if self.vulkan_memory_model_availability_visibility_chains {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("vulkanMemoryModelAvailabilityVisibilityChains")?;
        }
        if self.vulkan_memory_model_device_scope {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("vulkanMemoryModelDeviceScope")?;
        }
        if self.wide_lines {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("wideLines")?;
        }
        if self.workgroup_memory_explicit_layout {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("workgroupMemoryExplicitLayout")?;
        }
        if self.workgroup_memory_explicit_layout16_bit_access {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("workgroupMemoryExplicitLayout16BitAccess")?;
        }
        if self.workgroup_memory_explicit_layout8_bit_access {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("workgroupMemoryExplicitLayout8BitAccess")?;
        }
        if self.workgroup_memory_explicit_layout_scalar_block_layout {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("workgroupMemoryExplicitLayoutScalarBlockLayout")?;
        }
        if self.ycbcr2plane444_formats {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("ycbcr2plane444Formats")?;
        }
        if self.ycbcr_degamma {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("ycbcrDegamma")?;
        }
        if self.ycbcr_image_arrays {
            if !first {
                write!(f, ", ")?
            } else {
                first = false;
            }
            f.write_str("ycbcrImageArrays")?;
        }
        write!(f, "]")
    }
}
impl DeviceFeaturesFfi {
    pub(crate) fn write(&mut self, features: &DeviceFeatures) {
        if let Some(f) = [
            self
                .features_acceleration_structure_khr
                .as_mut()
                .map(|s| &mut s.acceleration_structure),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.acceleration_structure as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_acceleration_structure_khr
                .as_mut()
                .map(|s| &mut s.acceleration_structure_capture_replay),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.acceleration_structure_capture_replay as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_acceleration_structure_khr
                .as_mut()
                .map(|s| &mut s.acceleration_structure_host_commands),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.acceleration_structure_host_commands as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_acceleration_structure_khr
                .as_mut()
                .map(|s| &mut s.acceleration_structure_indirect_build),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.acceleration_structure_indirect_build as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_blend_operation_advanced_ext
                .as_mut()
                .map(|s| &mut s.advanced_blend_coherent_operations),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.advanced_blend_coherent_operations as ash::vk::Bool32;
        }
        if let Some(f) = [&mut self.features_vulkan10.features.alpha_to_one]
            .into_iter()
            .next()
        {
            *f = features.alpha_to_one as ash::vk::Bool32;
        }
        if let Some(f) = [
            self.features_amigo_profiling_sec.as_mut().map(|s| &mut s.amigo_profiling),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.amigo_profiling as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_attachment_feedback_loop_dynamic_state_ext
                .as_mut()
                .map(|s| &mut s.attachment_feedback_loop_dynamic_state),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.attachment_feedback_loop_dynamic_state as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_attachment_feedback_loop_layout_ext
                .as_mut()
                .map(|s| &mut s.attachment_feedback_loop_layout),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.attachment_feedback_loop_layout as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_fragment_shading_rate_khr
                .as_mut()
                .map(|s| &mut s.attachment_fragment_shading_rate),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.attachment_fragment_shading_rate as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_border_color_swizzle_ext
                .as_mut()
                .map(|s| &mut s.border_color_swizzle),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.border_color_swizzle as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_border_color_swizzle_ext
                .as_mut()
                .map(|s| &mut s.border_color_swizzle_from_image),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.border_color_swizzle_from_image as ash::vk::Bool32;
        }
        if let Some(f) = [
            self.features_line_rasterization_khr.as_mut().map(|s| &mut s.bresenham_lines),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.bresenham_lines as ash::vk::Bool32;
        }
        if let Some(f) = [
            self.features_vulkan12.as_mut().map(|s| &mut s.buffer_device_address),
            self
                .features_buffer_device_address
                .as_mut()
                .map(|s| &mut s.buffer_device_address),
            self
                .features_buffer_device_address_ext
                .as_mut()
                .map(|s| &mut s.buffer_device_address),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.buffer_device_address as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_vulkan12
                .as_mut()
                .map(|s| &mut s.buffer_device_address_capture_replay),
            self
                .features_buffer_device_address
                .as_mut()
                .map(|s| &mut s.buffer_device_address_capture_replay),
            self
                .features_buffer_device_address_ext
                .as_mut()
                .map(|s| &mut s.buffer_device_address_capture_replay),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.buffer_device_address_capture_replay as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_vulkan12
                .as_mut()
                .map(|s| &mut s.buffer_device_address_multi_device),
            self
                .features_buffer_device_address
                .as_mut()
                .map(|s| &mut s.buffer_device_address_multi_device),
            self
                .features_buffer_device_address_ext
                .as_mut()
                .map(|s| &mut s.buffer_device_address_multi_device),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.buffer_device_address_multi_device as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_cluster_culling_shader_huawei
                .as_mut()
                .map(|s| &mut s.clusterculling_shader),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.clusterculling_shader as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_color_write_enable_ext
                .as_mut()
                .map(|s| &mut s.color_write_enable),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.color_write_enable as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_compute_shader_derivatives_nv
                .as_mut()
                .map(|s| &mut s.compute_derivative_group_linear),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.compute_derivative_group_linear as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_compute_shader_derivatives_nv
                .as_mut()
                .map(|s| &mut s.compute_derivative_group_quads),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.compute_derivative_group_quads as ash::vk::Bool32;
        }
        if let Some(f) = [
            self.features_vulkan13.as_mut().map(|s| &mut s.compute_full_subgroups),
            self
                .features_subgroup_size_control
                .as_mut()
                .map(|s| &mut s.compute_full_subgroups),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.compute_full_subgroups as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_conditional_rendering_ext
                .as_mut()
                .map(|s| &mut s.conditional_rendering),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.conditional_rendering as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_portability_subset_khr
                .as_mut()
                .map(|s| &mut s.constant_alpha_color_blend_factors),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.constant_alpha_color_blend_factors as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_cooperative_matrix_khr
                .as_mut()
                .map(|s| &mut s.cooperative_matrix),
            self
                .features_cooperative_matrix_nv
                .as_mut()
                .map(|s| &mut s.cooperative_matrix),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.cooperative_matrix as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_cooperative_matrix_khr
                .as_mut()
                .map(|s| &mut s.cooperative_matrix_robust_buffer_access),
            self
                .features_cooperative_matrix_nv
                .as_mut()
                .map(|s| &mut s.cooperative_matrix_robust_buffer_access),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.cooperative_matrix_robust_buffer_access as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_corner_sampled_image_nv
                .as_mut()
                .map(|s| &mut s.corner_sampled_image),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.corner_sampled_image as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_coverage_reduction_mode_nv
                .as_mut()
                .map(|s| &mut s.coverage_reduction_mode),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.coverage_reduction_mode as ash::vk::Bool32;
        }
        if let Some(f) = [
            self.features_cubic_clamp_qcom.as_mut().map(|s| &mut s.cubic_range_clamp),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.cubic_range_clamp as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_cuda_kernel_launch_nv
                .as_mut()
                .map(|s| &mut s.cuda_kernel_launch_features),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.cuda_kernel_launch_features as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_custom_border_color_ext
                .as_mut()
                .map(|s| &mut s.custom_border_color_without_format),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.custom_border_color_without_format as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_custom_border_color_ext
                .as_mut()
                .map(|s| &mut s.custom_border_colors),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.custom_border_colors as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_astc_decode_ext
                .as_mut()
                .map(|s| &mut s.decode_mode_shared_exponent),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.decode_mode_shared_exponent as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_dedicated_allocation_image_aliasing_nv
                .as_mut()
                .map(|s| &mut s.dedicated_allocation_image_aliasing),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.dedicated_allocation_image_aliasing as ash::vk::Bool32;
        }
        if let Some(f) = [&mut self.features_vulkan10.features.depth_bias_clamp]
            .into_iter()
            .next()
        {
            *f = features.depth_bias_clamp as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_depth_bias_control_ext
                .as_mut()
                .map(|s| &mut s.depth_bias_control),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.depth_bias_control as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_depth_bias_control_ext
                .as_mut()
                .map(|s| &mut s.depth_bias_exact),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.depth_bias_exact as ash::vk::Bool32;
        }
        if let Some(f) = [&mut self.features_vulkan10.features.depth_bounds]
            .into_iter()
            .next()
        {
            *f = features.depth_bounds as ash::vk::Bool32;
        }
        if let Some(f) = [&mut self.features_vulkan10.features.depth_clamp]
            .into_iter()
            .next()
        {
            *f = features.depth_clamp as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_depth_clamp_zero_one_ext
                .as_mut()
                .map(|s| &mut s.depth_clamp_zero_one),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.depth_clamp_zero_one as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_depth_clip_control_ext
                .as_mut()
                .map(|s| &mut s.depth_clip_control),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.depth_clip_control as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_depth_clip_enable_ext
                .as_mut()
                .map(|s| &mut s.depth_clip_enable),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.depth_clip_enable as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_acceleration_structure_khr
                .as_mut()
                .map(|s| {
                    &mut s.descriptor_binding_acceleration_structure_update_after_bind
                }),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.descriptor_binding_acceleration_structure_update_after_bind
                as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_vulkan13
                .as_mut()
                .map(|s| {
                    &mut s.descriptor_binding_inline_uniform_block_update_after_bind
                }),
            self
                .features_inline_uniform_block
                .as_mut()
                .map(|s| {
                    &mut s.descriptor_binding_inline_uniform_block_update_after_bind
                }),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.descriptor_binding_inline_uniform_block_update_after_bind
                as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_vulkan12
                .as_mut()
                .map(|s| &mut s.descriptor_binding_partially_bound),
            self
                .features_descriptor_indexing
                .as_mut()
                .map(|s| &mut s.descriptor_binding_partially_bound),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.descriptor_binding_partially_bound as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_vulkan12
                .as_mut()
                .map(|s| &mut s.descriptor_binding_sampled_image_update_after_bind),
            self
                .features_descriptor_indexing
                .as_mut()
                .map(|s| &mut s.descriptor_binding_sampled_image_update_after_bind),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.descriptor_binding_sampled_image_update_after_bind
                as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_vulkan12
                .as_mut()
                .map(|s| &mut s.descriptor_binding_storage_buffer_update_after_bind),
            self
                .features_descriptor_indexing
                .as_mut()
                .map(|s| &mut s.descriptor_binding_storage_buffer_update_after_bind),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.descriptor_binding_storage_buffer_update_after_bind
                as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_vulkan12
                .as_mut()
                .map(|s| &mut s.descriptor_binding_storage_image_update_after_bind),
            self
                .features_descriptor_indexing
                .as_mut()
                .map(|s| &mut s.descriptor_binding_storage_image_update_after_bind),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.descriptor_binding_storage_image_update_after_bind
                as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_vulkan12
                .as_mut()
                .map(|s| {
                    &mut s.descriptor_binding_storage_texel_buffer_update_after_bind
                }),
            self
                .features_descriptor_indexing
                .as_mut()
                .map(|s| {
                    &mut s.descriptor_binding_storage_texel_buffer_update_after_bind
                }),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.descriptor_binding_storage_texel_buffer_update_after_bind
                as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_vulkan12
                .as_mut()
                .map(|s| &mut s.descriptor_binding_uniform_buffer_update_after_bind),
            self
                .features_descriptor_indexing
                .as_mut()
                .map(|s| &mut s.descriptor_binding_uniform_buffer_update_after_bind),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.descriptor_binding_uniform_buffer_update_after_bind
                as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_vulkan12
                .as_mut()
                .map(|s| {
                    &mut s.descriptor_binding_uniform_texel_buffer_update_after_bind
                }),
            self
                .features_descriptor_indexing
                .as_mut()
                .map(|s| {
                    &mut s.descriptor_binding_uniform_texel_buffer_update_after_bind
                }),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.descriptor_binding_uniform_texel_buffer_update_after_bind
                as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_vulkan12
                .as_mut()
                .map(|s| &mut s.descriptor_binding_update_unused_while_pending),
            self
                .features_descriptor_indexing
                .as_mut()
                .map(|s| &mut s.descriptor_binding_update_unused_while_pending),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.descriptor_binding_update_unused_while_pending
                as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_vulkan12
                .as_mut()
                .map(|s| &mut s.descriptor_binding_variable_descriptor_count),
            self
                .features_descriptor_indexing
                .as_mut()
                .map(|s| &mut s.descriptor_binding_variable_descriptor_count),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.descriptor_binding_variable_descriptor_count
                as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_descriptor_buffer_ext
                .as_mut()
                .map(|s| &mut s.descriptor_buffer),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.descriptor_buffer as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_descriptor_buffer_ext
                .as_mut()
                .map(|s| &mut s.descriptor_buffer_capture_replay),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.descriptor_buffer_capture_replay as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_descriptor_buffer_ext
                .as_mut()
                .map(|s| &mut s.descriptor_buffer_image_layout_ignored),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.descriptor_buffer_image_layout_ignored as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_descriptor_buffer_ext
                .as_mut()
                .map(|s| &mut s.descriptor_buffer_push_descriptors),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.descriptor_buffer_push_descriptors as ash::vk::Bool32;
        }
        if let Some(f) = [
            self.features_vulkan12.as_mut().map(|s| &mut s.descriptor_indexing),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.descriptor_indexing as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_descriptor_pool_overallocation_nv
                .as_mut()
                .map(|s| &mut s.descriptor_pool_overallocation),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.descriptor_pool_overallocation as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_descriptor_set_host_mapping_valve
                .as_mut()
                .map(|s| &mut s.descriptor_set_host_mapping),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.descriptor_set_host_mapping as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_coherent_memory_amd
                .as_mut()
                .map(|s| &mut s.device_coherent_memory),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.device_coherent_memory as ash::vk::Bool32;
        }
        if let Some(f) = [self.features_fault_ext.as_mut().map(|s| &mut s.device_fault)]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.device_fault as ash::vk::Bool32;
        }
        if let Some(f) = [
            self.features_fault_ext.as_mut().map(|s| &mut s.device_fault_vendor_binary),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.device_fault_vendor_binary as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_device_generated_commands_nv
                .as_mut()
                .map(|s| &mut s.device_generated_commands),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.device_generated_commands as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_device_generated_commands_compute_nv
                .as_mut()
                .map(|s| &mut s.device_generated_compute),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.device_generated_compute as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_device_generated_commands_compute_nv
                .as_mut()
                .map(|s| &mut s.device_generated_compute_capture_replay),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.device_generated_compute_capture_replay as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_device_generated_commands_compute_nv
                .as_mut()
                .map(|s| &mut s.device_generated_compute_pipelines),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.device_generated_compute_pipelines as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_device_memory_report_ext
                .as_mut()
                .map(|s| &mut s.device_memory_report),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.device_memory_report as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_diagnostics_config_nv
                .as_mut()
                .map(|s| &mut s.diagnostics_config),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.diagnostics_config as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_displacement_micromap_nv
                .as_mut()
                .map(|s| &mut s.displacement_micromap),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.displacement_micromap as ash::vk::Bool32;
        }
        if let Some(f) = [
            self.features_vulkan12.as_mut().map(|s| &mut s.draw_indirect_count),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.draw_indirect_count as ash::vk::Bool32;
        }
        if let Some(f) = [
            &mut self.features_vulkan10.features.draw_indirect_first_instance,
        ]
            .into_iter()
            .next()
        {
            *f = features.draw_indirect_first_instance as ash::vk::Bool32;
        }
        if let Some(f) = [&mut self.features_vulkan10.features.dual_src_blend]
            .into_iter()
            .next()
        {
            *f = features.dual_src_blend as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_per_stage_descriptor_set_nv
                .as_mut()
                .map(|s| &mut s.dynamic_pipeline_layout),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.dynamic_pipeline_layout as ash::vk::Bool32;
        }
        if let Some(f) = [
            self.features_vulkan13.as_mut().map(|s| &mut s.dynamic_rendering),
            self.features_dynamic_rendering.as_mut().map(|s| &mut s.dynamic_rendering),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.dynamic_rendering as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_dynamic_rendering_local_read_khr
                .as_mut()
                .map(|s| &mut s.dynamic_rendering_local_read),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.dynamic_rendering_local_read as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_dynamic_rendering_unused_attachments_ext
                .as_mut()
                .map(|s| &mut s.dynamic_rendering_unused_attachments),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.dynamic_rendering_unused_attachments as ash::vk::Bool32;
        }
        if let Some(f) = [
            self.features_portability_subset_khr.as_mut().map(|s| &mut s.events),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.events as ash::vk::Bool32;
        }
        if let Some(f) = [
            self.features_exclusive_scissor_nv.as_mut().map(|s| &mut s.exclusive_scissor),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.exclusive_scissor as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_extended_dynamic_state_ext
                .as_mut()
                .map(|s| &mut s.extended_dynamic_state),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.extended_dynamic_state as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_extended_dynamic_state2_ext
                .as_mut()
                .map(|s| &mut s.extended_dynamic_state2),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.extended_dynamic_state2 as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_extended_dynamic_state2_ext
                .as_mut()
                .map(|s| &mut s.extended_dynamic_state2_logic_op),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.extended_dynamic_state2_logic_op as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_extended_dynamic_state2_ext
                .as_mut()
                .map(|s| &mut s.extended_dynamic_state2_patch_control_points),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.extended_dynamic_state2_patch_control_points
                as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_extended_dynamic_state3_ext
                .as_mut()
                .map(|s| &mut s.extended_dynamic_state3_alpha_to_coverage_enable),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.extended_dynamic_state3_alpha_to_coverage_enable
                as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_extended_dynamic_state3_ext
                .as_mut()
                .map(|s| &mut s.extended_dynamic_state3_alpha_to_one_enable),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.extended_dynamic_state3_alpha_to_one_enable as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_extended_dynamic_state3_ext
                .as_mut()
                .map(|s| &mut s.extended_dynamic_state3_color_blend_advanced),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.extended_dynamic_state3_color_blend_advanced
                as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_extended_dynamic_state3_ext
                .as_mut()
                .map(|s| &mut s.extended_dynamic_state3_color_blend_enable),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.extended_dynamic_state3_color_blend_enable as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_extended_dynamic_state3_ext
                .as_mut()
                .map(|s| &mut s.extended_dynamic_state3_color_blend_equation),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.extended_dynamic_state3_color_blend_equation
                as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_extended_dynamic_state3_ext
                .as_mut()
                .map(|s| &mut s.extended_dynamic_state3_color_write_mask),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.extended_dynamic_state3_color_write_mask as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_extended_dynamic_state3_ext
                .as_mut()
                .map(|s| &mut s.extended_dynamic_state3_conservative_rasterization_mode),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.extended_dynamic_state3_conservative_rasterization_mode
                as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_extended_dynamic_state3_ext
                .as_mut()
                .map(|s| &mut s.extended_dynamic_state3_coverage_modulation_mode),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.extended_dynamic_state3_coverage_modulation_mode
                as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_extended_dynamic_state3_ext
                .as_mut()
                .map(|s| &mut s.extended_dynamic_state3_coverage_modulation_table),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.extended_dynamic_state3_coverage_modulation_table
                as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_extended_dynamic_state3_ext
                .as_mut()
                .map(|s| &mut s.extended_dynamic_state3_coverage_modulation_table_enable),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.extended_dynamic_state3_coverage_modulation_table_enable
                as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_extended_dynamic_state3_ext
                .as_mut()
                .map(|s| &mut s.extended_dynamic_state3_coverage_reduction_mode),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.extended_dynamic_state3_coverage_reduction_mode
                as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_extended_dynamic_state3_ext
                .as_mut()
                .map(|s| &mut s.extended_dynamic_state3_coverage_to_color_enable),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.extended_dynamic_state3_coverage_to_color_enable
                as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_extended_dynamic_state3_ext
                .as_mut()
                .map(|s| &mut s.extended_dynamic_state3_coverage_to_color_location),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.extended_dynamic_state3_coverage_to_color_location
                as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_extended_dynamic_state3_ext
                .as_mut()
                .map(|s| &mut s.extended_dynamic_state3_depth_clamp_enable),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.extended_dynamic_state3_depth_clamp_enable as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_extended_dynamic_state3_ext
                .as_mut()
                .map(|s| &mut s.extended_dynamic_state3_depth_clip_enable),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.extended_dynamic_state3_depth_clip_enable as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_extended_dynamic_state3_ext
                .as_mut()
                .map(|s| &mut s.extended_dynamic_state3_depth_clip_negative_one_to_one),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.extended_dynamic_state3_depth_clip_negative_one_to_one
                as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_extended_dynamic_state3_ext
                .as_mut()
                .map(|s| {
                    &mut s.extended_dynamic_state3_extra_primitive_overestimation_size
                }),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.extended_dynamic_state3_extra_primitive_overestimation_size
                as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_extended_dynamic_state3_ext
                .as_mut()
                .map(|s| &mut s.extended_dynamic_state3_line_rasterization_mode),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.extended_dynamic_state3_line_rasterization_mode
                as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_extended_dynamic_state3_ext
                .as_mut()
                .map(|s| &mut s.extended_dynamic_state3_line_stipple_enable),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.extended_dynamic_state3_line_stipple_enable as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_extended_dynamic_state3_ext
                .as_mut()
                .map(|s| &mut s.extended_dynamic_state3_logic_op_enable),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.extended_dynamic_state3_logic_op_enable as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_extended_dynamic_state3_ext
                .as_mut()
                .map(|s| &mut s.extended_dynamic_state3_polygon_mode),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.extended_dynamic_state3_polygon_mode as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_extended_dynamic_state3_ext
                .as_mut()
                .map(|s| &mut s.extended_dynamic_state3_provoking_vertex_mode),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.extended_dynamic_state3_provoking_vertex_mode
                as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_extended_dynamic_state3_ext
                .as_mut()
                .map(|s| &mut s.extended_dynamic_state3_rasterization_samples),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.extended_dynamic_state3_rasterization_samples
                as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_extended_dynamic_state3_ext
                .as_mut()
                .map(|s| &mut s.extended_dynamic_state3_rasterization_stream),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.extended_dynamic_state3_rasterization_stream
                as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_extended_dynamic_state3_ext
                .as_mut()
                .map(|s| {
                    &mut s.extended_dynamic_state3_representative_fragment_test_enable
                }),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.extended_dynamic_state3_representative_fragment_test_enable
                as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_extended_dynamic_state3_ext
                .as_mut()
                .map(|s| &mut s.extended_dynamic_state3_sample_locations_enable),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.extended_dynamic_state3_sample_locations_enable
                as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_extended_dynamic_state3_ext
                .as_mut()
                .map(|s| &mut s.extended_dynamic_state3_sample_mask),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.extended_dynamic_state3_sample_mask as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_extended_dynamic_state3_ext
                .as_mut()
                .map(|s| &mut s.extended_dynamic_state3_shading_rate_image_enable),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.extended_dynamic_state3_shading_rate_image_enable
                as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_extended_dynamic_state3_ext
                .as_mut()
                .map(|s| &mut s.extended_dynamic_state3_tessellation_domain_origin),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.extended_dynamic_state3_tessellation_domain_origin
                as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_extended_dynamic_state3_ext
                .as_mut()
                .map(|s| &mut s.extended_dynamic_state3_viewport_swizzle),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.extended_dynamic_state3_viewport_swizzle as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_extended_dynamic_state3_ext
                .as_mut()
                .map(|s| &mut s.extended_dynamic_state3_viewport_w_scaling_enable),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.extended_dynamic_state3_viewport_w_scaling_enable
                as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_extended_sparse_address_space_nv
                .as_mut()
                .map(|s| &mut s.extended_sparse_address_space),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.extended_sparse_address_space as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_external_format_resolve_android
                .as_mut()
                .map(|s| &mut s.external_format_resolve),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.external_format_resolve as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_external_memory_rdma_nv
                .as_mut()
                .map(|s| &mut s.external_memory_rdma),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.external_memory_rdma as ash::vk::Bool32;
        }
        if let Some(f) = [&mut self.features_vulkan10.features.fill_mode_non_solid]
            .into_iter()
            .next()
        {
            *f = features.fill_mode_non_solid as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_depth_bias_control_ext
                .as_mut()
                .map(|s| &mut s.float_representation),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.float_representation as ash::vk::Bool32;
        }
        if let Some(f) = [
            self.features_4444formats_ext.as_mut().map(|s| &mut s.format_a4b4g4r4),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.format_a4b4g4r4 as ash::vk::Bool32;
        }
        if let Some(f) = [
            self.features_4444formats_ext.as_mut().map(|s| &mut s.format_a4r4g4b4),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.format_a4r4g4b4 as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_rgba10x6_formats_ext
                .as_mut()
                .map(|s| &mut s.format_rgba10x6_without_y_cb_cr_sampler),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.format_rgba10x6_without_y_cb_cr_sampler as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_fragment_density_map_ext
                .as_mut()
                .map(|s| &mut s.fragment_density_map),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.fragment_density_map as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_fragment_density_map2_ext
                .as_mut()
                .map(|s| &mut s.fragment_density_map_deferred),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.fragment_density_map_deferred as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_fragment_density_map_ext
                .as_mut()
                .map(|s| &mut s.fragment_density_map_dynamic),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.fragment_density_map_dynamic as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_fragment_density_map_ext
                .as_mut()
                .map(|s| &mut s.fragment_density_map_non_subsampled_images),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.fragment_density_map_non_subsampled_images as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_fragment_density_map_offset_qcom
                .as_mut()
                .map(|s| &mut s.fragment_density_map_offset),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.fragment_density_map_offset as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_fragment_shader_barycentric_khr
                .as_mut()
                .map(|s| &mut s.fragment_shader_barycentric),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.fragment_shader_barycentric as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_fragment_shader_interlock_ext
                .as_mut()
                .map(|s| &mut s.fragment_shader_pixel_interlock),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.fragment_shader_pixel_interlock as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_fragment_shader_interlock_ext
                .as_mut()
                .map(|s| &mut s.fragment_shader_sample_interlock),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.fragment_shader_sample_interlock as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_fragment_shader_interlock_ext
                .as_mut()
                .map(|s| &mut s.fragment_shader_shading_rate_interlock),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.fragment_shader_shading_rate_interlock as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_fragment_shading_rate_enums_nv
                .as_mut()
                .map(|s| &mut s.fragment_shading_rate_enums),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.fragment_shading_rate_enums as ash::vk::Bool32;
        }
        if let Some(f) = [
            &mut self.features_vulkan10.features.fragment_stores_and_atomics,
        ]
            .into_iter()
            .next()
        {
            *f = features.fragment_stores_and_atomics as ash::vk::Bool32;
        }
        if let Some(f) = [
            self.features_frame_boundary_ext.as_mut().map(|s| &mut s.frame_boundary),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.frame_boundary as ash::vk::Bool32;
        }
        if let Some(f) = [&mut self.features_vulkan10.features.full_draw_index_uint32]
            .into_iter()
            .next()
        {
            *f = features.full_draw_index_uint32 as ash::vk::Bool32;
        }
        if let Some(f) = [&mut self.features_vulkan10.features.geometry_shader]
            .into_iter()
            .next()
        {
            *f = features.geometry_shader as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_transform_feedback_ext
                .as_mut()
                .map(|s| &mut s.geometry_streams),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.geometry_streams as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_global_priority_query_khr
                .as_mut()
                .map(|s| &mut s.global_priority_query),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.global_priority_query as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_graphics_pipeline_library_ext
                .as_mut()
                .map(|s| &mut s.graphics_pipeline_library),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.graphics_pipeline_library as ash::vk::Bool32;
        }
        if let Some(f) = [
            self.features_host_image_copy_ext.as_mut().map(|s| &mut s.host_image_copy),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.host_image_copy as ash::vk::Bool32;
        }
        if let Some(f) = [
            self.features_vulkan12.as_mut().map(|s| &mut s.host_query_reset),
            self.features_host_query_reset.as_mut().map(|s| &mut s.host_query_reset),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.host_query_reset as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_image2_d_view_of3_d_ext
                .as_mut()
                .map(|s| &mut s.image2_d_view_of3_d),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.image2_d_view_of3_d as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_image_compression_control_ext
                .as_mut()
                .map(|s| &mut s.image_compression_control),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.image_compression_control as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_image_compression_control_swapchain_ext
                .as_mut()
                .map(|s| &mut s.image_compression_control_swapchain),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.image_compression_control_swapchain as ash::vk::Bool32;
        }
        if let Some(f) = [&mut self.features_vulkan10.features.image_cube_array]
            .into_iter()
            .next()
        {
            *f = features.image_cube_array as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_shader_image_footprint_nv
                .as_mut()
                .map(|s| &mut s.image_footprint),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.image_footprint as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_image_sliced_view_of3_d_ext
                .as_mut()
                .map(|s| &mut s.image_sliced_view_of3_d),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.image_sliced_view_of3_d as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_portability_subset_khr
                .as_mut()
                .map(|s| &mut s.image_view2_d_on3_d_image),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.image_view2_d_on3_d_image as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_portability_subset_khr
                .as_mut()
                .map(|s| &mut s.image_view_format_reinterpretation),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.image_view_format_reinterpretation as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_portability_subset_khr
                .as_mut()
                .map(|s| &mut s.image_view_format_swizzle),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.image_view_format_swizzle as ash::vk::Bool32;
        }
        if let Some(f) = [
            self.features_vulkan12.as_mut().map(|s| &mut s.imageless_framebuffer),
            self
                .features_imageless_framebuffer
                .as_mut()
                .map(|s| &mut s.imageless_framebuffer),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.imageless_framebuffer as ash::vk::Bool32;
        }
        if let Some(f) = [&mut self.features_vulkan10.features.independent_blend]
            .into_iter()
            .next()
        {
            *f = features.independent_blend as ash::vk::Bool32;
        }
        if let Some(f) = [
            self.features_index_type_uint8_khr.as_mut().map(|s| &mut s.index_type_uint8),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.index_type_uint8 as ash::vk::Bool32;
        }
        if let Some(f) = [
            self.features_copy_memory_indirect_nv.as_mut().map(|s| &mut s.indirect_copy),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.indirect_copy as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_conditional_rendering_ext
                .as_mut()
                .map(|s| &mut s.inherited_conditional_rendering),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.inherited_conditional_rendering as ash::vk::Bool32;
        }
        if let Some(f) = [&mut self.features_vulkan10.features.inherited_queries]
            .into_iter()
            .next()
        {
            *f = features.inherited_queries as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_inherited_viewport_scissor_nv
                .as_mut()
                .map(|s| &mut s.inherited_viewport_scissor2_d),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.inherited_viewport_scissor2_d as ash::vk::Bool32;
        }
        if let Some(f) = [
            self.features_vulkan13.as_mut().map(|s| &mut s.inline_uniform_block),
            self
                .features_inline_uniform_block
                .as_mut()
                .map(|s| &mut s.inline_uniform_block),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.inline_uniform_block as ash::vk::Bool32;
        }
        if let Some(f) = [
            self.features_invocation_mask_huawei.as_mut().map(|s| &mut s.invocation_mask),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.invocation_mask as ash::vk::Bool32;
        }
        if let Some(f) = [&mut self.features_vulkan10.features.large_points]
            .into_iter()
            .next()
        {
            *f = features.large_points as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_depth_bias_control_ext
                .as_mut()
                .map(|s| &mut s.least_representable_value_force_unorm_representation),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.least_representable_value_force_unorm_representation
                as ash::vk::Bool32;
        }
        if let Some(f) = [
            self.features_legacy_dithering_ext.as_mut().map(|s| &mut s.legacy_dithering),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.legacy_dithering as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_linear_color_attachment_nv
                .as_mut()
                .map(|s| &mut s.linear_color_attachment),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.linear_color_attachment as ash::vk::Bool32;
        }
        if let Some(f) = [&mut self.features_vulkan10.features.logic_op]
            .into_iter()
            .next()
        {
            *f = features.logic_op as ash::vk::Bool32;
        }
        if let Some(f) = [
            self.features_vulkan13.as_mut().map(|s| &mut s.maintenance4),
            self.features_maintenance4.as_mut().map(|s| &mut s.maintenance4),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.maintenance4 as ash::vk::Bool32;
        }
        if let Some(f) = [
            self.features_maintenance5_khr.as_mut().map(|s| &mut s.maintenance5),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.maintenance5 as ash::vk::Bool32;
        }
        if let Some(f) = [
            self.features_maintenance6_khr.as_mut().map(|s| &mut s.maintenance6),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.maintenance6 as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_memory_decompression_nv
                .as_mut()
                .map(|s| &mut s.memory_decompression),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.memory_decompression as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_map_memory_placed_ext
                .as_mut()
                .map(|s| &mut s.memory_map_placed),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.memory_map_placed as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_map_memory_placed_ext
                .as_mut()
                .map(|s| &mut s.memory_map_range_placed),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.memory_map_range_placed as ash::vk::Bool32;
        }
        if let Some(f) = [
            self.features_memory_priority_ext.as_mut().map(|s| &mut s.memory_priority),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.memory_priority as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_map_memory_placed_ext
                .as_mut()
                .map(|s| &mut s.memory_unmap_reserve),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.memory_unmap_reserve as ash::vk::Bool32;
        }
        if let Some(f) = [
            self.features_mesh_shader_ext.as_mut().map(|s| &mut s.mesh_shader),
            self.features_mesh_shader_nv.as_mut().map(|s| &mut s.mesh_shader),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.mesh_shader as ash::vk::Bool32;
        }
        if let Some(f) = [
            self.features_mesh_shader_ext.as_mut().map(|s| &mut s.mesh_shader_queries),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.mesh_shader_queries as ash::vk::Bool32;
        }
        if let Some(f) = [
            self.features_opacity_micromap_ext.as_mut().map(|s| &mut s.micromap),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.micromap as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_opacity_micromap_ext
                .as_mut()
                .map(|s| &mut s.micromap_capture_replay),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.micromap_capture_replay as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_opacity_micromap_ext
                .as_mut()
                .map(|s| &mut s.micromap_host_commands),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.micromap_host_commands as ash::vk::Bool32;
        }
        if let Some(f) = [
            self.features_image_view_min_lod_ext.as_mut().map(|s| &mut s.min_lod),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.min_lod as ash::vk::Bool32;
        }
        if let Some(f) = [
            self.features_multi_draw_ext.as_mut().map(|s| &mut s.multi_draw),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.multi_draw as ash::vk::Bool32;
        }
        if let Some(f) = [&mut self.features_vulkan10.features.multi_draw_indirect]
            .into_iter()
            .next()
        {
            *f = features.multi_draw_indirect as ash::vk::Bool32;
        }
        if let Some(f) = [&mut self.features_vulkan10.features.multi_viewport]
            .into_iter()
            .next()
        {
            *f = features.multi_viewport as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_portability_subset_khr
                .as_mut()
                .map(|s| &mut s.multisample_array_image),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.multisample_array_image as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_multisampled_render_to_single_sampled_ext
                .as_mut()
                .map(|s| &mut s.multisampled_render_to_single_sampled),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.multisampled_render_to_single_sampled as ash::vk::Bool32;
        }
        if let Some(f) = [
            self.features_vulkan11.as_mut().map(|s| &mut s.multiview),
            self.features_multiview.as_mut().map(|s| &mut s.multiview),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.multiview as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_cluster_culling_shader_huawei
                .as_mut()
                .map(|s| &mut s.multiview_cluster_culling_shader),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.multiview_cluster_culling_shader as ash::vk::Bool32;
        }
        if let Some(f) = [
            self.features_vulkan11.as_mut().map(|s| &mut s.multiview_geometry_shader),
            self.features_multiview.as_mut().map(|s| &mut s.multiview_geometry_shader),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.multiview_geometry_shader as ash::vk::Bool32;
        }
        if let Some(f) = [
            self.features_mesh_shader_ext.as_mut().map(|s| &mut s.multiview_mesh_shader),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.multiview_mesh_shader as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_multiview_per_view_render_areas_qcom
                .as_mut()
                .map(|s| &mut s.multiview_per_view_render_areas),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.multiview_per_view_render_areas as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_multiview_per_view_viewports_qcom
                .as_mut()
                .map(|s| &mut s.multiview_per_view_viewports),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.multiview_per_view_viewports as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_vulkan11
                .as_mut()
                .map(|s| &mut s.multiview_tessellation_shader),
            self
                .features_multiview
                .as_mut()
                .map(|s| &mut s.multiview_tessellation_shader),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.multiview_tessellation_shader as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_portability_subset_khr
                .as_mut()
                .map(|s| &mut s.mutable_comparison_samplers),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.mutable_comparison_samplers as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_mutable_descriptor_type_ext
                .as_mut()
                .map(|s| &mut s.mutable_descriptor_type),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.mutable_descriptor_type as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_nested_command_buffer_ext
                .as_mut()
                .map(|s| &mut s.nested_command_buffer),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.nested_command_buffer as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_nested_command_buffer_ext
                .as_mut()
                .map(|s| &mut s.nested_command_buffer_rendering),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.nested_command_buffer_rendering as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_nested_command_buffer_ext
                .as_mut()
                .map(|s| &mut s.nested_command_buffer_simultaneous_use),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.nested_command_buffer_simultaneous_use as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_fragment_shading_rate_enums_nv
                .as_mut()
                .map(|s| &mut s.no_invocation_fragment_shading_rates),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.no_invocation_fragment_shading_rates as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_non_seamless_cube_map_ext
                .as_mut()
                .map(|s| &mut s.non_seamless_cube_map),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.non_seamless_cube_map as ash::vk::Bool32;
        }
        if let Some(f) = [
            self.features_robustness2_ext.as_mut().map(|s| &mut s.null_descriptor),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.null_descriptor as ash::vk::Bool32;
        }
        if let Some(f) = [&mut self.features_vulkan10.features.occlusion_query_precise]
            .into_iter()
            .next()
        {
            *f = features.occlusion_query_precise as ash::vk::Bool32;
        }
        if let Some(f) = [
            self.features_optical_flow_nv.as_mut().map(|s| &mut s.optical_flow),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.optical_flow as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_pageable_device_local_memory_ext
                .as_mut()
                .map(|s| &mut s.pageable_device_local_memory),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.pageable_device_local_memory as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_per_stage_descriptor_set_nv
                .as_mut()
                .map(|s| &mut s.per_stage_descriptor_set),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.per_stage_descriptor_set as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_performance_query_khr
                .as_mut()
                .map(|s| &mut s.performance_counter_multiple_query_pools),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.performance_counter_multiple_query_pools as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_performance_query_khr
                .as_mut()
                .map(|s| &mut s.performance_counter_query_pools),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.performance_counter_query_pools as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_vulkan13
                .as_mut()
                .map(|s| &mut s.pipeline_creation_cache_control),
            self
                .features_pipeline_creation_cache_control
                .as_mut()
                .map(|s| &mut s.pipeline_creation_cache_control),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.pipeline_creation_cache_control as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_pipeline_executable_properties_khr
                .as_mut()
                .map(|s| &mut s.pipeline_executable_info),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.pipeline_executable_info as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_fragment_shading_rate_khr
                .as_mut()
                .map(|s| &mut s.pipeline_fragment_shading_rate),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.pipeline_fragment_shading_rate as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_pipeline_library_group_handles_ext
                .as_mut()
                .map(|s| &mut s.pipeline_library_group_handles),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.pipeline_library_group_handles as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_pipeline_properties_ext
                .as_mut()
                .map(|s| &mut s.pipeline_properties_identifier),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.pipeline_properties_identifier as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_pipeline_protected_access_ext
                .as_mut()
                .map(|s| &mut s.pipeline_protected_access),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.pipeline_protected_access as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_pipeline_robustness_ext
                .as_mut()
                .map(|s| &mut s.pipeline_robustness),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.pipeline_robustness as ash::vk::Bool32;
        }
        if let Some(f) = [&mut self.features_vulkan10.features.pipeline_statistics_query]
            .into_iter()
            .next()
        {
            *f = features.pipeline_statistics_query as ash::vk::Bool32;
        }
        if let Some(f) = [
            self.features_portability_subset_khr.as_mut().map(|s| &mut s.point_polygons),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.point_polygons as ash::vk::Bool32;
        }
        if let Some(f) = [
            self.features_present_barrier_nv.as_mut().map(|s| &mut s.present_barrier),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.present_barrier as ash::vk::Bool32;
        }
        if let Some(f) = [
            self.features_present_id_khr.as_mut().map(|s| &mut s.present_id),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.present_id as ash::vk::Bool32;
        }
        if let Some(f) = [
            self.features_present_wait_khr.as_mut().map(|s| &mut s.present_wait),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.present_wait as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_fragment_shading_rate_khr
                .as_mut()
                .map(|s| &mut s.primitive_fragment_shading_rate),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.primitive_fragment_shading_rate as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_mesh_shader_ext
                .as_mut()
                .map(|s| &mut s.primitive_fragment_shading_rate_mesh_shader),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.primitive_fragment_shading_rate_mesh_shader as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_primitive_topology_list_restart_ext
                .as_mut()
                .map(|s| &mut s.primitive_topology_list_restart),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.primitive_topology_list_restart as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_primitive_topology_list_restart_ext
                .as_mut()
                .map(|s| &mut s.primitive_topology_patch_list_restart),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.primitive_topology_patch_list_restart as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_primitives_generated_query_ext
                .as_mut()
                .map(|s| &mut s.primitives_generated_query),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.primitives_generated_query as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_primitives_generated_query_ext
                .as_mut()
                .map(|s| &mut s.primitives_generated_query_with_non_zero_streams),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.primitives_generated_query_with_non_zero_streams
                as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_primitives_generated_query_ext
                .as_mut()
                .map(|s| &mut s.primitives_generated_query_with_rasterizer_discard),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.primitives_generated_query_with_rasterizer_discard
                as ash::vk::Bool32;
        }
        if let Some(f) = [
            self.features_vulkan13.as_mut().map(|s| &mut s.private_data),
            self.features_private_data.as_mut().map(|s| &mut s.private_data),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.private_data as ash::vk::Bool32;
        }
        if let Some(f) = [
            self.features_vulkan11.as_mut().map(|s| &mut s.protected_memory),
            self.features_protected_memory.as_mut().map(|s| &mut s.protected_memory),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.protected_memory as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_provoking_vertex_ext
                .as_mut()
                .map(|s| &mut s.provoking_vertex_last),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.provoking_vertex_last as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_rasterization_order_attachment_access_ext
                .as_mut()
                .map(|s| &mut s.rasterization_order_color_attachment_access),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.rasterization_order_color_attachment_access as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_rasterization_order_attachment_access_ext
                .as_mut()
                .map(|s| &mut s.rasterization_order_depth_attachment_access),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.rasterization_order_depth_attachment_access as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_rasterization_order_attachment_access_ext
                .as_mut()
                .map(|s| &mut s.rasterization_order_stencil_attachment_access),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.rasterization_order_stencil_attachment_access
                as ash::vk::Bool32;
        }
        if let Some(f) = [self.features_ray_query_khr.as_mut().map(|s| &mut s.ray_query)]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.ray_query as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_ray_tracing_invocation_reorder_nv
                .as_mut()
                .map(|s| &mut s.ray_tracing_invocation_reorder),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.ray_tracing_invocation_reorder as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_ray_tracing_maintenance1_khr
                .as_mut()
                .map(|s| &mut s.ray_tracing_maintenance1),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.ray_tracing_maintenance1 as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_ray_tracing_motion_blur_nv
                .as_mut()
                .map(|s| &mut s.ray_tracing_motion_blur),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.ray_tracing_motion_blur as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_ray_tracing_motion_blur_nv
                .as_mut()
                .map(|s| &mut s.ray_tracing_motion_blur_pipeline_trace_rays_indirect),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.ray_tracing_motion_blur_pipeline_trace_rays_indirect
                as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_ray_tracing_pipeline_khr
                .as_mut()
                .map(|s| &mut s.ray_tracing_pipeline),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.ray_tracing_pipeline as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_ray_tracing_pipeline_khr
                .as_mut()
                .map(|s| &mut s.ray_tracing_pipeline_shader_group_handle_capture_replay),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.ray_tracing_pipeline_shader_group_handle_capture_replay
                as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_ray_tracing_pipeline_khr
                .as_mut()
                .map(|s| {
                    &mut s.ray_tracing_pipeline_shader_group_handle_capture_replay_mixed
                }),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.ray_tracing_pipeline_shader_group_handle_capture_replay_mixed
                as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_ray_tracing_pipeline_khr
                .as_mut()
                .map(|s| &mut s.ray_tracing_pipeline_trace_rays_indirect),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.ray_tracing_pipeline_trace_rays_indirect as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_ray_tracing_maintenance1_khr
                .as_mut()
                .map(|s| &mut s.ray_tracing_pipeline_trace_rays_indirect2),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.ray_tracing_pipeline_trace_rays_indirect2 as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_ray_tracing_position_fetch_khr
                .as_mut()
                .map(|s| &mut s.ray_tracing_position_fetch),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.ray_tracing_position_fetch as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_ray_tracing_validation_nv
                .as_mut()
                .map(|s| &mut s.ray_tracing_validation),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.ray_tracing_validation as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_ray_tracing_pipeline_khr
                .as_mut()
                .map(|s| &mut s.ray_traversal_primitive_culling),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.ray_traversal_primitive_culling as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_line_rasterization_khr
                .as_mut()
                .map(|s| &mut s.rectangular_lines),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.rectangular_lines as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_relaxed_line_rasterization_img
                .as_mut()
                .map(|s| &mut s.relaxed_line_rasterization),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.relaxed_line_rasterization as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_render_pass_striped_arm
                .as_mut()
                .map(|s| &mut s.render_pass_striped),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.render_pass_striped as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_address_binding_report_ext
                .as_mut()
                .map(|s| &mut s.report_address_binding),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.report_address_binding as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_representative_fragment_test_nv
                .as_mut()
                .map(|s| &mut s.representative_fragment_test),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.representative_fragment_test as ash::vk::Bool32;
        }
        if let Some(f) = [&mut self.features_vulkan10.features.robust_buffer_access]
            .into_iter()
            .next()
        {
            *f = features.robust_buffer_access as ash::vk::Bool32;
        }
        if let Some(f) = [
            self.features_robustness2_ext.as_mut().map(|s| &mut s.robust_buffer_access2),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.robust_buffer_access2 as ash::vk::Bool32;
        }
        if let Some(f) = [
            self.features_vulkan13.as_mut().map(|s| &mut s.robust_image_access),
            self.features_image_robustness.as_mut().map(|s| &mut s.robust_image_access),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.robust_image_access as ash::vk::Bool32;
        }
        if let Some(f) = [
            self.features_robustness2_ext.as_mut().map(|s| &mut s.robust_image_access2),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.robust_image_access2 as ash::vk::Bool32;
        }
        if let Some(f) = [
            self.features_vulkan12.as_mut().map(|s| &mut s.runtime_descriptor_array),
            self
                .features_descriptor_indexing
                .as_mut()
                .map(|s| &mut s.runtime_descriptor_array),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.runtime_descriptor_array as ash::vk::Bool32;
        }
        if let Some(f) = [&mut self.features_vulkan10.features.sample_rate_shading]
            .into_iter()
            .next()
        {
            *f = features.sample_rate_shading as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_image2_d_view_of3_d_ext
                .as_mut()
                .map(|s| &mut s.sampler2_d_view_of3_d),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.sampler2_d_view_of3_d as ash::vk::Bool32;
        }
        if let Some(f) = [&mut self.features_vulkan10.features.sampler_anisotropy]
            .into_iter()
            .next()
        {
            *f = features.sampler_anisotropy as ash::vk::Bool32;
        }
        if let Some(f) = [
            self.features_vulkan12.as_mut().map(|s| &mut s.sampler_filter_minmax),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.sampler_filter_minmax as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_portability_subset_khr
                .as_mut()
                .map(|s| &mut s.sampler_mip_lod_bias),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.sampler_mip_lod_bias as ash::vk::Bool32;
        }
        if let Some(f) = [
            self.features_vulkan12.as_mut().map(|s| &mut s.sampler_mirror_clamp_to_edge),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.sampler_mirror_clamp_to_edge as ash::vk::Bool32;
        }
        if let Some(f) = [
            self.features_vulkan11.as_mut().map(|s| &mut s.sampler_ycbcr_conversion),
            self
                .features_sampler_ycbcr_conversion
                .as_mut()
                .map(|s| &mut s.sampler_ycbcr_conversion),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.sampler_ycbcr_conversion as ash::vk::Bool32;
        }
        if let Some(f) = [
            self.features_vulkan12.as_mut().map(|s| &mut s.scalar_block_layout),
            self
                .features_scalar_block_layout
                .as_mut()
                .map(|s| &mut s.scalar_block_layout),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.scalar_block_layout as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_scheduling_controls_arm
                .as_mut()
                .map(|s| &mut s.scheduling_controls),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.scheduling_controls as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_external_memory_screen_buffer_qnx
                .as_mut()
                .map(|s| &mut s.screen_buffer_import),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.screen_buffer_import as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_cubic_weights_qcom
                .as_mut()
                .map(|s| &mut s.selectable_cubic_weights),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.selectable_cubic_weights as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_vulkan12
                .as_mut()
                .map(|s| &mut s.separate_depth_stencil_layouts),
            self
                .features_separate_depth_stencil_layouts
                .as_mut()
                .map(|s| &mut s.separate_depth_stencil_layouts),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.separate_depth_stencil_layouts as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_portability_subset_khr
                .as_mut()
                .map(|s| &mut s.separate_stencil_mask_ref),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.separate_stencil_mask_ref as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_shader_atomic_float2_ext
                .as_mut()
                .map(|s| &mut s.shader_buffer_float16_atomic_add),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.shader_buffer_float16_atomic_add as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_shader_atomic_float2_ext
                .as_mut()
                .map(|s| &mut s.shader_buffer_float16_atomic_min_max),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.shader_buffer_float16_atomic_min_max as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_shader_atomic_float2_ext
                .as_mut()
                .map(|s| &mut s.shader_buffer_float16_atomics),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.shader_buffer_float16_atomics as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_shader_atomic_float_ext
                .as_mut()
                .map(|s| &mut s.shader_buffer_float32_atomic_add),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.shader_buffer_float32_atomic_add as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_shader_atomic_float2_ext
                .as_mut()
                .map(|s| &mut s.shader_buffer_float32_atomic_min_max),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.shader_buffer_float32_atomic_min_max as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_shader_atomic_float_ext
                .as_mut()
                .map(|s| &mut s.shader_buffer_float32_atomics),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.shader_buffer_float32_atomics as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_shader_atomic_float_ext
                .as_mut()
                .map(|s| &mut s.shader_buffer_float64_atomic_add),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.shader_buffer_float64_atomic_add as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_shader_atomic_float2_ext
                .as_mut()
                .map(|s| &mut s.shader_buffer_float64_atomic_min_max),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.shader_buffer_float64_atomic_min_max as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_shader_atomic_float_ext
                .as_mut()
                .map(|s| &mut s.shader_buffer_float64_atomics),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.shader_buffer_float64_atomics as ash::vk::Bool32;
        }
        if let Some(f) = [
            self.features_vulkan12.as_mut().map(|s| &mut s.shader_buffer_int64_atomics),
            self
                .features_shader_atomic_int64
                .as_mut()
                .map(|s| &mut s.shader_buffer_int64_atomics),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.shader_buffer_int64_atomics as ash::vk::Bool32;
        }
        if let Some(f) = [&mut self.features_vulkan10.features.shader_clip_distance]
            .into_iter()
            .next()
        {
            *f = features.shader_clip_distance as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_shader_core_builtins_arm
                .as_mut()
                .map(|s| &mut s.shader_core_builtins),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.shader_core_builtins as ash::vk::Bool32;
        }
        if let Some(f) = [&mut self.features_vulkan10.features.shader_cull_distance]
            .into_iter()
            .next()
        {
            *f = features.shader_cull_distance as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_vulkan13
                .as_mut()
                .map(|s| &mut s.shader_demote_to_helper_invocation),
            self
                .features_shader_demote_to_helper_invocation
                .as_mut()
                .map(|s| &mut s.shader_demote_to_helper_invocation),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.shader_demote_to_helper_invocation as ash::vk::Bool32;
        }
        if let Some(f) = [
            self.features_shader_clock_khr.as_mut().map(|s| &mut s.shader_device_clock),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.shader_device_clock as ash::vk::Bool32;
        }
        if let Some(f) = [
            self.features_vulkan11.as_mut().map(|s| &mut s.shader_draw_parameters),
            self
                .features_shader_draw_parameters
                .as_mut()
                .map(|s| &mut s.shader_draw_parameters),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.shader_draw_parameters as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_shader_early_and_late_fragment_tests_amd
                .as_mut()
                .map(|s| &mut s.shader_early_and_late_fragment_tests),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.shader_early_and_late_fragment_tests as ash::vk::Bool32;
        }
        if let Some(f) = [
            self.features_shader_enqueue_amdx.as_mut().map(|s| &mut s.shader_enqueue),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.shader_enqueue as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_shader_expect_assume_khr
                .as_mut()
                .map(|s| &mut s.shader_expect_assume),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.shader_expect_assume as ash::vk::Bool32;
        }
        if let Some(f) = [
            self.features_vulkan12.as_mut().map(|s| &mut s.shader_float16),
            self.features_shader_float16_int8.as_mut().map(|s| &mut s.shader_float16),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.shader_float16 as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_shader_atomic_float16_vector_nv
                .as_mut()
                .map(|s| &mut s.shader_float16_vector_atomics),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.shader_float16_vector_atomics as ash::vk::Bool32;
        }
        if let Some(f) = [&mut self.features_vulkan10.features.shader_float64]
            .into_iter()
            .next()
        {
            *f = features.shader_float64 as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_shader_float_controls2_khr
                .as_mut()
                .map(|s| &mut s.shader_float_controls2),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.shader_float_controls2 as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_shader_atomic_float_ext
                .as_mut()
                .map(|s| &mut s.shader_image_float32_atomic_add),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.shader_image_float32_atomic_add as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_shader_atomic_float2_ext
                .as_mut()
                .map(|s| &mut s.shader_image_float32_atomic_min_max),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.shader_image_float32_atomic_min_max as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_shader_atomic_float_ext
                .as_mut()
                .map(|s| &mut s.shader_image_float32_atomics),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.shader_image_float32_atomics as ash::vk::Bool32;
        }
        if let Some(f) = [
            &mut self.features_vulkan10.features.shader_image_gather_extended,
        ]
            .into_iter()
            .next()
        {
            *f = features.shader_image_gather_extended as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_shader_image_atomic_int64_ext
                .as_mut()
                .map(|s| &mut s.shader_image_int64_atomics),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.shader_image_int64_atomics as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_vulkan12
                .as_mut()
                .map(|s| &mut s.shader_input_attachment_array_dynamic_indexing),
            self
                .features_descriptor_indexing
                .as_mut()
                .map(|s| &mut s.shader_input_attachment_array_dynamic_indexing),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.shader_input_attachment_array_dynamic_indexing
                as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_vulkan12
                .as_mut()
                .map(|s| &mut s.shader_input_attachment_array_non_uniform_indexing),
            self
                .features_descriptor_indexing
                .as_mut()
                .map(|s| &mut s.shader_input_attachment_array_non_uniform_indexing),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.shader_input_attachment_array_non_uniform_indexing
                as ash::vk::Bool32;
        }
        if let Some(f) = [&mut self.features_vulkan10.features.shader_int16]
            .into_iter()
            .next()
        {
            *f = features.shader_int16 as ash::vk::Bool32;
        }
        if let Some(f) = [&mut self.features_vulkan10.features.shader_int64]
            .into_iter()
            .next()
        {
            *f = features.shader_int64 as ash::vk::Bool32;
        }
        if let Some(f) = [
            self.features_vulkan12.as_mut().map(|s| &mut s.shader_int8),
            self.features_shader_float16_int8.as_mut().map(|s| &mut s.shader_int8),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.shader_int8 as ash::vk::Bool32;
        }
        if let Some(f) = [
            self.features_vulkan13.as_mut().map(|s| &mut s.shader_integer_dot_product),
            self
                .features_shader_integer_dot_product
                .as_mut()
                .map(|s| &mut s.shader_integer_dot_product),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.shader_integer_dot_product as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_shader_integer_functions2_intel
                .as_mut()
                .map(|s| &mut s.shader_integer_functions2),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.shader_integer_functions2 as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_shader_maximal_reconvergence_khr
                .as_mut()
                .map(|s| &mut s.shader_maximal_reconvergence),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.shader_maximal_reconvergence as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_shader_module_identifier_ext
                .as_mut()
                .map(|s| &mut s.shader_module_identifier),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.shader_module_identifier as ash::vk::Bool32;
        }
        if let Some(f) = [
            self.features_shader_object_ext.as_mut().map(|s| &mut s.shader_object),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.shader_object as ash::vk::Bool32;
        }
        if let Some(f) = [
            self.features_vulkan12.as_mut().map(|s| &mut s.shader_output_layer),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.shader_output_layer as ash::vk::Bool32;
        }
        if let Some(f) = [
            self.features_vulkan12.as_mut().map(|s| &mut s.shader_output_viewport_index),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.shader_output_viewport_index as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_shader_quad_control_khr
                .as_mut()
                .map(|s| &mut s.shader_quad_control),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.shader_quad_control as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_raw_access_chains_nv
                .as_mut()
                .map(|s| &mut s.shader_raw_access_chains),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.shader_raw_access_chains as ash::vk::Bool32;
        }
        if let Some(f) = [&mut self.features_vulkan10.features.shader_resource_min_lod]
            .into_iter()
            .next()
        {
            *f = features.shader_resource_min_lod as ash::vk::Bool32;
        }
        if let Some(f) = [&mut self.features_vulkan10.features.shader_resource_residency]
            .into_iter()
            .next()
        {
            *f = features.shader_resource_residency as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_portability_subset_khr
                .as_mut()
                .map(|s| &mut s.shader_sample_rate_interpolation_functions),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.shader_sample_rate_interpolation_functions as ash::vk::Bool32;
        }
        if let Some(f) = [
            &mut self
                .features_vulkan10
                .features
                .shader_sampled_image_array_dynamic_indexing,
        ]
            .into_iter()
            .next()
        {
            *f = features.shader_sampled_image_array_dynamic_indexing as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_vulkan12
                .as_mut()
                .map(|s| &mut s.shader_sampled_image_array_non_uniform_indexing),
            self
                .features_descriptor_indexing
                .as_mut()
                .map(|s| &mut s.shader_sampled_image_array_non_uniform_indexing),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.shader_sampled_image_array_non_uniform_indexing
                as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_shader_atomic_float2_ext
                .as_mut()
                .map(|s| &mut s.shader_shared_float16_atomic_add),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.shader_shared_float16_atomic_add as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_shader_atomic_float2_ext
                .as_mut()
                .map(|s| &mut s.shader_shared_float16_atomic_min_max),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.shader_shared_float16_atomic_min_max as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_shader_atomic_float2_ext
                .as_mut()
                .map(|s| &mut s.shader_shared_float16_atomics),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.shader_shared_float16_atomics as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_shader_atomic_float_ext
                .as_mut()
                .map(|s| &mut s.shader_shared_float32_atomic_add),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.shader_shared_float32_atomic_add as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_shader_atomic_float2_ext
                .as_mut()
                .map(|s| &mut s.shader_shared_float32_atomic_min_max),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.shader_shared_float32_atomic_min_max as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_shader_atomic_float_ext
                .as_mut()
                .map(|s| &mut s.shader_shared_float32_atomics),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.shader_shared_float32_atomics as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_shader_atomic_float_ext
                .as_mut()
                .map(|s| &mut s.shader_shared_float64_atomic_add),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.shader_shared_float64_atomic_add as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_shader_atomic_float2_ext
                .as_mut()
                .map(|s| &mut s.shader_shared_float64_atomic_min_max),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.shader_shared_float64_atomic_min_max as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_shader_atomic_float_ext
                .as_mut()
                .map(|s| &mut s.shader_shared_float64_atomics),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.shader_shared_float64_atomics as ash::vk::Bool32;
        }
        if let Some(f) = [
            self.features_vulkan12.as_mut().map(|s| &mut s.shader_shared_int64_atomics),
            self
                .features_shader_atomic_int64
                .as_mut()
                .map(|s| &mut s.shader_shared_int64_atomics),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.shader_shared_int64_atomics as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_shader_sm_builtins_nv
                .as_mut()
                .map(|s| &mut s.shader_sm_builtins),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.shader_sm_builtins as ash::vk::Bool32;
        }
        if let Some(f) = [
            &mut self
                .features_vulkan10
                .features
                .shader_storage_buffer_array_dynamic_indexing,
        ]
            .into_iter()
            .next()
        {
            *f = features.shader_storage_buffer_array_dynamic_indexing
                as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_vulkan12
                .as_mut()
                .map(|s| &mut s.shader_storage_buffer_array_non_uniform_indexing),
            self
                .features_descriptor_indexing
                .as_mut()
                .map(|s| &mut s.shader_storage_buffer_array_non_uniform_indexing),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.shader_storage_buffer_array_non_uniform_indexing
                as ash::vk::Bool32;
        }
        if let Some(f) = [
            &mut self
                .features_vulkan10
                .features
                .shader_storage_image_array_dynamic_indexing,
        ]
            .into_iter()
            .next()
        {
            *f = features.shader_storage_image_array_dynamic_indexing as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_vulkan12
                .as_mut()
                .map(|s| &mut s.shader_storage_image_array_non_uniform_indexing),
            self
                .features_descriptor_indexing
                .as_mut()
                .map(|s| &mut s.shader_storage_image_array_non_uniform_indexing),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.shader_storage_image_array_non_uniform_indexing
                as ash::vk::Bool32;
        }
        if let Some(f) = [
            &mut self.features_vulkan10.features.shader_storage_image_extended_formats,
        ]
            .into_iter()
            .next()
        {
            *f = features.shader_storage_image_extended_formats as ash::vk::Bool32;
        }
        if let Some(f) = [
            &mut self.features_vulkan10.features.shader_storage_image_multisample,
        ]
            .into_iter()
            .next()
        {
            *f = features.shader_storage_image_multisample as ash::vk::Bool32;
        }
        if let Some(f) = [
            &mut self.features_vulkan10.features.shader_storage_image_read_without_format,
        ]
            .into_iter()
            .next()
        {
            *f = features.shader_storage_image_read_without_format as ash::vk::Bool32;
        }
        if let Some(f) = [
            &mut self
                .features_vulkan10
                .features
                .shader_storage_image_write_without_format,
        ]
            .into_iter()
            .next()
        {
            *f = features.shader_storage_image_write_without_format as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_vulkan12
                .as_mut()
                .map(|s| &mut s.shader_storage_texel_buffer_array_dynamic_indexing),
            self
                .features_descriptor_indexing
                .as_mut()
                .map(|s| &mut s.shader_storage_texel_buffer_array_dynamic_indexing),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.shader_storage_texel_buffer_array_dynamic_indexing
                as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_vulkan12
                .as_mut()
                .map(|s| &mut s.shader_storage_texel_buffer_array_non_uniform_indexing),
            self
                .features_descriptor_indexing
                .as_mut()
                .map(|s| &mut s.shader_storage_texel_buffer_array_non_uniform_indexing),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.shader_storage_texel_buffer_array_non_uniform_indexing
                as ash::vk::Bool32;
        }
        if let Some(f) = [
            self.features_shader_clock_khr.as_mut().map(|s| &mut s.shader_subgroup_clock),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.shader_subgroup_clock as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_vulkan12
                .as_mut()
                .map(|s| &mut s.shader_subgroup_extended_types),
            self
                .features_shader_subgroup_extended_types
                .as_mut()
                .map(|s| &mut s.shader_subgroup_extended_types),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.shader_subgroup_extended_types as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_shader_subgroup_rotate_khr
                .as_mut()
                .map(|s| &mut s.shader_subgroup_rotate),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.shader_subgroup_rotate as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_shader_subgroup_rotate_khr
                .as_mut()
                .map(|s| &mut s.shader_subgroup_rotate_clustered),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.shader_subgroup_rotate_clustered as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_shader_subgroup_uniform_control_flow_khr
                .as_mut()
                .map(|s| &mut s.shader_subgroup_uniform_control_flow),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.shader_subgroup_uniform_control_flow as ash::vk::Bool32;
        }
        if let Some(f) = [
            self.features_vulkan13.as_mut().map(|s| &mut s.shader_terminate_invocation),
            self
                .features_shader_terminate_invocation
                .as_mut()
                .map(|s| &mut s.shader_terminate_invocation),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.shader_terminate_invocation as ash::vk::Bool32;
        }
        if let Some(f) = [
            &mut self
                .features_vulkan10
                .features
                .shader_tessellation_and_geometry_point_size,
        ]
            .into_iter()
            .next()
        {
            *f = features.shader_tessellation_and_geometry_point_size as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_shader_tile_image_ext
                .as_mut()
                .map(|s| &mut s.shader_tile_image_color_read_access),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.shader_tile_image_color_read_access as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_shader_tile_image_ext
                .as_mut()
                .map(|s| &mut s.shader_tile_image_depth_read_access),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.shader_tile_image_depth_read_access as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_shader_tile_image_ext
                .as_mut()
                .map(|s| &mut s.shader_tile_image_stencil_read_access),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.shader_tile_image_stencil_read_access as ash::vk::Bool32;
        }
        if let Some(f) = [
            &mut self
                .features_vulkan10
                .features
                .shader_uniform_buffer_array_dynamic_indexing,
        ]
            .into_iter()
            .next()
        {
            *f = features.shader_uniform_buffer_array_dynamic_indexing
                as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_vulkan12
                .as_mut()
                .map(|s| &mut s.shader_uniform_buffer_array_non_uniform_indexing),
            self
                .features_descriptor_indexing
                .as_mut()
                .map(|s| &mut s.shader_uniform_buffer_array_non_uniform_indexing),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.shader_uniform_buffer_array_non_uniform_indexing
                as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_vulkan12
                .as_mut()
                .map(|s| &mut s.shader_uniform_texel_buffer_array_dynamic_indexing),
            self
                .features_descriptor_indexing
                .as_mut()
                .map(|s| &mut s.shader_uniform_texel_buffer_array_dynamic_indexing),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.shader_uniform_texel_buffer_array_dynamic_indexing
                as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_vulkan12
                .as_mut()
                .map(|s| &mut s.shader_uniform_texel_buffer_array_non_uniform_indexing),
            self
                .features_descriptor_indexing
                .as_mut()
                .map(|s| &mut s.shader_uniform_texel_buffer_array_non_uniform_indexing),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.shader_uniform_texel_buffer_array_non_uniform_indexing
                as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_vulkan13
                .as_mut()
                .map(|s| &mut s.shader_zero_initialize_workgroup_memory),
            self
                .features_zero_initialize_workgroup_memory
                .as_mut()
                .map(|s| &mut s.shader_zero_initialize_workgroup_memory),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.shader_zero_initialize_workgroup_memory as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_shading_rate_image_nv
                .as_mut()
                .map(|s| &mut s.shading_rate_coarse_sample_order),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.shading_rate_coarse_sample_order as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_shading_rate_image_nv
                .as_mut()
                .map(|s| &mut s.shading_rate_image),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.shading_rate_image as ash::vk::Bool32;
        }
        if let Some(f) = [
            self.features_line_rasterization_khr.as_mut().map(|s| &mut s.smooth_lines),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.smooth_lines as ash::vk::Bool32;
        }
        if let Some(f) = [&mut self.features_vulkan10.features.sparse_binding]
            .into_iter()
            .next()
        {
            *f = features.sparse_binding as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_shader_atomic_float_ext
                .as_mut()
                .map(|s| &mut s.sparse_image_float32_atomic_add),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.sparse_image_float32_atomic_add as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_shader_atomic_float2_ext
                .as_mut()
                .map(|s| &mut s.sparse_image_float32_atomic_min_max),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.sparse_image_float32_atomic_min_max as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_shader_atomic_float_ext
                .as_mut()
                .map(|s| &mut s.sparse_image_float32_atomics),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.sparse_image_float32_atomics as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_shader_image_atomic_int64_ext
                .as_mut()
                .map(|s| &mut s.sparse_image_int64_atomics),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.sparse_image_int64_atomics as ash::vk::Bool32;
        }
        if let Some(f) = [
            &mut self.features_vulkan10.features.sparse_residency16_samples,
        ]
            .into_iter()
            .next()
        {
            *f = features.sparse_residency16_samples as ash::vk::Bool32;
        }
        if let Some(f) = [&mut self.features_vulkan10.features.sparse_residency2_samples]
            .into_iter()
            .next()
        {
            *f = features.sparse_residency2_samples as ash::vk::Bool32;
        }
        if let Some(f) = [&mut self.features_vulkan10.features.sparse_residency4_samples]
            .into_iter()
            .next()
        {
            *f = features.sparse_residency4_samples as ash::vk::Bool32;
        }
        if let Some(f) = [&mut self.features_vulkan10.features.sparse_residency8_samples]
            .into_iter()
            .next()
        {
            *f = features.sparse_residency8_samples as ash::vk::Bool32;
        }
        if let Some(f) = [&mut self.features_vulkan10.features.sparse_residency_aliased]
            .into_iter()
            .next()
        {
            *f = features.sparse_residency_aliased as ash::vk::Bool32;
        }
        if let Some(f) = [&mut self.features_vulkan10.features.sparse_residency_buffer]
            .into_iter()
            .next()
        {
            *f = features.sparse_residency_buffer as ash::vk::Bool32;
        }
        if let Some(f) = [&mut self.features_vulkan10.features.sparse_residency_image2_d]
            .into_iter()
            .next()
        {
            *f = features.sparse_residency_image2_d as ash::vk::Bool32;
        }
        if let Some(f) = [&mut self.features_vulkan10.features.sparse_residency_image3_d]
            .into_iter()
            .next()
        {
            *f = features.sparse_residency_image3_d as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_line_rasterization_khr
                .as_mut()
                .map(|s| &mut s.stippled_bresenham_lines),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.stippled_bresenham_lines as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_line_rasterization_khr
                .as_mut()
                .map(|s| &mut s.stippled_rectangular_lines),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.stippled_rectangular_lines as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_line_rasterization_khr
                .as_mut()
                .map(|s| &mut s.stippled_smooth_lines),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.stippled_smooth_lines as ash::vk::Bool32;
        }
        if let Some(f) = [
            self.features_vulkan11.as_mut().map(|s| &mut s.storage_buffer16_bit_access),
            self
                .features_16bit_storage
                .as_mut()
                .map(|s| &mut s.storage_buffer16_bit_access),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.storage_buffer16_bit_access as ash::vk::Bool32;
        }
        if let Some(f) = [
            self.features_vulkan12.as_mut().map(|s| &mut s.storage_buffer8_bit_access),
            self
                .features_8bit_storage
                .as_mut()
                .map(|s| &mut s.storage_buffer8_bit_access),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.storage_buffer8_bit_access as ash::vk::Bool32;
        }
        if let Some(f) = [
            self.features_vulkan11.as_mut().map(|s| &mut s.storage_input_output16),
            self.features_16bit_storage.as_mut().map(|s| &mut s.storage_input_output16),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.storage_input_output16 as ash::vk::Bool32;
        }
        if let Some(f) = [
            self.features_vulkan11.as_mut().map(|s| &mut s.storage_push_constant16),
            self.features_16bit_storage.as_mut().map(|s| &mut s.storage_push_constant16),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.storage_push_constant16 as ash::vk::Bool32;
        }
        if let Some(f) = [
            self.features_vulkan12.as_mut().map(|s| &mut s.storage_push_constant8),
            self.features_8bit_storage.as_mut().map(|s| &mut s.storage_push_constant8),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.storage_push_constant8 as ash::vk::Bool32;
        }
        if let Some(f) = [
            self.features_vulkan12.as_mut().map(|s| &mut s.subgroup_broadcast_dynamic_id),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.subgroup_broadcast_dynamic_id as ash::vk::Bool32;
        }
        if let Some(f) = [
            self.features_vulkan13.as_mut().map(|s| &mut s.subgroup_size_control),
            self
                .features_subgroup_size_control
                .as_mut()
                .map(|s| &mut s.subgroup_size_control),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.subgroup_size_control as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_subpass_merge_feedback_ext
                .as_mut()
                .map(|s| &mut s.subpass_merge_feedback),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.subpass_merge_feedback as ash::vk::Bool32;
        }
        if let Some(f) = [
            self.features_subpass_shading_huawei.as_mut().map(|s| &mut s.subpass_shading),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.subpass_shading as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_fragment_shading_rate_enums_nv
                .as_mut()
                .map(|s| &mut s.supersample_fragment_shading_rates),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.supersample_fragment_shading_rates as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_swapchain_maintenance1_ext
                .as_mut()
                .map(|s| &mut s.swapchain_maintenance1),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.swapchain_maintenance1 as ash::vk::Bool32;
        }
        if let Some(f) = [
            self.features_vulkan13.as_mut().map(|s| &mut s.synchronization2),
            self.features_synchronization2.as_mut().map(|s| &mut s.synchronization2),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.synchronization2 as ash::vk::Bool32;
        }
        if let Some(f) = [
            self.features_mesh_shader_ext.as_mut().map(|s| &mut s.task_shader),
            self.features_mesh_shader_nv.as_mut().map(|s| &mut s.task_shader),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.task_shader as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_portability_subset_khr
                .as_mut()
                .map(|s| &mut s.tessellation_isolines),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.tessellation_isolines as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_portability_subset_khr
                .as_mut()
                .map(|s| &mut s.tessellation_point_mode),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.tessellation_point_mode as ash::vk::Bool32;
        }
        if let Some(f) = [&mut self.features_vulkan10.features.tessellation_shader]
            .into_iter()
            .next()
        {
            *f = features.tessellation_shader as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_texel_buffer_alignment_ext
                .as_mut()
                .map(|s| &mut s.texel_buffer_alignment),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.texel_buffer_alignment as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_image_processing_qcom
                .as_mut()
                .map(|s| &mut s.texture_block_match),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.texture_block_match as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_image_processing2_qcom
                .as_mut()
                .map(|s| &mut s.texture_block_match2),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.texture_block_match2 as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_image_processing_qcom
                .as_mut()
                .map(|s| &mut s.texture_box_filter),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.texture_box_filter as ash::vk::Bool32;
        }
        if let Some(f) = [
            self.features_vulkan13.as_mut().map(|s| &mut s.texture_compression_astc_hdr),
            self
                .features_texture_compression_astchdr
                .as_mut()
                .map(|s| &mut s.texture_compression_astc_hdr),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.texture_compression_astc_hdr as ash::vk::Bool32;
        }
        if let Some(f) = [
            &mut self.features_vulkan10.features.texture_compression_astc_ldr,
        ]
            .into_iter()
            .next()
        {
            *f = features.texture_compression_astc_ldr as ash::vk::Bool32;
        }
        if let Some(f) = [&mut self.features_vulkan10.features.texture_compression_bc]
            .into_iter()
            .next()
        {
            *f = features.texture_compression_bc as ash::vk::Bool32;
        }
        if let Some(f) = [&mut self.features_vulkan10.features.texture_compression_etc2]
            .into_iter()
            .next()
        {
            *f = features.texture_compression_etc2 as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_image_processing_qcom
                .as_mut()
                .map(|s| &mut s.texture_sample_weighted),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.texture_sample_weighted as ash::vk::Bool32;
        }
        if let Some(f) = [
            self.features_tile_properties_qcom.as_mut().map(|s| &mut s.tile_properties),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.tile_properties as ash::vk::Bool32;
        }
        if let Some(f) = [
            self.features_vulkan12.as_mut().map(|s| &mut s.timeline_semaphore),
            self.features_timeline_semaphore.as_mut().map(|s| &mut s.timeline_semaphore),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.timeline_semaphore as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_transform_feedback_ext
                .as_mut()
                .map(|s| &mut s.transform_feedback),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.transform_feedback as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_provoking_vertex_ext
                .as_mut()
                .map(|s| &mut s.transform_feedback_preserves_provoking_vertex),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.transform_feedback_preserves_provoking_vertex
                as ash::vk::Bool32;
        }
        if let Some(f) = [
            self.features_portability_subset_khr.as_mut().map(|s| &mut s.triangle_fans),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.triangle_fans as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_vulkan11
                .as_mut()
                .map(|s| &mut s.uniform_and_storage_buffer16_bit_access),
            self
                .features_16bit_storage
                .as_mut()
                .map(|s| &mut s.uniform_and_storage_buffer16_bit_access),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.uniform_and_storage_buffer16_bit_access as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_vulkan12
                .as_mut()
                .map(|s| &mut s.uniform_and_storage_buffer8_bit_access),
            self
                .features_8bit_storage
                .as_mut()
                .map(|s| &mut s.uniform_and_storage_buffer8_bit_access),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.uniform_and_storage_buffer8_bit_access as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_vulkan12
                .as_mut()
                .map(|s| &mut s.uniform_buffer_standard_layout),
            self
                .features_uniform_buffer_standard_layout
                .as_mut()
                .map(|s| &mut s.uniform_buffer_standard_layout),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.uniform_buffer_standard_layout as ash::vk::Bool32;
        }
        if let Some(f) = [&mut self.features_vulkan10.features.variable_multisample_rate]
            .into_iter()
            .next()
        {
            *f = features.variable_multisample_rate as ash::vk::Bool32;
        }
        if let Some(f) = [
            self.features_vulkan11.as_mut().map(|s| &mut s.variable_pointers),
            self.features_variable_pointers.as_mut().map(|s| &mut s.variable_pointers),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.variable_pointers as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_vulkan11
                .as_mut()
                .map(|s| &mut s.variable_pointers_storage_buffer),
            self
                .features_variable_pointers
                .as_mut()
                .map(|s| &mut s.variable_pointers_storage_buffer),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.variable_pointers_storage_buffer as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_portability_subset_khr
                .as_mut()
                .map(|s| &mut s.vertex_attribute_access_beyond_stride),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.vertex_attribute_access_beyond_stride as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_vertex_attribute_divisor_khr
                .as_mut()
                .map(|s| &mut s.vertex_attribute_instance_rate_divisor),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.vertex_attribute_instance_rate_divisor as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_vertex_attribute_divisor_khr
                .as_mut()
                .map(|s| &mut s.vertex_attribute_instance_rate_zero_divisor),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.vertex_attribute_instance_rate_zero_divisor as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_vertex_input_dynamic_state_ext
                .as_mut()
                .map(|s| &mut s.vertex_input_dynamic_state),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.vertex_input_dynamic_state as ash::vk::Bool32;
        }
        if let Some(f) = [
            &mut self.features_vulkan10.features.vertex_pipeline_stores_and_atomics,
        ]
            .into_iter()
            .next()
        {
            *f = features.vertex_pipeline_stores_and_atomics as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_video_maintenance1_khr
                .as_mut()
                .map(|s| &mut s.video_maintenance1),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.video_maintenance1 as ash::vk::Bool32;
        }
        if let Some(f) = [
            self.features_vulkan12.as_mut().map(|s| &mut s.vulkan_memory_model),
            self
                .features_vulkan_memory_model
                .as_mut()
                .map(|s| &mut s.vulkan_memory_model),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.vulkan_memory_model as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_vulkan12
                .as_mut()
                .map(|s| &mut s.vulkan_memory_model_availability_visibility_chains),
            self
                .features_vulkan_memory_model
                .as_mut()
                .map(|s| &mut s.vulkan_memory_model_availability_visibility_chains),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.vulkan_memory_model_availability_visibility_chains
                as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_vulkan12
                .as_mut()
                .map(|s| &mut s.vulkan_memory_model_device_scope),
            self
                .features_vulkan_memory_model
                .as_mut()
                .map(|s| &mut s.vulkan_memory_model_device_scope),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.vulkan_memory_model_device_scope as ash::vk::Bool32;
        }
        if let Some(f) = [&mut self.features_vulkan10.features.wide_lines]
            .into_iter()
            .next()
        {
            *f = features.wide_lines as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_workgroup_memory_explicit_layout_khr
                .as_mut()
                .map(|s| &mut s.workgroup_memory_explicit_layout),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.workgroup_memory_explicit_layout as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_workgroup_memory_explicit_layout_khr
                .as_mut()
                .map(|s| &mut s.workgroup_memory_explicit_layout16_bit_access),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.workgroup_memory_explicit_layout16_bit_access
                as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_workgroup_memory_explicit_layout_khr
                .as_mut()
                .map(|s| &mut s.workgroup_memory_explicit_layout8_bit_access),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.workgroup_memory_explicit_layout8_bit_access
                as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_workgroup_memory_explicit_layout_khr
                .as_mut()
                .map(|s| &mut s.workgroup_memory_explicit_layout_scalar_block_layout),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.workgroup_memory_explicit_layout_scalar_block_layout
                as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_ycbcr2_plane444_formats_ext
                .as_mut()
                .map(|s| &mut s.ycbcr2plane444_formats),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.ycbcr2plane444_formats as ash::vk::Bool32;
        }
        if let Some(f) = [
            self.features_ycbcr_degamma_qcom.as_mut().map(|s| &mut s.ycbcr_degamma),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.ycbcr_degamma as ash::vk::Bool32;
        }
        if let Some(f) = [
            self
                .features_ycbcr_image_arrays_ext
                .as_mut()
                .map(|s| &mut s.ycbcr_image_arrays),
        ]
            .into_iter()
            .flatten()
            .next()
        {
            *f = features.ycbcr_image_arrays as ash::vk::Bool32;
        }
    }
}
impl From<&DeviceFeaturesFfi> for DeviceFeatures {
    fn from(features_ffi: &DeviceFeaturesFfi) -> Self {
        DeviceFeatures {
            acceleration_structure: [
                features_ffi
                    .features_acceleration_structure_khr
                    .map(|s| s.acceleration_structure),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            acceleration_structure_capture_replay: [
                features_ffi
                    .features_acceleration_structure_khr
                    .map(|s| s.acceleration_structure_capture_replay),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            acceleration_structure_host_commands: [
                features_ffi
                    .features_acceleration_structure_khr
                    .map(|s| s.acceleration_structure_host_commands),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            acceleration_structure_indirect_build: [
                features_ffi
                    .features_acceleration_structure_khr
                    .map(|s| s.acceleration_structure_indirect_build),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            advanced_blend_coherent_operations: [
                features_ffi
                    .features_blend_operation_advanced_ext
                    .map(|s| s.advanced_blend_coherent_operations),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            alpha_to_one: [features_ffi.features_vulkan10.features.alpha_to_one]
                .into_iter()
                .next()
                .unwrap_or(0) != 0,
            amigo_profiling: [
                features_ffi.features_amigo_profiling_sec.map(|s| s.amigo_profiling),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            attachment_feedback_loop_dynamic_state: [
                features_ffi
                    .features_attachment_feedback_loop_dynamic_state_ext
                    .map(|s| s.attachment_feedback_loop_dynamic_state),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            attachment_feedback_loop_layout: [
                features_ffi
                    .features_attachment_feedback_loop_layout_ext
                    .map(|s| s.attachment_feedback_loop_layout),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            attachment_fragment_shading_rate: [
                features_ffi
                    .features_fragment_shading_rate_khr
                    .map(|s| s.attachment_fragment_shading_rate),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            border_color_swizzle: [
                features_ffi
                    .features_border_color_swizzle_ext
                    .map(|s| s.border_color_swizzle),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            border_color_swizzle_from_image: [
                features_ffi
                    .features_border_color_swizzle_ext
                    .map(|s| s.border_color_swizzle_from_image),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            bresenham_lines: [
                features_ffi.features_line_rasterization_khr.map(|s| s.bresenham_lines),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            buffer_device_address: [
                features_ffi.features_vulkan12.map(|s| s.buffer_device_address),
                features_ffi
                    .features_buffer_device_address
                    .map(|s| s.buffer_device_address),
                features_ffi
                    .features_buffer_device_address_ext
                    .map(|s| s.buffer_device_address),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            buffer_device_address_capture_replay: [
                features_ffi
                    .features_vulkan12
                    .map(|s| s.buffer_device_address_capture_replay),
                features_ffi
                    .features_buffer_device_address
                    .map(|s| s.buffer_device_address_capture_replay),
                features_ffi
                    .features_buffer_device_address_ext
                    .map(|s| s.buffer_device_address_capture_replay),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            buffer_device_address_multi_device: [
                features_ffi
                    .features_vulkan12
                    .map(|s| s.buffer_device_address_multi_device),
                features_ffi
                    .features_buffer_device_address
                    .map(|s| s.buffer_device_address_multi_device),
                features_ffi
                    .features_buffer_device_address_ext
                    .map(|s| s.buffer_device_address_multi_device),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            clusterculling_shader: [
                features_ffi
                    .features_cluster_culling_shader_huawei
                    .map(|s| s.clusterculling_shader),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            color_write_enable: [
                features_ffi
                    .features_color_write_enable_ext
                    .map(|s| s.color_write_enable),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            compute_derivative_group_linear: [
                features_ffi
                    .features_compute_shader_derivatives_nv
                    .map(|s| s.compute_derivative_group_linear),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            compute_derivative_group_quads: [
                features_ffi
                    .features_compute_shader_derivatives_nv
                    .map(|s| s.compute_derivative_group_quads),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            compute_full_subgroups: [
                features_ffi.features_vulkan13.map(|s| s.compute_full_subgroups),
                features_ffi
                    .features_subgroup_size_control
                    .map(|s| s.compute_full_subgroups),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            conditional_rendering: [
                features_ffi
                    .features_conditional_rendering_ext
                    .map(|s| s.conditional_rendering),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            constant_alpha_color_blend_factors: [
                features_ffi
                    .features_portability_subset_khr
                    .map(|s| s.constant_alpha_color_blend_factors),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            cooperative_matrix: [
                features_ffi
                    .features_cooperative_matrix_khr
                    .map(|s| s.cooperative_matrix),
                features_ffi.features_cooperative_matrix_nv.map(|s| s.cooperative_matrix),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            cooperative_matrix_robust_buffer_access: [
                features_ffi
                    .features_cooperative_matrix_khr
                    .map(|s| s.cooperative_matrix_robust_buffer_access),
                features_ffi
                    .features_cooperative_matrix_nv
                    .map(|s| s.cooperative_matrix_robust_buffer_access),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            corner_sampled_image: [
                features_ffi
                    .features_corner_sampled_image_nv
                    .map(|s| s.corner_sampled_image),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            coverage_reduction_mode: [
                features_ffi
                    .features_coverage_reduction_mode_nv
                    .map(|s| s.coverage_reduction_mode),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            cubic_range_clamp: [
                features_ffi.features_cubic_clamp_qcom.map(|s| s.cubic_range_clamp),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            cuda_kernel_launch_features: [
                features_ffi
                    .features_cuda_kernel_launch_nv
                    .map(|s| s.cuda_kernel_launch_features),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            custom_border_color_without_format: [
                features_ffi
                    .features_custom_border_color_ext
                    .map(|s| s.custom_border_color_without_format),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            custom_border_colors: [
                features_ffi
                    .features_custom_border_color_ext
                    .map(|s| s.custom_border_colors),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            decode_mode_shared_exponent: [
                features_ffi
                    .features_astc_decode_ext
                    .map(|s| s.decode_mode_shared_exponent),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            dedicated_allocation_image_aliasing: [
                features_ffi
                    .features_dedicated_allocation_image_aliasing_nv
                    .map(|s| s.dedicated_allocation_image_aliasing),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            depth_bias_clamp: [features_ffi.features_vulkan10.features.depth_bias_clamp]
                .into_iter()
                .next()
                .unwrap_or(0) != 0,
            depth_bias_control: [
                features_ffi
                    .features_depth_bias_control_ext
                    .map(|s| s.depth_bias_control),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            depth_bias_exact: [
                features_ffi.features_depth_bias_control_ext.map(|s| s.depth_bias_exact),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            depth_bounds: [features_ffi.features_vulkan10.features.depth_bounds]
                .into_iter()
                .next()
                .unwrap_or(0) != 0,
            depth_clamp: [features_ffi.features_vulkan10.features.depth_clamp]
                .into_iter()
                .next()
                .unwrap_or(0) != 0,
            depth_clamp_zero_one: [
                features_ffi
                    .features_depth_clamp_zero_one_ext
                    .map(|s| s.depth_clamp_zero_one),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            depth_clip_control: [
                features_ffi
                    .features_depth_clip_control_ext
                    .map(|s| s.depth_clip_control),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            depth_clip_enable: [
                features_ffi.features_depth_clip_enable_ext.map(|s| s.depth_clip_enable),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            descriptor_binding_acceleration_structure_update_after_bind: [
                features_ffi
                    .features_acceleration_structure_khr
                    .map(|s| {
                        s.descriptor_binding_acceleration_structure_update_after_bind
                    }),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            descriptor_binding_inline_uniform_block_update_after_bind: [
                features_ffi
                    .features_vulkan13
                    .map(|s| {
                        s.descriptor_binding_inline_uniform_block_update_after_bind
                    }),
                features_ffi
                    .features_inline_uniform_block
                    .map(|s| s.descriptor_binding_inline_uniform_block_update_after_bind),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            descriptor_binding_partially_bound: [
                features_ffi
                    .features_vulkan12
                    .map(|s| s.descriptor_binding_partially_bound),
                features_ffi
                    .features_descriptor_indexing
                    .map(|s| s.descriptor_binding_partially_bound),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            descriptor_binding_sampled_image_update_after_bind: [
                features_ffi
                    .features_vulkan12
                    .map(|s| s.descriptor_binding_sampled_image_update_after_bind),
                features_ffi
                    .features_descriptor_indexing
                    .map(|s| s.descriptor_binding_sampled_image_update_after_bind),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            descriptor_binding_storage_buffer_update_after_bind: [
                features_ffi
                    .features_vulkan12
                    .map(|s| s.descriptor_binding_storage_buffer_update_after_bind),
                features_ffi
                    .features_descriptor_indexing
                    .map(|s| s.descriptor_binding_storage_buffer_update_after_bind),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            descriptor_binding_storage_image_update_after_bind: [
                features_ffi
                    .features_vulkan12
                    .map(|s| s.descriptor_binding_storage_image_update_after_bind),
                features_ffi
                    .features_descriptor_indexing
                    .map(|s| s.descriptor_binding_storage_image_update_after_bind),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            descriptor_binding_storage_texel_buffer_update_after_bind: [
                features_ffi
                    .features_vulkan12
                    .map(|s| {
                        s.descriptor_binding_storage_texel_buffer_update_after_bind
                    }),
                features_ffi
                    .features_descriptor_indexing
                    .map(|s| s.descriptor_binding_storage_texel_buffer_update_after_bind),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            descriptor_binding_uniform_buffer_update_after_bind: [
                features_ffi
                    .features_vulkan12
                    .map(|s| s.descriptor_binding_uniform_buffer_update_after_bind),
                features_ffi
                    .features_descriptor_indexing
                    .map(|s| s.descriptor_binding_uniform_buffer_update_after_bind),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            descriptor_binding_uniform_texel_buffer_update_after_bind: [
                features_ffi
                    .features_vulkan12
                    .map(|s| {
                        s.descriptor_binding_uniform_texel_buffer_update_after_bind
                    }),
                features_ffi
                    .features_descriptor_indexing
                    .map(|s| s.descriptor_binding_uniform_texel_buffer_update_after_bind),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            descriptor_binding_update_unused_while_pending: [
                features_ffi
                    .features_vulkan12
                    .map(|s| s.descriptor_binding_update_unused_while_pending),
                features_ffi
                    .features_descriptor_indexing
                    .map(|s| s.descriptor_binding_update_unused_while_pending),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            descriptor_binding_variable_descriptor_count: [
                features_ffi
                    .features_vulkan12
                    .map(|s| s.descriptor_binding_variable_descriptor_count),
                features_ffi
                    .features_descriptor_indexing
                    .map(|s| s.descriptor_binding_variable_descriptor_count),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            descriptor_buffer: [
                features_ffi.features_descriptor_buffer_ext.map(|s| s.descriptor_buffer),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            descriptor_buffer_capture_replay: [
                features_ffi
                    .features_descriptor_buffer_ext
                    .map(|s| s.descriptor_buffer_capture_replay),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            descriptor_buffer_image_layout_ignored: [
                features_ffi
                    .features_descriptor_buffer_ext
                    .map(|s| s.descriptor_buffer_image_layout_ignored),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            descriptor_buffer_push_descriptors: [
                features_ffi
                    .features_descriptor_buffer_ext
                    .map(|s| s.descriptor_buffer_push_descriptors),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            descriptor_indexing: [
                features_ffi.features_vulkan12.map(|s| s.descriptor_indexing),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            descriptor_pool_overallocation: [
                features_ffi
                    .features_descriptor_pool_overallocation_nv
                    .map(|s| s.descriptor_pool_overallocation),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            descriptor_set_host_mapping: [
                features_ffi
                    .features_descriptor_set_host_mapping_valve
                    .map(|s| s.descriptor_set_host_mapping),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            device_coherent_memory: [
                features_ffi
                    .features_coherent_memory_amd
                    .map(|s| s.device_coherent_memory),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            device_fault: [features_ffi.features_fault_ext.map(|s| s.device_fault)]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            device_fault_vendor_binary: [
                features_ffi.features_fault_ext.map(|s| s.device_fault_vendor_binary),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            device_generated_commands: [
                features_ffi
                    .features_device_generated_commands_nv
                    .map(|s| s.device_generated_commands),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            device_generated_compute: [
                features_ffi
                    .features_device_generated_commands_compute_nv
                    .map(|s| s.device_generated_compute),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            device_generated_compute_capture_replay: [
                features_ffi
                    .features_device_generated_commands_compute_nv
                    .map(|s| s.device_generated_compute_capture_replay),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            device_generated_compute_pipelines: [
                features_ffi
                    .features_device_generated_commands_compute_nv
                    .map(|s| s.device_generated_compute_pipelines),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            device_memory_report: [
                features_ffi
                    .features_device_memory_report_ext
                    .map(|s| s.device_memory_report),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            diagnostics_config: [
                features_ffi.features_diagnostics_config_nv.map(|s| s.diagnostics_config),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            displacement_micromap: [
                features_ffi
                    .features_displacement_micromap_nv
                    .map(|s| s.displacement_micromap),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            draw_indirect_count: [
                features_ffi.features_vulkan12.map(|s| s.draw_indirect_count),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            draw_indirect_first_instance: [
                features_ffi.features_vulkan10.features.draw_indirect_first_instance,
            ]
                .into_iter()
                .next()
                .unwrap_or(0) != 0,
            dual_src_blend: [features_ffi.features_vulkan10.features.dual_src_blend]
                .into_iter()
                .next()
                .unwrap_or(0) != 0,
            dynamic_pipeline_layout: [
                features_ffi
                    .features_per_stage_descriptor_set_nv
                    .map(|s| s.dynamic_pipeline_layout),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            dynamic_rendering: [
                features_ffi.features_vulkan13.map(|s| s.dynamic_rendering),
                features_ffi.features_dynamic_rendering.map(|s| s.dynamic_rendering),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            dynamic_rendering_local_read: [
                features_ffi
                    .features_dynamic_rendering_local_read_khr
                    .map(|s| s.dynamic_rendering_local_read),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            dynamic_rendering_unused_attachments: [
                features_ffi
                    .features_dynamic_rendering_unused_attachments_ext
                    .map(|s| s.dynamic_rendering_unused_attachments),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            events: [features_ffi.features_portability_subset_khr.map(|s| s.events)]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            exclusive_scissor: [
                features_ffi.features_exclusive_scissor_nv.map(|s| s.exclusive_scissor),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            extended_dynamic_state: [
                features_ffi
                    .features_extended_dynamic_state_ext
                    .map(|s| s.extended_dynamic_state),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            extended_dynamic_state2: [
                features_ffi
                    .features_extended_dynamic_state2_ext
                    .map(|s| s.extended_dynamic_state2),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            extended_dynamic_state2_logic_op: [
                features_ffi
                    .features_extended_dynamic_state2_ext
                    .map(|s| s.extended_dynamic_state2_logic_op),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            extended_dynamic_state2_patch_control_points: [
                features_ffi
                    .features_extended_dynamic_state2_ext
                    .map(|s| s.extended_dynamic_state2_patch_control_points),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            extended_dynamic_state3_alpha_to_coverage_enable: [
                features_ffi
                    .features_extended_dynamic_state3_ext
                    .map(|s| s.extended_dynamic_state3_alpha_to_coverage_enable),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            extended_dynamic_state3_alpha_to_one_enable: [
                features_ffi
                    .features_extended_dynamic_state3_ext
                    .map(|s| s.extended_dynamic_state3_alpha_to_one_enable),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            extended_dynamic_state3_color_blend_advanced: [
                features_ffi
                    .features_extended_dynamic_state3_ext
                    .map(|s| s.extended_dynamic_state3_color_blend_advanced),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            extended_dynamic_state3_color_blend_enable: [
                features_ffi
                    .features_extended_dynamic_state3_ext
                    .map(|s| s.extended_dynamic_state3_color_blend_enable),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            extended_dynamic_state3_color_blend_equation: [
                features_ffi
                    .features_extended_dynamic_state3_ext
                    .map(|s| s.extended_dynamic_state3_color_blend_equation),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            extended_dynamic_state3_color_write_mask: [
                features_ffi
                    .features_extended_dynamic_state3_ext
                    .map(|s| s.extended_dynamic_state3_color_write_mask),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            extended_dynamic_state3_conservative_rasterization_mode: [
                features_ffi
                    .features_extended_dynamic_state3_ext
                    .map(|s| s.extended_dynamic_state3_conservative_rasterization_mode),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            extended_dynamic_state3_coverage_modulation_mode: [
                features_ffi
                    .features_extended_dynamic_state3_ext
                    .map(|s| s.extended_dynamic_state3_coverage_modulation_mode),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            extended_dynamic_state3_coverage_modulation_table: [
                features_ffi
                    .features_extended_dynamic_state3_ext
                    .map(|s| s.extended_dynamic_state3_coverage_modulation_table),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            extended_dynamic_state3_coverage_modulation_table_enable: [
                features_ffi
                    .features_extended_dynamic_state3_ext
                    .map(|s| s.extended_dynamic_state3_coverage_modulation_table_enable),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            extended_dynamic_state3_coverage_reduction_mode: [
                features_ffi
                    .features_extended_dynamic_state3_ext
                    .map(|s| s.extended_dynamic_state3_coverage_reduction_mode),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            extended_dynamic_state3_coverage_to_color_enable: [
                features_ffi
                    .features_extended_dynamic_state3_ext
                    .map(|s| s.extended_dynamic_state3_coverage_to_color_enable),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            extended_dynamic_state3_coverage_to_color_location: [
                features_ffi
                    .features_extended_dynamic_state3_ext
                    .map(|s| s.extended_dynamic_state3_coverage_to_color_location),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            extended_dynamic_state3_depth_clamp_enable: [
                features_ffi
                    .features_extended_dynamic_state3_ext
                    .map(|s| s.extended_dynamic_state3_depth_clamp_enable),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            extended_dynamic_state3_depth_clip_enable: [
                features_ffi
                    .features_extended_dynamic_state3_ext
                    .map(|s| s.extended_dynamic_state3_depth_clip_enable),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            extended_dynamic_state3_depth_clip_negative_one_to_one: [
                features_ffi
                    .features_extended_dynamic_state3_ext
                    .map(|s| s.extended_dynamic_state3_depth_clip_negative_one_to_one),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            extended_dynamic_state3_extra_primitive_overestimation_size: [
                features_ffi
                    .features_extended_dynamic_state3_ext
                    .map(|s| {
                        s.extended_dynamic_state3_extra_primitive_overestimation_size
                    }),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            extended_dynamic_state3_line_rasterization_mode: [
                features_ffi
                    .features_extended_dynamic_state3_ext
                    .map(|s| s.extended_dynamic_state3_line_rasterization_mode),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            extended_dynamic_state3_line_stipple_enable: [
                features_ffi
                    .features_extended_dynamic_state3_ext
                    .map(|s| s.extended_dynamic_state3_line_stipple_enable),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            extended_dynamic_state3_logic_op_enable: [
                features_ffi
                    .features_extended_dynamic_state3_ext
                    .map(|s| s.extended_dynamic_state3_logic_op_enable),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            extended_dynamic_state3_polygon_mode: [
                features_ffi
                    .features_extended_dynamic_state3_ext
                    .map(|s| s.extended_dynamic_state3_polygon_mode),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            extended_dynamic_state3_provoking_vertex_mode: [
                features_ffi
                    .features_extended_dynamic_state3_ext
                    .map(|s| s.extended_dynamic_state3_provoking_vertex_mode),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            extended_dynamic_state3_rasterization_samples: [
                features_ffi
                    .features_extended_dynamic_state3_ext
                    .map(|s| s.extended_dynamic_state3_rasterization_samples),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            extended_dynamic_state3_rasterization_stream: [
                features_ffi
                    .features_extended_dynamic_state3_ext
                    .map(|s| s.extended_dynamic_state3_rasterization_stream),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            extended_dynamic_state3_representative_fragment_test_enable: [
                features_ffi
                    .features_extended_dynamic_state3_ext
                    .map(|s| {
                        s.extended_dynamic_state3_representative_fragment_test_enable
                    }),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            extended_dynamic_state3_sample_locations_enable: [
                features_ffi
                    .features_extended_dynamic_state3_ext
                    .map(|s| s.extended_dynamic_state3_sample_locations_enable),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            extended_dynamic_state3_sample_mask: [
                features_ffi
                    .features_extended_dynamic_state3_ext
                    .map(|s| s.extended_dynamic_state3_sample_mask),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            extended_dynamic_state3_shading_rate_image_enable: [
                features_ffi
                    .features_extended_dynamic_state3_ext
                    .map(|s| s.extended_dynamic_state3_shading_rate_image_enable),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            extended_dynamic_state3_tessellation_domain_origin: [
                features_ffi
                    .features_extended_dynamic_state3_ext
                    .map(|s| s.extended_dynamic_state3_tessellation_domain_origin),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            extended_dynamic_state3_viewport_swizzle: [
                features_ffi
                    .features_extended_dynamic_state3_ext
                    .map(|s| s.extended_dynamic_state3_viewport_swizzle),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            extended_dynamic_state3_viewport_w_scaling_enable: [
                features_ffi
                    .features_extended_dynamic_state3_ext
                    .map(|s| s.extended_dynamic_state3_viewport_w_scaling_enable),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            extended_sparse_address_space: [
                features_ffi
                    .features_extended_sparse_address_space_nv
                    .map(|s| s.extended_sparse_address_space),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            external_format_resolve: [
                features_ffi
                    .features_external_format_resolve_android
                    .map(|s| s.external_format_resolve),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            external_memory_rdma: [
                features_ffi
                    .features_external_memory_rdma_nv
                    .map(|s| s.external_memory_rdma),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            fill_mode_non_solid: [
                features_ffi.features_vulkan10.features.fill_mode_non_solid,
            ]
                .into_iter()
                .next()
                .unwrap_or(0) != 0,
            float_representation: [
                features_ffi
                    .features_depth_bias_control_ext
                    .map(|s| s.float_representation),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            format_a4b4g4r4: [
                features_ffi.features_4444formats_ext.map(|s| s.format_a4b4g4r4),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            format_a4r4g4b4: [
                features_ffi.features_4444formats_ext.map(|s| s.format_a4r4g4b4),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            format_rgba10x6_without_y_cb_cr_sampler: [
                features_ffi
                    .features_rgba10x6_formats_ext
                    .map(|s| s.format_rgba10x6_without_y_cb_cr_sampler),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            fragment_density_map: [
                features_ffi
                    .features_fragment_density_map_ext
                    .map(|s| s.fragment_density_map),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            fragment_density_map_deferred: [
                features_ffi
                    .features_fragment_density_map2_ext
                    .map(|s| s.fragment_density_map_deferred),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            fragment_density_map_dynamic: [
                features_ffi
                    .features_fragment_density_map_ext
                    .map(|s| s.fragment_density_map_dynamic),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            fragment_density_map_non_subsampled_images: [
                features_ffi
                    .features_fragment_density_map_ext
                    .map(|s| s.fragment_density_map_non_subsampled_images),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            fragment_density_map_offset: [
                features_ffi
                    .features_fragment_density_map_offset_qcom
                    .map(|s| s.fragment_density_map_offset),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            fragment_shader_barycentric: [
                features_ffi
                    .features_fragment_shader_barycentric_khr
                    .map(|s| s.fragment_shader_barycentric),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            fragment_shader_pixel_interlock: [
                features_ffi
                    .features_fragment_shader_interlock_ext
                    .map(|s| s.fragment_shader_pixel_interlock),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            fragment_shader_sample_interlock: [
                features_ffi
                    .features_fragment_shader_interlock_ext
                    .map(|s| s.fragment_shader_sample_interlock),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            fragment_shader_shading_rate_interlock: [
                features_ffi
                    .features_fragment_shader_interlock_ext
                    .map(|s| s.fragment_shader_shading_rate_interlock),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            fragment_shading_rate_enums: [
                features_ffi
                    .features_fragment_shading_rate_enums_nv
                    .map(|s| s.fragment_shading_rate_enums),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            fragment_stores_and_atomics: [
                features_ffi.features_vulkan10.features.fragment_stores_and_atomics,
            ]
                .into_iter()
                .next()
                .unwrap_or(0) != 0,
            frame_boundary: [
                features_ffi.features_frame_boundary_ext.map(|s| s.frame_boundary),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            full_draw_index_uint32: [
                features_ffi.features_vulkan10.features.full_draw_index_uint32,
            ]
                .into_iter()
                .next()
                .unwrap_or(0) != 0,
            geometry_shader: [features_ffi.features_vulkan10.features.geometry_shader]
                .into_iter()
                .next()
                .unwrap_or(0) != 0,
            geometry_streams: [
                features_ffi.features_transform_feedback_ext.map(|s| s.geometry_streams),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            global_priority_query: [
                features_ffi
                    .features_global_priority_query_khr
                    .map(|s| s.global_priority_query),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            graphics_pipeline_library: [
                features_ffi
                    .features_graphics_pipeline_library_ext
                    .map(|s| s.graphics_pipeline_library),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            host_image_copy: [
                features_ffi.features_host_image_copy_ext.map(|s| s.host_image_copy),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            host_query_reset: [
                features_ffi.features_vulkan12.map(|s| s.host_query_reset),
                features_ffi.features_host_query_reset.map(|s| s.host_query_reset),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            image2_d_view_of3_d: [
                features_ffi
                    .features_image2_d_view_of3_d_ext
                    .map(|s| s.image2_d_view_of3_d),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            image_compression_control: [
                features_ffi
                    .features_image_compression_control_ext
                    .map(|s| s.image_compression_control),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            image_compression_control_swapchain: [
                features_ffi
                    .features_image_compression_control_swapchain_ext
                    .map(|s| s.image_compression_control_swapchain),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            image_cube_array: [features_ffi.features_vulkan10.features.image_cube_array]
                .into_iter()
                .next()
                .unwrap_or(0) != 0,
            image_footprint: [
                features_ffi
                    .features_shader_image_footprint_nv
                    .map(|s| s.image_footprint),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            image_sliced_view_of3_d: [
                features_ffi
                    .features_image_sliced_view_of3_d_ext
                    .map(|s| s.image_sliced_view_of3_d),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            image_view2_d_on3_d_image: [
                features_ffi
                    .features_portability_subset_khr
                    .map(|s| s.image_view2_d_on3_d_image),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            image_view_format_reinterpretation: [
                features_ffi
                    .features_portability_subset_khr
                    .map(|s| s.image_view_format_reinterpretation),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            image_view_format_swizzle: [
                features_ffi
                    .features_portability_subset_khr
                    .map(|s| s.image_view_format_swizzle),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            imageless_framebuffer: [
                features_ffi.features_vulkan12.map(|s| s.imageless_framebuffer),
                features_ffi
                    .features_imageless_framebuffer
                    .map(|s| s.imageless_framebuffer),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            independent_blend: [
                features_ffi.features_vulkan10.features.independent_blend,
            ]
                .into_iter()
                .next()
                .unwrap_or(0) != 0,
            index_type_uint8: [
                features_ffi.features_index_type_uint8_khr.map(|s| s.index_type_uint8),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            indirect_copy: [
                features_ffi.features_copy_memory_indirect_nv.map(|s| s.indirect_copy),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            inherited_conditional_rendering: [
                features_ffi
                    .features_conditional_rendering_ext
                    .map(|s| s.inherited_conditional_rendering),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            inherited_queries: [
                features_ffi.features_vulkan10.features.inherited_queries,
            ]
                .into_iter()
                .next()
                .unwrap_or(0) != 0,
            inherited_viewport_scissor2_d: [
                features_ffi
                    .features_inherited_viewport_scissor_nv
                    .map(|s| s.inherited_viewport_scissor2_d),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            inline_uniform_block: [
                features_ffi.features_vulkan13.map(|s| s.inline_uniform_block),
                features_ffi
                    .features_inline_uniform_block
                    .map(|s| s.inline_uniform_block),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            invocation_mask: [
                features_ffi.features_invocation_mask_huawei.map(|s| s.invocation_mask),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            large_points: [features_ffi.features_vulkan10.features.large_points]
                .into_iter()
                .next()
                .unwrap_or(0) != 0,
            least_representable_value_force_unorm_representation: [
                features_ffi
                    .features_depth_bias_control_ext
                    .map(|s| s.least_representable_value_force_unorm_representation),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            legacy_dithering: [
                features_ffi.features_legacy_dithering_ext.map(|s| s.legacy_dithering),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            linear_color_attachment: [
                features_ffi
                    .features_linear_color_attachment_nv
                    .map(|s| s.linear_color_attachment),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            logic_op: [features_ffi.features_vulkan10.features.logic_op]
                .into_iter()
                .next()
                .unwrap_or(0) != 0,
            maintenance4: [
                features_ffi.features_vulkan13.map(|s| s.maintenance4),
                features_ffi.features_maintenance4.map(|s| s.maintenance4),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            maintenance5: [
                features_ffi.features_maintenance5_khr.map(|s| s.maintenance5),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            maintenance6: [
                features_ffi.features_maintenance6_khr.map(|s| s.maintenance6),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            memory_decompression: [
                features_ffi
                    .features_memory_decompression_nv
                    .map(|s| s.memory_decompression),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            memory_map_placed: [
                features_ffi.features_map_memory_placed_ext.map(|s| s.memory_map_placed),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            memory_map_range_placed: [
                features_ffi
                    .features_map_memory_placed_ext
                    .map(|s| s.memory_map_range_placed),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            memory_priority: [
                features_ffi.features_memory_priority_ext.map(|s| s.memory_priority),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            memory_unmap_reserve: [
                features_ffi
                    .features_map_memory_placed_ext
                    .map(|s| s.memory_unmap_reserve),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            mesh_shader: [
                features_ffi.features_mesh_shader_ext.map(|s| s.mesh_shader),
                features_ffi.features_mesh_shader_nv.map(|s| s.mesh_shader),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            mesh_shader_queries: [
                features_ffi.features_mesh_shader_ext.map(|s| s.mesh_shader_queries),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            micromap: [features_ffi.features_opacity_micromap_ext.map(|s| s.micromap)]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            micromap_capture_replay: [
                features_ffi
                    .features_opacity_micromap_ext
                    .map(|s| s.micromap_capture_replay),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            micromap_host_commands: [
                features_ffi
                    .features_opacity_micromap_ext
                    .map(|s| s.micromap_host_commands),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            min_lod: [features_ffi.features_image_view_min_lod_ext.map(|s| s.min_lod)]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            multi_draw: [features_ffi.features_multi_draw_ext.map(|s| s.multi_draw)]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            multi_draw_indirect: [
                features_ffi.features_vulkan10.features.multi_draw_indirect,
            ]
                .into_iter()
                .next()
                .unwrap_or(0) != 0,
            multi_viewport: [features_ffi.features_vulkan10.features.multi_viewport]
                .into_iter()
                .next()
                .unwrap_or(0) != 0,
            multisample_array_image: [
                features_ffi
                    .features_portability_subset_khr
                    .map(|s| s.multisample_array_image),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            multisampled_render_to_single_sampled: [
                features_ffi
                    .features_multisampled_render_to_single_sampled_ext
                    .map(|s| s.multisampled_render_to_single_sampled),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            multiview: [
                features_ffi.features_vulkan11.map(|s| s.multiview),
                features_ffi.features_multiview.map(|s| s.multiview),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            multiview_cluster_culling_shader: [
                features_ffi
                    .features_cluster_culling_shader_huawei
                    .map(|s| s.multiview_cluster_culling_shader),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            multiview_geometry_shader: [
                features_ffi.features_vulkan11.map(|s| s.multiview_geometry_shader),
                features_ffi.features_multiview.map(|s| s.multiview_geometry_shader),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            multiview_mesh_shader: [
                features_ffi.features_mesh_shader_ext.map(|s| s.multiview_mesh_shader),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            multiview_per_view_render_areas: [
                features_ffi
                    .features_multiview_per_view_render_areas_qcom
                    .map(|s| s.multiview_per_view_render_areas),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            multiview_per_view_viewports: [
                features_ffi
                    .features_multiview_per_view_viewports_qcom
                    .map(|s| s.multiview_per_view_viewports),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            multiview_tessellation_shader: [
                features_ffi.features_vulkan11.map(|s| s.multiview_tessellation_shader),
                features_ffi.features_multiview.map(|s| s.multiview_tessellation_shader),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            mutable_comparison_samplers: [
                features_ffi
                    .features_portability_subset_khr
                    .map(|s| s.mutable_comparison_samplers),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            mutable_descriptor_type: [
                features_ffi
                    .features_mutable_descriptor_type_ext
                    .map(|s| s.mutable_descriptor_type),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            nested_command_buffer: [
                features_ffi
                    .features_nested_command_buffer_ext
                    .map(|s| s.nested_command_buffer),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            nested_command_buffer_rendering: [
                features_ffi
                    .features_nested_command_buffer_ext
                    .map(|s| s.nested_command_buffer_rendering),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            nested_command_buffer_simultaneous_use: [
                features_ffi
                    .features_nested_command_buffer_ext
                    .map(|s| s.nested_command_buffer_simultaneous_use),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            no_invocation_fragment_shading_rates: [
                features_ffi
                    .features_fragment_shading_rate_enums_nv
                    .map(|s| s.no_invocation_fragment_shading_rates),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            non_seamless_cube_map: [
                features_ffi
                    .features_non_seamless_cube_map_ext
                    .map(|s| s.non_seamless_cube_map),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            null_descriptor: [
                features_ffi.features_robustness2_ext.map(|s| s.null_descriptor),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            occlusion_query_precise: [
                features_ffi.features_vulkan10.features.occlusion_query_precise,
            ]
                .into_iter()
                .next()
                .unwrap_or(0) != 0,
            optical_flow: [features_ffi.features_optical_flow_nv.map(|s| s.optical_flow)]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            pageable_device_local_memory: [
                features_ffi
                    .features_pageable_device_local_memory_ext
                    .map(|s| s.pageable_device_local_memory),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            per_stage_descriptor_set: [
                features_ffi
                    .features_per_stage_descriptor_set_nv
                    .map(|s| s.per_stage_descriptor_set),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            performance_counter_multiple_query_pools: [
                features_ffi
                    .features_performance_query_khr
                    .map(|s| s.performance_counter_multiple_query_pools),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            performance_counter_query_pools: [
                features_ffi
                    .features_performance_query_khr
                    .map(|s| s.performance_counter_query_pools),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            pipeline_creation_cache_control: [
                features_ffi
                    .features_vulkan13
                    .map(|s| s.pipeline_creation_cache_control),
                features_ffi
                    .features_pipeline_creation_cache_control
                    .map(|s| s.pipeline_creation_cache_control),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            pipeline_executable_info: [
                features_ffi
                    .features_pipeline_executable_properties_khr
                    .map(|s| s.pipeline_executable_info),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            pipeline_fragment_shading_rate: [
                features_ffi
                    .features_fragment_shading_rate_khr
                    .map(|s| s.pipeline_fragment_shading_rate),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            pipeline_library_group_handles: [
                features_ffi
                    .features_pipeline_library_group_handles_ext
                    .map(|s| s.pipeline_library_group_handles),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            pipeline_properties_identifier: [
                features_ffi
                    .features_pipeline_properties_ext
                    .map(|s| s.pipeline_properties_identifier),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            pipeline_protected_access: [
                features_ffi
                    .features_pipeline_protected_access_ext
                    .map(|s| s.pipeline_protected_access),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            pipeline_robustness: [
                features_ffi
                    .features_pipeline_robustness_ext
                    .map(|s| s.pipeline_robustness),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            pipeline_statistics_query: [
                features_ffi.features_vulkan10.features.pipeline_statistics_query,
            ]
                .into_iter()
                .next()
                .unwrap_or(0) != 0,
            point_polygons: [
                features_ffi.features_portability_subset_khr.map(|s| s.point_polygons),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            present_barrier: [
                features_ffi.features_present_barrier_nv.map(|s| s.present_barrier),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            present_id: [features_ffi.features_present_id_khr.map(|s| s.present_id)]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            present_wait: [
                features_ffi.features_present_wait_khr.map(|s| s.present_wait),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            primitive_fragment_shading_rate: [
                features_ffi
                    .features_fragment_shading_rate_khr
                    .map(|s| s.primitive_fragment_shading_rate),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            primitive_fragment_shading_rate_mesh_shader: [
                features_ffi
                    .features_mesh_shader_ext
                    .map(|s| s.primitive_fragment_shading_rate_mesh_shader),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            primitive_topology_list_restart: [
                features_ffi
                    .features_primitive_topology_list_restart_ext
                    .map(|s| s.primitive_topology_list_restart),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            primitive_topology_patch_list_restart: [
                features_ffi
                    .features_primitive_topology_list_restart_ext
                    .map(|s| s.primitive_topology_patch_list_restart),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            primitives_generated_query: [
                features_ffi
                    .features_primitives_generated_query_ext
                    .map(|s| s.primitives_generated_query),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            primitives_generated_query_with_non_zero_streams: [
                features_ffi
                    .features_primitives_generated_query_ext
                    .map(|s| s.primitives_generated_query_with_non_zero_streams),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            primitives_generated_query_with_rasterizer_discard: [
                features_ffi
                    .features_primitives_generated_query_ext
                    .map(|s| s.primitives_generated_query_with_rasterizer_discard),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            private_data: [
                features_ffi.features_vulkan13.map(|s| s.private_data),
                features_ffi.features_private_data.map(|s| s.private_data),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            protected_memory: [
                features_ffi.features_vulkan11.map(|s| s.protected_memory),
                features_ffi.features_protected_memory.map(|s| s.protected_memory),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            provoking_vertex_last: [
                features_ffi
                    .features_provoking_vertex_ext
                    .map(|s| s.provoking_vertex_last),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            rasterization_order_color_attachment_access: [
                features_ffi
                    .features_rasterization_order_attachment_access_ext
                    .map(|s| s.rasterization_order_color_attachment_access),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            rasterization_order_depth_attachment_access: [
                features_ffi
                    .features_rasterization_order_attachment_access_ext
                    .map(|s| s.rasterization_order_depth_attachment_access),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            rasterization_order_stencil_attachment_access: [
                features_ffi
                    .features_rasterization_order_attachment_access_ext
                    .map(|s| s.rasterization_order_stencil_attachment_access),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            ray_query: [features_ffi.features_ray_query_khr.map(|s| s.ray_query)]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            ray_tracing_invocation_reorder: [
                features_ffi
                    .features_ray_tracing_invocation_reorder_nv
                    .map(|s| s.ray_tracing_invocation_reorder),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            ray_tracing_maintenance1: [
                features_ffi
                    .features_ray_tracing_maintenance1_khr
                    .map(|s| s.ray_tracing_maintenance1),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            ray_tracing_motion_blur: [
                features_ffi
                    .features_ray_tracing_motion_blur_nv
                    .map(|s| s.ray_tracing_motion_blur),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            ray_tracing_motion_blur_pipeline_trace_rays_indirect: [
                features_ffi
                    .features_ray_tracing_motion_blur_nv
                    .map(|s| s.ray_tracing_motion_blur_pipeline_trace_rays_indirect),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            ray_tracing_pipeline: [
                features_ffi
                    .features_ray_tracing_pipeline_khr
                    .map(|s| s.ray_tracing_pipeline),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            ray_tracing_pipeline_shader_group_handle_capture_replay: [
                features_ffi
                    .features_ray_tracing_pipeline_khr
                    .map(|s| s.ray_tracing_pipeline_shader_group_handle_capture_replay),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            ray_tracing_pipeline_shader_group_handle_capture_replay_mixed: [
                features_ffi
                    .features_ray_tracing_pipeline_khr
                    .map(|s| {
                        s.ray_tracing_pipeline_shader_group_handle_capture_replay_mixed
                    }),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            ray_tracing_pipeline_trace_rays_indirect: [
                features_ffi
                    .features_ray_tracing_pipeline_khr
                    .map(|s| s.ray_tracing_pipeline_trace_rays_indirect),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            ray_tracing_pipeline_trace_rays_indirect2: [
                features_ffi
                    .features_ray_tracing_maintenance1_khr
                    .map(|s| s.ray_tracing_pipeline_trace_rays_indirect2),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            ray_tracing_position_fetch: [
                features_ffi
                    .features_ray_tracing_position_fetch_khr
                    .map(|s| s.ray_tracing_position_fetch),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            ray_tracing_validation: [
                features_ffi
                    .features_ray_tracing_validation_nv
                    .map(|s| s.ray_tracing_validation),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            ray_traversal_primitive_culling: [
                features_ffi
                    .features_ray_tracing_pipeline_khr
                    .map(|s| s.ray_traversal_primitive_culling),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            rectangular_lines: [
                features_ffi.features_line_rasterization_khr.map(|s| s.rectangular_lines),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            relaxed_line_rasterization: [
                features_ffi
                    .features_relaxed_line_rasterization_img
                    .map(|s| s.relaxed_line_rasterization),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            render_pass_striped: [
                features_ffi
                    .features_render_pass_striped_arm
                    .map(|s| s.render_pass_striped),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            report_address_binding: [
                features_ffi
                    .features_address_binding_report_ext
                    .map(|s| s.report_address_binding),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            representative_fragment_test: [
                features_ffi
                    .features_representative_fragment_test_nv
                    .map(|s| s.representative_fragment_test),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            robust_buffer_access: [
                features_ffi.features_vulkan10.features.robust_buffer_access,
            ]
                .into_iter()
                .next()
                .unwrap_or(0) != 0,
            robust_buffer_access2: [
                features_ffi.features_robustness2_ext.map(|s| s.robust_buffer_access2),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            robust_image_access: [
                features_ffi.features_vulkan13.map(|s| s.robust_image_access),
                features_ffi.features_image_robustness.map(|s| s.robust_image_access),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            robust_image_access2: [
                features_ffi.features_robustness2_ext.map(|s| s.robust_image_access2),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            runtime_descriptor_array: [
                features_ffi.features_vulkan12.map(|s| s.runtime_descriptor_array),
                features_ffi
                    .features_descriptor_indexing
                    .map(|s| s.runtime_descriptor_array),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            sample_rate_shading: [
                features_ffi.features_vulkan10.features.sample_rate_shading,
            ]
                .into_iter()
                .next()
                .unwrap_or(0) != 0,
            sampler2_d_view_of3_d: [
                features_ffi
                    .features_image2_d_view_of3_d_ext
                    .map(|s| s.sampler2_d_view_of3_d),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            sampler_anisotropy: [
                features_ffi.features_vulkan10.features.sampler_anisotropy,
            ]
                .into_iter()
                .next()
                .unwrap_or(0) != 0,
            sampler_filter_minmax: [
                features_ffi.features_vulkan12.map(|s| s.sampler_filter_minmax),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            sampler_mip_lod_bias: [
                features_ffi
                    .features_portability_subset_khr
                    .map(|s| s.sampler_mip_lod_bias),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            sampler_mirror_clamp_to_edge: [
                features_ffi.features_vulkan12.map(|s| s.sampler_mirror_clamp_to_edge),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            sampler_ycbcr_conversion: [
                features_ffi.features_vulkan11.map(|s| s.sampler_ycbcr_conversion),
                features_ffi
                    .features_sampler_ycbcr_conversion
                    .map(|s| s.sampler_ycbcr_conversion),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            scalar_block_layout: [
                features_ffi.features_vulkan12.map(|s| s.scalar_block_layout),
                features_ffi.features_scalar_block_layout.map(|s| s.scalar_block_layout),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            scheduling_controls: [
                features_ffi
                    .features_scheduling_controls_arm
                    .map(|s| s.scheduling_controls),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            screen_buffer_import: [
                features_ffi
                    .features_external_memory_screen_buffer_qnx
                    .map(|s| s.screen_buffer_import),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            selectable_cubic_weights: [
                features_ffi
                    .features_cubic_weights_qcom
                    .map(|s| s.selectable_cubic_weights),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            separate_depth_stencil_layouts: [
                features_ffi.features_vulkan12.map(|s| s.separate_depth_stencil_layouts),
                features_ffi
                    .features_separate_depth_stencil_layouts
                    .map(|s| s.separate_depth_stencil_layouts),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            separate_stencil_mask_ref: [
                features_ffi
                    .features_portability_subset_khr
                    .map(|s| s.separate_stencil_mask_ref),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            shader_buffer_float16_atomic_add: [
                features_ffi
                    .features_shader_atomic_float2_ext
                    .map(|s| s.shader_buffer_float16_atomic_add),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            shader_buffer_float16_atomic_min_max: [
                features_ffi
                    .features_shader_atomic_float2_ext
                    .map(|s| s.shader_buffer_float16_atomic_min_max),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            shader_buffer_float16_atomics: [
                features_ffi
                    .features_shader_atomic_float2_ext
                    .map(|s| s.shader_buffer_float16_atomics),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            shader_buffer_float32_atomic_add: [
                features_ffi
                    .features_shader_atomic_float_ext
                    .map(|s| s.shader_buffer_float32_atomic_add),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            shader_buffer_float32_atomic_min_max: [
                features_ffi
                    .features_shader_atomic_float2_ext
                    .map(|s| s.shader_buffer_float32_atomic_min_max),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            shader_buffer_float32_atomics: [
                features_ffi
                    .features_shader_atomic_float_ext
                    .map(|s| s.shader_buffer_float32_atomics),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            shader_buffer_float64_atomic_add: [
                features_ffi
                    .features_shader_atomic_float_ext
                    .map(|s| s.shader_buffer_float64_atomic_add),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            shader_buffer_float64_atomic_min_max: [
                features_ffi
                    .features_shader_atomic_float2_ext
                    .map(|s| s.shader_buffer_float64_atomic_min_max),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            shader_buffer_float64_atomics: [
                features_ffi
                    .features_shader_atomic_float_ext
                    .map(|s| s.shader_buffer_float64_atomics),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            shader_buffer_int64_atomics: [
                features_ffi.features_vulkan12.map(|s| s.shader_buffer_int64_atomics),
                features_ffi
                    .features_shader_atomic_int64
                    .map(|s| s.shader_buffer_int64_atomics),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            shader_clip_distance: [
                features_ffi.features_vulkan10.features.shader_clip_distance,
            ]
                .into_iter()
                .next()
                .unwrap_or(0) != 0,
            shader_core_builtins: [
                features_ffi
                    .features_shader_core_builtins_arm
                    .map(|s| s.shader_core_builtins),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            shader_cull_distance: [
                features_ffi.features_vulkan10.features.shader_cull_distance,
            ]
                .into_iter()
                .next()
                .unwrap_or(0) != 0,
            shader_demote_to_helper_invocation: [
                features_ffi
                    .features_vulkan13
                    .map(|s| s.shader_demote_to_helper_invocation),
                features_ffi
                    .features_shader_demote_to_helper_invocation
                    .map(|s| s.shader_demote_to_helper_invocation),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            shader_device_clock: [
                features_ffi.features_shader_clock_khr.map(|s| s.shader_device_clock),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            shader_draw_parameters: [
                features_ffi.features_vulkan11.map(|s| s.shader_draw_parameters),
                features_ffi
                    .features_shader_draw_parameters
                    .map(|s| s.shader_draw_parameters),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            shader_early_and_late_fragment_tests: [
                features_ffi
                    .features_shader_early_and_late_fragment_tests_amd
                    .map(|s| s.shader_early_and_late_fragment_tests),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            shader_enqueue: [
                features_ffi.features_shader_enqueue_amdx.map(|s| s.shader_enqueue),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            shader_expect_assume: [
                features_ffi
                    .features_shader_expect_assume_khr
                    .map(|s| s.shader_expect_assume),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            shader_float16: [
                features_ffi.features_vulkan12.map(|s| s.shader_float16),
                features_ffi.features_shader_float16_int8.map(|s| s.shader_float16),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            shader_float16_vector_atomics: [
                features_ffi
                    .features_shader_atomic_float16_vector_nv
                    .map(|s| s.shader_float16_vector_atomics),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            shader_float64: [features_ffi.features_vulkan10.features.shader_float64]
                .into_iter()
                .next()
                .unwrap_or(0) != 0,
            shader_float_controls2: [
                features_ffi
                    .features_shader_float_controls2_khr
                    .map(|s| s.shader_float_controls2),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            shader_image_float32_atomic_add: [
                features_ffi
                    .features_shader_atomic_float_ext
                    .map(|s| s.shader_image_float32_atomic_add),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            shader_image_float32_atomic_min_max: [
                features_ffi
                    .features_shader_atomic_float2_ext
                    .map(|s| s.shader_image_float32_atomic_min_max),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            shader_image_float32_atomics: [
                features_ffi
                    .features_shader_atomic_float_ext
                    .map(|s| s.shader_image_float32_atomics),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            shader_image_gather_extended: [
                features_ffi.features_vulkan10.features.shader_image_gather_extended,
            ]
                .into_iter()
                .next()
                .unwrap_or(0) != 0,
            shader_image_int64_atomics: [
                features_ffi
                    .features_shader_image_atomic_int64_ext
                    .map(|s| s.shader_image_int64_atomics),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            shader_input_attachment_array_dynamic_indexing: [
                features_ffi
                    .features_vulkan12
                    .map(|s| s.shader_input_attachment_array_dynamic_indexing),
                features_ffi
                    .features_descriptor_indexing
                    .map(|s| s.shader_input_attachment_array_dynamic_indexing),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            shader_input_attachment_array_non_uniform_indexing: [
                features_ffi
                    .features_vulkan12
                    .map(|s| s.shader_input_attachment_array_non_uniform_indexing),
                features_ffi
                    .features_descriptor_indexing
                    .map(|s| s.shader_input_attachment_array_non_uniform_indexing),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            shader_int16: [features_ffi.features_vulkan10.features.shader_int16]
                .into_iter()
                .next()
                .unwrap_or(0) != 0,
            shader_int64: [features_ffi.features_vulkan10.features.shader_int64]
                .into_iter()
                .next()
                .unwrap_or(0) != 0,
            shader_int8: [
                features_ffi.features_vulkan12.map(|s| s.shader_int8),
                features_ffi.features_shader_float16_int8.map(|s| s.shader_int8),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            shader_integer_dot_product: [
                features_ffi.features_vulkan13.map(|s| s.shader_integer_dot_product),
                features_ffi
                    .features_shader_integer_dot_product
                    .map(|s| s.shader_integer_dot_product),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            shader_integer_functions2: [
                features_ffi
                    .features_shader_integer_functions2_intel
                    .map(|s| s.shader_integer_functions2),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            shader_maximal_reconvergence: [
                features_ffi
                    .features_shader_maximal_reconvergence_khr
                    .map(|s| s.shader_maximal_reconvergence),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            shader_module_identifier: [
                features_ffi
                    .features_shader_module_identifier_ext
                    .map(|s| s.shader_module_identifier),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            shader_object: [
                features_ffi.features_shader_object_ext.map(|s| s.shader_object),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            shader_output_layer: [
                features_ffi.features_vulkan12.map(|s| s.shader_output_layer),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            shader_output_viewport_index: [
                features_ffi.features_vulkan12.map(|s| s.shader_output_viewport_index),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            shader_quad_control: [
                features_ffi
                    .features_shader_quad_control_khr
                    .map(|s| s.shader_quad_control),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            shader_raw_access_chains: [
                features_ffi
                    .features_raw_access_chains_nv
                    .map(|s| s.shader_raw_access_chains),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            shader_resource_min_lod: [
                features_ffi.features_vulkan10.features.shader_resource_min_lod,
            ]
                .into_iter()
                .next()
                .unwrap_or(0) != 0,
            shader_resource_residency: [
                features_ffi.features_vulkan10.features.shader_resource_residency,
            ]
                .into_iter()
                .next()
                .unwrap_or(0) != 0,
            shader_sample_rate_interpolation_functions: [
                features_ffi
                    .features_portability_subset_khr
                    .map(|s| s.shader_sample_rate_interpolation_functions),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            shader_sampled_image_array_dynamic_indexing: [
                features_ffi
                    .features_vulkan10
                    .features
                    .shader_sampled_image_array_dynamic_indexing,
            ]
                .into_iter()
                .next()
                .unwrap_or(0) != 0,
            shader_sampled_image_array_non_uniform_indexing: [
                features_ffi
                    .features_vulkan12
                    .map(|s| s.shader_sampled_image_array_non_uniform_indexing),
                features_ffi
                    .features_descriptor_indexing
                    .map(|s| s.shader_sampled_image_array_non_uniform_indexing),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            shader_shared_float16_atomic_add: [
                features_ffi
                    .features_shader_atomic_float2_ext
                    .map(|s| s.shader_shared_float16_atomic_add),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            shader_shared_float16_atomic_min_max: [
                features_ffi
                    .features_shader_atomic_float2_ext
                    .map(|s| s.shader_shared_float16_atomic_min_max),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            shader_shared_float16_atomics: [
                features_ffi
                    .features_shader_atomic_float2_ext
                    .map(|s| s.shader_shared_float16_atomics),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            shader_shared_float32_atomic_add: [
                features_ffi
                    .features_shader_atomic_float_ext
                    .map(|s| s.shader_shared_float32_atomic_add),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            shader_shared_float32_atomic_min_max: [
                features_ffi
                    .features_shader_atomic_float2_ext
                    .map(|s| s.shader_shared_float32_atomic_min_max),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            shader_shared_float32_atomics: [
                features_ffi
                    .features_shader_atomic_float_ext
                    .map(|s| s.shader_shared_float32_atomics),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            shader_shared_float64_atomic_add: [
                features_ffi
                    .features_shader_atomic_float_ext
                    .map(|s| s.shader_shared_float64_atomic_add),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            shader_shared_float64_atomic_min_max: [
                features_ffi
                    .features_shader_atomic_float2_ext
                    .map(|s| s.shader_shared_float64_atomic_min_max),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            shader_shared_float64_atomics: [
                features_ffi
                    .features_shader_atomic_float_ext
                    .map(|s| s.shader_shared_float64_atomics),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            shader_shared_int64_atomics: [
                features_ffi.features_vulkan12.map(|s| s.shader_shared_int64_atomics),
                features_ffi
                    .features_shader_atomic_int64
                    .map(|s| s.shader_shared_int64_atomics),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            shader_sm_builtins: [
                features_ffi.features_shader_sm_builtins_nv.map(|s| s.shader_sm_builtins),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            shader_storage_buffer_array_dynamic_indexing: [
                features_ffi
                    .features_vulkan10
                    .features
                    .shader_storage_buffer_array_dynamic_indexing,
            ]
                .into_iter()
                .next()
                .unwrap_or(0) != 0,
            shader_storage_buffer_array_non_uniform_indexing: [
                features_ffi
                    .features_vulkan12
                    .map(|s| s.shader_storage_buffer_array_non_uniform_indexing),
                features_ffi
                    .features_descriptor_indexing
                    .map(|s| s.shader_storage_buffer_array_non_uniform_indexing),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            shader_storage_image_array_dynamic_indexing: [
                features_ffi
                    .features_vulkan10
                    .features
                    .shader_storage_image_array_dynamic_indexing,
            ]
                .into_iter()
                .next()
                .unwrap_or(0) != 0,
            shader_storage_image_array_non_uniform_indexing: [
                features_ffi
                    .features_vulkan12
                    .map(|s| s.shader_storage_image_array_non_uniform_indexing),
                features_ffi
                    .features_descriptor_indexing
                    .map(|s| s.shader_storage_image_array_non_uniform_indexing),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            shader_storage_image_extended_formats: [
                features_ffi
                    .features_vulkan10
                    .features
                    .shader_storage_image_extended_formats,
            ]
                .into_iter()
                .next()
                .unwrap_or(0) != 0,
            shader_storage_image_multisample: [
                features_ffi.features_vulkan10.features.shader_storage_image_multisample,
            ]
                .into_iter()
                .next()
                .unwrap_or(0) != 0,
            shader_storage_image_read_without_format: [
                features_ffi
                    .features_vulkan10
                    .features
                    .shader_storage_image_read_without_format,
            ]
                .into_iter()
                .next()
                .unwrap_or(0) != 0,
            shader_storage_image_write_without_format: [
                features_ffi
                    .features_vulkan10
                    .features
                    .shader_storage_image_write_without_format,
            ]
                .into_iter()
                .next()
                .unwrap_or(0) != 0,
            shader_storage_texel_buffer_array_dynamic_indexing: [
                features_ffi
                    .features_vulkan12
                    .map(|s| s.shader_storage_texel_buffer_array_dynamic_indexing),
                features_ffi
                    .features_descriptor_indexing
                    .map(|s| s.shader_storage_texel_buffer_array_dynamic_indexing),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            shader_storage_texel_buffer_array_non_uniform_indexing: [
                features_ffi
                    .features_vulkan12
                    .map(|s| s.shader_storage_texel_buffer_array_non_uniform_indexing),
                features_ffi
                    .features_descriptor_indexing
                    .map(|s| s.shader_storage_texel_buffer_array_non_uniform_indexing),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            shader_subgroup_clock: [
                features_ffi.features_shader_clock_khr.map(|s| s.shader_subgroup_clock),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            shader_subgroup_extended_types: [
                features_ffi.features_vulkan12.map(|s| s.shader_subgroup_extended_types),
                features_ffi
                    .features_shader_subgroup_extended_types
                    .map(|s| s.shader_subgroup_extended_types),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            shader_subgroup_rotate: [
                features_ffi
                    .features_shader_subgroup_rotate_khr
                    .map(|s| s.shader_subgroup_rotate),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            shader_subgroup_rotate_clustered: [
                features_ffi
                    .features_shader_subgroup_rotate_khr
                    .map(|s| s.shader_subgroup_rotate_clustered),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            shader_subgroup_uniform_control_flow: [
                features_ffi
                    .features_shader_subgroup_uniform_control_flow_khr
                    .map(|s| s.shader_subgroup_uniform_control_flow),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            shader_terminate_invocation: [
                features_ffi.features_vulkan13.map(|s| s.shader_terminate_invocation),
                features_ffi
                    .features_shader_terminate_invocation
                    .map(|s| s.shader_terminate_invocation),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            shader_tessellation_and_geometry_point_size: [
                features_ffi
                    .features_vulkan10
                    .features
                    .shader_tessellation_and_geometry_point_size,
            ]
                .into_iter()
                .next()
                .unwrap_or(0) != 0,
            shader_tile_image_color_read_access: [
                features_ffi
                    .features_shader_tile_image_ext
                    .map(|s| s.shader_tile_image_color_read_access),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            shader_tile_image_depth_read_access: [
                features_ffi
                    .features_shader_tile_image_ext
                    .map(|s| s.shader_tile_image_depth_read_access),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            shader_tile_image_stencil_read_access: [
                features_ffi
                    .features_shader_tile_image_ext
                    .map(|s| s.shader_tile_image_stencil_read_access),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            shader_uniform_buffer_array_dynamic_indexing: [
                features_ffi
                    .features_vulkan10
                    .features
                    .shader_uniform_buffer_array_dynamic_indexing,
            ]
                .into_iter()
                .next()
                .unwrap_or(0) != 0,
            shader_uniform_buffer_array_non_uniform_indexing: [
                features_ffi
                    .features_vulkan12
                    .map(|s| s.shader_uniform_buffer_array_non_uniform_indexing),
                features_ffi
                    .features_descriptor_indexing
                    .map(|s| s.shader_uniform_buffer_array_non_uniform_indexing),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            shader_uniform_texel_buffer_array_dynamic_indexing: [
                features_ffi
                    .features_vulkan12
                    .map(|s| s.shader_uniform_texel_buffer_array_dynamic_indexing),
                features_ffi
                    .features_descriptor_indexing
                    .map(|s| s.shader_uniform_texel_buffer_array_dynamic_indexing),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            shader_uniform_texel_buffer_array_non_uniform_indexing: [
                features_ffi
                    .features_vulkan12
                    .map(|s| s.shader_uniform_texel_buffer_array_non_uniform_indexing),
                features_ffi
                    .features_descriptor_indexing
                    .map(|s| s.shader_uniform_texel_buffer_array_non_uniform_indexing),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            shader_zero_initialize_workgroup_memory: [
                features_ffi
                    .features_vulkan13
                    .map(|s| s.shader_zero_initialize_workgroup_memory),
                features_ffi
                    .features_zero_initialize_workgroup_memory
                    .map(|s| s.shader_zero_initialize_workgroup_memory),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            shading_rate_coarse_sample_order: [
                features_ffi
                    .features_shading_rate_image_nv
                    .map(|s| s.shading_rate_coarse_sample_order),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            shading_rate_image: [
                features_ffi.features_shading_rate_image_nv.map(|s| s.shading_rate_image),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            smooth_lines: [
                features_ffi.features_line_rasterization_khr.map(|s| s.smooth_lines),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            sparse_binding: [features_ffi.features_vulkan10.features.sparse_binding]
                .into_iter()
                .next()
                .unwrap_or(0) != 0,
            sparse_image_float32_atomic_add: [
                features_ffi
                    .features_shader_atomic_float_ext
                    .map(|s| s.sparse_image_float32_atomic_add),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            sparse_image_float32_atomic_min_max: [
                features_ffi
                    .features_shader_atomic_float2_ext
                    .map(|s| s.sparse_image_float32_atomic_min_max),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            sparse_image_float32_atomics: [
                features_ffi
                    .features_shader_atomic_float_ext
                    .map(|s| s.sparse_image_float32_atomics),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            sparse_image_int64_atomics: [
                features_ffi
                    .features_shader_image_atomic_int64_ext
                    .map(|s| s.sparse_image_int64_atomics),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            sparse_residency16_samples: [
                features_ffi.features_vulkan10.features.sparse_residency16_samples,
            ]
                .into_iter()
                .next()
                .unwrap_or(0) != 0,
            sparse_residency2_samples: [
                features_ffi.features_vulkan10.features.sparse_residency2_samples,
            ]
                .into_iter()
                .next()
                .unwrap_or(0) != 0,
            sparse_residency4_samples: [
                features_ffi.features_vulkan10.features.sparse_residency4_samples,
            ]
                .into_iter()
                .next()
                .unwrap_or(0) != 0,
            sparse_residency8_samples: [
                features_ffi.features_vulkan10.features.sparse_residency8_samples,
            ]
                .into_iter()
                .next()
                .unwrap_or(0) != 0,
            sparse_residency_aliased: [
                features_ffi.features_vulkan10.features.sparse_residency_aliased,
            ]
                .into_iter()
                .next()
                .unwrap_or(0) != 0,
            sparse_residency_buffer: [
                features_ffi.features_vulkan10.features.sparse_residency_buffer,
            ]
                .into_iter()
                .next()
                .unwrap_or(0) != 0,
            sparse_residency_image2_d: [
                features_ffi.features_vulkan10.features.sparse_residency_image2_d,
            ]
                .into_iter()
                .next()
                .unwrap_or(0) != 0,
            sparse_residency_image3_d: [
                features_ffi.features_vulkan10.features.sparse_residency_image3_d,
            ]
                .into_iter()
                .next()
                .unwrap_or(0) != 0,
            stippled_bresenham_lines: [
                features_ffi
                    .features_line_rasterization_khr
                    .map(|s| s.stippled_bresenham_lines),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            stippled_rectangular_lines: [
                features_ffi
                    .features_line_rasterization_khr
                    .map(|s| s.stippled_rectangular_lines),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            stippled_smooth_lines: [
                features_ffi
                    .features_line_rasterization_khr
                    .map(|s| s.stippled_smooth_lines),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            storage_buffer16_bit_access: [
                features_ffi.features_vulkan11.map(|s| s.storage_buffer16_bit_access),
                features_ffi
                    .features_16bit_storage
                    .map(|s| s.storage_buffer16_bit_access),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            storage_buffer8_bit_access: [
                features_ffi.features_vulkan12.map(|s| s.storage_buffer8_bit_access),
                features_ffi.features_8bit_storage.map(|s| s.storage_buffer8_bit_access),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            storage_input_output16: [
                features_ffi.features_vulkan11.map(|s| s.storage_input_output16),
                features_ffi.features_16bit_storage.map(|s| s.storage_input_output16),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            storage_push_constant16: [
                features_ffi.features_vulkan11.map(|s| s.storage_push_constant16),
                features_ffi.features_16bit_storage.map(|s| s.storage_push_constant16),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            storage_push_constant8: [
                features_ffi.features_vulkan12.map(|s| s.storage_push_constant8),
                features_ffi.features_8bit_storage.map(|s| s.storage_push_constant8),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            subgroup_broadcast_dynamic_id: [
                features_ffi.features_vulkan12.map(|s| s.subgroup_broadcast_dynamic_id),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            subgroup_size_control: [
                features_ffi.features_vulkan13.map(|s| s.subgroup_size_control),
                features_ffi
                    .features_subgroup_size_control
                    .map(|s| s.subgroup_size_control),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            subpass_merge_feedback: [
                features_ffi
                    .features_subpass_merge_feedback_ext
                    .map(|s| s.subpass_merge_feedback),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            subpass_shading: [
                features_ffi.features_subpass_shading_huawei.map(|s| s.subpass_shading),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            supersample_fragment_shading_rates: [
                features_ffi
                    .features_fragment_shading_rate_enums_nv
                    .map(|s| s.supersample_fragment_shading_rates),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            swapchain_maintenance1: [
                features_ffi
                    .features_swapchain_maintenance1_ext
                    .map(|s| s.swapchain_maintenance1),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            synchronization2: [
                features_ffi.features_vulkan13.map(|s| s.synchronization2),
                features_ffi.features_synchronization2.map(|s| s.synchronization2),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            task_shader: [
                features_ffi.features_mesh_shader_ext.map(|s| s.task_shader),
                features_ffi.features_mesh_shader_nv.map(|s| s.task_shader),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            tessellation_isolines: [
                features_ffi
                    .features_portability_subset_khr
                    .map(|s| s.tessellation_isolines),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            tessellation_point_mode: [
                features_ffi
                    .features_portability_subset_khr
                    .map(|s| s.tessellation_point_mode),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            tessellation_shader: [
                features_ffi.features_vulkan10.features.tessellation_shader,
            ]
                .into_iter()
                .next()
                .unwrap_or(0) != 0,
            texel_buffer_alignment: [
                features_ffi
                    .features_texel_buffer_alignment_ext
                    .map(|s| s.texel_buffer_alignment),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            texture_block_match: [
                features_ffi
                    .features_image_processing_qcom
                    .map(|s| s.texture_block_match),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            texture_block_match2: [
                features_ffi
                    .features_image_processing2_qcom
                    .map(|s| s.texture_block_match2),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            texture_box_filter: [
                features_ffi.features_image_processing_qcom.map(|s| s.texture_box_filter),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            texture_compression_astc_hdr: [
                features_ffi.features_vulkan13.map(|s| s.texture_compression_astc_hdr),
                features_ffi
                    .features_texture_compression_astchdr
                    .map(|s| s.texture_compression_astc_hdr),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            texture_compression_astc_ldr: [
                features_ffi.features_vulkan10.features.texture_compression_astc_ldr,
            ]
                .into_iter()
                .next()
                .unwrap_or(0) != 0,
            texture_compression_bc: [
                features_ffi.features_vulkan10.features.texture_compression_bc,
            ]
                .into_iter()
                .next()
                .unwrap_or(0) != 0,
            texture_compression_etc2: [
                features_ffi.features_vulkan10.features.texture_compression_etc2,
            ]
                .into_iter()
                .next()
                .unwrap_or(0) != 0,
            texture_sample_weighted: [
                features_ffi
                    .features_image_processing_qcom
                    .map(|s| s.texture_sample_weighted),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            tile_properties: [
                features_ffi.features_tile_properties_qcom.map(|s| s.tile_properties),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            timeline_semaphore: [
                features_ffi.features_vulkan12.map(|s| s.timeline_semaphore),
                features_ffi.features_timeline_semaphore.map(|s| s.timeline_semaphore),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            transform_feedback: [
                features_ffi
                    .features_transform_feedback_ext
                    .map(|s| s.transform_feedback),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            transform_feedback_preserves_provoking_vertex: [
                features_ffi
                    .features_provoking_vertex_ext
                    .map(|s| s.transform_feedback_preserves_provoking_vertex),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            triangle_fans: [
                features_ffi.features_portability_subset_khr.map(|s| s.triangle_fans),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            uniform_and_storage_buffer16_bit_access: [
                features_ffi
                    .features_vulkan11
                    .map(|s| s.uniform_and_storage_buffer16_bit_access),
                features_ffi
                    .features_16bit_storage
                    .map(|s| s.uniform_and_storage_buffer16_bit_access),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            uniform_and_storage_buffer8_bit_access: [
                features_ffi
                    .features_vulkan12
                    .map(|s| s.uniform_and_storage_buffer8_bit_access),
                features_ffi
                    .features_8bit_storage
                    .map(|s| s.uniform_and_storage_buffer8_bit_access),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            uniform_buffer_standard_layout: [
                features_ffi.features_vulkan12.map(|s| s.uniform_buffer_standard_layout),
                features_ffi
                    .features_uniform_buffer_standard_layout
                    .map(|s| s.uniform_buffer_standard_layout),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            variable_multisample_rate: [
                features_ffi.features_vulkan10.features.variable_multisample_rate,
            ]
                .into_iter()
                .next()
                .unwrap_or(0) != 0,
            variable_pointers: [
                features_ffi.features_vulkan11.map(|s| s.variable_pointers),
                features_ffi.features_variable_pointers.map(|s| s.variable_pointers),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            variable_pointers_storage_buffer: [
                features_ffi
                    .features_vulkan11
                    .map(|s| s.variable_pointers_storage_buffer),
                features_ffi
                    .features_variable_pointers
                    .map(|s| s.variable_pointers_storage_buffer),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            vertex_attribute_access_beyond_stride: [
                features_ffi
                    .features_portability_subset_khr
                    .map(|s| s.vertex_attribute_access_beyond_stride),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            vertex_attribute_instance_rate_divisor: [
                features_ffi
                    .features_vertex_attribute_divisor_khr
                    .map(|s| s.vertex_attribute_instance_rate_divisor),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            vertex_attribute_instance_rate_zero_divisor: [
                features_ffi
                    .features_vertex_attribute_divisor_khr
                    .map(|s| s.vertex_attribute_instance_rate_zero_divisor),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            vertex_input_dynamic_state: [
                features_ffi
                    .features_vertex_input_dynamic_state_ext
                    .map(|s| s.vertex_input_dynamic_state),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            vertex_pipeline_stores_and_atomics: [
                features_ffi
                    .features_vulkan10
                    .features
                    .vertex_pipeline_stores_and_atomics,
            ]
                .into_iter()
                .next()
                .unwrap_or(0) != 0,
            video_maintenance1: [
                features_ffi
                    .features_video_maintenance1_khr
                    .map(|s| s.video_maintenance1),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            vulkan_memory_model: [
                features_ffi.features_vulkan12.map(|s| s.vulkan_memory_model),
                features_ffi.features_vulkan_memory_model.map(|s| s.vulkan_memory_model),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            vulkan_memory_model_availability_visibility_chains: [
                features_ffi
                    .features_vulkan12
                    .map(|s| s.vulkan_memory_model_availability_visibility_chains),
                features_ffi
                    .features_vulkan_memory_model
                    .map(|s| s.vulkan_memory_model_availability_visibility_chains),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            vulkan_memory_model_device_scope: [
                features_ffi
                    .features_vulkan12
                    .map(|s| s.vulkan_memory_model_device_scope),
                features_ffi
                    .features_vulkan_memory_model
                    .map(|s| s.vulkan_memory_model_device_scope),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            wide_lines: [features_ffi.features_vulkan10.features.wide_lines]
                .into_iter()
                .next()
                .unwrap_or(0) != 0,
            workgroup_memory_explicit_layout: [
                features_ffi
                    .features_workgroup_memory_explicit_layout_khr
                    .map(|s| s.workgroup_memory_explicit_layout),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            workgroup_memory_explicit_layout16_bit_access: [
                features_ffi
                    .features_workgroup_memory_explicit_layout_khr
                    .map(|s| s.workgroup_memory_explicit_layout16_bit_access),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            workgroup_memory_explicit_layout8_bit_access: [
                features_ffi
                    .features_workgroup_memory_explicit_layout_khr
                    .map(|s| s.workgroup_memory_explicit_layout8_bit_access),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            workgroup_memory_explicit_layout_scalar_block_layout: [
                features_ffi
                    .features_workgroup_memory_explicit_layout_khr
                    .map(|s| s.workgroup_memory_explicit_layout_scalar_block_layout),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            ycbcr2plane444_formats: [
                features_ffi
                    .features_ycbcr2_plane444_formats_ext
                    .map(|s| s.ycbcr2plane444_formats),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            ycbcr_degamma: [
                features_ffi.features_ycbcr_degamma_qcom.map(|s| s.ycbcr_degamma),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            ycbcr_image_arrays: [
                features_ffi
                    .features_ycbcr_image_arrays_ext
                    .map(|s| s.ycbcr_image_arrays),
            ]
                .into_iter()
                .flatten()
                .next()
                .unwrap_or(0) != 0,
            _ne: crate::NonExhaustive(()),
        }
    }
}
impl IntoIterator for DeviceFeatures {
    type Item = (&'static str, bool);
    type IntoIter = std::array::IntoIter<Self::Item, 419usize>;
    #[inline]
    fn into_iter(self) -> Self::IntoIter {
        [
            ("accelerationStructure", self.acceleration_structure),
            (
                "accelerationStructureCaptureReplay",
                self.acceleration_structure_capture_replay,
            ),
            (
                "accelerationStructureHostCommands",
                self.acceleration_structure_host_commands,
            ),
            (
                "accelerationStructureIndirectBuild",
                self.acceleration_structure_indirect_build,
            ),
            ("advancedBlendCoherentOperations", self.advanced_blend_coherent_operations),
            ("alphaToOne", self.alpha_to_one),
            ("amigoProfiling", self.amigo_profiling),
            (
                "attachmentFeedbackLoopDynamicState",
                self.attachment_feedback_loop_dynamic_state,
            ),
            ("attachmentFeedbackLoopLayout", self.attachment_feedback_loop_layout),
            ("attachmentFragmentShadingRate", self.attachment_fragment_shading_rate),
            ("borderColorSwizzle", self.border_color_swizzle),
            ("borderColorSwizzleFromImage", self.border_color_swizzle_from_image),
            ("bresenhamLines", self.bresenham_lines),
            ("bufferDeviceAddress", self.buffer_device_address),
            (
                "bufferDeviceAddressCaptureReplay",
                self.buffer_device_address_capture_replay,
            ),
            ("bufferDeviceAddressMultiDevice", self.buffer_device_address_multi_device),
            ("clustercullingShader", self.clusterculling_shader),
            ("colorWriteEnable", self.color_write_enable),
            ("computeDerivativeGroupLinear", self.compute_derivative_group_linear),
            ("computeDerivativeGroupQuads", self.compute_derivative_group_quads),
            ("computeFullSubgroups", self.compute_full_subgroups),
            ("conditionalRendering", self.conditional_rendering),
            ("constantAlphaColorBlendFactors", self.constant_alpha_color_blend_factors),
            ("cooperativeMatrix", self.cooperative_matrix),
            (
                "cooperativeMatrixRobustBufferAccess",
                self.cooperative_matrix_robust_buffer_access,
            ),
            ("cornerSampledImage", self.corner_sampled_image),
            ("coverageReductionMode", self.coverage_reduction_mode),
            ("cubicRangeClamp", self.cubic_range_clamp),
            ("cudaKernelLaunchFeatures", self.cuda_kernel_launch_features),
            ("customBorderColorWithoutFormat", self.custom_border_color_without_format),
            ("customBorderColors", self.custom_border_colors),
            ("decodeModeSharedExponent", self.decode_mode_shared_exponent),
            (
                "dedicatedAllocationImageAliasing",
                self.dedicated_allocation_image_aliasing,
            ),
            ("depthBiasClamp", self.depth_bias_clamp),
            ("depthBiasControl", self.depth_bias_control),
            ("depthBiasExact", self.depth_bias_exact),
            ("depthBounds", self.depth_bounds),
            ("depthClamp", self.depth_clamp),
            ("depthClampZeroOne", self.depth_clamp_zero_one),
            ("depthClipControl", self.depth_clip_control),
            ("depthClipEnable", self.depth_clip_enable),
            (
                "descriptorBindingAccelerationStructureUpdateAfterBind",
                self.descriptor_binding_acceleration_structure_update_after_bind,
            ),
            (
                "descriptorBindingInlineUniformBlockUpdateAfterBind",
                self.descriptor_binding_inline_uniform_block_update_after_bind,
            ),
            ("descriptorBindingPartiallyBound", self.descriptor_binding_partially_bound),
            (
                "descriptorBindingSampledImageUpdateAfterBind",
                self.descriptor_binding_sampled_image_update_after_bind,
            ),
            (
                "descriptorBindingStorageBufferUpdateAfterBind",
                self.descriptor_binding_storage_buffer_update_after_bind,
            ),
            (
                "descriptorBindingStorageImageUpdateAfterBind",
                self.descriptor_binding_storage_image_update_after_bind,
            ),
            (
                "descriptorBindingStorageTexelBufferUpdateAfterBind",
                self.descriptor_binding_storage_texel_buffer_update_after_bind,
            ),
            (
                "descriptorBindingUniformBufferUpdateAfterBind",
                self.descriptor_binding_uniform_buffer_update_after_bind,
            ),
            (
                "descriptorBindingUniformTexelBufferUpdateAfterBind",
                self.descriptor_binding_uniform_texel_buffer_update_after_bind,
            ),
            (
                "descriptorBindingUpdateUnusedWhilePending",
                self.descriptor_binding_update_unused_while_pending,
            ),
            (
                "descriptorBindingVariableDescriptorCount",
                self.descriptor_binding_variable_descriptor_count,
            ),
            ("descriptorBuffer", self.descriptor_buffer),
            ("descriptorBufferCaptureReplay", self.descriptor_buffer_capture_replay),
            (
                "descriptorBufferImageLayoutIgnored",
                self.descriptor_buffer_image_layout_ignored,
            ),
            ("descriptorBufferPushDescriptors", self.descriptor_buffer_push_descriptors),
            ("descriptorIndexing", self.descriptor_indexing),
            ("descriptorPoolOverallocation", self.descriptor_pool_overallocation),
            ("descriptorSetHostMapping", self.descriptor_set_host_mapping),
            ("deviceCoherentMemory", self.device_coherent_memory),
            ("deviceFault", self.device_fault),
            ("deviceFaultVendorBinary", self.device_fault_vendor_binary),
            ("deviceGeneratedCommands", self.device_generated_commands),
            ("deviceGeneratedCompute", self.device_generated_compute),
            (
                "deviceGeneratedComputeCaptureReplay",
                self.device_generated_compute_capture_replay,
            ),
            ("deviceGeneratedComputePipelines", self.device_generated_compute_pipelines),
            ("deviceMemoryReport", self.device_memory_report),
            ("diagnosticsConfig", self.diagnostics_config),
            ("displacementMicromap", self.displacement_micromap),
            ("drawIndirectCount", self.draw_indirect_count),
            ("drawIndirectFirstInstance", self.draw_indirect_first_instance),
            ("dualSrcBlend", self.dual_src_blend),
            ("dynamicPipelineLayout", self.dynamic_pipeline_layout),
            ("dynamicRendering", self.dynamic_rendering),
            ("dynamicRenderingLocalRead", self.dynamic_rendering_local_read),
            (
                "dynamicRenderingUnusedAttachments",
                self.dynamic_rendering_unused_attachments,
            ),
            ("events", self.events),
            ("exclusiveScissor", self.exclusive_scissor),
            ("extendedDynamicState", self.extended_dynamic_state),
            ("extendedDynamicState2", self.extended_dynamic_state2),
            ("extendedDynamicState2LogicOp", self.extended_dynamic_state2_logic_op),
            (
                "extendedDynamicState2PatchControlPoints",
                self.extended_dynamic_state2_patch_control_points,
            ),
            (
                "extendedDynamicState3AlphaToCoverageEnable",
                self.extended_dynamic_state3_alpha_to_coverage_enable,
            ),
            (
                "extendedDynamicState3AlphaToOneEnable",
                self.extended_dynamic_state3_alpha_to_one_enable,
            ),
            (
                "extendedDynamicState3ColorBlendAdvanced",
                self.extended_dynamic_state3_color_blend_advanced,
            ),
            (
                "extendedDynamicState3ColorBlendEnable",
                self.extended_dynamic_state3_color_blend_enable,
            ),
            (
                "extendedDynamicState3ColorBlendEquation",
                self.extended_dynamic_state3_color_blend_equation,
            ),
            (
                "extendedDynamicState3ColorWriteMask",
                self.extended_dynamic_state3_color_write_mask,
            ),
            (
                "extendedDynamicState3ConservativeRasterizationMode",
                self.extended_dynamic_state3_conservative_rasterization_mode,
            ),
            (
                "extendedDynamicState3CoverageModulationMode",
                self.extended_dynamic_state3_coverage_modulation_mode,
            ),
            (
                "extendedDynamicState3CoverageModulationTable",
                self.extended_dynamic_state3_coverage_modulation_table,
            ),
            (
                "extendedDynamicState3CoverageModulationTableEnable",
                self.extended_dynamic_state3_coverage_modulation_table_enable,
            ),
            (
                "extendedDynamicState3CoverageReductionMode",
                self.extended_dynamic_state3_coverage_reduction_mode,
            ),
            (
                "extendedDynamicState3CoverageToColorEnable",
                self.extended_dynamic_state3_coverage_to_color_enable,
            ),
            (
                "extendedDynamicState3CoverageToColorLocation",
                self.extended_dynamic_state3_coverage_to_color_location,
            ),
            (
                "extendedDynamicState3DepthClampEnable",
                self.extended_dynamic_state3_depth_clamp_enable,
            ),
            (
                "extendedDynamicState3DepthClipEnable",
                self.extended_dynamic_state3_depth_clip_enable,
            ),
            (
                "extendedDynamicState3DepthClipNegativeOneToOne",
                self.extended_dynamic_state3_depth_clip_negative_one_to_one,
            ),
            (
                "extendedDynamicState3ExtraPrimitiveOverestimationSize",
                self.extended_dynamic_state3_extra_primitive_overestimation_size,
            ),
            (
                "extendedDynamicState3LineRasterizationMode",
                self.extended_dynamic_state3_line_rasterization_mode,
            ),
            (
                "extendedDynamicState3LineStippleEnable",
                self.extended_dynamic_state3_line_stipple_enable,
            ),
            (
                "extendedDynamicState3LogicOpEnable",
                self.extended_dynamic_state3_logic_op_enable,
            ),
            (
                "extendedDynamicState3PolygonMode",
                self.extended_dynamic_state3_polygon_mode,
            ),
            (
                "extendedDynamicState3ProvokingVertexMode",
                self.extended_dynamic_state3_provoking_vertex_mode,
            ),
            (
                "extendedDynamicState3RasterizationSamples",
                self.extended_dynamic_state3_rasterization_samples,
            ),
            (
                "extendedDynamicState3RasterizationStream",
                self.extended_dynamic_state3_rasterization_stream,
            ),
            (
                "extendedDynamicState3RepresentativeFragmentTestEnable",
                self.extended_dynamic_state3_representative_fragment_test_enable,
            ),
            (
                "extendedDynamicState3SampleLocationsEnable",
                self.extended_dynamic_state3_sample_locations_enable,
            ),
            (
                "extendedDynamicState3SampleMask",
                self.extended_dynamic_state3_sample_mask,
            ),
            (
                "extendedDynamicState3ShadingRateImageEnable",
                self.extended_dynamic_state3_shading_rate_image_enable,
            ),
            (
                "extendedDynamicState3TessellationDomainOrigin",
                self.extended_dynamic_state3_tessellation_domain_origin,
            ),
            (
                "extendedDynamicState3ViewportSwizzle",
                self.extended_dynamic_state3_viewport_swizzle,
            ),
            (
                "extendedDynamicState3ViewportWScalingEnable",
                self.extended_dynamic_state3_viewport_w_scaling_enable,
            ),
            ("extendedSparseAddressSpace", self.extended_sparse_address_space),
            ("externalFormatResolve", self.external_format_resolve),
            ("externalMemoryRDMA", self.external_memory_rdma),
            ("fillModeNonSolid", self.fill_mode_non_solid),
            ("floatRepresentation", self.float_representation),
            ("formatA4B4G4R4", self.format_a4b4g4r4),
            ("formatA4R4G4B4", self.format_a4r4g4b4),
            (
                "formatRgba10x6WithoutYCbCrSampler",
                self.format_rgba10x6_without_y_cb_cr_sampler,
            ),
            ("fragmentDensityMap", self.fragment_density_map),
            ("fragmentDensityMapDeferred", self.fragment_density_map_deferred),
            ("fragmentDensityMapDynamic", self.fragment_density_map_dynamic),
            (
                "fragmentDensityMapNonSubsampledImages",
                self.fragment_density_map_non_subsampled_images,
            ),
            ("fragmentDensityMapOffset", self.fragment_density_map_offset),
            ("fragmentShaderBarycentric", self.fragment_shader_barycentric),
            ("fragmentShaderPixelInterlock", self.fragment_shader_pixel_interlock),
            ("fragmentShaderSampleInterlock", self.fragment_shader_sample_interlock),
            (
                "fragmentShaderShadingRateInterlock",
                self.fragment_shader_shading_rate_interlock,
            ),
            ("fragmentShadingRateEnums", self.fragment_shading_rate_enums),
            ("fragmentStoresAndAtomics", self.fragment_stores_and_atomics),
            ("frameBoundary", self.frame_boundary),
            ("fullDrawIndexUint32", self.full_draw_index_uint32),
            ("geometryShader", self.geometry_shader),
            ("geometryStreams", self.geometry_streams),
            ("globalPriorityQuery", self.global_priority_query),
            ("graphicsPipelineLibrary", self.graphics_pipeline_library),
            ("hostImageCopy", self.host_image_copy),
            ("hostQueryReset", self.host_query_reset),
            ("image2DViewOf3D", self.image2_d_view_of3_d),
            ("imageCompressionControl", self.image_compression_control),
            (
                "imageCompressionControlSwapchain",
                self.image_compression_control_swapchain,
            ),
            ("imageCubeArray", self.image_cube_array),
            ("imageFootprint", self.image_footprint),
            ("imageSlicedViewOf3D", self.image_sliced_view_of3_d),
            ("imageView2DOn3DImage", self.image_view2_d_on3_d_image),
            ("imageViewFormatReinterpretation", self.image_view_format_reinterpretation),
            ("imageViewFormatSwizzle", self.image_view_format_swizzle),
            ("imagelessFramebuffer", self.imageless_framebuffer),
            ("independentBlend", self.independent_blend),
            ("indexTypeUint8", self.index_type_uint8),
            ("indirectCopy", self.indirect_copy),
            ("inheritedConditionalRendering", self.inherited_conditional_rendering),
            ("inheritedQueries", self.inherited_queries),
            ("inheritedViewportScissor2D", self.inherited_viewport_scissor2_d),
            ("inlineUniformBlock", self.inline_uniform_block),
            ("invocationMask", self.invocation_mask),
            ("largePoints", self.large_points),
            (
                "leastRepresentableValueForceUnormRepresentation",
                self.least_representable_value_force_unorm_representation,
            ),
            ("legacyDithering", self.legacy_dithering),
            ("linearColorAttachment", self.linear_color_attachment),
            ("logicOp", self.logic_op),
            ("maintenance4", self.maintenance4),
            ("maintenance5", self.maintenance5),
            ("maintenance6", self.maintenance6),
            ("memoryDecompression", self.memory_decompression),
            ("memoryMapPlaced", self.memory_map_placed),
            ("memoryMapRangePlaced", self.memory_map_range_placed),
            ("memoryPriority", self.memory_priority),
            ("memoryUnmapReserve", self.memory_unmap_reserve),
            ("meshShader", self.mesh_shader),
            ("meshShaderQueries", self.mesh_shader_queries),
            ("micromap", self.micromap),
            ("micromapCaptureReplay", self.micromap_capture_replay),
            ("micromapHostCommands", self.micromap_host_commands),
            ("minLod", self.min_lod),
            ("multiDraw", self.multi_draw),
            ("multiDrawIndirect", self.multi_draw_indirect),
            ("multiViewport", self.multi_viewport),
            ("multisampleArrayImage", self.multisample_array_image),
            (
                "multisampledRenderToSingleSampled",
                self.multisampled_render_to_single_sampled,
            ),
            ("multiview", self.multiview),
            ("multiviewClusterCullingShader", self.multiview_cluster_culling_shader),
            ("multiviewGeometryShader", self.multiview_geometry_shader),
            ("multiviewMeshShader", self.multiview_mesh_shader),
            ("multiviewPerViewRenderAreas", self.multiview_per_view_render_areas),
            ("multiviewPerViewViewports", self.multiview_per_view_viewports),
            ("multiviewTessellationShader", self.multiview_tessellation_shader),
            ("mutableComparisonSamplers", self.mutable_comparison_samplers),
            ("mutableDescriptorType", self.mutable_descriptor_type),
            ("nestedCommandBuffer", self.nested_command_buffer),
            ("nestedCommandBufferRendering", self.nested_command_buffer_rendering),
            (
                "nestedCommandBufferSimultaneousUse",
                self.nested_command_buffer_simultaneous_use,
            ),
            (
                "noInvocationFragmentShadingRates",
                self.no_invocation_fragment_shading_rates,
            ),
            ("nonSeamlessCubeMap", self.non_seamless_cube_map),
            ("nullDescriptor", self.null_descriptor),
            ("occlusionQueryPrecise", self.occlusion_query_precise),
            ("opticalFlow", self.optical_flow),
            ("pageableDeviceLocalMemory", self.pageable_device_local_memory),
            ("perStageDescriptorSet", self.per_stage_descriptor_set),
            (
                "performanceCounterMultipleQueryPools",
                self.performance_counter_multiple_query_pools,
            ),
            ("performanceCounterQueryPools", self.performance_counter_query_pools),
            ("pipelineCreationCacheControl", self.pipeline_creation_cache_control),
            ("pipelineExecutableInfo", self.pipeline_executable_info),
            ("pipelineFragmentShadingRate", self.pipeline_fragment_shading_rate),
            ("pipelineLibraryGroupHandles", self.pipeline_library_group_handles),
            ("pipelinePropertiesIdentifier", self.pipeline_properties_identifier),
            ("pipelineProtectedAccess", self.pipeline_protected_access),
            ("pipelineRobustness", self.pipeline_robustness),
            ("pipelineStatisticsQuery", self.pipeline_statistics_query),
            ("pointPolygons", self.point_polygons),
            ("presentBarrier", self.present_barrier),
            ("presentId", self.present_id),
            ("presentWait", self.present_wait),
            ("primitiveFragmentShadingRate", self.primitive_fragment_shading_rate),
            (
                "primitiveFragmentShadingRateMeshShader",
                self.primitive_fragment_shading_rate_mesh_shader,
            ),
            ("primitiveTopologyListRestart", self.primitive_topology_list_restart),
            (
                "primitiveTopologyPatchListRestart",
                self.primitive_topology_patch_list_restart,
            ),
            ("primitivesGeneratedQuery", self.primitives_generated_query),
            (
                "primitivesGeneratedQueryWithNonZeroStreams",
                self.primitives_generated_query_with_non_zero_streams,
            ),
            (
                "primitivesGeneratedQueryWithRasterizerDiscard",
                self.primitives_generated_query_with_rasterizer_discard,
            ),
            ("privateData", self.private_data),
            ("protectedMemory", self.protected_memory),
            ("provokingVertexLast", self.provoking_vertex_last),
            (
                "rasterizationOrderColorAttachmentAccess",
                self.rasterization_order_color_attachment_access,
            ),
            (
                "rasterizationOrderDepthAttachmentAccess",
                self.rasterization_order_depth_attachment_access,
            ),
            (
                "rasterizationOrderStencilAttachmentAccess",
                self.rasterization_order_stencil_attachment_access,
            ),
            ("rayQuery", self.ray_query),
            ("rayTracingInvocationReorder", self.ray_tracing_invocation_reorder),
            ("rayTracingMaintenance1", self.ray_tracing_maintenance1),
            ("rayTracingMotionBlur", self.ray_tracing_motion_blur),
            (
                "rayTracingMotionBlurPipelineTraceRaysIndirect",
                self.ray_tracing_motion_blur_pipeline_trace_rays_indirect,
            ),
            ("rayTracingPipeline", self.ray_tracing_pipeline),
            (
                "rayTracingPipelineShaderGroupHandleCaptureReplay",
                self.ray_tracing_pipeline_shader_group_handle_capture_replay,
            ),
            (
                "rayTracingPipelineShaderGroupHandleCaptureReplayMixed",
                self.ray_tracing_pipeline_shader_group_handle_capture_replay_mixed,
            ),
            (
                "rayTracingPipelineTraceRaysIndirect",
                self.ray_tracing_pipeline_trace_rays_indirect,
            ),
            (
                "rayTracingPipelineTraceRaysIndirect2",
                self.ray_tracing_pipeline_trace_rays_indirect2,
            ),
            ("rayTracingPositionFetch", self.ray_tracing_position_fetch),
            ("rayTracingValidation", self.ray_tracing_validation),
            ("rayTraversalPrimitiveCulling", self.ray_traversal_primitive_culling),
            ("rectangularLines", self.rectangular_lines),
            ("relaxedLineRasterization", self.relaxed_line_rasterization),
            ("renderPassStriped", self.render_pass_striped),
            ("reportAddressBinding", self.report_address_binding),
            ("representativeFragmentTest", self.representative_fragment_test),
            ("robustBufferAccess", self.robust_buffer_access),
            ("robustBufferAccess2", self.robust_buffer_access2),
            ("robustImageAccess", self.robust_image_access),
            ("robustImageAccess2", self.robust_image_access2),
            ("runtimeDescriptorArray", self.runtime_descriptor_array),
            ("sampleRateShading", self.sample_rate_shading),
            ("sampler2DViewOf3D", self.sampler2_d_view_of3_d),
            ("samplerAnisotropy", self.sampler_anisotropy),
            ("samplerFilterMinmax", self.sampler_filter_minmax),
            ("samplerMipLodBias", self.sampler_mip_lod_bias),
            ("samplerMirrorClampToEdge", self.sampler_mirror_clamp_to_edge),
            ("samplerYcbcrConversion", self.sampler_ycbcr_conversion),
            ("scalarBlockLayout", self.scalar_block_layout),
            ("schedulingControls", self.scheduling_controls),
            ("screenBufferImport", self.screen_buffer_import),
            ("selectableCubicWeights", self.selectable_cubic_weights),
            ("separateDepthStencilLayouts", self.separate_depth_stencil_layouts),
            ("separateStencilMaskRef", self.separate_stencil_mask_ref),
            ("shaderBufferFloat16AtomicAdd", self.shader_buffer_float16_atomic_add),
            (
                "shaderBufferFloat16AtomicMinMax",
                self.shader_buffer_float16_atomic_min_max,
            ),
            ("shaderBufferFloat16Atomics", self.shader_buffer_float16_atomics),
            ("shaderBufferFloat32AtomicAdd", self.shader_buffer_float32_atomic_add),
            (
                "shaderBufferFloat32AtomicMinMax",
                self.shader_buffer_float32_atomic_min_max,
            ),
            ("shaderBufferFloat32Atomics", self.shader_buffer_float32_atomics),
            ("shaderBufferFloat64AtomicAdd", self.shader_buffer_float64_atomic_add),
            (
                "shaderBufferFloat64AtomicMinMax",
                self.shader_buffer_float64_atomic_min_max,
            ),
            ("shaderBufferFloat64Atomics", self.shader_buffer_float64_atomics),
            ("shaderBufferInt64Atomics", self.shader_buffer_int64_atomics),
            ("shaderClipDistance", self.shader_clip_distance),
            ("shaderCoreBuiltins", self.shader_core_builtins),
            ("shaderCullDistance", self.shader_cull_distance),
            ("shaderDemoteToHelperInvocation", self.shader_demote_to_helper_invocation),
            ("shaderDeviceClock", self.shader_device_clock),
            ("shaderDrawParameters", self.shader_draw_parameters),
            (
                "shaderEarlyAndLateFragmentTests",
                self.shader_early_and_late_fragment_tests,
            ),
            ("shaderEnqueue", self.shader_enqueue),
            ("shaderExpectAssume", self.shader_expect_assume),
            ("shaderFloat16", self.shader_float16),
            ("shaderFloat16VectorAtomics", self.shader_float16_vector_atomics),
            ("shaderFloat64", self.shader_float64),
            ("shaderFloatControls2", self.shader_float_controls2),
            ("shaderImageFloat32AtomicAdd", self.shader_image_float32_atomic_add),
            ("shaderImageFloat32AtomicMinMax", self.shader_image_float32_atomic_min_max),
            ("shaderImageFloat32Atomics", self.shader_image_float32_atomics),
            ("shaderImageGatherExtended", self.shader_image_gather_extended),
            ("shaderImageInt64Atomics", self.shader_image_int64_atomics),
            (
                "shaderInputAttachmentArrayDynamicIndexing",
                self.shader_input_attachment_array_dynamic_indexing,
            ),
            (
                "shaderInputAttachmentArrayNonUniformIndexing",
                self.shader_input_attachment_array_non_uniform_indexing,
            ),
            ("shaderInt16", self.shader_int16),
            ("shaderInt64", self.shader_int64),
            ("shaderInt8", self.shader_int8),
            ("shaderIntegerDotProduct", self.shader_integer_dot_product),
            ("shaderIntegerFunctions2", self.shader_integer_functions2),
            ("shaderMaximalReconvergence", self.shader_maximal_reconvergence),
            ("shaderModuleIdentifier", self.shader_module_identifier),
            ("shaderObject", self.shader_object),
            ("shaderOutputLayer", self.shader_output_layer),
            ("shaderOutputViewportIndex", self.shader_output_viewport_index),
            ("shaderQuadControl", self.shader_quad_control),
            ("shaderRawAccessChains", self.shader_raw_access_chains),
            ("shaderResourceMinLod", self.shader_resource_min_lod),
            ("shaderResourceResidency", self.shader_resource_residency),
            (
                "shaderSampleRateInterpolationFunctions",
                self.shader_sample_rate_interpolation_functions,
            ),
            (
                "shaderSampledImageArrayDynamicIndexing",
                self.shader_sampled_image_array_dynamic_indexing,
            ),
            (
                "shaderSampledImageArrayNonUniformIndexing",
                self.shader_sampled_image_array_non_uniform_indexing,
            ),
            ("shaderSharedFloat16AtomicAdd", self.shader_shared_float16_atomic_add),
            (
                "shaderSharedFloat16AtomicMinMax",
                self.shader_shared_float16_atomic_min_max,
            ),
            ("shaderSharedFloat16Atomics", self.shader_shared_float16_atomics),
            ("shaderSharedFloat32AtomicAdd", self.shader_shared_float32_atomic_add),
            (
                "shaderSharedFloat32AtomicMinMax",
                self.shader_shared_float32_atomic_min_max,
            ),
            ("shaderSharedFloat32Atomics", self.shader_shared_float32_atomics),
            ("shaderSharedFloat64AtomicAdd", self.shader_shared_float64_atomic_add),
            (
                "shaderSharedFloat64AtomicMinMax",
                self.shader_shared_float64_atomic_min_max,
            ),
            ("shaderSharedFloat64Atomics", self.shader_shared_float64_atomics),
            ("shaderSharedInt64Atomics", self.shader_shared_int64_atomics),
            ("shaderSMBuiltins", self.shader_sm_builtins),
            (
                "shaderStorageBufferArrayDynamicIndexing",
                self.shader_storage_buffer_array_dynamic_indexing,
            ),
            (
                "shaderStorageBufferArrayNonUniformIndexing",
                self.shader_storage_buffer_array_non_uniform_indexing,
            ),
            (
                "shaderStorageImageArrayDynamicIndexing",
                self.shader_storage_image_array_dynamic_indexing,
            ),
            (
                "shaderStorageImageArrayNonUniformIndexing",
                self.shader_storage_image_array_non_uniform_indexing,
            ),
            (
                "shaderStorageImageExtendedFormats",
                self.shader_storage_image_extended_formats,
            ),
            ("shaderStorageImageMultisample", self.shader_storage_image_multisample),
            (
                "shaderStorageImageReadWithoutFormat",
                self.shader_storage_image_read_without_format,
            ),
            (
                "shaderStorageImageWriteWithoutFormat",
                self.shader_storage_image_write_without_format,
            ),
            (
                "shaderStorageTexelBufferArrayDynamicIndexing",
                self.shader_storage_texel_buffer_array_dynamic_indexing,
            ),
            (
                "shaderStorageTexelBufferArrayNonUniformIndexing",
                self.shader_storage_texel_buffer_array_non_uniform_indexing,
            ),
            ("shaderSubgroupClock", self.shader_subgroup_clock),
            ("shaderSubgroupExtendedTypes", self.shader_subgroup_extended_types),
            ("shaderSubgroupRotate", self.shader_subgroup_rotate),
            ("shaderSubgroupRotateClustered", self.shader_subgroup_rotate_clustered),
            (
                "shaderSubgroupUniformControlFlow",
                self.shader_subgroup_uniform_control_flow,
            ),
            ("shaderTerminateInvocation", self.shader_terminate_invocation),
            (
                "shaderTessellationAndGeometryPointSize",
                self.shader_tessellation_and_geometry_point_size,
            ),
            ("shaderTileImageColorReadAccess", self.shader_tile_image_color_read_access),
            ("shaderTileImageDepthReadAccess", self.shader_tile_image_depth_read_access),
            (
                "shaderTileImageStencilReadAccess",
                self.shader_tile_image_stencil_read_access,
            ),
            (
                "shaderUniformBufferArrayDynamicIndexing",
                self.shader_uniform_buffer_array_dynamic_indexing,
            ),
            (
                "shaderUniformBufferArrayNonUniformIndexing",
                self.shader_uniform_buffer_array_non_uniform_indexing,
            ),
            (
                "shaderUniformTexelBufferArrayDynamicIndexing",
                self.shader_uniform_texel_buffer_array_dynamic_indexing,
            ),
            (
                "shaderUniformTexelBufferArrayNonUniformIndexing",
                self.shader_uniform_texel_buffer_array_non_uniform_indexing,
            ),
            (
                "shaderZeroInitializeWorkgroupMemory",
                self.shader_zero_initialize_workgroup_memory,
            ),
            ("shadingRateCoarseSampleOrder", self.shading_rate_coarse_sample_order),
            ("shadingRateImage", self.shading_rate_image),
            ("smoothLines", self.smooth_lines),
            ("sparseBinding", self.sparse_binding),
            ("sparseImageFloat32AtomicAdd", self.sparse_image_float32_atomic_add),
            ("sparseImageFloat32AtomicMinMax", self.sparse_image_float32_atomic_min_max),
            ("sparseImageFloat32Atomics", self.sparse_image_float32_atomics),
            ("sparseImageInt64Atomics", self.sparse_image_int64_atomics),
            ("sparseResidency16Samples", self.sparse_residency16_samples),
            ("sparseResidency2Samples", self.sparse_residency2_samples),
            ("sparseResidency4Samples", self.sparse_residency4_samples),
            ("sparseResidency8Samples", self.sparse_residency8_samples),
            ("sparseResidencyAliased", self.sparse_residency_aliased),
            ("sparseResidencyBuffer", self.sparse_residency_buffer),
            ("sparseResidencyImage2D", self.sparse_residency_image2_d),
            ("sparseResidencyImage3D", self.sparse_residency_image3_d),
            ("stippledBresenhamLines", self.stippled_bresenham_lines),
            ("stippledRectangularLines", self.stippled_rectangular_lines),
            ("stippledSmoothLines", self.stippled_smooth_lines),
            ("storageBuffer16BitAccess", self.storage_buffer16_bit_access),
            ("storageBuffer8BitAccess", self.storage_buffer8_bit_access),
            ("storageInputOutput16", self.storage_input_output16),
            ("storagePushConstant16", self.storage_push_constant16),
            ("storagePushConstant8", self.storage_push_constant8),
            ("subgroupBroadcastDynamicId", self.subgroup_broadcast_dynamic_id),
            ("subgroupSizeControl", self.subgroup_size_control),
            ("subpassMergeFeedback", self.subpass_merge_feedback),
            ("subpassShading", self.subpass_shading),
            ("supersampleFragmentShadingRates", self.supersample_fragment_shading_rates),
            ("swapchainMaintenance1", self.swapchain_maintenance1),
            ("synchronization2", self.synchronization2),
            ("taskShader", self.task_shader),
            ("tessellationIsolines", self.tessellation_isolines),
            ("tessellationPointMode", self.tessellation_point_mode),
            ("tessellationShader", self.tessellation_shader),
            ("texelBufferAlignment", self.texel_buffer_alignment),
            ("textureBlockMatch", self.texture_block_match),
            ("textureBlockMatch2", self.texture_block_match2),
            ("textureBoxFilter", self.texture_box_filter),
            ("textureCompressionASTC_HDR", self.texture_compression_astc_hdr),
            ("textureCompressionASTC_LDR", self.texture_compression_astc_ldr),
            ("textureCompressionBC", self.texture_compression_bc),
            ("textureCompressionETC2", self.texture_compression_etc2),
            ("textureSampleWeighted", self.texture_sample_weighted),
            ("tileProperties", self.tile_properties),
            ("timelineSemaphore", self.timeline_semaphore),
            ("transformFeedback", self.transform_feedback),
            (
                "transformFeedbackPreservesProvokingVertex",
                self.transform_feedback_preserves_provoking_vertex,
            ),
            ("triangleFans", self.triangle_fans),
            (
                "uniformAndStorageBuffer16BitAccess",
                self.uniform_and_storage_buffer16_bit_access,
            ),
            (
                "uniformAndStorageBuffer8BitAccess",
                self.uniform_and_storage_buffer8_bit_access,
            ),
            ("uniformBufferStandardLayout", self.uniform_buffer_standard_layout),
            ("variableMultisampleRate", self.variable_multisample_rate),
            ("variablePointers", self.variable_pointers),
            ("variablePointersStorageBuffer", self.variable_pointers_storage_buffer),
            (
                "vertexAttributeAccessBeyondStride",
                self.vertex_attribute_access_beyond_stride,
            ),
            (
                "vertexAttributeInstanceRateDivisor",
                self.vertex_attribute_instance_rate_divisor,
            ),
            (
                "vertexAttributeInstanceRateZeroDivisor",
                self.vertex_attribute_instance_rate_zero_divisor,
            ),
            ("vertexInputDynamicState", self.vertex_input_dynamic_state),
            ("vertexPipelineStoresAndAtomics", self.vertex_pipeline_stores_and_atomics),
            ("videoMaintenance1", self.video_maintenance1),
            ("vulkanMemoryModel", self.vulkan_memory_model),
            (
                "vulkanMemoryModelAvailabilityVisibilityChains",
                self.vulkan_memory_model_availability_visibility_chains,
            ),
            ("vulkanMemoryModelDeviceScope", self.vulkan_memory_model_device_scope),
            ("wideLines", self.wide_lines),
            ("workgroupMemoryExplicitLayout", self.workgroup_memory_explicit_layout),
            (
                "workgroupMemoryExplicitLayout16BitAccess",
                self.workgroup_memory_explicit_layout16_bit_access,
            ),
            (
                "workgroupMemoryExplicitLayout8BitAccess",
                self.workgroup_memory_explicit_layout8_bit_access,
            ),
            (
                "workgroupMemoryExplicitLayoutScalarBlockLayout",
                self.workgroup_memory_explicit_layout_scalar_block_layout,
            ),
            ("ycbcr2plane444Formats", self.ycbcr2plane444_formats),
            ("ycbcrDegamma", self.ycbcr_degamma),
            ("ycbcrImageArrays", self.ycbcr_image_arrays),
        ]
            .into_iter()
    }
}
#[derive(Default)]
pub(crate) struct DeviceFeaturesFfi {
    features_vulkan10: ash::vk::PhysicalDeviceFeatures2KHR<'static>,
    features_vulkan11: Option<ash::vk::PhysicalDeviceVulkan11Features<'static>>,
    features_vulkan12: Option<ash::vk::PhysicalDeviceVulkan12Features<'static>>,
    features_vulkan13: Option<ash::vk::PhysicalDeviceVulkan13Features<'static>>,
    features_16bit_storage: Option<ash::vk::PhysicalDevice16BitStorageFeatures<'static>>,
    features_multiview: Option<ash::vk::PhysicalDeviceMultiviewFeatures<'static>>,
    features_protected_memory: Option<
        ash::vk::PhysicalDeviceProtectedMemoryFeatures<'static>,
    >,
    features_sampler_ycbcr_conversion: Option<
        ash::vk::PhysicalDeviceSamplerYcbcrConversionFeatures<'static>,
    >,
    features_shader_draw_parameters: Option<
        ash::vk::PhysicalDeviceShaderDrawParametersFeatures<'static>,
    >,
    features_variable_pointers: Option<
        ash::vk::PhysicalDeviceVariablePointersFeatures<'static>,
    >,
    features_8bit_storage: Option<ash::vk::PhysicalDevice8BitStorageFeatures<'static>>,
    features_buffer_device_address: Option<
        ash::vk::PhysicalDeviceBufferDeviceAddressFeatures<'static>,
    >,
    features_descriptor_indexing: Option<
        ash::vk::PhysicalDeviceDescriptorIndexingFeatures<'static>,
    >,
    features_host_query_reset: Option<
        ash::vk::PhysicalDeviceHostQueryResetFeatures<'static>,
    >,
    features_imageless_framebuffer: Option<
        ash::vk::PhysicalDeviceImagelessFramebufferFeatures<'static>,
    >,
    features_scalar_block_layout: Option<
        ash::vk::PhysicalDeviceScalarBlockLayoutFeatures<'static>,
    >,
    features_separate_depth_stencil_layouts: Option<
        ash::vk::PhysicalDeviceSeparateDepthStencilLayoutsFeatures<'static>,
    >,
    features_shader_atomic_int64: Option<
        ash::vk::PhysicalDeviceShaderAtomicInt64Features<'static>,
    >,
    features_shader_float16_int8: Option<
        ash::vk::PhysicalDeviceShaderFloat16Int8Features<'static>,
    >,
    features_shader_subgroup_extended_types: Option<
        ash::vk::PhysicalDeviceShaderSubgroupExtendedTypesFeatures<'static>,
    >,
    features_timeline_semaphore: Option<
        ash::vk::PhysicalDeviceTimelineSemaphoreFeatures<'static>,
    >,
    features_uniform_buffer_standard_layout: Option<
        ash::vk::PhysicalDeviceUniformBufferStandardLayoutFeatures<'static>,
    >,
    features_vulkan_memory_model: Option<
        ash::vk::PhysicalDeviceVulkanMemoryModelFeatures<'static>,
    >,
    features_dynamic_rendering: Option<
        ash::vk::PhysicalDeviceDynamicRenderingFeatures<'static>,
    >,
    features_image_robustness: Option<
        ash::vk::PhysicalDeviceImageRobustnessFeatures<'static>,
    >,
    features_inline_uniform_block: Option<
        ash::vk::PhysicalDeviceInlineUniformBlockFeatures<'static>,
    >,
    features_maintenance4: Option<ash::vk::PhysicalDeviceMaintenance4Features<'static>>,
    features_pipeline_creation_cache_control: Option<
        ash::vk::PhysicalDevicePipelineCreationCacheControlFeatures<'static>,
    >,
    features_private_data: Option<ash::vk::PhysicalDevicePrivateDataFeatures<'static>>,
    features_shader_demote_to_helper_invocation: Option<
        ash::vk::PhysicalDeviceShaderDemoteToHelperInvocationFeatures<'static>,
    >,
    features_shader_integer_dot_product: Option<
        ash::vk::PhysicalDeviceShaderIntegerDotProductFeatures<'static>,
    >,
    features_shader_terminate_invocation: Option<
        ash::vk::PhysicalDeviceShaderTerminateInvocationFeatures<'static>,
    >,
    features_subgroup_size_control: Option<
        ash::vk::PhysicalDeviceSubgroupSizeControlFeatures<'static>,
    >,
    features_synchronization2: Option<
        ash::vk::PhysicalDeviceSynchronization2Features<'static>,
    >,
    features_texture_compression_astchdr: Option<
        ash::vk::PhysicalDeviceTextureCompressionASTCHDRFeatures<'static>,
    >,
    features_zero_initialize_workgroup_memory: Option<
        ash::vk::PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures<'static>,
    >,
    features_acceleration_structure_khr: Option<
        ash::vk::PhysicalDeviceAccelerationStructureFeaturesKHR<'static>,
    >,
    features_cooperative_matrix_khr: Option<
        ash::vk::PhysicalDeviceCooperativeMatrixFeaturesKHR<'static>,
    >,
    features_dynamic_rendering_local_read_khr: Option<
        ash::vk::PhysicalDeviceDynamicRenderingLocalReadFeaturesKHR<'static>,
    >,
    features_fragment_shader_barycentric_khr: Option<
        ash::vk::PhysicalDeviceFragmentShaderBarycentricFeaturesKHR<'static>,
    >,
    features_fragment_shading_rate_khr: Option<
        ash::vk::PhysicalDeviceFragmentShadingRateFeaturesKHR<'static>,
    >,
    features_global_priority_query_khr: Option<
        ash::vk::PhysicalDeviceGlobalPriorityQueryFeaturesKHR<'static>,
    >,
    features_index_type_uint8_khr: Option<
        ash::vk::PhysicalDeviceIndexTypeUint8FeaturesKHR<'static>,
    >,
    features_line_rasterization_khr: Option<
        ash::vk::PhysicalDeviceLineRasterizationFeaturesKHR<'static>,
    >,
    features_maintenance5_khr: Option<
        ash::vk::PhysicalDeviceMaintenance5FeaturesKHR<'static>,
    >,
    features_maintenance6_khr: Option<
        ash::vk::PhysicalDeviceMaintenance6FeaturesKHR<'static>,
    >,
    features_performance_query_khr: Option<
        ash::vk::PhysicalDevicePerformanceQueryFeaturesKHR<'static>,
    >,
    features_pipeline_executable_properties_khr: Option<
        ash::vk::PhysicalDevicePipelineExecutablePropertiesFeaturesKHR<'static>,
    >,
    features_portability_subset_khr: Option<
        ash::vk::PhysicalDevicePortabilitySubsetFeaturesKHR<'static>,
    >,
    features_present_id_khr: Option<
        ash::vk::PhysicalDevicePresentIdFeaturesKHR<'static>,
    >,
    features_present_wait_khr: Option<
        ash::vk::PhysicalDevicePresentWaitFeaturesKHR<'static>,
    >,
    features_ray_query_khr: Option<ash::vk::PhysicalDeviceRayQueryFeaturesKHR<'static>>,
    features_ray_tracing_maintenance1_khr: Option<
        ash::vk::PhysicalDeviceRayTracingMaintenance1FeaturesKHR<'static>,
    >,
    features_ray_tracing_pipeline_khr: Option<
        ash::vk::PhysicalDeviceRayTracingPipelineFeaturesKHR<'static>,
    >,
    features_ray_tracing_position_fetch_khr: Option<
        ash::vk::PhysicalDeviceRayTracingPositionFetchFeaturesKHR<'static>,
    >,
    features_shader_clock_khr: Option<
        ash::vk::PhysicalDeviceShaderClockFeaturesKHR<'static>,
    >,
    features_shader_expect_assume_khr: Option<
        ash::vk::PhysicalDeviceShaderExpectAssumeFeaturesKHR<'static>,
    >,
    features_shader_float_controls2_khr: Option<
        ash::vk::PhysicalDeviceShaderFloatControls2FeaturesKHR<'static>,
    >,
    features_shader_maximal_reconvergence_khr: Option<
        ash::vk::PhysicalDeviceShaderMaximalReconvergenceFeaturesKHR<'static>,
    >,
    features_shader_quad_control_khr: Option<
        ash::vk::PhysicalDeviceShaderQuadControlFeaturesKHR<'static>,
    >,
    features_shader_subgroup_rotate_khr: Option<
        ash::vk::PhysicalDeviceShaderSubgroupRotateFeaturesKHR<'static>,
    >,
    features_shader_subgroup_uniform_control_flow_khr: Option<
        ash::vk::PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR<'static>,
    >,
    features_vertex_attribute_divisor_khr: Option<
        ash::vk::PhysicalDeviceVertexAttributeDivisorFeaturesKHR<'static>,
    >,
    features_video_maintenance1_khr: Option<
        ash::vk::PhysicalDeviceVideoMaintenance1FeaturesKHR<'static>,
    >,
    features_workgroup_memory_explicit_layout_khr: Option<
        ash::vk::PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR<'static>,
    >,
    features_4444formats_ext: Option<
        ash::vk::PhysicalDevice4444FormatsFeaturesEXT<'static>,
    >,
    features_astc_decode_ext: Option<
        ash::vk::PhysicalDeviceASTCDecodeFeaturesEXT<'static>,
    >,
    features_address_binding_report_ext: Option<
        ash::vk::PhysicalDeviceAddressBindingReportFeaturesEXT<'static>,
    >,
    features_attachment_feedback_loop_dynamic_state_ext: Option<
        ash::vk::PhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT<'static>,
    >,
    features_attachment_feedback_loop_layout_ext: Option<
        ash::vk::PhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT<'static>,
    >,
    features_blend_operation_advanced_ext: Option<
        ash::vk::PhysicalDeviceBlendOperationAdvancedFeaturesEXT<'static>,
    >,
    features_border_color_swizzle_ext: Option<
        ash::vk::PhysicalDeviceBorderColorSwizzleFeaturesEXT<'static>,
    >,
    features_buffer_device_address_ext: Option<
        ash::vk::PhysicalDeviceBufferDeviceAddressFeaturesEXT<'static>,
    >,
    features_color_write_enable_ext: Option<
        ash::vk::PhysicalDeviceColorWriteEnableFeaturesEXT<'static>,
    >,
    features_conditional_rendering_ext: Option<
        ash::vk::PhysicalDeviceConditionalRenderingFeaturesEXT<'static>,
    >,
    features_custom_border_color_ext: Option<
        ash::vk::PhysicalDeviceCustomBorderColorFeaturesEXT<'static>,
    >,
    features_depth_bias_control_ext: Option<
        ash::vk::PhysicalDeviceDepthBiasControlFeaturesEXT<'static>,
    >,
    features_depth_clamp_zero_one_ext: Option<
        ash::vk::PhysicalDeviceDepthClampZeroOneFeaturesEXT<'static>,
    >,
    features_depth_clip_control_ext: Option<
        ash::vk::PhysicalDeviceDepthClipControlFeaturesEXT<'static>,
    >,
    features_depth_clip_enable_ext: Option<
        ash::vk::PhysicalDeviceDepthClipEnableFeaturesEXT<'static>,
    >,
    features_descriptor_buffer_ext: Option<
        ash::vk::PhysicalDeviceDescriptorBufferFeaturesEXT<'static>,
    >,
    features_device_memory_report_ext: Option<
        ash::vk::PhysicalDeviceDeviceMemoryReportFeaturesEXT<'static>,
    >,
    features_dynamic_rendering_unused_attachments_ext: Option<
        ash::vk::PhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT<'static>,
    >,
    features_extended_dynamic_state2_ext: Option<
        ash::vk::PhysicalDeviceExtendedDynamicState2FeaturesEXT<'static>,
    >,
    features_extended_dynamic_state3_ext: Option<
        ash::vk::PhysicalDeviceExtendedDynamicState3FeaturesEXT<'static>,
    >,
    features_extended_dynamic_state_ext: Option<
        ash::vk::PhysicalDeviceExtendedDynamicStateFeaturesEXT<'static>,
    >,
    features_fault_ext: Option<ash::vk::PhysicalDeviceFaultFeaturesEXT<'static>>,
    features_fragment_density_map2_ext: Option<
        ash::vk::PhysicalDeviceFragmentDensityMap2FeaturesEXT<'static>,
    >,
    features_fragment_density_map_ext: Option<
        ash::vk::PhysicalDeviceFragmentDensityMapFeaturesEXT<'static>,
    >,
    features_fragment_shader_interlock_ext: Option<
        ash::vk::PhysicalDeviceFragmentShaderInterlockFeaturesEXT<'static>,
    >,
    features_frame_boundary_ext: Option<
        ash::vk::PhysicalDeviceFrameBoundaryFeaturesEXT<'static>,
    >,
    features_graphics_pipeline_library_ext: Option<
        ash::vk::PhysicalDeviceGraphicsPipelineLibraryFeaturesEXT<'static>,
    >,
    features_host_image_copy_ext: Option<
        ash::vk::PhysicalDeviceHostImageCopyFeaturesEXT<'static>,
    >,
    features_image2_d_view_of3_d_ext: Option<
        ash::vk::PhysicalDeviceImage2DViewOf3DFeaturesEXT<'static>,
    >,
    features_image_compression_control_ext: Option<
        ash::vk::PhysicalDeviceImageCompressionControlFeaturesEXT<'static>,
    >,
    features_image_compression_control_swapchain_ext: Option<
        ash::vk::PhysicalDeviceImageCompressionControlSwapchainFeaturesEXT<'static>,
    >,
    features_image_sliced_view_of3_d_ext: Option<
        ash::vk::PhysicalDeviceImageSlicedViewOf3DFeaturesEXT<'static>,
    >,
    features_image_view_min_lod_ext: Option<
        ash::vk::PhysicalDeviceImageViewMinLodFeaturesEXT<'static>,
    >,
    features_legacy_dithering_ext: Option<
        ash::vk::PhysicalDeviceLegacyDitheringFeaturesEXT<'static>,
    >,
    features_map_memory_placed_ext: Option<
        ash::vk::PhysicalDeviceMapMemoryPlacedFeaturesEXT<'static>,
    >,
    features_memory_priority_ext: Option<
        ash::vk::PhysicalDeviceMemoryPriorityFeaturesEXT<'static>,
    >,
    features_mesh_shader_ext: Option<
        ash::vk::PhysicalDeviceMeshShaderFeaturesEXT<'static>,
    >,
    features_multi_draw_ext: Option<
        ash::vk::PhysicalDeviceMultiDrawFeaturesEXT<'static>,
    >,
    features_multisampled_render_to_single_sampled_ext: Option<
        ash::vk::PhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT<'static>,
    >,
    features_mutable_descriptor_type_ext: Option<
        ash::vk::PhysicalDeviceMutableDescriptorTypeFeaturesEXT<'static>,
    >,
    features_nested_command_buffer_ext: Option<
        ash::vk::PhysicalDeviceNestedCommandBufferFeaturesEXT<'static>,
    >,
    features_non_seamless_cube_map_ext: Option<
        ash::vk::PhysicalDeviceNonSeamlessCubeMapFeaturesEXT<'static>,
    >,
    features_opacity_micromap_ext: Option<
        ash::vk::PhysicalDeviceOpacityMicromapFeaturesEXT<'static>,
    >,
    features_pageable_device_local_memory_ext: Option<
        ash::vk::PhysicalDevicePageableDeviceLocalMemoryFeaturesEXT<'static>,
    >,
    features_pipeline_library_group_handles_ext: Option<
        ash::vk::PhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT<'static>,
    >,
    features_pipeline_properties_ext: Option<
        ash::vk::PhysicalDevicePipelinePropertiesFeaturesEXT<'static>,
    >,
    features_pipeline_protected_access_ext: Option<
        ash::vk::PhysicalDevicePipelineProtectedAccessFeaturesEXT<'static>,
    >,
    features_pipeline_robustness_ext: Option<
        ash::vk::PhysicalDevicePipelineRobustnessFeaturesEXT<'static>,
    >,
    features_primitive_topology_list_restart_ext: Option<
        ash::vk::PhysicalDevicePrimitiveTopologyListRestartFeaturesEXT<'static>,
    >,
    features_primitives_generated_query_ext: Option<
        ash::vk::PhysicalDevicePrimitivesGeneratedQueryFeaturesEXT<'static>,
    >,
    features_provoking_vertex_ext: Option<
        ash::vk::PhysicalDeviceProvokingVertexFeaturesEXT<'static>,
    >,
    features_rgba10x6_formats_ext: Option<
        ash::vk::PhysicalDeviceRGBA10X6FormatsFeaturesEXT<'static>,
    >,
    features_rasterization_order_attachment_access_ext: Option<
        ash::vk::PhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT<'static>,
    >,
    features_robustness2_ext: Option<
        ash::vk::PhysicalDeviceRobustness2FeaturesEXT<'static>,
    >,
    features_shader_atomic_float2_ext: Option<
        ash::vk::PhysicalDeviceShaderAtomicFloat2FeaturesEXT<'static>,
    >,
    features_shader_atomic_float_ext: Option<
        ash::vk::PhysicalDeviceShaderAtomicFloatFeaturesEXT<'static>,
    >,
    features_shader_image_atomic_int64_ext: Option<
        ash::vk::PhysicalDeviceShaderImageAtomicInt64FeaturesEXT<'static>,
    >,
    features_shader_module_identifier_ext: Option<
        ash::vk::PhysicalDeviceShaderModuleIdentifierFeaturesEXT<'static>,
    >,
    features_shader_object_ext: Option<
        ash::vk::PhysicalDeviceShaderObjectFeaturesEXT<'static>,
    >,
    features_shader_tile_image_ext: Option<
        ash::vk::PhysicalDeviceShaderTileImageFeaturesEXT<'static>,
    >,
    features_subpass_merge_feedback_ext: Option<
        ash::vk::PhysicalDeviceSubpassMergeFeedbackFeaturesEXT<'static>,
    >,
    features_swapchain_maintenance1_ext: Option<
        ash::vk::PhysicalDeviceSwapchainMaintenance1FeaturesEXT<'static>,
    >,
    features_texel_buffer_alignment_ext: Option<
        ash::vk::PhysicalDeviceTexelBufferAlignmentFeaturesEXT<'static>,
    >,
    features_transform_feedback_ext: Option<
        ash::vk::PhysicalDeviceTransformFeedbackFeaturesEXT<'static>,
    >,
    features_vertex_input_dynamic_state_ext: Option<
        ash::vk::PhysicalDeviceVertexInputDynamicStateFeaturesEXT<'static>,
    >,
    features_ycbcr2_plane444_formats_ext: Option<
        ash::vk::PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT<'static>,
    >,
    features_ycbcr_image_arrays_ext: Option<
        ash::vk::PhysicalDeviceYcbcrImageArraysFeaturesEXT<'static>,
    >,
    features_amigo_profiling_sec: Option<
        ash::vk::PhysicalDeviceAmigoProfilingFeaturesSEC<'static>,
    >,
    features_cluster_culling_shader_huawei: Option<
        ash::vk::PhysicalDeviceClusterCullingShaderFeaturesHUAWEI<'static>,
    >,
    features_coherent_memory_amd: Option<
        ash::vk::PhysicalDeviceCoherentMemoryFeaturesAMD<'static>,
    >,
    features_compute_shader_derivatives_nv: Option<
        ash::vk::PhysicalDeviceComputeShaderDerivativesFeaturesNV<'static>,
    >,
    features_cooperative_matrix_nv: Option<
        ash::vk::PhysicalDeviceCooperativeMatrixFeaturesNV<'static>,
    >,
    features_copy_memory_indirect_nv: Option<
        ash::vk::PhysicalDeviceCopyMemoryIndirectFeaturesNV<'static>,
    >,
    features_corner_sampled_image_nv: Option<
        ash::vk::PhysicalDeviceCornerSampledImageFeaturesNV<'static>,
    >,
    features_coverage_reduction_mode_nv: Option<
        ash::vk::PhysicalDeviceCoverageReductionModeFeaturesNV<'static>,
    >,
    features_cubic_clamp_qcom: Option<
        ash::vk::PhysicalDeviceCubicClampFeaturesQCOM<'static>,
    >,
    features_cubic_weights_qcom: Option<
        ash::vk::PhysicalDeviceCubicWeightsFeaturesQCOM<'static>,
    >,
    features_cuda_kernel_launch_nv: Option<
        ash::vk::PhysicalDeviceCudaKernelLaunchFeaturesNV<'static>,
    >,
    features_dedicated_allocation_image_aliasing_nv: Option<
        ash::vk::PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV<'static>,
    >,
    features_descriptor_pool_overallocation_nv: Option<
        ash::vk::PhysicalDeviceDescriptorPoolOverallocationFeaturesNV<'static>,
    >,
    features_descriptor_set_host_mapping_valve: Option<
        ash::vk::PhysicalDeviceDescriptorSetHostMappingFeaturesVALVE<'static>,
    >,
    features_device_generated_commands_compute_nv: Option<
        ash::vk::PhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV<'static>,
    >,
    features_device_generated_commands_nv: Option<
        ash::vk::PhysicalDeviceDeviceGeneratedCommandsFeaturesNV<'static>,
    >,
    features_diagnostics_config_nv: Option<
        ash::vk::PhysicalDeviceDiagnosticsConfigFeaturesNV<'static>,
    >,
    features_displacement_micromap_nv: Option<
        ash::vk::PhysicalDeviceDisplacementMicromapFeaturesNV<'static>,
    >,
    features_exclusive_scissor_nv: Option<
        ash::vk::PhysicalDeviceExclusiveScissorFeaturesNV<'static>,
    >,
    features_extended_sparse_address_space_nv: Option<
        ash::vk::PhysicalDeviceExtendedSparseAddressSpaceFeaturesNV<'static>,
    >,
    features_external_format_resolve_android: Option<
        ash::vk::PhysicalDeviceExternalFormatResolveFeaturesANDROID<'static>,
    >,
    features_external_memory_rdma_nv: Option<
        ash::vk::PhysicalDeviceExternalMemoryRDMAFeaturesNV<'static>,
    >,
    features_external_memory_screen_buffer_qnx: Option<
        ash::vk::PhysicalDeviceExternalMemoryScreenBufferFeaturesQNX<'static>,
    >,
    features_fragment_density_map_offset_qcom: Option<
        ash::vk::PhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM<'static>,
    >,
    features_fragment_shading_rate_enums_nv: Option<
        ash::vk::PhysicalDeviceFragmentShadingRateEnumsFeaturesNV<'static>,
    >,
    features_image_processing2_qcom: Option<
        ash::vk::PhysicalDeviceImageProcessing2FeaturesQCOM<'static>,
    >,
    features_image_processing_qcom: Option<
        ash::vk::PhysicalDeviceImageProcessingFeaturesQCOM<'static>,
    >,
    features_inherited_viewport_scissor_nv: Option<
        ash::vk::PhysicalDeviceInheritedViewportScissorFeaturesNV<'static>,
    >,
    features_invocation_mask_huawei: Option<
        ash::vk::PhysicalDeviceInvocationMaskFeaturesHUAWEI<'static>,
    >,
    features_linear_color_attachment_nv: Option<
        ash::vk::PhysicalDeviceLinearColorAttachmentFeaturesNV<'static>,
    >,
    features_memory_decompression_nv: Option<
        ash::vk::PhysicalDeviceMemoryDecompressionFeaturesNV<'static>,
    >,
    features_mesh_shader_nv: Option<
        ash::vk::PhysicalDeviceMeshShaderFeaturesNV<'static>,
    >,
    features_multiview_per_view_render_areas_qcom: Option<
        ash::vk::PhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM<'static>,
    >,
    features_multiview_per_view_viewports_qcom: Option<
        ash::vk::PhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM<'static>,
    >,
    features_optical_flow_nv: Option<
        ash::vk::PhysicalDeviceOpticalFlowFeaturesNV<'static>,
    >,
    features_per_stage_descriptor_set_nv: Option<
        ash::vk::PhysicalDevicePerStageDescriptorSetFeaturesNV<'static>,
    >,
    features_present_barrier_nv: Option<
        ash::vk::PhysicalDevicePresentBarrierFeaturesNV<'static>,
    >,
    features_raw_access_chains_nv: Option<
        ash::vk::PhysicalDeviceRawAccessChainsFeaturesNV<'static>,
    >,
    features_ray_tracing_invocation_reorder_nv: Option<
        ash::vk::PhysicalDeviceRayTracingInvocationReorderFeaturesNV<'static>,
    >,
    features_ray_tracing_motion_blur_nv: Option<
        ash::vk::PhysicalDeviceRayTracingMotionBlurFeaturesNV<'static>,
    >,
    features_ray_tracing_validation_nv: Option<
        ash::vk::PhysicalDeviceRayTracingValidationFeaturesNV<'static>,
    >,
    features_relaxed_line_rasterization_img: Option<
        ash::vk::PhysicalDeviceRelaxedLineRasterizationFeaturesIMG<'static>,
    >,
    features_render_pass_striped_arm: Option<
        ash::vk::PhysicalDeviceRenderPassStripedFeaturesARM<'static>,
    >,
    features_representative_fragment_test_nv: Option<
        ash::vk::PhysicalDeviceRepresentativeFragmentTestFeaturesNV<'static>,
    >,
    features_scheduling_controls_arm: Option<
        ash::vk::PhysicalDeviceSchedulingControlsFeaturesARM<'static>,
    >,
    features_shader_atomic_float16_vector_nv: Option<
        ash::vk::PhysicalDeviceShaderAtomicFloat16VectorFeaturesNV<'static>,
    >,
    features_shader_core_builtins_arm: Option<
        ash::vk::PhysicalDeviceShaderCoreBuiltinsFeaturesARM<'static>,
    >,
    features_shader_early_and_late_fragment_tests_amd: Option<
        ash::vk::PhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD<'static>,
    >,
    features_shader_enqueue_amdx: Option<
        ash::vk::PhysicalDeviceShaderEnqueueFeaturesAMDX<'static>,
    >,
    features_shader_image_footprint_nv: Option<
        ash::vk::PhysicalDeviceShaderImageFootprintFeaturesNV<'static>,
    >,
    features_shader_integer_functions2_intel: Option<
        ash::vk::PhysicalDeviceShaderIntegerFunctions2FeaturesINTEL<'static>,
    >,
    features_shader_sm_builtins_nv: Option<
        ash::vk::PhysicalDeviceShaderSMBuiltinsFeaturesNV<'static>,
    >,
    features_shading_rate_image_nv: Option<
        ash::vk::PhysicalDeviceShadingRateImageFeaturesNV<'static>,
    >,
    features_subpass_shading_huawei: Option<
        ash::vk::PhysicalDeviceSubpassShadingFeaturesHUAWEI<'static>,
    >,
    features_tile_properties_qcom: Option<
        ash::vk::PhysicalDeviceTilePropertiesFeaturesQCOM<'static>,
    >,
    features_ycbcr_degamma_qcom: Option<
        ash::vk::PhysicalDeviceYcbcrDegammaFeaturesQCOM<'static>,
    >,
}
impl DeviceFeaturesFfi {
    pub(crate) fn make_chain(
        &mut self,
        api_version: crate::Version,
        device_extensions: &crate::device::DeviceExtensions,
        _instance_extensions: &crate::instance::InstanceExtensions,
    ) {
        self.features_vulkan10 = Default::default();
        let head = &mut self.features_vulkan10;
        if [api_version >= crate::Version::V1_2].into_iter().any(|x| x)
            && [].into_iter().all(|x| x)
        {
            self.features_vulkan11 = Some(Default::default());
            let member = self.features_vulkan11.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [api_version >= crate::Version::V1_2].into_iter().any(|x| x)
            && [].into_iter().all(|x| x)
        {
            self.features_vulkan12 = Some(Default::default());
            let member = self.features_vulkan12.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [api_version >= crate::Version::V1_3].into_iter().any(|x| x)
            && [].into_iter().all(|x| x)
        {
            self.features_vulkan13 = Some(Default::default());
            let member = self.features_vulkan13.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [api_version >= crate::Version::V1_1, device_extensions.khr_16bit_storage]
            .into_iter()
            .any(|x| x) && [self.features_vulkan11.is_none()].into_iter().all(|x| x)
        {
            self.features_16bit_storage = Some(Default::default());
            let member = self.features_16bit_storage.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [api_version >= crate::Version::V1_1, device_extensions.khr_multiview]
            .into_iter()
            .any(|x| x) && [self.features_vulkan11.is_none()].into_iter().all(|x| x)
        {
            self.features_multiview = Some(Default::default());
            let member = self.features_multiview.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [api_version >= crate::Version::V1_1].into_iter().any(|x| x)
            && [self.features_vulkan11.is_none()].into_iter().all(|x| x)
        {
            self.features_protected_memory = Some(Default::default());
            let member = self.features_protected_memory.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [
            api_version >= crate::Version::V1_1,
            device_extensions.khr_sampler_ycbcr_conversion,
        ]
            .into_iter()
            .any(|x| x) && [self.features_vulkan11.is_none()].into_iter().all(|x| x)
        {
            self.features_sampler_ycbcr_conversion = Some(Default::default());
            let member = self.features_sampler_ycbcr_conversion.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [api_version >= crate::Version::V1_1].into_iter().any(|x| x)
            && [self.features_vulkan11.is_none()].into_iter().all(|x| x)
        {
            self.features_shader_draw_parameters = Some(Default::default());
            let member = self.features_shader_draw_parameters.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [api_version >= crate::Version::V1_1, device_extensions.khr_variable_pointers]
            .into_iter()
            .any(|x| x) && [self.features_vulkan11.is_none()].into_iter().all(|x| x)
        {
            self.features_variable_pointers = Some(Default::default());
            let member = self.features_variable_pointers.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [api_version >= crate::Version::V1_2, device_extensions.khr_8bit_storage]
            .into_iter()
            .any(|x| x) && [self.features_vulkan12.is_none()].into_iter().all(|x| x)
        {
            self.features_8bit_storage = Some(Default::default());
            let member = self.features_8bit_storage.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [
            api_version >= crate::Version::V1_2,
            device_extensions.khr_buffer_device_address,
        ]
            .into_iter()
            .any(|x| x) && [self.features_vulkan12.is_none()].into_iter().all(|x| x)
        {
            self.features_buffer_device_address = Some(Default::default());
            let member = self.features_buffer_device_address.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [
            api_version >= crate::Version::V1_2,
            device_extensions.ext_descriptor_indexing,
        ]
            .into_iter()
            .any(|x| x) && [self.features_vulkan12.is_none()].into_iter().all(|x| x)
        {
            self.features_descriptor_indexing = Some(Default::default());
            let member = self.features_descriptor_indexing.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [api_version >= crate::Version::V1_2, device_extensions.ext_host_query_reset]
            .into_iter()
            .any(|x| x) && [self.features_vulkan12.is_none()].into_iter().all(|x| x)
        {
            self.features_host_query_reset = Some(Default::default());
            let member = self.features_host_query_reset.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [
            api_version >= crate::Version::V1_2,
            device_extensions.khr_imageless_framebuffer,
        ]
            .into_iter()
            .any(|x| x) && [self.features_vulkan12.is_none()].into_iter().all(|x| x)
        {
            self.features_imageless_framebuffer = Some(Default::default());
            let member = self.features_imageless_framebuffer.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [
            api_version >= crate::Version::V1_2,
            device_extensions.ext_scalar_block_layout,
        ]
            .into_iter()
            .any(|x| x) && [self.features_vulkan12.is_none()].into_iter().all(|x| x)
        {
            self.features_scalar_block_layout = Some(Default::default());
            let member = self.features_scalar_block_layout.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [
            api_version >= crate::Version::V1_2,
            device_extensions.khr_separate_depth_stencil_layouts,
        ]
            .into_iter()
            .any(|x| x) && [self.features_vulkan12.is_none()].into_iter().all(|x| x)
        {
            self.features_separate_depth_stencil_layouts = Some(Default::default());
            let member = self.features_separate_depth_stencil_layouts.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [
            api_version >= crate::Version::V1_2,
            device_extensions.khr_shader_atomic_int64,
        ]
            .into_iter()
            .any(|x| x) && [self.features_vulkan12.is_none()].into_iter().all(|x| x)
        {
            self.features_shader_atomic_int64 = Some(Default::default());
            let member = self.features_shader_atomic_int64.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [
            api_version >= crate::Version::V1_2,
            device_extensions.khr_shader_float16_int8,
        ]
            .into_iter()
            .any(|x| x) && [self.features_vulkan12.is_none()].into_iter().all(|x| x)
        {
            self.features_shader_float16_int8 = Some(Default::default());
            let member = self.features_shader_float16_int8.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [
            api_version >= crate::Version::V1_2,
            device_extensions.khr_shader_subgroup_extended_types,
        ]
            .into_iter()
            .any(|x| x) && [self.features_vulkan12.is_none()].into_iter().all(|x| x)
        {
            self.features_shader_subgroup_extended_types = Some(Default::default());
            let member = self.features_shader_subgroup_extended_types.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [
            api_version >= crate::Version::V1_2,
            device_extensions.khr_timeline_semaphore,
        ]
            .into_iter()
            .any(|x| x) && [self.features_vulkan12.is_none()].into_iter().all(|x| x)
        {
            self.features_timeline_semaphore = Some(Default::default());
            let member = self.features_timeline_semaphore.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [
            api_version >= crate::Version::V1_2,
            device_extensions.khr_uniform_buffer_standard_layout,
        ]
            .into_iter()
            .any(|x| x) && [self.features_vulkan12.is_none()].into_iter().all(|x| x)
        {
            self.features_uniform_buffer_standard_layout = Some(Default::default());
            let member = self.features_uniform_buffer_standard_layout.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [
            api_version >= crate::Version::V1_2,
            device_extensions.khr_vulkan_memory_model,
        ]
            .into_iter()
            .any(|x| x) && [self.features_vulkan12.is_none()].into_iter().all(|x| x)
        {
            self.features_vulkan_memory_model = Some(Default::default());
            let member = self.features_vulkan_memory_model.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [api_version >= crate::Version::V1_3, device_extensions.khr_dynamic_rendering]
            .into_iter()
            .any(|x| x) && [self.features_vulkan13.is_none()].into_iter().all(|x| x)
        {
            self.features_dynamic_rendering = Some(Default::default());
            let member = self.features_dynamic_rendering.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [api_version >= crate::Version::V1_3, device_extensions.ext_image_robustness]
            .into_iter()
            .any(|x| x) && [self.features_vulkan13.is_none()].into_iter().all(|x| x)
        {
            self.features_image_robustness = Some(Default::default());
            let member = self.features_image_robustness.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [
            api_version >= crate::Version::V1_3,
            device_extensions.ext_inline_uniform_block,
        ]
            .into_iter()
            .any(|x| x) && [self.features_vulkan13.is_none()].into_iter().all(|x| x)
        {
            self.features_inline_uniform_block = Some(Default::default());
            let member = self.features_inline_uniform_block.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [api_version >= crate::Version::V1_3, device_extensions.khr_maintenance4]
            .into_iter()
            .any(|x| x) && [self.features_vulkan13.is_none()].into_iter().all(|x| x)
        {
            self.features_maintenance4 = Some(Default::default());
            let member = self.features_maintenance4.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [
            api_version >= crate::Version::V1_3,
            device_extensions.ext_pipeline_creation_cache_control,
        ]
            .into_iter()
            .any(|x| x) && [self.features_vulkan13.is_none()].into_iter().all(|x| x)
        {
            self.features_pipeline_creation_cache_control = Some(Default::default());
            let member = self.features_pipeline_creation_cache_control.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [api_version >= crate::Version::V1_3, device_extensions.ext_private_data]
            .into_iter()
            .any(|x| x) && [self.features_vulkan13.is_none()].into_iter().all(|x| x)
        {
            self.features_private_data = Some(Default::default());
            let member = self.features_private_data.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [
            api_version >= crate::Version::V1_3,
            device_extensions.ext_shader_demote_to_helper_invocation,
        ]
            .into_iter()
            .any(|x| x) && [self.features_vulkan13.is_none()].into_iter().all(|x| x)
        {
            self.features_shader_demote_to_helper_invocation = Some(Default::default());
            let member = self
                .features_shader_demote_to_helper_invocation
                .as_mut()
                .unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [
            api_version >= crate::Version::V1_3,
            device_extensions.khr_shader_integer_dot_product,
        ]
            .into_iter()
            .any(|x| x) && [self.features_vulkan13.is_none()].into_iter().all(|x| x)
        {
            self.features_shader_integer_dot_product = Some(Default::default());
            let member = self.features_shader_integer_dot_product.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [
            api_version >= crate::Version::V1_3,
            device_extensions.khr_shader_terminate_invocation,
        ]
            .into_iter()
            .any(|x| x) && [self.features_vulkan13.is_none()].into_iter().all(|x| x)
        {
            self.features_shader_terminate_invocation = Some(Default::default());
            let member = self.features_shader_terminate_invocation.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [
            api_version >= crate::Version::V1_3,
            device_extensions.ext_subgroup_size_control,
        ]
            .into_iter()
            .any(|x| x) && [self.features_vulkan13.is_none()].into_iter().all(|x| x)
        {
            self.features_subgroup_size_control = Some(Default::default());
            let member = self.features_subgroup_size_control.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [api_version >= crate::Version::V1_3, device_extensions.khr_synchronization2]
            .into_iter()
            .any(|x| x) && [self.features_vulkan13.is_none()].into_iter().all(|x| x)
        {
            self.features_synchronization2 = Some(Default::default());
            let member = self.features_synchronization2.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [
            api_version >= crate::Version::V1_3,
            device_extensions.ext_texture_compression_astc_hdr,
        ]
            .into_iter()
            .any(|x| x) && [self.features_vulkan13.is_none()].into_iter().all(|x| x)
        {
            self.features_texture_compression_astchdr = Some(Default::default());
            let member = self.features_texture_compression_astchdr.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [
            api_version >= crate::Version::V1_3,
            device_extensions.khr_zero_initialize_workgroup_memory,
        ]
            .into_iter()
            .any(|x| x) && [self.features_vulkan13.is_none()].into_iter().all(|x| x)
        {
            self.features_zero_initialize_workgroup_memory = Some(Default::default());
            let member = self
                .features_zero_initialize_workgroup_memory
                .as_mut()
                .unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [device_extensions.khr_acceleration_structure].into_iter().any(|x| x)
            && [].into_iter().all(|x| x)
        {
            self.features_acceleration_structure_khr = Some(Default::default());
            let member = self.features_acceleration_structure_khr.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [device_extensions.khr_cooperative_matrix].into_iter().any(|x| x)
            && [].into_iter().all(|x| x)
        {
            self.features_cooperative_matrix_khr = Some(Default::default());
            let member = self.features_cooperative_matrix_khr.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [device_extensions.khr_dynamic_rendering_local_read].into_iter().any(|x| x)
            && [].into_iter().all(|x| x)
        {
            self.features_dynamic_rendering_local_read_khr = Some(Default::default());
            let member = self
                .features_dynamic_rendering_local_read_khr
                .as_mut()
                .unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [
            device_extensions.khr_fragment_shader_barycentric,
            device_extensions.nv_fragment_shader_barycentric,
        ]
            .into_iter()
            .any(|x| x) && [].into_iter().all(|x| x)
        {
            self.features_fragment_shader_barycentric_khr = Some(Default::default());
            let member = self.features_fragment_shader_barycentric_khr.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [device_extensions.khr_fragment_shading_rate].into_iter().any(|x| x)
            && [].into_iter().all(|x| x)
        {
            self.features_fragment_shading_rate_khr = Some(Default::default());
            let member = self.features_fragment_shading_rate_khr.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [
            device_extensions.khr_global_priority,
            device_extensions.ext_global_priority_query,
        ]
            .into_iter()
            .any(|x| x) && [].into_iter().all(|x| x)
        {
            self.features_global_priority_query_khr = Some(Default::default());
            let member = self.features_global_priority_query_khr.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [
            device_extensions.khr_index_type_uint8,
            device_extensions.ext_index_type_uint8,
        ]
            .into_iter()
            .any(|x| x) && [].into_iter().all(|x| x)
        {
            self.features_index_type_uint8_khr = Some(Default::default());
            let member = self.features_index_type_uint8_khr.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [
            device_extensions.khr_line_rasterization,
            device_extensions.ext_line_rasterization,
        ]
            .into_iter()
            .any(|x| x) && [].into_iter().all(|x| x)
        {
            self.features_line_rasterization_khr = Some(Default::default());
            let member = self.features_line_rasterization_khr.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [device_extensions.khr_maintenance5].into_iter().any(|x| x)
            && [].into_iter().all(|x| x)
        {
            self.features_maintenance5_khr = Some(Default::default());
            let member = self.features_maintenance5_khr.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [device_extensions.khr_maintenance6].into_iter().any(|x| x)
            && [].into_iter().all(|x| x)
        {
            self.features_maintenance6_khr = Some(Default::default());
            let member = self.features_maintenance6_khr.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [device_extensions.khr_performance_query].into_iter().any(|x| x)
            && [].into_iter().all(|x| x)
        {
            self.features_performance_query_khr = Some(Default::default());
            let member = self.features_performance_query_khr.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [device_extensions.khr_pipeline_executable_properties].into_iter().any(|x| x)
            && [].into_iter().all(|x| x)
        {
            self.features_pipeline_executable_properties_khr = Some(Default::default());
            let member = self
                .features_pipeline_executable_properties_khr
                .as_mut()
                .unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [device_extensions.khr_portability_subset].into_iter().any(|x| x)
            && [].into_iter().all(|x| x)
        {
            self.features_portability_subset_khr = Some(Default::default());
            let member = self.features_portability_subset_khr.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [device_extensions.khr_present_id].into_iter().any(|x| x)
            && [].into_iter().all(|x| x)
        {
            self.features_present_id_khr = Some(Default::default());
            let member = self.features_present_id_khr.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [device_extensions.khr_present_wait].into_iter().any(|x| x)
            && [].into_iter().all(|x| x)
        {
            self.features_present_wait_khr = Some(Default::default());
            let member = self.features_present_wait_khr.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [device_extensions.khr_ray_query].into_iter().any(|x| x)
            && [].into_iter().all(|x| x)
        {
            self.features_ray_query_khr = Some(Default::default());
            let member = self.features_ray_query_khr.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [device_extensions.khr_ray_tracing_maintenance1].into_iter().any(|x| x)
            && [].into_iter().all(|x| x)
        {
            self.features_ray_tracing_maintenance1_khr = Some(Default::default());
            let member = self.features_ray_tracing_maintenance1_khr.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [device_extensions.khr_ray_tracing_pipeline].into_iter().any(|x| x)
            && [].into_iter().all(|x| x)
        {
            self.features_ray_tracing_pipeline_khr = Some(Default::default());
            let member = self.features_ray_tracing_pipeline_khr.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [device_extensions.khr_ray_tracing_position_fetch].into_iter().any(|x| x)
            && [].into_iter().all(|x| x)
        {
            self.features_ray_tracing_position_fetch_khr = Some(Default::default());
            let member = self.features_ray_tracing_position_fetch_khr.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [device_extensions.khr_shader_clock].into_iter().any(|x| x)
            && [].into_iter().all(|x| x)
        {
            self.features_shader_clock_khr = Some(Default::default());
            let member = self.features_shader_clock_khr.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [device_extensions.khr_shader_expect_assume].into_iter().any(|x| x)
            && [].into_iter().all(|x| x)
        {
            self.features_shader_expect_assume_khr = Some(Default::default());
            let member = self.features_shader_expect_assume_khr.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [device_extensions.khr_shader_float_controls2].into_iter().any(|x| x)
            && [].into_iter().all(|x| x)
        {
            self.features_shader_float_controls2_khr = Some(Default::default());
            let member = self.features_shader_float_controls2_khr.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [device_extensions.khr_shader_maximal_reconvergence].into_iter().any(|x| x)
            && [].into_iter().all(|x| x)
        {
            self.features_shader_maximal_reconvergence_khr = Some(Default::default());
            let member = self
                .features_shader_maximal_reconvergence_khr
                .as_mut()
                .unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [device_extensions.khr_shader_quad_control].into_iter().any(|x| x)
            && [].into_iter().all(|x| x)
        {
            self.features_shader_quad_control_khr = Some(Default::default());
            let member = self.features_shader_quad_control_khr.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [device_extensions.khr_shader_subgroup_rotate].into_iter().any(|x| x)
            && [].into_iter().all(|x| x)
        {
            self.features_shader_subgroup_rotate_khr = Some(Default::default());
            let member = self.features_shader_subgroup_rotate_khr.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [device_extensions.khr_shader_subgroup_uniform_control_flow]
            .into_iter()
            .any(|x| x) && [].into_iter().all(|x| x)
        {
            self.features_shader_subgroup_uniform_control_flow_khr = Some(
                Default::default(),
            );
            let member = self
                .features_shader_subgroup_uniform_control_flow_khr
                .as_mut()
                .unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [
            device_extensions.khr_vertex_attribute_divisor,
            device_extensions.ext_vertex_attribute_divisor,
        ]
            .into_iter()
            .any(|x| x) && [].into_iter().all(|x| x)
        {
            self.features_vertex_attribute_divisor_khr = Some(Default::default());
            let member = self.features_vertex_attribute_divisor_khr.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [device_extensions.khr_video_maintenance1].into_iter().any(|x| x)
            && [].into_iter().all(|x| x)
        {
            self.features_video_maintenance1_khr = Some(Default::default());
            let member = self.features_video_maintenance1_khr.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [device_extensions.khr_workgroup_memory_explicit_layout]
            .into_iter()
            .any(|x| x) && [].into_iter().all(|x| x)
        {
            self.features_workgroup_memory_explicit_layout_khr = Some(
                Default::default(),
            );
            let member = self
                .features_workgroup_memory_explicit_layout_khr
                .as_mut()
                .unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [device_extensions.ext_4444_formats].into_iter().any(|x| x)
            && [].into_iter().all(|x| x)
        {
            self.features_4444formats_ext = Some(Default::default());
            let member = self.features_4444formats_ext.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [device_extensions.ext_astc_decode_mode].into_iter().any(|x| x)
            && [].into_iter().all(|x| x)
        {
            self.features_astc_decode_ext = Some(Default::default());
            let member = self.features_astc_decode_ext.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [device_extensions.ext_device_address_binding_report].into_iter().any(|x| x)
            && [].into_iter().all(|x| x)
        {
            self.features_address_binding_report_ext = Some(Default::default());
            let member = self.features_address_binding_report_ext.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [device_extensions.ext_attachment_feedback_loop_dynamic_state]
            .into_iter()
            .any(|x| x) && [].into_iter().all(|x| x)
        {
            self.features_attachment_feedback_loop_dynamic_state_ext = Some(
                Default::default(),
            );
            let member = self
                .features_attachment_feedback_loop_dynamic_state_ext
                .as_mut()
                .unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [device_extensions.ext_attachment_feedback_loop_layout].into_iter().any(|x| x)
            && [].into_iter().all(|x| x)
        {
            self.features_attachment_feedback_loop_layout_ext = Some(Default::default());
            let member = self
                .features_attachment_feedback_loop_layout_ext
                .as_mut()
                .unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [device_extensions.ext_blend_operation_advanced].into_iter().any(|x| x)
            && [].into_iter().all(|x| x)
        {
            self.features_blend_operation_advanced_ext = Some(Default::default());
            let member = self.features_blend_operation_advanced_ext.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [device_extensions.ext_border_color_swizzle].into_iter().any(|x| x)
            && [].into_iter().all(|x| x)
        {
            self.features_border_color_swizzle_ext = Some(Default::default());
            let member = self.features_border_color_swizzle_ext.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [device_extensions.ext_buffer_device_address].into_iter().any(|x| x)
            && [
                self.features_vulkan12.is_none(),
                self.features_buffer_device_address.is_none(),
            ]
                .into_iter()
                .all(|x| x)
        {
            self.features_buffer_device_address_ext = Some(Default::default());
            let member = self.features_buffer_device_address_ext.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [device_extensions.ext_color_write_enable].into_iter().any(|x| x)
            && [].into_iter().all(|x| x)
        {
            self.features_color_write_enable_ext = Some(Default::default());
            let member = self.features_color_write_enable_ext.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [device_extensions.ext_conditional_rendering].into_iter().any(|x| x)
            && [].into_iter().all(|x| x)
        {
            self.features_conditional_rendering_ext = Some(Default::default());
            let member = self.features_conditional_rendering_ext.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [device_extensions.ext_custom_border_color].into_iter().any(|x| x)
            && [].into_iter().all(|x| x)
        {
            self.features_custom_border_color_ext = Some(Default::default());
            let member = self.features_custom_border_color_ext.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [device_extensions.ext_depth_bias_control].into_iter().any(|x| x)
            && [].into_iter().all(|x| x)
        {
            self.features_depth_bias_control_ext = Some(Default::default());
            let member = self.features_depth_bias_control_ext.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [device_extensions.ext_depth_clamp_zero_one].into_iter().any(|x| x)
            && [].into_iter().all(|x| x)
        {
            self.features_depth_clamp_zero_one_ext = Some(Default::default());
            let member = self.features_depth_clamp_zero_one_ext.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [device_extensions.ext_depth_clip_control].into_iter().any(|x| x)
            && [].into_iter().all(|x| x)
        {
            self.features_depth_clip_control_ext = Some(Default::default());
            let member = self.features_depth_clip_control_ext.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [device_extensions.ext_depth_clip_enable].into_iter().any(|x| x)
            && [].into_iter().all(|x| x)
        {
            self.features_depth_clip_enable_ext = Some(Default::default());
            let member = self.features_depth_clip_enable_ext.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [device_extensions.ext_descriptor_buffer].into_iter().any(|x| x)
            && [].into_iter().all(|x| x)
        {
            self.features_descriptor_buffer_ext = Some(Default::default());
            let member = self.features_descriptor_buffer_ext.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [device_extensions.ext_device_memory_report].into_iter().any(|x| x)
            && [].into_iter().all(|x| x)
        {
            self.features_device_memory_report_ext = Some(Default::default());
            let member = self.features_device_memory_report_ext.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [device_extensions.ext_dynamic_rendering_unused_attachments]
            .into_iter()
            .any(|x| x) && [].into_iter().all(|x| x)
        {
            self.features_dynamic_rendering_unused_attachments_ext = Some(
                Default::default(),
            );
            let member = self
                .features_dynamic_rendering_unused_attachments_ext
                .as_mut()
                .unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [device_extensions.ext_extended_dynamic_state2].into_iter().any(|x| x)
            && [].into_iter().all(|x| x)
        {
            self.features_extended_dynamic_state2_ext = Some(Default::default());
            let member = self.features_extended_dynamic_state2_ext.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [device_extensions.ext_extended_dynamic_state3].into_iter().any(|x| x)
            && [].into_iter().all(|x| x)
        {
            self.features_extended_dynamic_state3_ext = Some(Default::default());
            let member = self.features_extended_dynamic_state3_ext.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [device_extensions.ext_extended_dynamic_state].into_iter().any(|x| x)
            && [].into_iter().all(|x| x)
        {
            self.features_extended_dynamic_state_ext = Some(Default::default());
            let member = self.features_extended_dynamic_state_ext.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [device_extensions.ext_device_fault].into_iter().any(|x| x)
            && [].into_iter().all(|x| x)
        {
            self.features_fault_ext = Some(Default::default());
            let member = self.features_fault_ext.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [device_extensions.ext_fragment_density_map2].into_iter().any(|x| x)
            && [].into_iter().all(|x| x)
        {
            self.features_fragment_density_map2_ext = Some(Default::default());
            let member = self.features_fragment_density_map2_ext.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [device_extensions.ext_fragment_density_map].into_iter().any(|x| x)
            && [].into_iter().all(|x| x)
        {
            self.features_fragment_density_map_ext = Some(Default::default());
            let member = self.features_fragment_density_map_ext.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [device_extensions.ext_fragment_shader_interlock].into_iter().any(|x| x)
            && [].into_iter().all(|x| x)
        {
            self.features_fragment_shader_interlock_ext = Some(Default::default());
            let member = self.features_fragment_shader_interlock_ext.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [device_extensions.ext_frame_boundary].into_iter().any(|x| x)
            && [].into_iter().all(|x| x)
        {
            self.features_frame_boundary_ext = Some(Default::default());
            let member = self.features_frame_boundary_ext.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [device_extensions.ext_graphics_pipeline_library].into_iter().any(|x| x)
            && [].into_iter().all(|x| x)
        {
            self.features_graphics_pipeline_library_ext = Some(Default::default());
            let member = self.features_graphics_pipeline_library_ext.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [device_extensions.ext_host_image_copy].into_iter().any(|x| x)
            && [].into_iter().all(|x| x)
        {
            self.features_host_image_copy_ext = Some(Default::default());
            let member = self.features_host_image_copy_ext.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [device_extensions.ext_image_2d_view_of_3d].into_iter().any(|x| x)
            && [].into_iter().all(|x| x)
        {
            self.features_image2_d_view_of3_d_ext = Some(Default::default());
            let member = self.features_image2_d_view_of3_d_ext.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [device_extensions.ext_image_compression_control].into_iter().any(|x| x)
            && [].into_iter().all(|x| x)
        {
            self.features_image_compression_control_ext = Some(Default::default());
            let member = self.features_image_compression_control_ext.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [device_extensions.ext_image_compression_control_swapchain]
            .into_iter()
            .any(|x| x) && [].into_iter().all(|x| x)
        {
            self.features_image_compression_control_swapchain_ext = Some(
                Default::default(),
            );
            let member = self
                .features_image_compression_control_swapchain_ext
                .as_mut()
                .unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [device_extensions.ext_image_sliced_view_of_3d].into_iter().any(|x| x)
            && [].into_iter().all(|x| x)
        {
            self.features_image_sliced_view_of3_d_ext = Some(Default::default());
            let member = self.features_image_sliced_view_of3_d_ext.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [device_extensions.ext_image_view_min_lod].into_iter().any(|x| x)
            && [].into_iter().all(|x| x)
        {
            self.features_image_view_min_lod_ext = Some(Default::default());
            let member = self.features_image_view_min_lod_ext.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [device_extensions.ext_legacy_dithering].into_iter().any(|x| x)
            && [].into_iter().all(|x| x)
        {
            self.features_legacy_dithering_ext = Some(Default::default());
            let member = self.features_legacy_dithering_ext.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [device_extensions.ext_map_memory_placed].into_iter().any(|x| x)
            && [].into_iter().all(|x| x)
        {
            self.features_map_memory_placed_ext = Some(Default::default());
            let member = self.features_map_memory_placed_ext.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [device_extensions.ext_memory_priority].into_iter().any(|x| x)
            && [].into_iter().all(|x| x)
        {
            self.features_memory_priority_ext = Some(Default::default());
            let member = self.features_memory_priority_ext.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [device_extensions.ext_mesh_shader].into_iter().any(|x| x)
            && [].into_iter().all(|x| x)
        {
            self.features_mesh_shader_ext = Some(Default::default());
            let member = self.features_mesh_shader_ext.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [device_extensions.ext_multi_draw].into_iter().any(|x| x)
            && [].into_iter().all(|x| x)
        {
            self.features_multi_draw_ext = Some(Default::default());
            let member = self.features_multi_draw_ext.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [device_extensions.ext_multisampled_render_to_single_sampled]
            .into_iter()
            .any(|x| x) && [].into_iter().all(|x| x)
        {
            self.features_multisampled_render_to_single_sampled_ext = Some(
                Default::default(),
            );
            let member = self
                .features_multisampled_render_to_single_sampled_ext
                .as_mut()
                .unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [
            device_extensions.ext_mutable_descriptor_type,
            device_extensions.valve_mutable_descriptor_type,
        ]
            .into_iter()
            .any(|x| x) && [].into_iter().all(|x| x)
        {
            self.features_mutable_descriptor_type_ext = Some(Default::default());
            let member = self.features_mutable_descriptor_type_ext.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [device_extensions.ext_nested_command_buffer].into_iter().any(|x| x)
            && [].into_iter().all(|x| x)
        {
            self.features_nested_command_buffer_ext = Some(Default::default());
            let member = self.features_nested_command_buffer_ext.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [device_extensions.ext_non_seamless_cube_map].into_iter().any(|x| x)
            && [].into_iter().all(|x| x)
        {
            self.features_non_seamless_cube_map_ext = Some(Default::default());
            let member = self.features_non_seamless_cube_map_ext.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [device_extensions.ext_opacity_micromap].into_iter().any(|x| x)
            && [].into_iter().all(|x| x)
        {
            self.features_opacity_micromap_ext = Some(Default::default());
            let member = self.features_opacity_micromap_ext.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [device_extensions.ext_pageable_device_local_memory].into_iter().any(|x| x)
            && [].into_iter().all(|x| x)
        {
            self.features_pageable_device_local_memory_ext = Some(Default::default());
            let member = self
                .features_pageable_device_local_memory_ext
                .as_mut()
                .unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [device_extensions.ext_pipeline_library_group_handles].into_iter().any(|x| x)
            && [].into_iter().all(|x| x)
        {
            self.features_pipeline_library_group_handles_ext = Some(Default::default());
            let member = self
                .features_pipeline_library_group_handles_ext
                .as_mut()
                .unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [device_extensions.ext_pipeline_properties].into_iter().any(|x| x)
            && [].into_iter().all(|x| x)
        {
            self.features_pipeline_properties_ext = Some(Default::default());
            let member = self.features_pipeline_properties_ext.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [device_extensions.ext_pipeline_protected_access].into_iter().any(|x| x)
            && [].into_iter().all(|x| x)
        {
            self.features_pipeline_protected_access_ext = Some(Default::default());
            let member = self.features_pipeline_protected_access_ext.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [device_extensions.ext_pipeline_robustness].into_iter().any(|x| x)
            && [].into_iter().all(|x| x)
        {
            self.features_pipeline_robustness_ext = Some(Default::default());
            let member = self.features_pipeline_robustness_ext.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [device_extensions.ext_primitive_topology_list_restart].into_iter().any(|x| x)
            && [].into_iter().all(|x| x)
        {
            self.features_primitive_topology_list_restart_ext = Some(Default::default());
            let member = self
                .features_primitive_topology_list_restart_ext
                .as_mut()
                .unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [device_extensions.ext_primitives_generated_query].into_iter().any(|x| x)
            && [].into_iter().all(|x| x)
        {
            self.features_primitives_generated_query_ext = Some(Default::default());
            let member = self.features_primitives_generated_query_ext.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [device_extensions.ext_provoking_vertex].into_iter().any(|x| x)
            && [].into_iter().all(|x| x)
        {
            self.features_provoking_vertex_ext = Some(Default::default());
            let member = self.features_provoking_vertex_ext.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [device_extensions.ext_rgba10x6_formats].into_iter().any(|x| x)
            && [].into_iter().all(|x| x)
        {
            self.features_rgba10x6_formats_ext = Some(Default::default());
            let member = self.features_rgba10x6_formats_ext.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [
            device_extensions.ext_rasterization_order_attachment_access,
            device_extensions.arm_rasterization_order_attachment_access,
        ]
            .into_iter()
            .any(|x| x) && [].into_iter().all(|x| x)
        {
            self.features_rasterization_order_attachment_access_ext = Some(
                Default::default(),
            );
            let member = self
                .features_rasterization_order_attachment_access_ext
                .as_mut()
                .unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [device_extensions.ext_robustness2].into_iter().any(|x| x)
            && [].into_iter().all(|x| x)
        {
            self.features_robustness2_ext = Some(Default::default());
            let member = self.features_robustness2_ext.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [device_extensions.ext_shader_atomic_float2].into_iter().any(|x| x)
            && [].into_iter().all(|x| x)
        {
            self.features_shader_atomic_float2_ext = Some(Default::default());
            let member = self.features_shader_atomic_float2_ext.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [device_extensions.ext_shader_atomic_float].into_iter().any(|x| x)
            && [].into_iter().all(|x| x)
        {
            self.features_shader_atomic_float_ext = Some(Default::default());
            let member = self.features_shader_atomic_float_ext.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [device_extensions.ext_shader_image_atomic_int64].into_iter().any(|x| x)
            && [].into_iter().all(|x| x)
        {
            self.features_shader_image_atomic_int64_ext = Some(Default::default());
            let member = self.features_shader_image_atomic_int64_ext.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [device_extensions.ext_shader_module_identifier].into_iter().any(|x| x)
            && [].into_iter().all(|x| x)
        {
            self.features_shader_module_identifier_ext = Some(Default::default());
            let member = self.features_shader_module_identifier_ext.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [device_extensions.ext_shader_object].into_iter().any(|x| x)
            && [].into_iter().all(|x| x)
        {
            self.features_shader_object_ext = Some(Default::default());
            let member = self.features_shader_object_ext.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [device_extensions.ext_shader_tile_image].into_iter().any(|x| x)
            && [].into_iter().all(|x| x)
        {
            self.features_shader_tile_image_ext = Some(Default::default());
            let member = self.features_shader_tile_image_ext.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [device_extensions.ext_subpass_merge_feedback].into_iter().any(|x| x)
            && [].into_iter().all(|x| x)
        {
            self.features_subpass_merge_feedback_ext = Some(Default::default());
            let member = self.features_subpass_merge_feedback_ext.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [device_extensions.ext_swapchain_maintenance1].into_iter().any(|x| x)
            && [].into_iter().all(|x| x)
        {
            self.features_swapchain_maintenance1_ext = Some(Default::default());
            let member = self.features_swapchain_maintenance1_ext.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [device_extensions.ext_texel_buffer_alignment].into_iter().any(|x| x)
            && [].into_iter().all(|x| x)
        {
            self.features_texel_buffer_alignment_ext = Some(Default::default());
            let member = self.features_texel_buffer_alignment_ext.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [device_extensions.ext_transform_feedback].into_iter().any(|x| x)
            && [].into_iter().all(|x| x)
        {
            self.features_transform_feedback_ext = Some(Default::default());
            let member = self.features_transform_feedback_ext.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [device_extensions.ext_vertex_input_dynamic_state].into_iter().any(|x| x)
            && [].into_iter().all(|x| x)
        {
            self.features_vertex_input_dynamic_state_ext = Some(Default::default());
            let member = self.features_vertex_input_dynamic_state_ext.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [device_extensions.ext_ycbcr_2plane_444_formats].into_iter().any(|x| x)
            && [].into_iter().all(|x| x)
        {
            self.features_ycbcr2_plane444_formats_ext = Some(Default::default());
            let member = self.features_ycbcr2_plane444_formats_ext.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [device_extensions.ext_ycbcr_image_arrays].into_iter().any(|x| x)
            && [].into_iter().all(|x| x)
        {
            self.features_ycbcr_image_arrays_ext = Some(Default::default());
            let member = self.features_ycbcr_image_arrays_ext.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [device_extensions.sec_amigo_profiling].into_iter().any(|x| x)
            && [].into_iter().all(|x| x)
        {
            self.features_amigo_profiling_sec = Some(Default::default());
            let member = self.features_amigo_profiling_sec.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [device_extensions.huawei_cluster_culling_shader].into_iter().any(|x| x)
            && [].into_iter().all(|x| x)
        {
            self.features_cluster_culling_shader_huawei = Some(Default::default());
            let member = self.features_cluster_culling_shader_huawei.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [device_extensions.amd_device_coherent_memory].into_iter().any(|x| x)
            && [].into_iter().all(|x| x)
        {
            self.features_coherent_memory_amd = Some(Default::default());
            let member = self.features_coherent_memory_amd.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [device_extensions.nv_compute_shader_derivatives].into_iter().any(|x| x)
            && [].into_iter().all(|x| x)
        {
            self.features_compute_shader_derivatives_nv = Some(Default::default());
            let member = self.features_compute_shader_derivatives_nv.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [device_extensions.nv_cooperative_matrix].into_iter().any(|x| x)
            && [self.features_cooperative_matrix_khr.is_none()].into_iter().all(|x| x)
        {
            self.features_cooperative_matrix_nv = Some(Default::default());
            let member = self.features_cooperative_matrix_nv.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [device_extensions.nv_copy_memory_indirect].into_iter().any(|x| x)
            && [].into_iter().all(|x| x)
        {
            self.features_copy_memory_indirect_nv = Some(Default::default());
            let member = self.features_copy_memory_indirect_nv.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [device_extensions.nv_corner_sampled_image].into_iter().any(|x| x)
            && [].into_iter().all(|x| x)
        {
            self.features_corner_sampled_image_nv = Some(Default::default());
            let member = self.features_corner_sampled_image_nv.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [device_extensions.nv_coverage_reduction_mode].into_iter().any(|x| x)
            && [].into_iter().all(|x| x)
        {
            self.features_coverage_reduction_mode_nv = Some(Default::default());
            let member = self.features_coverage_reduction_mode_nv.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [device_extensions.qcom_filter_cubic_clamp].into_iter().any(|x| x)
            && [].into_iter().all(|x| x)
        {
            self.features_cubic_clamp_qcom = Some(Default::default());
            let member = self.features_cubic_clamp_qcom.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [device_extensions.qcom_filter_cubic_weights].into_iter().any(|x| x)
            && [].into_iter().all(|x| x)
        {
            self.features_cubic_weights_qcom = Some(Default::default());
            let member = self.features_cubic_weights_qcom.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [device_extensions.nv_cuda_kernel_launch].into_iter().any(|x| x)
            && [].into_iter().all(|x| x)
        {
            self.features_cuda_kernel_launch_nv = Some(Default::default());
            let member = self.features_cuda_kernel_launch_nv.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [device_extensions.nv_dedicated_allocation_image_aliasing]
            .into_iter()
            .any(|x| x) && [].into_iter().all(|x| x)
        {
            self.features_dedicated_allocation_image_aliasing_nv = Some(
                Default::default(),
            );
            let member = self
                .features_dedicated_allocation_image_aliasing_nv
                .as_mut()
                .unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [device_extensions.nv_descriptor_pool_overallocation].into_iter().any(|x| x)
            && [].into_iter().all(|x| x)
        {
            self.features_descriptor_pool_overallocation_nv = Some(Default::default());
            let member = self
                .features_descriptor_pool_overallocation_nv
                .as_mut()
                .unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [device_extensions.valve_descriptor_set_host_mapping].into_iter().any(|x| x)
            && [].into_iter().all(|x| x)
        {
            self.features_descriptor_set_host_mapping_valve = Some(Default::default());
            let member = self
                .features_descriptor_set_host_mapping_valve
                .as_mut()
                .unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [device_extensions.nv_device_generated_commands_compute]
            .into_iter()
            .any(|x| x) && [].into_iter().all(|x| x)
        {
            self.features_device_generated_commands_compute_nv = Some(
                Default::default(),
            );
            let member = self
                .features_device_generated_commands_compute_nv
                .as_mut()
                .unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [device_extensions.nv_device_generated_commands].into_iter().any(|x| x)
            && [].into_iter().all(|x| x)
        {
            self.features_device_generated_commands_nv = Some(Default::default());
            let member = self.features_device_generated_commands_nv.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [device_extensions.nv_device_diagnostics_config].into_iter().any(|x| x)
            && [].into_iter().all(|x| x)
        {
            self.features_diagnostics_config_nv = Some(Default::default());
            let member = self.features_diagnostics_config_nv.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [device_extensions.nv_displacement_micromap].into_iter().any(|x| x)
            && [].into_iter().all(|x| x)
        {
            self.features_displacement_micromap_nv = Some(Default::default());
            let member = self.features_displacement_micromap_nv.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [device_extensions.nv_scissor_exclusive].into_iter().any(|x| x)
            && [].into_iter().all(|x| x)
        {
            self.features_exclusive_scissor_nv = Some(Default::default());
            let member = self.features_exclusive_scissor_nv.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [device_extensions.nv_extended_sparse_address_space].into_iter().any(|x| x)
            && [].into_iter().all(|x| x)
        {
            self.features_extended_sparse_address_space_nv = Some(Default::default());
            let member = self
                .features_extended_sparse_address_space_nv
                .as_mut()
                .unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [device_extensions.android_external_format_resolve].into_iter().any(|x| x)
            && [].into_iter().all(|x| x)
        {
            self.features_external_format_resolve_android = Some(Default::default());
            let member = self.features_external_format_resolve_android.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [device_extensions.nv_external_memory_rdma].into_iter().any(|x| x)
            && [].into_iter().all(|x| x)
        {
            self.features_external_memory_rdma_nv = Some(Default::default());
            let member = self.features_external_memory_rdma_nv.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [device_extensions.qnx_external_memory_screen_buffer].into_iter().any(|x| x)
            && [].into_iter().all(|x| x)
        {
            self.features_external_memory_screen_buffer_qnx = Some(Default::default());
            let member = self
                .features_external_memory_screen_buffer_qnx
                .as_mut()
                .unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [device_extensions.qcom_fragment_density_map_offset].into_iter().any(|x| x)
            && [].into_iter().all(|x| x)
        {
            self.features_fragment_density_map_offset_qcom = Some(Default::default());
            let member = self
                .features_fragment_density_map_offset_qcom
                .as_mut()
                .unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [device_extensions.nv_fragment_shading_rate_enums].into_iter().any(|x| x)
            && [].into_iter().all(|x| x)
        {
            self.features_fragment_shading_rate_enums_nv = Some(Default::default());
            let member = self.features_fragment_shading_rate_enums_nv.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [device_extensions.qcom_image_processing2].into_iter().any(|x| x)
            && [].into_iter().all(|x| x)
        {
            self.features_image_processing2_qcom = Some(Default::default());
            let member = self.features_image_processing2_qcom.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [device_extensions.qcom_image_processing].into_iter().any(|x| x)
            && [].into_iter().all(|x| x)
        {
            self.features_image_processing_qcom = Some(Default::default());
            let member = self.features_image_processing_qcom.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [device_extensions.nv_inherited_viewport_scissor].into_iter().any(|x| x)
            && [].into_iter().all(|x| x)
        {
            self.features_inherited_viewport_scissor_nv = Some(Default::default());
            let member = self.features_inherited_viewport_scissor_nv.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [device_extensions.huawei_invocation_mask].into_iter().any(|x| x)
            && [].into_iter().all(|x| x)
        {
            self.features_invocation_mask_huawei = Some(Default::default());
            let member = self.features_invocation_mask_huawei.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [device_extensions.nv_linear_color_attachment].into_iter().any(|x| x)
            && [].into_iter().all(|x| x)
        {
            self.features_linear_color_attachment_nv = Some(Default::default());
            let member = self.features_linear_color_attachment_nv.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [device_extensions.nv_memory_decompression].into_iter().any(|x| x)
            && [].into_iter().all(|x| x)
        {
            self.features_memory_decompression_nv = Some(Default::default());
            let member = self.features_memory_decompression_nv.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [device_extensions.nv_mesh_shader].into_iter().any(|x| x)
            && [self.features_mesh_shader_ext.is_none()].into_iter().all(|x| x)
        {
            self.features_mesh_shader_nv = Some(Default::default());
            let member = self.features_mesh_shader_nv.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [device_extensions.qcom_multiview_per_view_render_areas]
            .into_iter()
            .any(|x| x) && [].into_iter().all(|x| x)
        {
            self.features_multiview_per_view_render_areas_qcom = Some(
                Default::default(),
            );
            let member = self
                .features_multiview_per_view_render_areas_qcom
                .as_mut()
                .unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [device_extensions.qcom_multiview_per_view_viewports].into_iter().any(|x| x)
            && [].into_iter().all(|x| x)
        {
            self.features_multiview_per_view_viewports_qcom = Some(Default::default());
            let member = self
                .features_multiview_per_view_viewports_qcom
                .as_mut()
                .unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [device_extensions.nv_optical_flow].into_iter().any(|x| x)
            && [].into_iter().all(|x| x)
        {
            self.features_optical_flow_nv = Some(Default::default());
            let member = self.features_optical_flow_nv.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [device_extensions.nv_per_stage_descriptor_set].into_iter().any(|x| x)
            && [].into_iter().all(|x| x)
        {
            self.features_per_stage_descriptor_set_nv = Some(Default::default());
            let member = self.features_per_stage_descriptor_set_nv.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [device_extensions.nv_present_barrier].into_iter().any(|x| x)
            && [].into_iter().all(|x| x)
        {
            self.features_present_barrier_nv = Some(Default::default());
            let member = self.features_present_barrier_nv.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [device_extensions.nv_raw_access_chains].into_iter().any(|x| x)
            && [].into_iter().all(|x| x)
        {
            self.features_raw_access_chains_nv = Some(Default::default());
            let member = self.features_raw_access_chains_nv.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [device_extensions.nv_ray_tracing_invocation_reorder].into_iter().any(|x| x)
            && [].into_iter().all(|x| x)
        {
            self.features_ray_tracing_invocation_reorder_nv = Some(Default::default());
            let member = self
                .features_ray_tracing_invocation_reorder_nv
                .as_mut()
                .unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [device_extensions.nv_ray_tracing_motion_blur].into_iter().any(|x| x)
            && [].into_iter().all(|x| x)
        {
            self.features_ray_tracing_motion_blur_nv = Some(Default::default());
            let member = self.features_ray_tracing_motion_blur_nv.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [device_extensions.nv_ray_tracing_validation].into_iter().any(|x| x)
            && [].into_iter().all(|x| x)
        {
            self.features_ray_tracing_validation_nv = Some(Default::default());
            let member = self.features_ray_tracing_validation_nv.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [device_extensions.img_relaxed_line_rasterization].into_iter().any(|x| x)
            && [].into_iter().all(|x| x)
        {
            self.features_relaxed_line_rasterization_img = Some(Default::default());
            let member = self.features_relaxed_line_rasterization_img.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [device_extensions.arm_render_pass_striped].into_iter().any(|x| x)
            && [].into_iter().all(|x| x)
        {
            self.features_render_pass_striped_arm = Some(Default::default());
            let member = self.features_render_pass_striped_arm.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [device_extensions.nv_representative_fragment_test].into_iter().any(|x| x)
            && [].into_iter().all(|x| x)
        {
            self.features_representative_fragment_test_nv = Some(Default::default());
            let member = self.features_representative_fragment_test_nv.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [device_extensions.arm_scheduling_controls].into_iter().any(|x| x)
            && [].into_iter().all(|x| x)
        {
            self.features_scheduling_controls_arm = Some(Default::default());
            let member = self.features_scheduling_controls_arm.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [device_extensions.nv_shader_atomic_float16_vector].into_iter().any(|x| x)
            && [].into_iter().all(|x| x)
        {
            self.features_shader_atomic_float16_vector_nv = Some(Default::default());
            let member = self.features_shader_atomic_float16_vector_nv.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [device_extensions.arm_shader_core_builtins].into_iter().any(|x| x)
            && [].into_iter().all(|x| x)
        {
            self.features_shader_core_builtins_arm = Some(Default::default());
            let member = self.features_shader_core_builtins_arm.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [device_extensions.amd_shader_early_and_late_fragment_tests]
            .into_iter()
            .any(|x| x) && [].into_iter().all(|x| x)
        {
            self.features_shader_early_and_late_fragment_tests_amd = Some(
                Default::default(),
            );
            let member = self
                .features_shader_early_and_late_fragment_tests_amd
                .as_mut()
                .unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [device_extensions.amdx_shader_enqueue].into_iter().any(|x| x)
            && [].into_iter().all(|x| x)
        {
            self.features_shader_enqueue_amdx = Some(Default::default());
            let member = self.features_shader_enqueue_amdx.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [device_extensions.nv_shader_image_footprint].into_iter().any(|x| x)
            && [].into_iter().all(|x| x)
        {
            self.features_shader_image_footprint_nv = Some(Default::default());
            let member = self.features_shader_image_footprint_nv.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [device_extensions.intel_shader_integer_functions2].into_iter().any(|x| x)
            && [].into_iter().all(|x| x)
        {
            self.features_shader_integer_functions2_intel = Some(Default::default());
            let member = self.features_shader_integer_functions2_intel.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [device_extensions.nv_shader_sm_builtins].into_iter().any(|x| x)
            && [].into_iter().all(|x| x)
        {
            self.features_shader_sm_builtins_nv = Some(Default::default());
            let member = self.features_shader_sm_builtins_nv.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [device_extensions.nv_shading_rate_image].into_iter().any(|x| x)
            && [].into_iter().all(|x| x)
        {
            self.features_shading_rate_image_nv = Some(Default::default());
            let member = self.features_shading_rate_image_nv.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [device_extensions.huawei_subpass_shading].into_iter().any(|x| x)
            && [].into_iter().all(|x| x)
        {
            self.features_subpass_shading_huawei = Some(Default::default());
            let member = self.features_subpass_shading_huawei.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [device_extensions.qcom_tile_properties].into_iter().any(|x| x)
            && [].into_iter().all(|x| x)
        {
            self.features_tile_properties_qcom = Some(Default::default());
            let member = self.features_tile_properties_qcom.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
        if [device_extensions.qcom_ycbcr_degamma].into_iter().any(|x| x)
            && [].into_iter().all(|x| x)
        {
            self.features_ycbcr_degamma_qcom = Some(Default::default());
            let member = self.features_ycbcr_degamma_qcom.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = <*mut _>::cast(member);
        }
    }
    pub(crate) fn head_as_ref(&self) -> &ash::vk::PhysicalDeviceFeatures2KHR<'static> {
        &self.features_vulkan10
    }
    pub(crate) fn head_as_mut(
        &mut self,
    ) -> &mut ash::vk::PhysicalDeviceFeatures2KHR<'static> {
        &mut self.features_vulkan10
    }
}
